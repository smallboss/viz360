{"version":3,"file":"vendors.f6424e8c5113d414a169.js","sources":["webpack:///../node_modules/react/index.js","webpack:///../node_modules/classnames/index.js","webpack:///../node_modules/keycode/index.js","webpack:///../node_modules/object-assign/index.js","webpack:///../node_modules/three-full/builds/Three.es.js","webpack:///../node_modules/schedule/cjs/schedule.production.min.js","webpack:///../node_modules/prop-types/factoryWithThrowingShims.js","webpack:///../node_modules/@material-ui/core/Button/Button.js","webpack:///../node_modules/is-plain-object/index.js","webpack:///../node_modules/@material-ui/core/styles/createPalette.js"],"sourcesContent":["'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n","/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","// Source: http://jsfiddle.net/vWx8V/\n// http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes\n\n/**\n * Conenience method returns corresponding value for given keyName or keyCode.\n *\n * @param {Mixed} keyCode {Number} or keyName {String}\n * @return {Mixed}\n * @api public\n */\n\nfunction keyCode(searchInput) {\n  // Keyboard Events\n  if (searchInput && 'object' === typeof searchInput) {\n    var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode\n    if (hasKeyCode) searchInput = hasKeyCode\n  }\n\n  // Numbers\n  if ('number' === typeof searchInput) return names[searchInput]\n\n  // Everything else (cast to string)\n  var search = String(searchInput)\n\n  // check codes\n  var foundNamedKey = codes[search.toLowerCase()]\n  if (foundNamedKey) return foundNamedKey\n\n  // check aliases\n  var foundNamedKey = aliases[search.toLowerCase()]\n  if (foundNamedKey) return foundNamedKey\n\n  // weird character?\n  if (search.length === 1) return search.charCodeAt(0)\n\n  return undefined\n}\n\n/**\n * Compares a keyboard event with a given keyCode or keyName.\n *\n * @param {Event} event Keyboard event that should be tested\n * @param {Mixed} keyCode {Number} or keyName {String}\n * @return {Boolean}\n * @api public\n */\nkeyCode.isEventKey = function isEventKey(event, nameOrCode) {\n  if (event && 'object' === typeof event) {\n    var keyCode = event.which || event.keyCode || event.charCode\n    if (keyCode === null || keyCode === undefined) { return false; }\n    if (typeof nameOrCode === 'string') {\n      // check codes\n      var foundNamedKey = codes[nameOrCode.toLowerCase()]\n      if (foundNamedKey) { return foundNamedKey === keyCode; }\n    \n      // check aliases\n      var foundNamedKey = aliases[nameOrCode.toLowerCase()]\n      if (foundNamedKey) { return foundNamedKey === keyCode; }\n    } else if (typeof nameOrCode === 'number') {\n      return nameOrCode === keyCode;\n    }\n    return false;\n  }\n}\n\nexports = module.exports = keyCode;\n\n/**\n * Get by name\n *\n *   exports.code['enter'] // => 13\n */\n\nvar codes = exports.code = exports.codes = {\n  'backspace': 8,\n  'tab': 9,\n  'enter': 13,\n  'shift': 16,\n  'ctrl': 17,\n  'alt': 18,\n  'pause/break': 19,\n  'caps lock': 20,\n  'esc': 27,\n  'space': 32,\n  'page up': 33,\n  'page down': 34,\n  'end': 35,\n  'home': 36,\n  'left': 37,\n  'up': 38,\n  'right': 39,\n  'down': 40,\n  'insert': 45,\n  'delete': 46,\n  'command': 91,\n  'left command': 91,\n  'right command': 93,\n  'numpad *': 106,\n  'numpad +': 107,\n  'numpad -': 109,\n  'numpad .': 110,\n  'numpad /': 111,\n  'num lock': 144,\n  'scroll lock': 145,\n  'my computer': 182,\n  'my calculator': 183,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  \"'\": 222\n}\n\n// Helper aliases\n\nvar aliases = exports.aliases = {\n  'windows': 91,\n  '⇧': 16,\n  '⌥': 18,\n  '⌃': 17,\n  '⌘': 91,\n  'ctl': 17,\n  'control': 17,\n  'option': 18,\n  'pause': 19,\n  'break': 19,\n  'caps': 20,\n  'return': 13,\n  'escape': 27,\n  'spc': 32,\n  'spacebar': 32,\n  'pgup': 33,\n  'pgdn': 34,\n  'ins': 45,\n  'del': 46,\n  'cmd': 91\n}\n\n/*!\n * Programatically add the following\n */\n\n// lower case chars\nfor (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32\n\n// numbers\nfor (var i = 48; i < 58; i++) codes[i - 48] = i\n\n// function keys\nfor (i = 1; i < 13; i++) codes['f'+i] = i + 111\n\n// numpad keys\nfor (i = 0; i < 10; i++) codes['numpad '+i] = i + 96\n\n/**\n * Get by code\n *\n *   exports.name[13] // => 'Enter'\n */\n\nvar names = exports.names = exports.title = {} // title for backward compat\n\n// Create reverse mapping\nfor (i in codes) names[codes[i]] = i\n\n// Add aliases\nfor (var alias in aliases) {\n  codes[alias] = aliases[alias]\n}\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","// Made by Itee (https://github.com/Itee) with ES6 Convertor script\n\n\n// Polyfills\n\nif ( Number.EPSILON === undefined ) {\n\n\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n}\n\nif ( Number.isInteger === undefined ) {\n\n\t// Missing in IE\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n\n\tNumber.isInteger = function ( value ) {\n\n\t\treturn typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;\n\n\t};\n\n}\n\n//\n\nif ( Math.sign === undefined ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\tMath.sign = function ( x ) {\n\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t};\n\n}\n\nif ( 'name' in Function.prototype === false ) {\n\n\t// Missing in IE\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\tget: function () {\n\n\t\t\treturn this.toString().match( /^\\s*function\\s*([^\\(\\s]*)/ )[ 1 ];\n\n\t\t}\n\n\t} );\n\n}\n\nif ( Object.assign === undefined ) {\n\n\t// Missing in IE\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t( function () {\n\n\t\tObject.assign = function ( target ) {\n\t\t\tvar arguments$1 = arguments;\n\n\n\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t}\n\n\t\t\tvar output = Object( target );\n\n\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\tvar source = arguments$1[ index ];\n\n\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t};\n\n\t} )();\n\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar _Math = {\r\n\r\n\tDEG2RAD: Math.PI / 180,\r\n\tRAD2DEG: 180 / Math.PI,\r\n\r\n\tgenerateUUID: ( function () {\r\n\r\n\t\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\r\n\r\n\t\tvar lut = [];\r\n\r\n\t\tfor ( var i = 0; i < 256; i ++ ) {\r\n\r\n\t\t\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\r\n\r\n\t\t}\r\n\r\n\t\treturn function generateUUID() {\r\n\r\n\t\t\tvar d0 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar d1 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar d2 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar d3 = Math.random() * 0xffffffff | 0;\r\n\t\t\tvar uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\r\n\t\t\t\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\r\n\t\t\t\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\r\n\t\t\t\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\r\n\r\n\t\t\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\r\n\t\t\treturn uuid.toUpperCase();\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tclamp: function ( value, min, max ) {\r\n\r\n\t\treturn Math.max( min, Math.min( max, value ) );\r\n\r\n\t},\r\n\r\n\t// compute euclidian modulo of m % n\r\n\t// https://en.wikipedia.org/wiki/Modulo_operation\r\n\r\n\teuclideanModulo: function ( n, m ) {\r\n\r\n\t\treturn ( ( n % m ) + m ) % m;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// https://en.wikipedia.org/wiki/Linear_interpolation\r\n\r\n\tlerp: function ( x, y, t ) {\r\n\r\n\t\treturn ( 1 - t ) * x + t * y;\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) { return 0; }\r\n\t\tif ( x >= max ) { return 1; }\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * ( 3 - 2 * x );\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) { return 0; }\r\n\t\tif ( x >= max ) { return 1; }\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tdegToRad: function ( degrees ) {\r\n\r\n\t\treturn degrees * _Math.DEG2RAD;\r\n\r\n\t},\r\n\r\n\tradToDeg: function ( radians ) {\r\n\r\n\t\treturn radians * _Math.RAD2DEG;\r\n\r\n\t},\r\n\r\n\tisPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n\t},\r\n\r\n\tceilPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t},\r\n\r\n\tfloorPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Matrix4() {\r\n\r\n\tthis.elements = [\r\n\r\n\t\t1, 0, 0, 0,\r\n\t\t0, 1, 0, 0,\r\n\t\t0, 0, 1, 0,\r\n\t\t0, 0, 0, 1\r\n\r\n\t];\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( Matrix4.prototype, {\r\n\r\n\tisMatrix4: true,\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new Matrix4().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\r\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\r\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\r\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements, me = m.elements;\r\n\r\n\t\tte[ 12 ] = me[ 12 ];\r\n\t\tte[ 13 ] = me[ 13 ];\r\n\t\tte[ 14 ] = me[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\tthis.set(\r\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractRotation: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function extractRotation( m ) {\r\n\r\n\t\t\t// this method does not support reflection matrices\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\t\t\tte[ 3 ] = 0;\r\n\r\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\t\t\tte[ 7 ] = 0;\r\n\r\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\t\t\tte[ 11 ] = 0;\r\n\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeRotationFromEuler: function ( euler ) {\r\n\r\n\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\tconsole.error( 'Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - c * f;\r\n\t\t\tte[ 8 ] = d;\r\n\r\n\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\tte[ 9 ] = - b * c;\r\n\r\n\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\tte[ 8 ] = a * d;\r\n\r\n\t\t\tte[ 1 ] = a * f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b;\r\n\r\n\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\tte[ 4 ] = - a * f;\r\n\t\t\tte[ 8 ] = de + cf * b;\r\n\r\n\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = df - ce * b;\r\n\r\n\t\t\tte[ 2 ] = - a * d;\r\n\t\t\tte[ 6 ] = b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\tte[ 8 ] = ae * d + bf;\r\n\r\n\t\t\tte[ 1 ] = c * f;\r\n\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\tte[ 9 ] = af * d - be;\r\n\r\n\t\t\tte[ 2 ] = - d;\r\n\t\t\tte[ 6 ] = b * c;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\tte[ 8 ] = bc * f + ad;\r\n\r\n\t\t\tte[ 1 ] = f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b * e;\r\n\r\n\t\t\tte[ 2 ] = - d * e;\r\n\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\tte[ 10 ] = ac - bd * f;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - f;\r\n\t\t\tte[ 8 ] = d * e;\r\n\r\n\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = ad * f - bc;\r\n\r\n\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\tte[ 6 ] = b * e;\r\n\t\t\tte[ 10 ] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\t// bottom row\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// last column\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationFromQuaternion: function () {\r\n\r\n\t\tvar zero = new Vector3( 0, 0, 0 );\r\n\t\tvar one = new Vector3( 1, 1, 1 );\r\n\r\n\t\treturn function makeRotationFromQuaternion( q ) {\r\n\r\n\t\t\treturn this.compose( zero, q, one );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar x = new Vector3();\r\n\t\tvar y = new Vector3();\r\n\t\tvar z = new Vector3();\r\n\r\n\t\treturn function lookAt( eye, target, up ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target );\r\n\r\n\t\t\tif ( z.lengthSq() === 0 ) {\r\n\r\n\t\t\t\t// eye and target are in the same position\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tz.normalize();\r\n\t\t\tx.crossVectors( up, z );\r\n\r\n\t\t\tif ( x.lengthSq() === 0 ) {\r\n\r\n\t\t\t\t// up and z are parallel\r\n\r\n\t\t\t\tif ( Math.abs( up.z ) === 1 ) {\r\n\r\n\t\t\t\t\tz.x += 0.0001;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz.z += 0.0001;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tz.normalize();\r\n\t\t\t\tx.crossVectors( up, z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.normalize();\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToBufferAttribute: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function applyToBufferAttribute( attribute ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\tv1.x = attribute.getX( i );\r\n\t\t\t\tv1.y = attribute.getY( i );\r\n\t\t\t\tv1.z = attribute.getZ( i );\r\n\r\n\t\t\t\tv1.applyMatrix4( this$1 );\r\n\r\n\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn attribute;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t - n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t - n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t - n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t + n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 12 ] = v.x;\r\n\t\tte[ 13 ] = v.y;\r\n\t\tte[ 14 ] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, throwOnDegenerate ) {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements,\r\n\t\t\tme = m.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\r\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\r\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\r\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\r\n\r\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\r\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"Matrix4: .getInverse() can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate === true ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\r\n\t\t}\r\n\r\n\t\tvar detInv = 1 / det;\r\n\r\n\t\tte[ 0 ] = t11 * detInv;\r\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\r\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\r\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\r\n\r\n\t\tte[ 4 ] = t12 * detInv;\r\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\r\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\r\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\r\n\r\n\t\tte[ 8 ] = t13 * detInv;\r\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\r\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\r\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\r\n\r\n\t\tte[ 12 ] = t14 * detInv;\r\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\r\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\r\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, c, - s, 0,\r\n\t\t\t0, s, c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t- s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, - s, 0, 0,\r\n\t\t\ts, c, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeShear: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, y, z, 0,\r\n\t\t\tx, 1, z, 0,\r\n\t\t\tx, y, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcompose: function ( position, quaternion, scale ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\r\n\t\tvar x2 = x + x,\ty2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tvar sx = scale.x, sy = scale.y, sz = scale.z;\r\n\r\n\t        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\r\n\t        te[ 1 ] = ( xy + wz ) * sx;\r\n\t        te[ 2 ] = ( xz - wy ) * sx;\r\n\t        te[ 3 ] = 0;\r\n\r\n\t        te[ 4 ] = ( xy - wz ) * sy;\r\n\t        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\r\n\t        te[ 6 ] = ( yz + wx ) * sy;\r\n\t        te[ 7 ] = 0;\r\n\r\n\t        te[ 8 ] = ( xz + wy ) * sz;\r\n\t        te[ 9 ] = ( yz - wx ) * sz;\r\n\t        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\r\n\t        te[ 11 ] = 0;\r\n\r\n\t        te[ 12 ] = position.x;\r\n\t        te[ 13 ] = position.y;\r\n\t        te[ 14 ] = position.z;\r\n\t        te[ 15 ] = 1;\r\n\r\n\t        return this;\r\n\r\n\t},\r\n\r\n\tdecompose: function () {\r\n\r\n\t\tvar vector = new Vector3();\r\n\t\tvar matrix = new Matrix4();\r\n\r\n\t\treturn function decompose( position, quaternion, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\tvar det = this.determinant();\r\n\t\t\tif ( det < 0 ) { sx = - sx; }\r\n\r\n\t\t\tposition.x = te[ 12 ];\r\n\t\t\tposition.y = te[ 13 ];\r\n\t\t\tposition.z = te[ 14 ];\r\n\r\n\t\t\t// scale the rotation part\r\n\t\t\tmatrix.copy( this );\r\n\r\n\t\t\tvar invSX = 1 / sx;\r\n\t\t\tvar invSY = 1 / sy;\r\n\t\t\tvar invSZ = 1 / sz;\r\n\r\n\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\r\n\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\r\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\r\n\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakePerspective: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tif ( far === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = 1.0 / ( right - left );\r\n\t\tvar h = 1.0 / ( top - bottom );\r\n\t\tvar p = 1.0 / ( far - near );\r\n\r\n\t\tvar x = ( right + left ) * w;\r\n\t\tvar y = ( top + bottom ) * h;\r\n\t\tvar z = ( far + near ) * p;\r\n\r\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( matrix ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) { return false; }\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tthis$1.elements[ i ] = array[ i + offset ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) { array = []; }\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\r\n\t\tarray[ offset + 8 ] = te[ 8 ];\r\n\t\tarray[ offset + 9 ] = te[ 9 ];\r\n\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\r\n\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Vector3( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n}\r\n\r\nObject.assign( Vector3.prototype, {\r\n\r\n\tisVector3: true,\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar quaternion = new Quaternion();\r\n\r\n\t\treturn function applyEuler( euler ) {\r\n\r\n\t\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\t\tconsole.error( 'Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar quaternion = new Quaternion();\r\n\r\n\t\treturn function applyAxisAngle( axis, angle ) {\r\n\r\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\r\n\r\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\r\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\r\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix = qw * x + qy * z - qz * y;\r\n\t\tvar iy = qw * y + qz * x - qx * z;\r\n\t\tvar iz = qw * z + qx * y - qy * x;\r\n\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tproject: function ( camera ) {\r\n\r\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\r\n\r\n\t},\r\n\r\n\tunproject: function () {\r\n\r\n\t\tvar matrix = new Matrix4();\r\n\r\n\t\treturn function unproject( camera ) {\r\n\r\n\t\t\treturn this.applyMatrix4( matrix.getInverse( camera.projectionMatrix ) ).applyMatrix4( camera.matrixWorld );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\treturn this.normalize();\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min = new Vector3();\r\n\t\tvar max = new Vector3();\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\t// TODO lengthSquared?\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tmanhattanLength: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.crossVectors( this, v );\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function ( vector ) {\r\n\r\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\r\n\r\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\r\n\r\n\t},\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function projectOnPlane( planeNormal ) {\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t// normal is assumed to have unit length\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function reflect( normal ) {\r\n\r\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tmanhattanDistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\r\n\r\n\t},\r\n\r\n\tsetFromSpherical: function ( s ) {\r\n\r\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\r\n\r\n\t},\r\n\r\n\tsetFromSphericalCoords: function ( radius, phi, theta ) {\r\n\r\n\t\tvar sinPhiRadius = Math.sin( phi ) * radius;\r\n\r\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\r\n\t\tthis.y = Math.cos( phi ) * radius;\r\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCylindrical: function ( c ) {\r\n\r\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\r\n\r\n\t},\r\n\r\n\tsetFromCylindricalCoords: function ( radius, theta, y ) {\r\n\r\n\t\tthis.x = radius * Math.sin( theta );\r\n\t\tthis.y = y;\r\n\t\tthis.z = radius * Math.cos( theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixPosition: function ( m ) {\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 12 ];\r\n\t\tthis.y = e[ 13 ];\r\n\t\tthis.z = e[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixScale: function ( m ) {\r\n\r\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixColumn: function ( m, index ) {\r\n\r\n\t\treturn this.fromArray( m.elements, index * 4 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) { array = []; }\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector3: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x = attribute.getX( index );\r\n\t\tthis.y = attribute.getY( index );\r\n\t\tthis.z = attribute.getZ( index );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Quaternion( x, y, z, w ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._w = ( w !== undefined ) ? w : 1;\r\n\r\n}\r\n\r\nObject.assign( Quaternion, {\r\n\r\n\tslerp: function ( qa, qb, qm, t ) {\r\n\r\n\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n\t},\r\n\r\n\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\r\n\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\r\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\r\n\r\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\r\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\r\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\r\n\t\t\tvar s = 1 - t,\r\n\r\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\r\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\tsqrSin = 1 - cos * cos;\r\n\r\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\r\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\r\n\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar tDir = t * dir;\r\n\r\n\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\tw0 = w0 * s + w1 * tDir;\r\n\r\n\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\tif ( s === 1 - t ) {\r\n\r\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\r\n\t\t\t\tx0 *= f;\r\n\t\t\t\ty0 *= f;\r\n\t\t\t\tz0 *= f;\r\n\t\t\t\tw0 *= f;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdst[ dstOffset ] = x0;\r\n\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\tdst[ dstOffset + 3 ] = w0;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.defineProperties( Quaternion.prototype, {\r\n\r\n\tx: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._x;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ty: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._y;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tz: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._z;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tw: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._w;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._w = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( Quaternion.prototype, {\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._w = w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( quaternion ) {\r\n\r\n\t\tthis._x = quaternion.x;\r\n\t\tthis._y = quaternion.y;\r\n\t\tthis._z = quaternion.z;\r\n\t\tthis._w = quaternion.w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( euler, update ) {\r\n\r\n\t\tif ( ! ( euler && euler.isEuler ) ) {\r\n\r\n\t\t\tthrow new Error( 'Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar cos = Math.cos;\r\n\t\tvar sin = Math.sin;\r\n\r\n\t\tvar c1 = cos( x / 2 );\r\n\t\tvar c2 = cos( y / 2 );\r\n\t\tvar c3 = cos( z / 2 );\r\n\r\n\t\tvar s1 = sin( x / 2 );\r\n\t\tvar s2 = sin( y / 2 );\r\n\t\tvar s3 = sin( z / 2 );\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\tif ( update !== false ) { this.onChangeCallback(); }\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\tthis._x = axis.x * s;\r\n\t\tthis._y = axis.y * s;\r\n\t\tthis._z = axis.z * s;\r\n\t\tthis._w = Math.cos( halfAngle );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis._w = 0.25 / s;\r\n\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\tthis._x = 0.25 * s;\r\n\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\tthis._y = 0.25 * s;\r\n\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\tthis._z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromUnitVectors: function () {\r\n\r\n\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar r;\r\n\r\n\t\tvar EPS = 0.000001;\r\n\r\n\t\treturn function setFromUnitVectors( vFrom, vTo ) {\r\n\r\n\t\t\tif ( v1 === undefined ) { v1 = new Vector3(); }\r\n\r\n\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\r\n\t\t\tif ( r < EPS ) {\r\n\r\n\t\t\t\tr = 0;\r\n\r\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._x = v1.x;\r\n\t\t\tthis._y = v1.y;\r\n\t\t\tthis._z = v1.z;\r\n\t\t\tthis._w = r;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( q ) {\r\n\r\n\t\treturn 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );\r\n\r\n\t},\r\n\r\n\trotateTowards: function ( q, step ) {\r\n\r\n\t\tvar angle = this.angleTo( q );\r\n\r\n\t\tif ( angle === 0 ) { return this; }\r\n\r\n\t\tvar t = Math.min( 1, step / angle );\r\n\r\n\t\tthis.slerp( q, t );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tinverse: function () {\r\n\r\n\t\t// quaternion is assumed to have unit length\r\n\r\n\t\treturn this.conjugate();\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis._x *= - 1;\r\n\t\tthis._y *= - 1;\r\n\t\tthis._z *= - 1;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis._x = 0;\r\n\t\t\tthis._y = 0;\r\n\t\t\tthis._z = 0;\r\n\t\t\tthis._w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis._x = this._x * l;\r\n\t\t\tthis._y = this._y * l;\r\n\t\t\tthis._z = this._z * l;\r\n\t\t\tthis._w = this._w * l;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( q ) {\r\n\r\n\t\treturn this.multiplyQuaternions( q, this );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tif ( t === 0 ) { return this; }\r\n\t\tif ( t === 1 ) { return this.copy( qb ); }\r\n\r\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis._w = - qb._w;\r\n\t\t\tthis._x = - qb._x;\r\n\t\t\tthis._y = - qb._y;\r\n\t\t\tthis._z = - qb._z;\r\n\r\n\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis._w = w;\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\r\n\r\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\r\n\r\n\t\t\tvar s = 1 - t;\r\n\t\t\tthis._w = s * w + t * this._w;\r\n\t\t\tthis._x = s * x + t * this._x;\r\n\t\t\tthis._y = s * y + t * this._y;\r\n\t\t\tthis._z = s * z + t * this._z;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t}\r\n\r\n\t\tvar sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\r\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( quaternion ) {\r\n\r\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tthis._x = array[ offset ];\r\n\t\tthis._y = array[ offset + 1 ];\r\n\t\tthis._z = array[ offset + 2 ];\r\n\t\tthis._w = array[ offset + 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) { array = []; }\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction EventDispatcher() {}\r\n\r\nObject.assign( EventDispatcher.prototype, {\r\n\r\n\taddEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) { this._listeners = {}; }\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\thasEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) { return false; }\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\r\n\r\n\t},\r\n\r\n\tremoveEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) { return; }\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tvar index = listenerArray.indexOf( listener );\r\n\r\n\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdispatchEvent: function ( event ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( this._listeners === undefined ) { return; }\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tevent.target = this;\r\n\r\n\t\t\tvar array = listenerArray.slice( 0 );\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ].call( this$1, event );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Euler( x, y, z, order ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._order = order || Euler.DefaultOrder;\r\n\r\n}\r\n\r\nEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nEuler.DefaultOrder = 'XYZ';\r\n\r\nObject.defineProperties( Euler.prototype, {\r\n\r\n\tx: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._x;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ty: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._y;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tz: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._z;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\torder: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._order;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._order = value;\r\n\t\t\tthis.onChangeCallback();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( Euler.prototype, {\r\n\r\n\tisEuler: true,\r\n\r\n\tset: function ( x, y, z, order ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._order = order || this._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\r\n\r\n\t},\r\n\r\n\tcopy: function ( euler ) {\r\n\r\n\t\tthis._x = euler._x;\r\n\t\tthis._y = euler._y;\r\n\t\tthis._z = euler._z;\r\n\t\tthis._order = euler._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\r\n\t\tvar clamp = _Math.clamp;\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\torder = order || this._order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'Euler: .setFromRotationMatrix() given unsupported order: ' + order );\r\n\r\n\t\t}\r\n\r\n\t\tthis._order = order;\r\n\r\n\t\tif ( update !== false ) { this.onChangeCallback(); }\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromQuaternion: function () {\r\n\r\n\t\tvar matrix = new Matrix4();\r\n\r\n\t\treturn function setFromQuaternion( q, order, update ) {\r\n\r\n\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\r\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromVector3: function ( v, order ) {\r\n\r\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n\t},\r\n\r\n\treorder: function () {\r\n\r\n\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\tvar q = new Quaternion();\r\n\r\n\t\treturn function reorder( newOrder ) {\r\n\r\n\t\t\tq.setFromEuler( this );\r\n\r\n\t\t\treturn this.setFromQuaternion( q, newOrder );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( euler ) {\r\n\r\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis._x = array[ 0 ];\r\n\t\tthis._y = array[ 1 ];\r\n\t\tthis._z = array[ 2 ];\r\n\t\tif ( array[ 3 ] !== undefined ) { this._order = array[ 3 ]; }\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) { array = []; }\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._order;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\ttoVector3: function ( optionalResult ) {\r\n\r\n\t\tif ( optionalResult ) {\r\n\r\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn new Vector3( this._x, this._y, this._z );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Layers() {\r\n\r\n\tthis.mask = 1 | 0;\r\n\r\n}\r\n\r\nObject.assign( Layers.prototype, {\r\n\r\n\tset: function ( channel ) {\r\n\r\n\t\tthis.mask = 1 << channel | 0;\r\n\r\n\t},\r\n\r\n\tenable: function ( channel ) {\r\n\r\n\t\tthis.mask |= 1 << channel | 0;\r\n\r\n\t},\r\n\r\n\ttoggle: function ( channel ) {\r\n\r\n\t\tthis.mask ^= 1 << channel | 0;\r\n\r\n\t},\r\n\r\n\tdisable: function ( channel ) {\r\n\r\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\r\n\r\n\t},\r\n\r\n\ttest: function ( layers ) {\r\n\r\n\t\treturn ( this.mask & layers.mask ) !== 0;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Matrix3() {\r\n\r\n\tthis.elements = [\r\n\r\n\t\t1, 0, 0,\r\n\t\t0, 1, 0,\r\n\t\t0, 0, 1\r\n\r\n\t];\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( Matrix3.prototype, {\r\n\r\n\tisMatrix3: true,\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\r\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\r\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix4: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\r\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\r\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToBufferAttribute: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function applyToBufferAttribute( attribute ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\tv1.x = attribute.getX( i );\r\n\t\t\t\tv1.y = attribute.getY( i );\r\n\t\t\t\tv1.z = attribute.getZ( i );\r\n\r\n\t\t\t\tv1.applyMatrix3( this$1 );\r\n\r\n\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn attribute;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\r\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\r\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\r\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\r\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\r\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\r\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\r\n\r\n\t\tif ( matrix && matrix.isMatrix4 ) {\r\n\r\n\t\t\tconsole.error( \"Matrix3: .getInverse() no longer takes a Matrix4 argument.\" );\r\n\r\n\t\t}\r\n\r\n\t\tvar me = matrix.elements,\r\n\t\t\tte = this.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\r\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\r\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\r\n\r\n\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\r\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"Matrix3: .getInverse() can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate === true ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\r\n\t\t}\r\n\r\n\t\tvar detInv = 1 / det;\r\n\r\n\t\tte[ 0 ] = t11 * detInv;\r\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\r\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\r\n\r\n\t\tte[ 3 ] = t12 * detInv;\r\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\r\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\r\n\r\n\t\tte[ 6 ] = t13 * detInv;\r\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\r\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( matrix4 ) {\r\n\r\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\r\n\r\n\t\tvar c = Math.cos( rotation );\r\n\t\tvar s = Math.sin( rotation );\r\n\r\n\t\tthis.set(\r\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\r\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\r\n\t\t\t0, 0, 1\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tscale: function ( sx, sy ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\r\n\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotate: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta );\r\n\t\tvar s = Math.sin( theta );\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\r\n\t\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\r\n\r\n\t\tte[ 0 ] = c * a11 + s * a21;\r\n\t\tte[ 3 ] = c * a12 + s * a22;\r\n\t\tte[ 6 ] = c * a13 + s * a23;\r\n\r\n\t\tte[ 1 ] = - s * a11 + c * a21;\r\n\t\tte[ 4 ] = - s * a12 + c * a22;\r\n\t\tte[ 7 ] = - s * a13 + c * a23;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( tx, ty ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\r\n\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( matrix ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tfor ( var i = 0; i < 9; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) { return false; }\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tfor ( var i = 0; i < 9; i ++ ) {\r\n\r\n\t\t\tthis$1.elements[ i ] = array[ i + offset ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) { array = []; }\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\tarray[ offset + 8 ] = te[ 8 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar object3DId = 0;\r\n\r\nfunction Object3D() {\r\n\r\n\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Object3D';\r\n\r\n\tthis.parent = null;\r\n\tthis.children = [];\r\n\r\n\tthis.up = Object3D.DefaultUp.clone();\r\n\r\n\tvar position = new Vector3();\r\n\tvar rotation = new Euler();\r\n\tvar quaternion = new Quaternion();\r\n\tvar scale = new Vector3( 1, 1, 1 );\r\n\r\n\tfunction onRotationChange() {\r\n\r\n\t\tquaternion.setFromEuler( rotation, false );\r\n\r\n\t}\r\n\r\n\tfunction onQuaternionChange() {\r\n\r\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\r\n\t}\r\n\r\n\trotation.onChange( onRotationChange );\r\n\tquaternion.onChange( onQuaternionChange );\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tposition: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: position\r\n\t\t},\r\n\t\trotation: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: rotation\r\n\t\t},\r\n\t\tquaternion: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: quaternion\r\n\t\t},\r\n\t\tscale: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: scale\r\n\t\t},\r\n\t\tmodelViewMatrix: {\r\n\t\t\tvalue: new Matrix4()\r\n\t\t},\r\n\t\tnormalMatrix: {\r\n\t\t\tvalue: new Matrix3()\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.matrix = new Matrix4();\r\n\tthis.matrixWorld = new Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\r\n\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\tthis.layers = new Layers();\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\tthis.renderOrder = 0;\r\n\r\n\tthis.userData = {};\r\n\r\n}\r\n\r\nObject3D.DefaultUp = new Vector3( 0, 1, 0 );\r\nObject3D.DefaultMatrixAutoUpdate = true;\r\n\r\nObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: Object3D,\r\n\r\n\tisObject3D: true,\r\n\r\n\tonBeforeRender: function () {},\r\n\tonAfterRender: function () {},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tthis.quaternion.premultiply( q );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( euler ) {\r\n\r\n\t\tthis.quaternion.setFromEuler( euler, true );\r\n\r\n\t},\r\n\r\n\tsetRotationFromMatrix: function ( m ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\t// assumes q is normalized\r\n\r\n\t\tthis.quaternion.copy( q );\r\n\r\n\t},\r\n\r\n\trotateOnAxis: function () {\r\n\r\n\t\t// rotate object on axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar q1 = new Quaternion();\r\n\r\n\t\treturn function rotateOnAxis( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.multiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateOnWorldAxis: function () {\r\n\r\n\t\t// rotate object on axis in world space\r\n\t\t// axis is assumed to be normalized\r\n\t\t// method assumes no rotated parent\r\n\r\n\t\tvar q1 = new Quaternion();\r\n\r\n\t\treturn function rotateOnWorldAxis( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.premultiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateX: function () {\r\n\r\n\t\tvar v1 = new Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateOnAxis: function () {\r\n\r\n\t\t// translate object by distance along axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function translateOnAxis( axis, distance ) {\r\n\r\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateX: function () {\r\n\r\n\t\tvar v1 = new Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function translateX( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateY: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function translateY( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateZ: function () {\r\n\r\n\t\tvar v1 = new Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function translateZ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function () {\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function worldToLocal( vector ) {\r\n\r\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\r\n\r\n\t\tvar q1 = new Quaternion();\r\n\t\tvar m1 = new Matrix4();\r\n\t\tvar target = new Vector3();\r\n\t\tvar position = new Vector3();\r\n\r\n\t\treturn function lookAt( x, y, z ) {\r\n\r\n\t\t\tif ( x.isVector3 ) {\r\n\r\n\t\t\t\ttarget.copy( x );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget.set( x, y, z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parent = this.parent;\r\n\r\n\t\t\tthis.updateWorldMatrix( true, false );\r\n\r\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tif ( this.isCamera ) {\r\n\r\n\t\t\t\tm1.lookAt( position, target, this.up );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tm1.lookAt( target, position, this.up );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\tm1.extractRotation( parent.matrixWorld );\r\n\t\t\t\tq1.setFromRotationMatrix( m1 );\r\n\t\t\t\tthis.quaternion.premultiply( q1.inverse() );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( object ) {\n\t\tvar arguments$1 = arguments;\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis$1.add( arguments$1[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tconsole.error( \"Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( object && object.isObject3D ) ) {\r\n\r\n\t\t\tif ( object.parent !== null ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( \"Object3D.add: object not an instance of Object3D.\", object );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\n\t\tvar arguments$1 = arguments;\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis$1.remove( arguments$1[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = null;\r\n\r\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetObjectById: function ( id ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'id', id );\r\n\r\n\t},\r\n\r\n\tgetObjectByName: function ( name ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'name', name );\r\n\r\n\t},\r\n\r\n\tgetObjectByProperty: function ( name, value ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( this[ name ] === value ) { return this; }\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this$1.children[ i ];\r\n\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\r\n\t\t\tif ( object !== undefined ) {\r\n\r\n\t\t\t\treturn object;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetWorldPosition: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Object3D: .getWorldPosition() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tgetWorldQuaternion: function () {\r\n\r\n\t\tvar position = new Vector3();\r\n\t\tvar scale = new Vector3();\r\n\r\n\t\treturn function getWorldQuaternion( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Object3D: .getWorldQuaternion() target is now required' );\r\n\t\t\t\ttarget = new Quaternion();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, target, scale );\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldScale: function () {\r\n\r\n\t\tvar position = new Vector3();\r\n\t\tvar quaternion = new Quaternion();\r\n\r\n\t\treturn function getWorldScale( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Object3D: .getWorldScale() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, target );\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldDirection: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Object3D: .getWorldDirection() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\tvar e = this.matrixWorld.elements;\r\n\r\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\r\n\r\n\t},\r\n\r\n\traycast: function () {},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseVisible: function ( callback ) {\r\n\r\n\t\tif ( this.visible === false ) { return; }\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverseVisible( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseAncestors: function ( callback ) {\r\n\r\n\t\tvar parent = this.parent;\r\n\r\n\t\tif ( parent !== null ) {\r\n\r\n\t\t\tcallback( parent );\r\n\r\n\t\t\tparent.traverseAncestors( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate ) { this.updateMatrix(); }\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\t\tif ( this.parent === null ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateWorldMatrix: function ( updateParents, updateChildren ) {\r\n\r\n\t\tvar parent = this.parent;\r\n\r\n\t\tif ( updateParents === true && parent !== null ) {\r\n\r\n\t\t\tparent.updateWorldMatrix( true, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.matrixAutoUpdate ) { this.updateMatrix(); }\r\n\r\n\t\tif ( this.parent === null ) {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tif ( updateChildren === true ) {\r\n\r\n\t\t\tvar children = this.children;\r\n\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tchildren[ i ].updateWorldMatrix( false, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\t// meta is a string when called from JSON.stringify\r\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\t\tvar output = {};\r\n\r\n\t\t// meta is a hash used to collect geometries, materials.\r\n\t\t// not providing it implies that this is the root object\r\n\t\t// being serialized.\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\t// initialize meta obj\r\n\t\t\tmeta = {\r\n\t\t\t\tgeometries: {},\r\n\t\t\t\tmaterials: {},\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {},\r\n\t\t\t\tshapes: {}\r\n\t\t\t};\r\n\r\n\t\t\toutput.metadata = {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Object',\r\n\t\t\t\tgenerator: 'Object3D.toJSON'\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// standard Object3D serialization\r\n\r\n\t\tvar object = {};\r\n\r\n\t\tobject.uuid = this.uuid;\r\n\t\tobject.type = this.type;\r\n\r\n\t\tif ( this.name !== '' ) { object.name = this.name; }\r\n\t\tif ( this.castShadow === true ) { object.castShadow = true; }\r\n\t\tif ( this.receiveShadow === true ) { object.receiveShadow = true; }\r\n\t\tif ( this.visible === false ) { object.visible = false; }\r\n\t\tif ( this.frustumCulled === false ) { object.frustumCulled = false; }\r\n\t\tif ( this.renderOrder !== 0 ) { object.renderOrder = this.renderOrder; }\r\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) { object.userData = this.userData; }\r\n\r\n\t\tobject.layers = this.layers.mask;\r\n\t\tobject.matrix = this.matrix.toArray();\r\n\r\n\t\tif ( this.matrixAutoUpdate === false ) { object.matrixAutoUpdate = false; }\r\n\r\n\t\t//\r\n\r\n\t\tfunction serialize( library, element ) {\r\n\r\n\t\t\tif ( library[ element.uuid ] === undefined ) {\r\n\r\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn element.uuid;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.isMesh || this.isLine || this.isPoints ) {\r\n\r\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\r\n\r\n\t\t\tvar parameters = this.geometry.parameters;\r\n\r\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\r\n\r\n\t\t\t\tvar shapes = parameters.shapes;\r\n\r\n\t\t\t\tif ( Array.isArray( shapes ) ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar shape = shapes[ i ];\r\n\r\n\t\t\t\t\t\tserialize( meta.shapes, shape );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tserialize( meta.shapes, shapes );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.material !== undefined ) {\r\n\r\n\t\t\tif ( Array.isArray( this.material ) ) {\r\n\r\n\t\t\t\tvar uuids = [];\r\n\r\n\t\t\t\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tuuids.push( serialize( meta.materials, this$1.material[ i ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.material = uuids;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.children.length > 0 ) {\r\n\r\n\t\t\tobject.children = [];\r\n\r\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\t\tobject.children.push( this$1.children[ i ].toJSON( meta ).object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\tvar geometries = extractFromCache( meta.geometries );\r\n\t\t\tvar materials = extractFromCache( meta.materials );\r\n\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\tvar images = extractFromCache( meta.images );\r\n\t\t\tvar shapes = extractFromCache( meta.shapes );\r\n\r\n\t\t\tif ( geometries.length > 0 ) { output.geometries = geometries; }\r\n\t\t\tif ( materials.length > 0 ) { output.materials = materials; }\r\n\t\t\tif ( textures.length > 0 ) { output.textures = textures; }\r\n\t\t\tif ( images.length > 0 ) { output.images = images; }\r\n\t\t\tif ( shapes.length > 0 ) { output.shapes = shapes; }\r\n\r\n\t\t}\r\n\r\n\t\toutput.object = object;\r\n\r\n\t\treturn output;\r\n\r\n\t\t// extract data from the cache hash\r\n\t\t// remove metadata on each item\r\n\t\t// and return as array\r\n\t\tfunction extractFromCache( cache ) {\r\n\r\n\t\t\tvar values = [];\r\n\t\t\tfor ( var key in cache ) {\r\n\r\n\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function ( recursive ) {\r\n\r\n\t\treturn new this.constructor().copy( this, recursive );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source, recursive ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( recursive === undefined ) { recursive = true; }\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.up.copy( source.up );\r\n\r\n\t\tthis.position.copy( source.position );\r\n\t\tthis.quaternion.copy( source.quaternion );\r\n\t\tthis.scale.copy( source.scale );\r\n\r\n\t\tthis.matrix.copy( source.matrix );\r\n\t\tthis.matrixWorld.copy( source.matrixWorld );\r\n\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\r\n\t\tthis.layers.mask = source.layers.mask;\r\n\t\tthis.visible = source.visible;\r\n\r\n\t\tthis.castShadow = source.castShadow;\r\n\t\tthis.receiveShadow = source.receiveShadow;\r\n\r\n\t\tthis.frustumCulled = source.frustumCulled;\r\n\t\tthis.renderOrder = source.renderOrder;\r\n\r\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = source.children[ i ];\r\n\t\t\t\tthis$1.add( child.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\nfunction Color( r, g, b ) {\r\n\r\n\tif ( g === undefined && b === undefined ) {\r\n\r\n\t\t// r is Color, hex or string\r\n\t\treturn this.set( r );\r\n\r\n\t}\r\n\r\n\treturn this.setRGB( r, g, b );\r\n\r\n}\r\n\r\nObject.assign( Color.prototype, {\r\n\r\n\tisColor: true,\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value && value.isColor ) {\r\n\r\n\t\t\tthis.copy( value );\r\n\r\n\t\t} else if ( typeof value === 'number' ) {\r\n\r\n\t\t\tthis.setHex( value );\r\n\r\n\t\t} else if ( typeof value === 'string' ) {\r\n\r\n\t\t\tthis.setStyle( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.r = scalar;\r\n\t\tthis.g = scalar;\r\n\t\tthis.b = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSL: function () {\r\n\r\n\t\tfunction hue2rgb( p, q, t ) {\r\n\r\n\t\t\tif ( t < 0 ) { t += 1; }\r\n\t\t\tif ( t > 1 ) { t -= 1; }\r\n\t\t\tif ( t < 1 / 6 ) { return p + ( q - p ) * 6 * t; }\r\n\t\t\tif ( t < 1 / 2 ) { return q; }\r\n\t\t\tif ( t < 2 / 3 ) { return p + ( q - p ) * 6 * ( 2 / 3 - t ); }\r\n\t\t\treturn p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function setHSL( h, s, l ) {\r\n\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\t\th = _Math.euclideanModulo( h, 1 );\r\n\t\t\ts = _Math.clamp( s, 0, 1 );\r\n\t\t\tl = _Math.clamp( l, 0, 1 );\r\n\r\n\t\t\tif ( s === 0 ) {\r\n\r\n\t\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\tfunction handleAlpha( string ) {\r\n\r\n\t\t\tif ( string === undefined ) { return; }\r\n\r\n\t\t\tif ( parseFloat( string ) < 1 ) {\r\n\r\n\t\t\t\tconsole.warn( 'Color: Alpha component of ' + style + ' will be ignored.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar m;\r\n\r\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\r\n\t\t\t// rgb / hsl\r\n\r\n\t\t\tvar color;\r\n\t\t\tvar name = m[ 1 ];\r\n\t\t\tvar components = m[ 2 ];\r\n\r\n\t\t\tswitch ( name ) {\r\n\r\n\t\t\t\tcase 'rgb':\r\n\t\t\t\tcase 'rgba':\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'hsl':\r\n\t\t\t\tcase 'hsla':\r\n\r\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\r\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\r\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\r\n\t\t\t// hex color\r\n\r\n\t\t\tvar hex = m[ 1 ];\r\n\t\t\tvar size = hex.length;\r\n\r\n\t\t\tif ( size === 3 ) {\r\n\r\n\t\t\t\t// #ff0\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t} else if ( size === 6 ) {\r\n\r\n\t\t\t\t// #ff0000\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( style && style.length > 0 ) {\r\n\r\n\t\t\t// color keywords\r\n\t\t\tvar hex = ColorKeywords[ style ];\r\n\r\n\t\t\tif ( hex !== undefined ) {\r\n\r\n\t\t\t\t// red\r\n\t\t\t\tthis.setHex( hex );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// unknown color\r\n\t\t\t\tconsole.warn( 'Color: Unknown color ' + style );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.r, this.g, this.b );\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) { gammaFactor = 2.0; }\r\n\r\n\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) { gammaFactor = 2.0; }\r\n\r\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function ( gammaFactor ) {\r\n\r\n\t\tthis.copyGammaToLinear( this, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function ( gammaFactor ) {\r\n\r\n\t\tthis.copyLinearToGamma( this, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopySRGBToLinear: function () {\r\n\r\n\t\tfunction SRGBToLinear( c ) {\r\n\r\n\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\r\n\r\n\t\t}\r\n\r\n\t\treturn function copySRGBToLinear( color ) {\r\n\r\n\t\t\tthis.r = SRGBToLinear( color.r );\r\n\t\t\tthis.g = SRGBToLinear( color.g );\r\n\t\t\tthis.b = SRGBToLinear( color.b );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopyLinearToSRGB: function () {\r\n\r\n\t\tfunction LinearToSRGB( c ) {\r\n\r\n\t\t\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\r\n\r\n\t\t}\r\n\r\n\t\treturn function copyLinearToSRGB( color ) {\r\n\r\n\t\t\tthis.r = LinearToSRGB( color.r );\r\n\t\t\tthis.g = LinearToSRGB( color.g );\r\n\t\t\tthis.b = LinearToSRGB( color.b );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tconvertSRGBToLinear: function () {\r\n\r\n\t\tthis.copySRGBToLinear( this );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToSRGB: function () {\r\n\r\n\t\tthis.copyLinearToSRGB( this );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function ( target ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Color: .getHSL() target is now required' );\r\n\t\t\ttarget = { h: 0, s: 0, l: 0 };\r\n\r\n\t\t}\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tvar max = Math.max( r, g, b );\r\n\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\tvar hue, saturation;\r\n\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\tif ( min === max ) {\r\n\r\n\t\t\thue = 0;\r\n\t\t\tsaturation = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar delta = max - min;\r\n\r\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thue /= 6;\r\n\r\n\t\t}\r\n\r\n\t\ttarget.h = hue;\r\n\t\ttarget.s = saturation;\r\n\t\ttarget.l = lightness;\r\n\r\n\t\treturn target;\r\n\r\n\t},\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function () {\r\n\r\n\t\tvar hsl = {};\r\n\r\n\t\treturn function ( h, s, l ) {\r\n\r\n\t\t\tthis.getHSL( hsl );\r\n\r\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( color ) {\r\n\r\n\t\tthis.r = Math.max( 0, this.r - color.r );\r\n\t\tthis.g = Math.max( 0, this.g - color.g );\r\n\t\tthis.b = Math.max( 0, this.b - color.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpHSL: function () {\r\n\r\n\t\tvar hslA = { h: 0, s: 0, l: 0 };\r\n\t\tvar hslB = { h: 0, s: 0, l: 0 };\r\n\r\n\t\treturn function lerpHSL( color, alpha ) {\r\n\r\n\t\t\tthis.getHSL( hslA );\r\n\t\t\tcolor.getHSL( hslB );\r\n\r\n\t\t\tvar h = _Math.lerp( hslA.h, hslB.h, alpha );\r\n\t\t\tvar s = _Math.lerp( hslA.s, hslB.s, alpha );\r\n\t\t\tvar l = _Math.lerp( hslA.l, hslB.l, alpha );\r\n\r\n\t\t\tthis.setHSL( h, s, l );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( c ) {\r\n\r\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tthis.r = array[ offset ];\r\n\t\tthis.g = array[ offset + 1 ];\r\n\t\tthis.b = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) { array = []; }\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tarray[ offset ] = this.r;\r\n\t\tarray[ offset + 1 ] = this.g;\r\n\t\tarray[ offset + 2 ] = this.b;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\treturn this.getHex();\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Face3( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\r\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\r\n\tthis.color = ( color && color.isColor ) ? color : new Color();\r\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n}\r\n\r\nObject.assign( Face3.prototype, {\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.a = source.a;\r\n\t\tthis.b = source.b;\r\n\t\tthis.c = source.c;\r\n\r\n\t\tthis.normal.copy( source.normal );\r\n\t\tthis.color.copy( source.color );\r\n\r\n\t\tthis.materialIndex = source.materialIndex;\r\n\r\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis$1.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis$1.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Box3( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n}\r\n\r\nObject.assign( Box3.prototype, {\r\n\r\n\tisBox3: true,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromArray: function ( array ) {\r\n\r\n\t\tvar minX = + Infinity;\r\n\t\tvar minY = + Infinity;\r\n\t\tvar minZ = + Infinity;\r\n\r\n\t\tvar maxX = - Infinity;\r\n\t\tvar maxY = - Infinity;\r\n\t\tvar maxZ = - Infinity;\r\n\r\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n\t\t\tvar x = array[ i ];\r\n\t\t\tvar y = array[ i + 1 ];\r\n\t\t\tvar z = array[ i + 2 ];\r\n\r\n\t\t\tif ( x < minX ) { minX = x; }\r\n\t\t\tif ( y < minY ) { minY = y; }\r\n\t\t\tif ( z < minZ ) { minZ = z; }\r\n\r\n\t\t\tif ( x > maxX ) { maxX = x; }\r\n\t\t\tif ( y > maxY ) { maxY = y; }\r\n\t\t\tif ( z > maxZ ) { maxZ = z; }\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromBufferAttribute: function ( attribute ) {\r\n\r\n\t\tvar minX = + Infinity;\r\n\t\tvar minY = + Infinity;\r\n\t\tvar minZ = + Infinity;\r\n\r\n\t\tvar maxX = - Infinity;\r\n\t\tvar maxY = - Infinity;\r\n\t\tvar maxZ = - Infinity;\r\n\r\n\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\tvar x = attribute.getX( i );\r\n\t\t\tvar y = attribute.getY( i );\r\n\t\t\tvar z = attribute.getZ( i );\r\n\r\n\t\t\tif ( x < minX ) { minX = x; }\r\n\t\t\tif ( y < minY ) { minY = y; }\r\n\t\t\tif ( z < minZ ) { minZ = z; }\r\n\r\n\t\t\tif ( x > maxX ) { maxX = x; }\r\n\t\t\tif ( y > maxY ) { maxY = y; }\r\n\t\t\tif ( z > maxZ ) { maxZ = z; }\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis$1.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function setFromCenterAndSize( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function ( object ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\treturn this.expandByObject( object );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tisEmpty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tgetCenter: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Box3: .getCenter() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tgetSize: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Box3: .getSize() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByObject: function () {\r\n\r\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t// accounting for both the object's, and children's, world transforms\r\n\r\n\t\tvar scope, i, l;\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\tfunction traverse( node ) {\r\n\r\n\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\tif ( geometry.isGeometry ) {\r\n\r\n\t\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\tvar attribute = geometry.attributes.position;\r\n\r\n\t\t\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn function expandByObject( object ) {\r\n\r\n\t\t\tscope = this;\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tobject.traverse( traverse );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\r\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\r\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\r\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, target ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Box3: .getParameter() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\r\n\r\n\t},\r\n\r\n\tintersectsSphere: ( function () {\r\n\r\n\t\tvar closestPoint = new Vector3();\r\n\r\n\t\treturn function intersectsSphere( sphere ) {\r\n\r\n\t\t\t// Find the point on the AABB closest to the sphere center.\r\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\r\n\r\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\r\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// We compute the minimum and maximum dot product values. If those values\r\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\r\n\r\n\t\tvar min, max;\r\n\r\n\t\tif ( plane.normal.x > 0 ) {\r\n\r\n\t\t\tmin = plane.normal.x * this.min.x;\r\n\t\t\tmax = plane.normal.x * this.max.x;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin = plane.normal.x * this.max.x;\r\n\t\t\tmax = plane.normal.x * this.min.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.y > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.y * this.min.y;\r\n\t\t\tmax += plane.normal.y * this.max.y;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.y * this.max.y;\r\n\t\t\tmax += plane.normal.y * this.min.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.z > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.z * this.min.z;\r\n\t\t\tmax += plane.normal.z * this.max.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.z * this.max.z;\r\n\t\t\tmax += plane.normal.z * this.min.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn ( min <= plane.constant && max >= plane.constant );\r\n\r\n\t},\r\n\r\n\tintersectsTriangle: ( function () {\r\n\r\n\t\t// triangle centered vertices\r\n\t\tvar v0 = new Vector3();\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar v2 = new Vector3();\r\n\r\n\t\t// triangle edge vectors\r\n\t\tvar f0 = new Vector3();\r\n\t\tvar f1 = new Vector3();\r\n\t\tvar f2 = new Vector3();\r\n\r\n\t\tvar testAxis = new Vector3();\r\n\r\n\t\tvar center = new Vector3();\r\n\t\tvar extents = new Vector3();\r\n\r\n\t\tvar triangleNormal = new Vector3();\r\n\r\n\t\tfunction satForAxes( axes ) {\r\n\r\n\t\t\tvar i, j;\r\n\r\n\t\t\tfor ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {\r\n\r\n\t\t\t\ttestAxis.fromArray( axes, i );\r\n\t\t\t\t// project the aabb onto the seperating axis\r\n\t\t\t\tvar r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );\r\n\t\t\t\t// project all 3 vertices of the triangle onto the seperating axis\r\n\t\t\t\tvar p0 = v0.dot( testAxis );\r\n\t\t\t\tvar p1 = v1.dot( testAxis );\r\n\t\t\t\tvar p2 = v2.dot( testAxis );\r\n\t\t\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\r\n\t\t\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\r\n\r\n\t\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\r\n\t\t\t\t\t// the axis is seperating and we can exit\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn function intersectsTriangle( triangle ) {\r\n\r\n\t\t\tif ( this.isEmpty() ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// compute box center and extents\r\n\t\t\tthis.getCenter( center );\r\n\t\t\textents.subVectors( this.max, center );\r\n\r\n\t\t\t// translate triangle to aabb origin\r\n\t\t\tv0.subVectors( triangle.a, center );\r\n\t\t\tv1.subVectors( triangle.b, center );\r\n\t\t\tv2.subVectors( triangle.c, center );\r\n\r\n\t\t\t// compute edge vectors for triangle\r\n\t\t\tf0.subVectors( v1, v0 );\r\n\t\t\tf1.subVectors( v2, v1 );\r\n\t\t\tf2.subVectors( v0, v2 );\r\n\r\n\t\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\r\n\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\r\n\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\r\n\t\t\tvar axes = [\r\n\t\t\t\t0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,\r\n\t\t\t\tf0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,\r\n\t\t\t\t- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0\r\n\t\t\t];\r\n\t\t\tif ( ! satForAxes( axes ) ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// test 3 face normals from the aabb\r\n\t\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\r\n\t\t\tif ( ! satForAxes( axes ) ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// finally testing the face normal of the triangle\r\n\t\t\t// use already existing triangle edge vectors here\r\n\t\t\ttriangleNormal.crossVectors( f0, f1 );\r\n\t\t\taxes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];\r\n\t\t\treturn satForAxes( axes );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tclampPoint: function ( point, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Box3: .clampPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function distanceToPoint( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function getBoundingSphere( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Box3: .getBoundingSphere() target is now required' );\r\n\t\t\t\ttarget = new Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.getCenter( target.center );\r\n\r\n\t\t\ttarget.radius = this.getSize( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\r\n\t\tif ( this.isEmpty() ) { this.makeEmpty(); }\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3(),\r\n\t\t\tnew Vector3()\r\n\t\t];\r\n\r\n\t\treturn function applyMatrix4( matrix ) {\r\n\r\n\t\t\t// transform of empty box is an empty box.\r\n\t\t\tif ( this.isEmpty() ) { return this; }\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\r\n\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Sphere( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n}\r\n\r\nObject.assign( Sphere.prototype, {\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function () {\r\n\r\n\t\tvar box = new Box3();\r\n\r\n\t\treturn function setFromPoints( points, optionalCenter ) {\r\n\r\n\t\t\tvar center = this.center;\r\n\r\n\t\t\tif ( optionalCenter !== undefined ) {\r\n\r\n\t\t\t\tcenter.copy( optionalCenter );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.setFromPoints( points ).getCenter( center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsSphere( this );\r\n\r\n\t},\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, target ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Sphere: .clampPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\ttarget.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\ttarget.sub( this.center ).normalize();\r\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Sphere: .getBoundingBox() target is now required' );\r\n\t\t\ttarget = new Box3();\r\n\r\n\t\t}\r\n\r\n\t\ttarget.set( this.center, this.center );\r\n\t\ttarget.expandByScalar( this.radius );\r\n\r\n\t\treturn target;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Vector2( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n}\r\n\r\nObject.defineProperties( Vector2.prototype, {\r\n\r\n\t\"width\": {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.x;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis.x = value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t\"height\": {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.y;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis.y = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( Vector2.prototype, {\r\n\r\n\tisVector2: true,\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v ) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min = new Vector2();\r\n\t\tvar max = new Vector2();\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tmin.set( minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tcross: function ( v ) {\r\n\r\n\t\treturn this.x * v.y - this.y * v.x;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tmanhattanLength: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t},\r\n\r\n\tangle: function () {\r\n\r\n\t\t// computes the angle in radians with respect to the positive x-axis\r\n\r\n\t\tvar angle = Math.atan2( this.y, this.x );\r\n\r\n\t\tif ( angle < 0 ) { angle += 2 * Math.PI; }\r\n\r\n\t\treturn angle;\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tmanhattanDistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) { array = []; }\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector2: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x = attribute.getX( index );\r\n\t\tthis.y = attribute.getY( index );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateAround: function ( center, angle ) {\r\n\r\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\r\n\r\n\t\tvar x = this.x - center.x;\r\n\t\tvar y = this.y - center.y;\r\n\r\n\t\tthis.x = x * c - y * s + center.x;\r\n\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar geometryId = 0; // Geometry uses even numbers as Id\r\n\r\nfunction Geometry() {\r\n\r\n\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Geometry';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];\r\n\tthis.faces = [];\r\n\tthis.faceVertexUvs = [[]];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n}\r\n\r\nGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: Geometry,\r\n\r\n\tisGeometry: true,\r\n\r\n\tapplyMatrix: function ( matrix ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this$1.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this$1.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.verticesNeedUpdate = true;\r\n\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj = new Object3D();\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tfromBufferGeometry: function ( geometry ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar positions = attributes.position.array;\r\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\r\n\t\tif ( uvs2 !== undefined ) { this.faceVertexUvs[ 1 ] = []; }\r\n\r\n\t\tvar tempNormals = [];\r\n\t\tvar tempUVs = [];\r\n\t\tvar tempUVs2 = [];\r\n\r\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\r\n\t\t\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\r\n\r\n\t\t\tif ( normals !== undefined ) {\r\n\r\n\t\t\t\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colors !== undefined ) {\r\n\r\n\t\t\t\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs2 !== undefined ) {\r\n\r\n\t\t\t\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction addFace( a, b, c, materialIndex ) {\r\n\r\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\r\n\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\r\n\r\n\t\t\tscope.faces.push( face );\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs2 !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = geometry.groups;\r\n\r\n\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\t\tvar start = group.start;\r\n\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function () {\r\n\r\n\t\tvar offset = new Vector3();\r\n\r\n\t\treturn function center() {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t\tthis.boundingBox.getCenter( offset ).negate();\r\n\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tthis.computeBoundingSphere();\r\n\r\n\t\tvar center = this.boundingSphere.center;\r\n\t\tvar radius = this.boundingSphere.radius;\r\n\r\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\r\n\r\n\t\tvar matrix = new Matrix4();\r\n\t\tmatrix.set(\r\n\t\t\ts, 0, 0, - s * center.x,\r\n\t\t\t0, s, 0, - s * center.y,\r\n\t\t\t0, 0, s, - s * center.z,\r\n\t\t\t0, 0, 0, 1\r\n\t\t);\r\n\r\n\t\tthis.applyMatrix( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar cb = new Vector3(), ab = new Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this$1.faces[ f ];\r\n\r\n\t\t\tvar vA = this$1.vertices[ face.a ];\r\n\t\t\tvar vB = this$1.vertices[ face.b ];\r\n\t\t\tvar vC = this$1.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( areaWeighted === undefined ) { areaWeighted = true; }\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\tvertices = new Array( this.vertices.length );\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ] = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this$1.faces[ f ];\r\n\r\n\t\t\t\tvA = this$1.vertices[ face.a ];\r\n\t\t\t\tvB = this$1.vertices[ face.b ];\r\n\t\t\t\tvC = this$1.vertices[ face.c ];\r\n\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.computeFaceNormals();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this$1.faces[ f ];\r\n\r\n\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this$1.faces[ f ];\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.faces.length > 0 ) {\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeFlatVertexNormals: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar f, fl, face;\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this$1.faces[ f ];\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\r\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\r\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\r\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\r\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.faces.length > 0 ) {\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this$1.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) { face.__originalVertexNormals = []; }\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this$1.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis$1.morphNormals[ i ] = {};\r\n\t\t\t\tthis$1.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis$1.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this$1.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this$1.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tfaceNormal = new Vector3();\r\n\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this$1.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this$1.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this$1.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this$1.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\r\n\r\n\t\t\tconsole.error( 'Geometry.merge(): geometry not an instance of Geometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalMatrix,\r\n\t\t\tvertexOffset = this.vertices.length,\r\n\t\t\tvertices1 = this.vertices,\r\n\t\t\tvertices2 = geometry.vertices,\r\n\t\t\tfaces1 = this.faces,\r\n\t\t\tfaces2 = geometry.faces,\r\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\r\n\t\t\tcolors1 = this.colors,\r\n\t\t\tcolors2 = geometry.colors;\r\n\r\n\t\tif ( materialIndexOffset === undefined ) { materialIndexOffset = 0; }\r\n\r\n\t\tif ( matrix !== undefined ) {\r\n\r\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix !== undefined ) { vertexCopy.applyMatrix4( matrix ); }\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\r\n\r\n\t\t\tcolors1.push( colors2[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tif ( uv === undefined ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmergeMesh: function ( mesh ) {\r\n\r\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\r\n\r\n\t\t\tconsole.error( 'Geometry.mergeMesh(): mesh not an instance of Mesh.', mesh );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( mesh.matrixAutoUpdate ) { mesh.updateMatrix(); }\r\n\r\n\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\r\n\t},\r\n\r\n\tmergeVertices: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i, il, face;\r\n\t\tvar indices, j, jl;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this$1.vertices[ i ];\r\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this$1.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this$1.faces[ i ];\r\n\r\n\t\t\tface.a = changes[ face.a ];\r\n\t\t\tface.b = changes[ face.b ];\r\n\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\r\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\r\n\t\t\tthis$1.faces.splice( idx, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis$1.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.vertices = [];\r\n\r\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar point = points[ i ];\r\n\t\t\tthis$1.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsortFacesByMaterialIndex: function () {\r\n\r\n\t\tvar faces = this.faces;\r\n\t\tvar length = faces.length;\r\n\r\n\t\t// tag faces\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tfaces[ i ]._id = i;\r\n\r\n\t\t}\r\n\r\n\t\t// sort faces\r\n\r\n\t\tfunction materialIndexSort( a, b ) {\r\n\r\n\t\t\treturn a.materialIndex - b.materialIndex;\r\n\r\n\t\t}\r\n\r\n\t\tfaces.sort( materialIndexSort );\r\n\r\n\t\t// sort uvs\r\n\r\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\r\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\r\n\r\n\t\tvar newUvs1, newUvs2;\r\n\r\n\t\tif ( uvs1 && uvs1.length === length ) { newUvs1 = []; }\r\n\t\tif ( uvs2 && uvs2.length === length ) { newUvs2 = []; }\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar id = faces[ i ]._id;\r\n\r\n\t\t\tif ( newUvs1 ) { newUvs1.push( uvs1[ id ] ); }\r\n\t\t\tif ( newUvs2 ) { newUvs2.push( uvs2[ id ] ); }\r\n\r\n\t\t}\r\n\r\n\t\tif ( newUvs1 ) { this.faceVertexUvs[ 0 ] = newUvs1; }\r\n\t\tif ( newUvs2 ) { this.faceVertexUvs[ 1 ] = newUvs2; }\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Geometry',\r\n\t\t\t\tgenerator: 'Geometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard Geometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) { data.name = this.name; }\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tvar vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n\t\t\tvar vertex = this$1.vertices[ i ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = [];\r\n\t\tvar normals = [];\r\n\t\tvar normalsHash = {};\r\n\t\tvar colors = [];\r\n\t\tvar colorsHash = {};\r\n\t\tvar uvs = [];\r\n\t\tvar uvsHash = {};\r\n\r\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = this$1.faces[ i ];\r\n\r\n\t\t\tvar hasMaterial = true;\r\n\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\tvar hasFaceVertexUv = this$1.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n\t\t\tvar faceType = 0;\r\n\r\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\r\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n\t\t\tfaces.push( faceType );\r\n\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\t\tfaces.push( face.materialIndex );\r\n\r\n\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\tvar faceVertexUvs = this$1.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction setBit( value, position, enabled ) {\r\n\r\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNormalIndex( normal ) {\r\n\r\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getColorIndex( color ) {\r\n\r\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\tcolors.push( color.getHex() );\r\n\r\n\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getUvIndex( uv ) {\r\n\r\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\r\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = {};\r\n\r\n\t\tdata.data.vertices = vertices;\r\n\t\tdata.data.normals = normals;\r\n\t\tif ( colors.length > 0 ) { data.data.colors = colors; }\r\n\t\tif ( uvs.length > 0 ) { data.data.uvs = [ uvs ]; } // temporal backward compatibility\r\n\t\tdata.data.faces = faces;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new Geometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar i, il, j, jl, k, kl;\r\n\r\n\t\t// reset\r\n\r\n\t\tthis.vertices = [];\r\n\t\tthis.colors = [];\r\n\t\tthis.faces = [];\r\n\t\tthis.faceVertexUvs = [[]];\r\n\t\tthis.morphTargets = [];\r\n\t\tthis.morphNormals = [];\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\tthis.lineDistances = [];\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\r\n\t\t// name\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\t// vertices\r\n\r\n\t\tvar vertices = source.vertices;\r\n\r\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis$1.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tvar colors = source.colors;\r\n\r\n\t\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis$1.colors.push( colors[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tvar faces = source.faces;\r\n\r\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis$1.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// face vertex uvs\r\n\r\n\t\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\r\n\r\n\t\t\tif ( this$1.faceVertexUvs[ i ] === undefined ) {\r\n\r\n\t\t\t\tthis$1.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n\t\t\t\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\tvar uv = uvs[ k ];\r\n\r\n\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis$1.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// morph targets\r\n\r\n\t\tvar morphTargets = source.morphTargets;\r\n\r\n\t\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morphTarget = {};\r\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\r\n\r\n\t\t\t// vertices\r\n\r\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\r\n\r\n\t\t\t\tmorphTarget.vertices = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// normals\r\n\r\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\r\n\r\n\t\t\t\tmorphTarget.normals = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis$1.morphTargets.push( morphTarget );\r\n\r\n\t\t}\r\n\r\n\t\t// morph normals\r\n\r\n\t\tvar morphNormals = source.morphNormals;\r\n\r\n\t\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morphNormal = {};\r\n\r\n\t\t\t// vertex normals\r\n\r\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\r\n\r\n\t\t\t\tmorphNormal.vertexNormals = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\r\n\t\t\t\t\tvar destVertexNormal = {};\r\n\r\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\r\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\r\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\r\n\r\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// face normals\r\n\r\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\r\n\r\n\t\t\t\tmorphNormal.faceNormals = [];\r\n\r\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis$1.morphNormals.push( morphNormal );\r\n\r\n\t\t}\r\n\r\n\t\t// skin weights\r\n\r\n\t\tvar skinWeights = source.skinWeights;\r\n\r\n\t\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis$1.skinWeights.push( skinWeights[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// skin indices\r\n\r\n\t\tvar skinIndices = source.skinIndices;\r\n\r\n\t\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis$1.skinIndices.push( skinIndices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// line distances\r\n\r\n\t\tvar lineDistances = source.lineDistances;\r\n\r\n\t\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis$1.lineDistances.push( lineDistances[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// bounding box\r\n\r\n\t\tvar boundingBox = source.boundingBox;\r\n\r\n\t\tif ( boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// bounding sphere\r\n\r\n\t\tvar boundingSphere = source.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// update flags\r\n\r\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\r\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\r\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\r\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\r\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\r\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\r\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Vector4( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n}\r\n\r\nObject.assign( Vector4.prototype, {\r\n\r\n\tisVector4: true,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\t\tthis.w = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\t\tthis.w += v.w * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\t\tthis.w -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\t\tthis.w *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\tthis.x = 1;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = q.x / s;\r\n\t\t\tthis.y = q.y / s;\r\n\t\t\tthis.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\r\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\r\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\r\n\r\n\t\t\t\t// m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) {\r\n\r\n\t\t\t\t// m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\r\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\r\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) { s = 1; }\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\t\tthis.w = Math.min( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\t\tthis.w = Math.max( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// assumes min < max, componentwise\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new Vector4();\r\n\t\t\t\tmax = new Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\t\tthis.w = Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\t\tthis.w = Math.ceil( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\t\tthis.w = Math.round( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\t\tthis.w = - this.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tmanhattanLength: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() || 1 );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.normalize().multiplyScalar( length );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\t\tthis.w = array[ offset + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) { array = []; }\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\t\tarray[ offset + 3 ] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromBufferAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Vector4: offset has been removed from .fromBufferAttribute().' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x = attribute.getX( index );\r\n\t\tthis.y = attribute.getY( index );\r\n\t\tthis.z = attribute.getZ( index );\r\n\t\tthis.w = attribute.getW( index );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tif ( Array.isArray( array ) ) {\r\n\r\n\t\tthrow new TypeError( 'BufferAttribute: array should be a Typed Array.' );\r\n\r\n\t}\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.array = array;\r\n\tthis.itemSize = itemSize;\r\n\tthis.count = array !== undefined ? array.length / itemSize : 0;\r\n\tthis.normalized = normalized === true;\r\n\r\n\tthis.dynamic = false;\r\n\tthis.updateRange = { offset: 0, count: - 1 };\r\n\r\n\tthis.version = 0;\r\n\r\n}\r\n\r\nObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value === true ) { this.version ++; }\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( BufferAttribute.prototype, {\r\n\r\n\tisBufferAttribute: true,\r\n\r\n\tonUploadCallback: function () {},\r\n\r\n\tsetArray: function ( array ) {\r\n\r\n\t\tif ( Array.isArray( array ) ) {\r\n\r\n\t\t\tthrow new TypeError( 'BufferAttribute: array should be a Typed Array.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\r\n\t\tthis.array = array;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetDynamic: function ( value ) {\r\n\r\n\t\tthis.dynamic = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.name = source.name;\r\n\t\tthis.array = new source.array.constructor( source.array );\r\n\t\tthis.itemSize = source.itemSize;\r\n\t\tthis.count = source.count;\r\n\t\tthis.normalized = source.normalized;\r\n\r\n\t\tthis.dynamic = source.dynamic;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tindex1 *= this.itemSize;\r\n\t\tindex2 *= attribute.itemSize;\r\n\r\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n\t\t\tthis$1.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyArray: function ( array ) {\r\n\r\n\t\tthis.array.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyColorsArray: function ( colors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar color = colors[ i ];\r\n\r\n\t\t\tif ( color === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'BufferAttribute.copyColorsArray(): color is undefined', i );\r\n\t\t\t\tcolor = new Color();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = color.r;\r\n\t\t\tarray[ offset ++ ] = color.g;\r\n\t\t\tarray[ offset ++ ] = color.b;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector2sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector3sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector4sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\t\tarray[ offset ++ ] = vector.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetX: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize ];\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.array[ index * this.itemSize ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetY: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 1 ];\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetZ: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 2 ];\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetW: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 3 ];\r\n\r\n\t},\r\n\r\n\tsetW: function ( index, w ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\t\tthis.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonUpload: function ( callback ) {\r\n\r\n\t\tthis.onUploadCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n//\r\n\r\nfunction Int8BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\r\n\r\nfunction Uint8BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\r\n\r\nfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\r\n\r\nfunction Int16BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\r\n\r\nfunction Uint16BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\r\n\r\nfunction Int32BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\r\n\r\nfunction Uint32BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\r\n\r\nfunction Float32BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\r\n\r\nfunction Float64BufferAttribute( array, itemSize, normalized ) {\r\n\r\n\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\r\n\r\n}\r\n\r\nFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\r\nFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction DirectGeometry() {\r\n\r\n\tthis.vertices = [];\r\n\tthis.normals = [];\r\n\tthis.colors = [];\r\n\tthis.uvs = [];\r\n\tthis.uvs2 = [];\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.morphTargets = {};\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\t// this.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n}\r\n\r\nObject.assign( DirectGeometry.prototype, {\r\n\r\n\tcomputeGroups: function ( geometry ) {\r\n\r\n\t\tvar group;\r\n\t\tvar groups = [];\r\n\t\tvar materialIndex = undefined;\r\n\r\n\t\tvar faces = geometry.faces;\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t// materials\r\n\r\n\t\t\tif ( face.materialIndex !== materialIndex ) {\r\n\r\n\t\t\t\tmaterialIndex = face.materialIndex;\r\n\r\n\t\t\t\tif ( group !== undefined ) {\r\n\r\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\t\tgroups.push( group );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgroup = {\r\n\t\t\t\t\tstart: i * 3,\r\n\t\t\t\t\tmaterialIndex: materialIndex\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( group !== undefined ) {\r\n\r\n\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\tgroups.push( group );\r\n\r\n\t\t}\r\n\r\n\t\tthis.groups = groups;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\r\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\r\n\t\t// morphs\r\n\r\n\t\tvar morphTargets = geometry.morphTargets;\r\n\t\tvar morphTargetsLength = morphTargets.length;\r\n\r\n\t\tvar morphTargetsPosition;\r\n\r\n\t\tif ( morphTargetsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsPosition = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsPosition[ i ] = {\r\n\t\t\t\t\tname: morphTargets[ i ].name,\r\n\t\t\t\t \tdata: []\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\r\n\r\n\t\t}\r\n\r\n\t\tvar morphNormals = geometry.morphNormals;\r\n\t\tvar morphNormalsLength = morphNormals.length;\r\n\r\n\t\tvar morphTargetsNormal;\r\n\r\n\t\tif ( morphNormalsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsNormal = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsNormal[ i ] = {\r\n\t\t\t\t\tname: morphNormals[ i ].name,\r\n\t\t\t\t \tdata: []\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\r\n\r\n\t\t}\r\n\r\n\t\t// skins\r\n\r\n\t\tvar skinIndices = geometry.skinIndices;\r\n\t\tvar skinWeights = geometry.skinWeights;\r\n\r\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\r\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\r\n\r\n\t\t//\r\n\r\n\t\tif ( vertices.length > 0 && faces.length === 0 ) {\r\n\r\n\t\t\tconsole.error( 'DirectGeometry: Faceless geometries are not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tthis$1.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tthis$1.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar normal = face.normal;\r\n\r\n\t\t\t\tthis$1.normals.push( normal, normal, normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\tif ( vertexColors.length === 3 ) {\r\n\r\n\t\t\t\tthis$1.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar color = face.color;\r\n\r\n\t\t\t\tthis$1.colors.push( color, color, color );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis$1.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\r\n\t\t\t\t\tthis$1.uvs.push( new Vector2(), new Vector2(), new Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv2 === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis$1.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\r\n\t\t\t\t\tthis$1.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// morphs\r\n\r\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\r\n\r\n\t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\r\n\t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// skins\r\n\r\n\t\t\tif ( hasSkinIndices ) {\r\n\r\n\t\t\t\tthis$1.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasSkinWeights ) {\r\n\r\n\t\t\t\tthis$1.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeGroups( geometry );\r\n\r\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction arrayMin( array ) {\r\n\r\n\tif ( array.length === 0 ) { return Infinity; }\r\n\r\n\tvar min = array[ 0 ];\r\n\r\n\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\r\n\r\n\t\tif ( array[ i ] < min ) { min = array[ i ]; }\r\n\r\n\t}\r\n\r\n\treturn min;\r\n\r\n}\r\n\r\nfunction arrayMax( array ) {\r\n\r\n\tif ( array.length === 0 ) { return - Infinity; }\r\n\r\n\tvar max = array[ 0 ];\r\n\r\n\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\r\n\r\n\t\tif ( array[ i ] > max ) { max = array[ i ]; }\r\n\r\n\t}\r\n\r\n\treturn max;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\r\n\r\nfunction BufferGeometry() {\r\n\r\n\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'BufferGeometry';\r\n\r\n\tthis.index = null;\r\n\tthis.attributes = {};\r\n\r\n\tthis.morphAttributes = {};\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.drawRange = { start: 0, count: Infinity };\r\n\r\n\tthis.userData = {};\r\n\r\n}\r\n\r\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: BufferGeometry,\r\n\r\n\tisBufferGeometry: true,\r\n\r\n\tgetIndex: function () {\r\n\r\n\t\treturn this.index;\r\n\r\n\t},\r\n\r\n\tsetIndex: function ( index ) {\r\n\r\n\t\tif ( Array.isArray( index ) ) {\r\n\r\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.index = index;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\taddAttribute: function ( name, attribute ) {\r\n\r\n\t\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\r\n\r\n\t\t\tconsole.warn( 'BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n\t\t\treturn this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( name === 'index' ) {\r\n\r\n\t\t\tconsole.warn( 'BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n\t\t\tthis.setIndex( attribute );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.attributes[ name ] = attribute;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetAttribute: function ( name ) {\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t},\r\n\r\n\tremoveAttribute: function ( name ) {\r\n\r\n\t\tdelete this.attributes[ name ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddGroup: function ( start, count, materialIndex ) {\r\n\r\n\t\tthis.groups.push( {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tclearGroups: function () {\r\n\r\n\t\tthis.groups = [];\r\n\r\n\t},\r\n\r\n\tsetDrawRange: function ( start, count ) {\r\n\r\n\t\tthis.drawRange.start = start;\r\n\t\tthis.drawRange.count = count;\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tmatrix.applyToBufferAttribute( position );\r\n\t\t\tposition.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = this.attributes.normal;\r\n\r\n\t\tif ( normal !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t\tnormalMatrix.applyToBufferAttribute( normal );\r\n\t\t\tnormal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1 = new Matrix4();\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj = new Object3D();\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcenter: function () {\r\n\r\n\t\tvar offset = new Vector3();\r\n\r\n\t\treturn function center() {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t\tthis.boundingBox.getCenter( offset ).negate();\r\n\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function ( object ) {\r\n\r\n\t\t// console.log( 'BufferGeometry.setFromObject(). Converting', object, this );\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object.isPoints || object.isLine ) {\r\n\r\n\t\t\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\r\n\t\t\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\r\n\r\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\r\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\r\n\t\t\t\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\r\n\r\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object.isMesh ) {\r\n\r\n\t\t\tif ( geometry && geometry.isGeometry ) {\r\n\r\n\t\t\t\tthis.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tvar position = [];\r\n\r\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar point = points[ i ];\r\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateFromObject: function ( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object.isMesh ) {\r\n\r\n\t\t\tvar direct = geometry.__directGeometry;\r\n\r\n\t\t\tif ( geometry.elementsNeedUpdate === true ) {\r\n\r\n\t\t\t\tdirect = undefined;\r\n\t\t\t\tgeometry.elementsNeedUpdate = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( direct === undefined ) {\r\n\r\n\t\t\t\treturn this.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t\tgeometry = direct;\r\n\r\n\t\t}\r\n\r\n\t\tvar attribute;\r\n\r\n\t\tif ( geometry.verticesNeedUpdate === true ) {\r\n\r\n\t\t\tattribute = this.attributes.position;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.normalsNeedUpdate === true ) {\r\n\r\n\t\t\tattribute = this.attributes.normal;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colorsNeedUpdate === true ) {\r\n\r\n\t\t\tattribute = this.attributes.color;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvsNeedUpdate ) {\r\n\r\n\t\t\tattribute = this.attributes.uv;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\r\n\r\n\t\t\tattribute = this.attributes.lineDistance;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.groupsNeedUpdate ) {\r\n\r\n\t\t\tgeometry.computeGroups( object.geometry );\r\n\t\t\tthis.groups = geometry.groups;\r\n\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\r\n\r\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\r\n\r\n\t},\r\n\r\n\tfromDirectGeometry: function ( geometry ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\r\n\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\r\n\t\tif ( geometry.normals.length > 0 ) {\r\n\r\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\r\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colors.length > 0 ) {\r\n\r\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\r\n\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs.length > 0 ) {\r\n\r\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs2.length > 0 ) {\r\n\r\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\r\n\t\t}\r\n\r\n\t\t// groups\r\n\r\n\t\tthis.groups = geometry.groups;\r\n\r\n\t\t// morphs\r\n\r\n\t\tfor ( var name in geometry.morphTargets ) {\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\r\n\r\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\r\n\t\t\t\tvar attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\r\n\t\t\t\tattribute.name = morphTarget.name;\r\n\r\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis$1.morphAttributes[ name ] = array;\r\n\r\n\t\t}\r\n\r\n\t\t// skinning\r\n\r\n\t\tif ( geometry.skinIndices.length > 0 ) {\r\n\r\n\t\t\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.skinWeights.length > 0 ) {\r\n\r\n\t\t\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new Box3();\r\n\r\n\t\t}\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.boundingBox.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n\t\t\tconsole.error( 'BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tvar box = new Box3();\r\n\t\tvar vector = new Vector3();\r\n\r\n\t\treturn function computeBoundingSphere() {\r\n\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = new Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar position = this.attributes.position;\r\n\r\n\t\t\tif ( position ) {\r\n\r\n\t\t\t\tvar center = this.boundingSphere.center;\r\n\r\n\t\t\t\tbox.setFromBufferAttribute( position );\r\n\t\t\t\tbox.getCenter( center );\r\n\r\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvector.x = position.getX( i );\r\n\t\t\t\t\tvector.y = position.getY( i );\r\n\t\t\t\t\tvector.z = position.getZ( i );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\t// backwards compatibility\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tvar index = this.index;\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tif ( attributes.position ) {\r\n\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.normal === undefined ) {\r\n\r\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tvar array = attributes.normal.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tarray[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\r\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = index.count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvA = indices[ i + 0 ] * 3;\r\n\t\t\t\t\tvB = indices[ i + 1 ] * 3;\r\n\t\t\t\t\tvC = indices[ i + 2 ] * 3;\r\n\r\n\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\tpC.fromArray( positions, vC );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ vA ] += cb.x;\r\n\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\r\n\t\t\t\t\tnormals[ vB ] += cb.x;\r\n\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\r\n\t\t\t\t\tnormals[ vC ] += cb.x;\r\n\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tattributes.normal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, offset ) {\r\n\r\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\r\n\r\n\t\t\tconsole.error( 'BufferGeometry.merge(): geometry not an instance of BufferGeometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( offset === undefined ) {\r\n\r\n\t\t\toffset = 0;\r\n\r\n\t\t\tconsole.warn(\r\n\t\t\t\t'BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\r\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tif ( geometry.attributes[ key ] === undefined ) { continue; }\r\n\r\n\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\tvar attributeArray1 = attribute1.array;\r\n\r\n\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\tvar attributeArray2 = attribute2.array;\r\n\r\n\t\t\tvar attributeSize = attribute2.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar vector = new Vector3();\r\n\r\n\t\treturn function normalizeNormals() {\r\n\r\n\t\t\tvar normals = this.attributes.normal;\r\n\r\n\t\t\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\r\n\r\n\t\t\t\tvector.x = normals.getX( i );\r\n\t\t\t\tvector.y = normals.getY( i );\r\n\t\t\t\tvector.z = normals.getZ( i );\r\n\r\n\t\t\t\tvector.normalize();\r\n\r\n\t\t\t\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttoNonIndexed: function () {\r\n\r\n\t\tif ( this.index === null ) {\r\n\r\n\t\t\tconsole.warn( 'BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar geometry2 = new BufferGeometry();\r\n\r\n\t\tvar indices = this.index.array;\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\r\n\t\t\tvar array = attribute.array;\r\n\t\t\tvar itemSize = attribute.itemSize;\r\n\r\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\r\n\r\n\t\t\tvar index = 0, index2 = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tindex = indices[ i ] * itemSize;\r\n\r\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\r\n\r\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard BufferGeometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) { data.name = this.name; }\r\n\t\tif ( Object.keys( this.userData ).length > 0 ) { data.userData = this.userData; }\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = { attributes: {} };\r\n\r\n\t\tvar index = this.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( index.array );\r\n\r\n\t\t\tdata.data.index = {\r\n\t\t\t\ttype: index.array.constructor.name,\r\n\t\t\t\tarray: array\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\r\n\t\t\tdata.data.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\tarray: array,\r\n\t\t\t\tnormalized: attribute.normalized\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = this.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tdata.data.boundingSphere = {\r\n\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new BufferGeometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar name, i, l;\r\n\r\n\t\t// reset\r\n\r\n\t\tthis.index = null;\r\n\t\tthis.attributes = {};\r\n\t\tthis.morphAttributes = {};\r\n\t\tthis.groups = [];\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\r\n\t\t// name\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\t// index\r\n\r\n\t\tvar index = source.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tthis.setIndex( index.clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// attributes\r\n\r\n\t\tvar attributes = source.attributes;\r\n\r\n\t\tfor ( name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\t\t\tthis$1.addAttribute( name, attribute.clone() );\r\n\r\n\t\t}\r\n\r\n\t\t// morph attributes\r\n\r\n\t\tvar morphAttributes = source.morphAttributes;\r\n\r\n\t\tfor ( name in morphAttributes ) {\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\r\n\r\n\t\t\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray.push( morphAttribute[ i ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis$1.morphAttributes[ name ] = array;\r\n\r\n\t\t}\r\n\r\n\t\t// groups\r\n\r\n\t\tvar groups = source.groups;\r\n\r\n\t\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tthis$1.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// bounding box\r\n\r\n\t\tvar boundingBox = source.boundingBox;\r\n\r\n\t\tif ( boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// bounding sphere\r\n\r\n\t\tvar boundingSphere = source.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// draw range\r\n\r\n\t\tthis.drawRange.start = source.drawRange.start;\r\n\t\tthis.drawRange.count = source.drawRange.count;\r\n\r\n\t\t// user data\r\n\r\n\t\tthis.userData = source.userData;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// SphereGeometry\r\n\r\nfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'SphereGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nSphereGeometry.prototype = Object.create( Geometry.prototype );\r\nSphereGeometry.prototype.constructor = SphereGeometry;\r\n\r\n// SphereBufferGeometry\r\n\r\nfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'SphereBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradius = radius || 1;\r\n\r\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n\tvar thetaEnd = thetaStart + thetaLength;\r\n\r\n\tvar ix, iy;\r\n\r\n\tvar index = 0;\r\n\tvar grid = [];\r\n\r\n\tvar vertex = new Vector3();\r\n\tvar normal = new Vector3();\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( iy = 0; iy <= heightSegments; iy ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\r\n\t\tvar v = iy / heightSegments;\r\n\r\n\t\tfor ( ix = 0; ix <= widthSegments; ix ++ ) {\r\n\r\n\t\t\tvar u = ix / widthSegments;\r\n\r\n\t\t\t// vertex\r\n\r\n\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\r\n\t\t\tnormal.set( vertex.x, vertex.y, vertex.z ).normalize();\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t// uv\r\n\r\n\t\t\tuvs.push( u, 1 - v );\r\n\r\n\t\t\tverticesRow.push( index ++ );\r\n\r\n\t\t}\r\n\r\n\t\tgrid.push( verticesRow );\r\n\r\n\t}\r\n\r\n\t// indices\r\n\r\n\tfor ( iy = 0; iy < heightSegments; iy ++ ) {\r\n\r\n\t\tfor ( ix = 0; ix < widthSegments; ix ++ ) {\r\n\r\n\t\t\tvar a = grid[ iy ][ ix + 1 ];\r\n\t\t\tvar b = grid[ iy ][ ix ];\r\n\t\t\tvar c = grid[ iy + 1 ][ ix ];\r\n\t\t\tvar d = grid[ iy + 1 ][ ix + 1 ];\r\n\r\n\t\t\tif ( iy !== 0 || thetaStart > 0 ) { indices.push( a, b, d ); }\r\n\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) { indices.push( b, c, d ); }\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n}\r\n\r\nSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar REVISION = '96';\r\nvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\nvar CullFaceNone = 0;\r\nvar CullFaceBack = 1;\r\nvar CullFaceFront = 2;\r\nvar CullFaceFrontBack = 3;\r\nvar FrontFaceDirectionCW = 0;\r\nvar FrontFaceDirectionCCW = 1;\r\nvar BasicShadowMap = 0;\r\nvar PCFShadowMap = 1;\r\nvar PCFSoftShadowMap = 2;\r\nvar FrontSide = 0;\r\nvar BackSide = 1;\r\nvar DoubleSide = 2;\r\nvar FlatShading = 1;\r\nvar SmoothShading = 2;\r\nvar NoColors = 0;\r\nvar FaceColors = 1;\r\nvar VertexColors = 2;\r\nvar NoBlending = 0;\r\nvar NormalBlending = 1;\r\nvar AdditiveBlending = 2;\r\nvar SubtractiveBlending = 3;\r\nvar MultiplyBlending = 4;\r\nvar CustomBlending = 5;\r\nvar AddEquation = 100;\r\nvar SubtractEquation = 101;\r\nvar ReverseSubtractEquation = 102;\r\nvar MinEquation = 103;\r\nvar MaxEquation = 104;\r\nvar ZeroFactor = 200;\r\nvar OneFactor = 201;\r\nvar SrcColorFactor = 202;\r\nvar OneMinusSrcColorFactor = 203;\r\nvar SrcAlphaFactor = 204;\r\nvar OneMinusSrcAlphaFactor = 205;\r\nvar DstAlphaFactor = 206;\r\nvar OneMinusDstAlphaFactor = 207;\r\nvar DstColorFactor = 208;\r\nvar OneMinusDstColorFactor = 209;\r\nvar SrcAlphaSaturateFactor = 210;\r\nvar NeverDepth = 0;\r\nvar AlwaysDepth = 1;\r\nvar LessDepth = 2;\r\nvar LessEqualDepth = 3;\r\nvar EqualDepth = 4;\r\nvar GreaterEqualDepth = 5;\r\nvar GreaterDepth = 6;\r\nvar NotEqualDepth = 7;\r\nvar MultiplyOperation = 0;\r\nvar MixOperation = 1;\r\nvar AddOperation = 2;\r\nvar NoToneMapping = 0;\r\nvar LinearToneMapping = 1;\r\nvar ReinhardToneMapping = 2;\r\nvar Uncharted2ToneMapping = 3;\r\nvar CineonToneMapping = 4;\r\nvar UVMapping = 300;\r\nvar CubeReflectionMapping = 301;\r\nvar CubeRefractionMapping = 302;\r\nvar EquirectangularReflectionMapping = 303;\r\nvar EquirectangularRefractionMapping = 304;\r\nvar SphericalReflectionMapping = 305;\r\nvar CubeUVReflectionMapping = 306;\r\nvar CubeUVRefractionMapping = 307;\r\nvar RepeatWrapping = 1000;\r\nvar ClampToEdgeWrapping = 1001;\r\nvar MirroredRepeatWrapping = 1002;\r\nvar NearestFilter = 1003;\r\nvar NearestMipMapNearestFilter = 1004;\r\nvar NearestMipMapLinearFilter = 1005;\r\nvar LinearFilter = 1006;\r\nvar LinearMipMapNearestFilter = 1007;\r\nvar LinearMipMapLinearFilter = 1008;\r\nvar UnsignedByteType = 1009;\r\nvar ByteType = 1010;\r\nvar ShortType = 1011;\r\nvar UnsignedShortType = 1012;\r\nvar IntType = 1013;\r\nvar UnsignedIntType = 1014;\r\nvar FloatType = 1015;\r\nvar HalfFloatType = 1016;\r\nvar UnsignedShort4444Type = 1017;\r\nvar UnsignedShort5551Type = 1018;\r\nvar UnsignedShort565Type = 1019;\r\nvar UnsignedInt248Type = 1020;\r\nvar AlphaFormat = 1021;\r\nvar RGBFormat = 1022;\r\nvar RGBAFormat = 1023;\r\nvar LuminanceFormat = 1024;\r\nvar LuminanceAlphaFormat = 1025;\r\nvar RGBEFormat = RGBAFormat;\r\nvar DepthFormat = 1026;\r\nvar DepthStencilFormat = 1027;\r\nvar RGB_S3TC_DXT1_Format = 33776;\r\nvar RGBA_S3TC_DXT1_Format = 33777;\r\nvar RGBA_S3TC_DXT3_Format = 33778;\r\nvar RGBA_S3TC_DXT5_Format = 33779;\r\nvar RGB_PVRTC_4BPPV1_Format = 35840;\r\nvar RGB_PVRTC_2BPPV1_Format = 35841;\r\nvar RGBA_PVRTC_4BPPV1_Format = 35842;\r\nvar RGBA_PVRTC_2BPPV1_Format = 35843;\r\nvar RGB_ETC1_Format = 36196;\r\nvar RGBA_ASTC_4x4_Format = 37808;\r\nvar RGBA_ASTC_5x4_Format = 37809;\r\nvar RGBA_ASTC_5x5_Format = 37810;\r\nvar RGBA_ASTC_6x5_Format = 37811;\r\nvar RGBA_ASTC_6x6_Format = 37812;\r\nvar RGBA_ASTC_8x5_Format = 37813;\r\nvar RGBA_ASTC_8x6_Format = 37814;\r\nvar RGBA_ASTC_8x8_Format = 37815;\r\nvar RGBA_ASTC_10x5_Format = 37816;\r\nvar RGBA_ASTC_10x6_Format = 37817;\r\nvar RGBA_ASTC_10x8_Format = 37818;\r\nvar RGBA_ASTC_10x10_Format = 37819;\r\nvar RGBA_ASTC_12x10_Format = 37820;\r\nvar RGBA_ASTC_12x12_Format = 37821;\r\nvar LoopOnce = 2200;\r\nvar LoopRepeat = 2201;\r\nvar LoopPingPong = 2202;\r\nvar InterpolateDiscrete = 2300;\r\nvar InterpolateLinear = 2301;\r\nvar InterpolateSmooth = 2302;\r\nvar ZeroCurvatureEnding = 2400;\r\nvar ZeroSlopeEnding = 2401;\r\nvar WrapAroundEnding = 2402;\r\nvar TrianglesDrawMode = 0;\r\nvar TriangleStripDrawMode = 1;\r\nvar TriangleFanDrawMode = 2;\r\nvar LinearEncoding = 3000;\r\nvar sRGBEncoding = 3001;\r\nvar GammaEncoding = 3007;\r\nvar RGBEEncoding = 3002;\r\nvar LogLuvEncoding = 3003;\r\nvar RGBM7Encoding = 3004;\r\nvar RGBM16Encoding = 3005;\r\nvar RGBDEncoding = 3006;\r\nvar BasicDepthPacking = 3200;\r\nvar RGBADepthPacking = 3201;\r\nvar TangentSpaceNormalMap = 0;\r\nvar ObjectSpaceNormalMap = 1;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar materialId = 0;\r\n\r\nfunction Material() {\r\n\r\n\tObject.defineProperty( this, 'id', { value: materialId ++ } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Material';\r\n\r\n\tthis.fog = true;\r\n\tthis.lights = true;\r\n\r\n\tthis.blending = NormalBlending;\r\n\tthis.side = FrontSide;\r\n\tthis.flatShading = false;\r\n\tthis.vertexColors = NoColors; // NoColors, VertexColors, FaceColors\r\n\r\n\tthis.opacity = 1;\r\n\tthis.transparent = false;\r\n\r\n\tthis.blendSrc = SrcAlphaFactor;\r\n\tthis.blendDst = OneMinusSrcAlphaFactor;\r\n\tthis.blendEquation = AddEquation;\r\n\tthis.blendSrcAlpha = null;\r\n\tthis.blendDstAlpha = null;\r\n\tthis.blendEquationAlpha = null;\r\n\r\n\tthis.depthFunc = LessEqualDepth;\r\n\tthis.depthTest = true;\r\n\tthis.depthWrite = true;\r\n\r\n\tthis.clippingPlanes = null;\r\n\tthis.clipIntersection = false;\r\n\tthis.clipShadows = false;\r\n\r\n\tthis.shadowSide = null;\r\n\r\n\tthis.colorWrite = true;\r\n\r\n\tthis.precision = null; // override the renderer's default precision for this material\r\n\r\n\tthis.polygonOffset = false;\r\n\tthis.polygonOffsetFactor = 0;\r\n\tthis.polygonOffsetUnits = 0;\r\n\r\n\tthis.dithering = false;\r\n\r\n\tthis.alphaTest = 0;\r\n\tthis.premultipliedAlpha = false;\r\n\r\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis.userData = {};\r\n\r\n\tthis.needsUpdate = true;\r\n\r\n}\r\n\r\nMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: Material,\r\n\r\n\tisMaterial: true,\r\n\r\n\tonBeforeCompile: function () {},\r\n\r\n\tsetValues: function ( values ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( values === undefined ) { return; }\r\n\r\n\t\tfor ( var key in values ) {\r\n\r\n\t\t\tvar newValue = values[ key ];\r\n\r\n\t\t\tif ( newValue === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// for backward compatability if shading is set in the constructor\r\n\t\t\tif ( key === 'shading' ) {\r\n\r\n\t\t\t\tconsole.warn( '' + this$1.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\r\n\t\t\t\tthis$1.flatShading = ( newValue === FlatShading ) ? true : false;\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar currentValue = this$1[ key ];\r\n\r\n\t\t\tif ( currentValue === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"\" + this$1.type + \": '\" + key + \"' is not a property of this material.\" );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( currentValue && currentValue.isColor ) {\r\n\r\n\t\t\t\tcurrentValue.set( newValue );\r\n\r\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\r\n\r\n\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t} else if ( key === 'overdraw' ) {\r\n\r\n\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\r\n\t\t\t\tthis$1[ key ] = Number( newValue );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis$1[ key ] = newValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar isRoot = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tmeta = {\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {}\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Material',\r\n\t\t\t\tgenerator: 'Material.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard Material serialization\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\r\n\t\tif ( this.name !== '' ) { data.name = this.name; }\r\n\r\n\t\tif ( this.color && this.color.isColor ) { data.color = this.color.getHex(); }\r\n\r\n\t\tif ( this.roughness !== undefined ) { data.roughness = this.roughness; }\r\n\t\tif ( this.metalness !== undefined ) { data.metalness = this.metalness; }\r\n\r\n\t\tif ( this.emissive && this.emissive.isColor ) { data.emissive = this.emissive.getHex(); }\r\n\t\tif ( this.emissiveIntensity !== 1 ) { data.emissiveIntensity = this.emissiveIntensity; }\r\n\r\n\t\tif ( this.specular && this.specular.isColor ) { data.specular = this.specular.getHex(); }\r\n\t\tif ( this.shininess !== undefined ) { data.shininess = this.shininess; }\r\n\t\tif ( this.clearCoat !== undefined ) { data.clearCoat = this.clearCoat; }\r\n\t\tif ( this.clearCoatRoughness !== undefined ) { data.clearCoatRoughness = this.clearCoatRoughness; }\r\n\r\n\t\tif ( this.map && this.map.isTexture ) { data.map = this.map.toJSON( meta ).uuid; }\r\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) { data.alphaMap = this.alphaMap.toJSON( meta ).uuid; }\r\n\t\tif ( this.lightMap && this.lightMap.isTexture ) { data.lightMap = this.lightMap.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\r\n\r\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\r\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\r\n\r\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\r\n\t\t\tdata.bumpScale = this.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\r\n\r\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\r\n\t\t\tdata.normalMapType = this.normalMapType;\r\n\t\t\tdata.normalScale = this.normalScale.toArray();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\r\n\r\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\r\n\t\t\tdata.displacementScale = this.displacementScale;\r\n\t\t\tdata.displacementBias = this.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) { data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid; }\r\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) { data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) { data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid; }\r\n\t\tif ( this.specularMap && this.specularMap.isTexture ) { data.specularMap = this.specularMap.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.envMap && this.envMap.isTexture ) {\r\n\r\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\r\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\r\n\r\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.size !== undefined ) { data.size = this.size; }\r\n\t\tif ( this.sizeAttenuation !== undefined ) { data.sizeAttenuation = this.sizeAttenuation; }\r\n\r\n\t\tif ( this.blending !== NormalBlending ) { data.blending = this.blending; }\r\n\t\tif ( this.flatShading === true ) { data.flatShading = this.flatShading; }\r\n\t\tif ( this.side !== FrontSide ) { data.side = this.side; }\r\n\t\tif ( this.vertexColors !== NoColors ) { data.vertexColors = this.vertexColors; }\r\n\r\n\t\tif ( this.opacity < 1 ) { data.opacity = this.opacity; }\r\n\t\tif ( this.transparent === true ) { data.transparent = this.transparent; }\r\n\r\n\t\tdata.depthFunc = this.depthFunc;\r\n\t\tdata.depthTest = this.depthTest;\r\n\t\tdata.depthWrite = this.depthWrite;\r\n\r\n\t\t// rotation (SpriteMaterial)\r\n\t\tif ( this.rotation !== 0 ) { data.rotation = this.rotation; }\r\n\r\n\t\tif ( this.polygonOffset === true ) { data.polygonOffset = true; }\r\n\t\tif ( this.polygonOffsetFactor !== 0 ) { data.polygonOffsetFactor = this.polygonOffsetFactor; }\r\n\t\tif ( this.polygonOffsetUnits !== 0 ) { data.polygonOffsetUnits = this.polygonOffsetUnits; }\r\n\r\n\t\tif ( this.linewidth !== 1 ) { data.linewidth = this.linewidth; }\r\n\t\tif ( this.dashSize !== undefined ) { data.dashSize = this.dashSize; }\r\n\t\tif ( this.gapSize !== undefined ) { data.gapSize = this.gapSize; }\r\n\t\tif ( this.scale !== undefined ) { data.scale = this.scale; }\r\n\r\n\t\tif ( this.dithering === true ) { data.dithering = true; }\r\n\r\n\t\tif ( this.alphaTest > 0 ) { data.alphaTest = this.alphaTest; }\r\n\t\tif ( this.premultipliedAlpha === true ) { data.premultipliedAlpha = this.premultipliedAlpha; }\r\n\r\n\t\tif ( this.wireframe === true ) { data.wireframe = this.wireframe; }\r\n\t\tif ( this.wireframeLinewidth > 1 ) { data.wireframeLinewidth = this.wireframeLinewidth; }\r\n\t\tif ( this.wireframeLinecap !== 'round' ) { data.wireframeLinecap = this.wireframeLinecap; }\r\n\t\tif ( this.wireframeLinejoin !== 'round' ) { data.wireframeLinejoin = this.wireframeLinejoin; }\r\n\r\n\t\tif ( this.morphTargets === true ) { data.morphTargets = true; }\r\n\t\tif ( this.skinning === true ) { data.skinning = true; }\r\n\r\n\t\tif ( this.visible === false ) { data.visible = false; }\r\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }\r\n\r\n\t\t// TODO: Copied from Object3D.toJSON\r\n\r\n\t\tfunction extractFromCache( cache ) {\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tfor ( var key in cache ) {\r\n\r\n\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\tvar images = extractFromCache( meta.images );\r\n\r\n\t\t\tif ( textures.length > 0 ) { data.textures = textures; }\r\n\t\t\tif ( images.length > 0 ) { data.images = images; }\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.fog = source.fog;\r\n\t\tthis.lights = source.lights;\r\n\r\n\t\tthis.blending = source.blending;\r\n\t\tthis.side = source.side;\r\n\t\tthis.flatShading = source.flatShading;\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\r\n\t\tthis.opacity = source.opacity;\r\n\t\tthis.transparent = source.transparent;\r\n\r\n\t\tthis.blendSrc = source.blendSrc;\r\n\t\tthis.blendDst = source.blendDst;\r\n\t\tthis.blendEquation = source.blendEquation;\r\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\r\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\r\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\r\n\r\n\t\tthis.depthFunc = source.depthFunc;\r\n\t\tthis.depthTest = source.depthTest;\r\n\t\tthis.depthWrite = source.depthWrite;\r\n\r\n\t\tthis.colorWrite = source.colorWrite;\r\n\r\n\t\tthis.precision = source.precision;\r\n\r\n\t\tthis.polygonOffset = source.polygonOffset;\r\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\r\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\r\n\r\n\t\tthis.dithering = source.dithering;\r\n\r\n\t\tthis.alphaTest = source.alphaTest;\r\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\r\n\r\n\t\tthis.overdraw = source.overdraw;\r\n\r\n\t\tthis.visible = source.visible;\r\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n\t\tthis.clipShadows = source.clipShadows;\r\n\t\tthis.clipIntersection = source.clipIntersection;\r\n\r\n\t\tvar srcPlanes = source.clippingPlanes,\r\n\t\t\tdstPlanes = null;\r\n\r\n\t\tif ( srcPlanes !== null ) {\r\n\r\n\t\t\tvar n = srcPlanes.length;\r\n\t\t\tdstPlanes = new Array( n );\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i )\r\n\t\t\t\t{ dstPlanes[ i ] = srcPlanes[ i ].clone(); }\r\n\r\n\t\t}\r\n\r\n\t\tthis.clippingPlanes = dstPlanes;\r\n\r\n\t\tthis.shadowSide = source.shadowSide;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshBasicMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'MeshBasicMaterial';\r\n\r\n\tthis.color = new Color( 0xffffff ); // emissive\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nMeshBasicMaterial.prototype = Object.create( Material.prototype );\r\nMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\r\n\r\nMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\r\n\r\nMeshBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LineBasicMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'LineBasicMaterial';\r\n\r\n\tthis.color = new Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\tthis.linecap = 'round';\r\n\tthis.linejoin = 'round';\r\n\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nLineBasicMaterial.prototype = Object.create( Material.prototype );\r\nLineBasicMaterial.prototype.constructor = LineBasicMaterial;\r\n\r\nLineBasicMaterial.prototype.isLineBasicMaterial = true;\r\n\r\nLineBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.linewidth = source.linewidth;\r\n\tthis.linecap = source.linecap;\r\n\tthis.linejoin = source.linejoin;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Ray( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\r\n\r\n}\r\n\r\nObject.assign( Ray.prototype, {\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function ( t, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Ray: .at() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tlookAt: function ( v ) {\r\n\r\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trecast: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function recast( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Ray: .closestPointToPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\ttarget.subVectors( point, this.origin );\r\n\r\n\t\tvar directionDistance = target.dot( this.direction );\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn target.copy( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\r\n\r\n\t},\r\n\r\n\tdistanceSqToPoint: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function distanceSqToPoint( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n\t\t\t// point behind the ray\r\n\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\t\treturn this.origin.distanceToSquared( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceToSquared( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdistanceSqToSegment: function () {\r\n\r\n\t\tvar segCenter = new Vector3();\r\n\t\tvar segDir = new Vector3();\r\n\t\tvar diff = new Vector3();\r\n\r\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\r\n\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t// defined by v0 and v1\r\n\t\t\t// It can also set two optional targets :\r\n\t\t\t// - The closest point on the ray\r\n\t\t\t// - The closest point on the segment\r\n\r\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\r\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\tvar c = diff.lengthSq();\r\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\tvar s0, s1, sqrDist, extDet;\r\n\r\n\t\t\tif ( det > 0 ) {\r\n\r\n\t\t\t\t// The ray and segment are not parallel.\r\n\r\n\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\textDet = segExtent * det;\r\n\r\n\t\t\t\tif ( s0 >= 0 ) {\r\n\r\n\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\r\n\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\r\n\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// region 1\r\n\r\n\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 5\r\n\r\n\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\r\n\t\t\t\t\t\t// region 4\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t// region 3\r\n\r\n\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 2\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Ray and segment are parallel.\r\n\r\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnRay ) {\r\n\r\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnSegment ) {\r\n\r\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn sqrDist;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectSphere: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function intersectSphere( sphere, target ) {\r\n\r\n\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\t\tvar tca = v1.dot( this.direction );\r\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\r\n\t\t\tif ( d2 > radius2 ) { return null; }\r\n\r\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\r\n\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\tvar t0 = tca - thc;\r\n\r\n\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\tvar t1 = tca + thc;\r\n\r\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\tif ( t0 < 0 && t1 < 0 ) { return null; }\r\n\r\n\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\tif ( t0 < 0 ) { return this.at( t1, target ); }\r\n\r\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n\t\t\treturn this.at( t0, target );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\t// Return if the ray never intersects the plane\r\n\r\n\t\treturn t >= 0 ? t : null;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, target ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === null ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.at( t, target );\r\n\r\n\t},\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// check if the ray lies on the plane first\r\n\r\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n\t\tif ( distToPoint === 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator * distToPoint < 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tintersectBox: function ( box, target ) {\r\n\r\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\tinvdirz = 1 / this.direction.z;\r\n\r\n\t\tvar origin = this.origin;\r\n\r\n\t\tif ( invdirx >= 0 ) {\r\n\r\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\r\n\t\t}\r\n\r\n\t\tif ( invdiry >= 0 ) {\r\n\r\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) { return null; }\r\n\r\n\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n\t\tif ( tymin > tmin || tmin !== tmin ) { tmin = tymin; }\r\n\r\n\t\tif ( tymax < tmax || tmax !== tmax ) { tmax = tymax; }\r\n\r\n\t\tif ( invdirz >= 0 ) {\r\n\r\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) { return null; }\r\n\r\n\t\tif ( tzmin > tmin || tmin !== tmin ) { tmin = tzmin; }\r\n\r\n\t\tif ( tzmax < tmax || tmax !== tmax ) { tmax = tzmax; }\r\n\r\n\t\t//return point closest to the ray (positive side)\r\n\r\n\t\tif ( tmax < 0 ) { return null; }\r\n\r\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\r\n\r\n\t},\r\n\r\n\tintersectsBox: ( function () {\r\n\r\n\t\tvar v = new Vector3();\r\n\r\n\t\treturn function intersectsBox( box ) {\r\n\r\n\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectTriangle: function () {\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\t\tvar diff = new Vector3();\r\n\t\tvar edge1 = new Vector3();\r\n\t\tvar edge2 = new Vector3();\r\n\t\tvar normal = new Vector3();\r\n\r\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, target ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\r\n\r\n\t\t\tedge1.subVectors( b, a );\r\n\t\t\tedge2.subVectors( c, a );\r\n\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\r\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\tvar sign;\r\n\r\n\t\t\tif ( DdN > 0 ) {\r\n\r\n\t\t\t\tif ( backfaceCulling ) { return null; }\r\n\t\t\t\tsign = 1;\r\n\r\n\t\t\t} else if ( DdN < 0 ) {\r\n\r\n\t\t\t\tsign = - 1;\r\n\t\t\t\tDdN = - DdN;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n\t\t\t// b1 < 0, no intersection\r\n\t\t\tif ( DdQxE2 < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n\t\t\t// b2 < 0, no intersection\r\n\t\t\tif ( DdE1xQ < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\r\n\t\t\t// t < 0, no intersection\r\n\t\t\tif ( QdN < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Ray intersects triangle.\r\n\t\t\treturn this.at( QdN / DdN, target );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.transformDirection( matrix4 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Triangle( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new Vector3();\r\n\r\n}\r\n\r\nObject.assign( Triangle, {\r\n\r\n\tgetNormal: function () {\r\n\r\n\t\tvar v0 = new Vector3();\r\n\r\n\t\treturn function getNormal( a, b, c, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Triangle: .getNormal() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.subVectors( c, b );\r\n\t\t\tv0.subVectors( a, b );\r\n\t\t\ttarget.cross( v0 );\r\n\r\n\t\t\tvar targetLengthSq = target.lengthSq();\r\n\t\t\tif ( targetLengthSq > 0 ) {\r\n\r\n\t\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.set( 0, 0, 0 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\t// static/instance method to calculate barycentric coordinates\r\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\n\tgetBarycoord: function () {\r\n\r\n\t\tvar v0 = new Vector3();\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar v2 = new Vector3();\r\n\r\n\t\treturn function getBarycoord( point, a, b, c, target ) {\r\n\r\n\t\t\tv0.subVectors( c, a );\r\n\t\t\tv1.subVectors( b, a );\r\n\t\t\tv2.subVectors( point, a );\r\n\r\n\t\t\tvar dot00 = v0.dot( v0 );\r\n\t\t\tvar dot01 = v0.dot( v1 );\r\n\t\t\tvar dot02 = v0.dot( v2 );\r\n\t\t\tvar dot11 = v1.dot( v1 );\r\n\t\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Triangle: .getBarycoord() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// collinear or singular triangle\r\n\t\t\tif ( denom === 0 ) {\r\n\r\n\t\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\t\treturn target.set( - 2, - 1, - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar invDenom = 1 / denom;\r\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t\t// barycentric coordinates must always sum to 1\r\n\t\t\treturn target.set( 1 - u - v, v, u );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcontainsPoint: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function containsPoint( point, a, b, c ) {\r\n\r\n\t\t\tTriangle.getBarycoord( point, a, b, c, v1 );\r\n\r\n\t\t\treturn ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetUV: function () {\r\n\r\n\t\tvar barycoord = new Vector3();\r\n\r\n\t\treturn function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {\r\n\r\n\t\t\tthis.getBarycoord( point, p1, p2, p3, barycoord );\r\n\r\n\t\t\ttarget.set( 0, 0 );\r\n\t\t\ttarget.addScaledVector( uv1, barycoord.x );\r\n\t\t\ttarget.addScaledVector( uv2, barycoord.y );\r\n\t\t\ttarget.addScaledVector( uv3, barycoord.z );\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}()\r\n\r\n} );\r\n\r\nObject.assign( Triangle.prototype, {\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[ i0 ] );\r\n\t\tthis.b.copy( points[ i1 ] );\r\n\t\tthis.c.copy( points[ i2 ] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetArea: function () {\r\n\r\n\t\tvar v0 = new Vector3();\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function getArea() {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetMidpoint: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Triangle: .getMidpoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tgetNormal: function ( target ) {\r\n\r\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\r\n\r\n\t},\r\n\r\n\tgetPlane: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Triangle: .getPlane() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tgetBarycoord: function ( point, target ) {\r\n\r\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tgetUV: function ( point, uv1, uv2, uv3, result ) {\r\n\r\n\t\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsTriangle( this );\r\n\r\n\t},\r\n\r\n\tclosestPointToPoint: function () {\r\n\r\n\t\tvar vab = new Vector3();\r\n\t\tvar vac = new Vector3();\r\n\t\tvar vbc = new Vector3();\r\n\t\tvar vap = new Vector3();\r\n\t\tvar vbp = new Vector3();\r\n\t\tvar vcp = new Vector3();\r\n\r\n\t\treturn function closestPointToPoint( p, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Triangle: .closestPointToPoint() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar a = this.a, b = this.b, c = this.c;\r\n\t\t\tvar v, w;\r\n\r\n\t\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\r\n\t\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\r\n\t\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\r\n\t\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\r\n\t\t\t// the point lies in with the minimum amount of redundant computation.\r\n\r\n\t\t\tvab.subVectors( b, a );\r\n\t\t\tvac.subVectors( c, a );\r\n\t\t\tvap.subVectors( p, a );\r\n\t\t\tvar d1 = vab.dot( vap );\r\n\t\t\tvar d2 = vac.dot( vap );\r\n\t\t\tif ( d1 <= 0 && d2 <= 0 ) {\r\n\r\n\t\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\r\n\t\t\t\treturn target.copy( a );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvbp.subVectors( p, b );\r\n\t\t\tvar d3 = vab.dot( vbp );\r\n\t\t\tvar d4 = vac.dot( vbp );\r\n\t\t\tif ( d3 >= 0 && d4 <= d3 ) {\r\n\r\n\t\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\r\n\t\t\t\treturn target.copy( b );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vc = d1 * d4 - d3 * d2;\r\n\t\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\r\n\r\n\t\t\t\tv = d1 / ( d1 - d3 );\r\n\t\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\r\n\t\t\t\treturn target.copy( a ).addScaledVector( vab, v );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvcp.subVectors( p, c );\r\n\t\t\tvar d5 = vab.dot( vcp );\r\n\t\t\tvar d6 = vac.dot( vcp );\r\n\t\t\tif ( d6 >= 0 && d5 <= d6 ) {\r\n\r\n\t\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\r\n\t\t\t\treturn target.copy( c );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vb = d5 * d2 - d1 * d6;\r\n\t\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\r\n\r\n\t\t\t\tw = d2 / ( d2 - d6 );\r\n\t\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\r\n\t\t\t\treturn target.copy( a ).addScaledVector( vac, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar va = d3 * d6 - d5 * d4;\r\n\t\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\r\n\r\n\t\t\t\tvbc.subVectors( c, b );\r\n\t\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\r\n\t\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\r\n\t\t\t\treturn target.copy( b ).addScaledVector( vbc, w ); // edge region of BC\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// face region\r\n\t\t\tvar denom = 1 / ( va + vb + vc );\r\n\t\t\t// u = va * denom\r\n\t\t\tv = vb * denom;\r\n\t\t\tw = vc * denom;\r\n\t\t\treturn target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Mesh( geometry, material ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'Mesh';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\r\n\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.drawMode = TrianglesDrawMode;\r\n\r\n\tthis.updateMorphTargets();\r\n\r\n}\r\n\r\nMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: Mesh,\r\n\r\n\tisMesh: true,\r\n\r\n\tsetDrawMode: function ( value ) {\r\n\r\n\t\tthis.drawMode = value;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tObject3D.prototype.copy.call( this, source );\r\n\r\n\t\tthis.drawMode = source.drawMode;\r\n\r\n\t\tif ( source.morphTargetInfluences !== undefined ) {\r\n\r\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\r\n\r\n\t\t}\r\n\r\n\t\tif ( source.morphTargetDictionary !== undefined ) {\r\n\r\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateMorphTargets: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar geometry = this.geometry;\r\n\t\tvar m, ml, name;\r\n\r\n\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tvar morphAttributes = geometry.morphAttributes;\r\n\t\t\tvar keys = Object.keys( morphAttributes );\r\n\r\n\t\t\tif ( keys.length > 0 ) {\r\n\r\n\t\t\t\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\r\n\r\n\t\t\t\tif ( morphAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\t\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\t\t\t\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\tname = morphAttribute[ m ].name || String( m );\r\n\r\n\t\t\t\t\t\tthis$1.morphTargetInfluences.push( 0 );\r\n\t\t\t\t\t\tthis$1.morphTargetDictionary[ name ] = m;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar morphTargets = geometry.morphTargets;\r\n\r\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\t\t\tfor ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\tname = morphTargets[ m ].name || String( m );\r\n\r\n\t\t\t\t\tthis$1.morphTargetInfluences.push( 0 );\r\n\t\t\t\t\tthis$1.morphTargetDictionary[ name ] = m;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\traycast: ( function () {\r\n\r\n\t\tvar inverseMatrix = new Matrix4();\r\n\t\tvar ray = new Ray();\r\n\t\tvar sphere = new Sphere();\r\n\r\n\t\tvar vA = new Vector3();\r\n\t\tvar vB = new Vector3();\r\n\t\tvar vC = new Vector3();\r\n\r\n\t\tvar tempA = new Vector3();\r\n\t\tvar tempB = new Vector3();\r\n\t\tvar tempC = new Vector3();\r\n\r\n\t\tvar uvA = new Vector2();\r\n\t\tvar uvB = new Vector2();\r\n\t\tvar uvC = new Vector2();\r\n\r\n\t\tvar intersectionPoint = new Vector3();\r\n\t\tvar intersectionPointWorld = new Vector3();\r\n\r\n\t\tfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\r\n\r\n\t\t\tvar intersect;\r\n\r\n\t\t\tif ( material.side === BackSide ) {\r\n\r\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( intersect === null ) { return null; }\r\n\r\n\t\t\tintersectionPointWorld.copy( point );\r\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) { return null; }\r\n\r\n\t\t\treturn {\r\n\t\t\t\tdistance: distance,\r\n\t\t\t\tpoint: intersectionPointWorld.clone(),\r\n\t\t\t\tobject: object\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, uv, a, b, c ) {\r\n\r\n\t\t\tvA.fromBufferAttribute( position, a );\r\n\t\t\tvB.fromBufferAttribute( position, b );\r\n\t\t\tvC.fromBufferAttribute( position, c );\r\n\r\n\t\t\tvar intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\r\n\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\tif ( uv ) {\r\n\r\n\t\t\t\t\tuvA.fromBufferAttribute( uv, a );\r\n\t\t\t\t\tuvB.fromBufferAttribute( uv, b );\r\n\t\t\t\t\tuvC.fromBufferAttribute( uv, c );\r\n\r\n\t\t\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar face = new Face3( a, b, c );\r\n\t\t\t\tTriangle.getNormal( vA, vB, vC, face.normal );\r\n\r\n\t\t\t\tintersection.face = face;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn intersection;\r\n\r\n\t\t}\r\n\r\n\t\treturn function raycast( raycaster, intersects ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar material = this.material;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\r\n\t\t\tif ( material === undefined ) { return; }\r\n\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }\r\n\r\n\t\t\t//\r\n\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t\t// Check boundingBox before continuing\r\n\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) { return; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar intersection;\r\n\r\n\t\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\tvar a, b, c;\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar position = geometry.attributes.position;\r\n\t\t\t\tvar uv = geometry.attributes.uv;\r\n\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\tvar drawRange = geometry.drawRange;\r\n\t\t\t\tvar i, j, il, jl;\r\n\t\t\t\tvar group, groupMaterial;\r\n\t\t\t\tvar start, end;\r\n\r\n\t\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t\t// indexed buffer geometry\r\n\r\n\t\t\t\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tgroup = groups[ i ];\r\n\t\t\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\r\n\t\t\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\ta = index.getX( j );\r\n\t\t\t\t\t\t\t\tb = index.getX( j + 1 );\r\n\t\t\t\t\t\t\t\tc = index.getX( j + 2 );\r\n\r\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this$1, groupMaterial, raycaster, ray, position, uv, a, b, c );\r\n\r\n\t\t\t\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\r\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tstart = Math.max( 0, drawRange.start );\r\n\t\t\t\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\ta = index.getX( i );\r\n\t\t\t\t\t\t\tb = index.getX( i + 1 );\r\n\t\t\t\t\t\t\tc = index.getX( i + 2 );\r\n\r\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this$1, material, raycaster, ray, position, uv, a, b, c );\r\n\r\n\t\t\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\r\n\t\t\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( position !== undefined ) {\r\n\r\n\t\t\t\t\t// non-indexed buffer geometry\r\n\r\n\t\t\t\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tgroup = groups[ i ];\r\n\t\t\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\r\n\t\t\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\ta = j;\r\n\t\t\t\t\t\t\t\tb = j + 1;\r\n\t\t\t\t\t\t\t\tc = j + 2;\r\n\r\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this$1, groupMaterial, raycaster, ray, position, uv, a, b, c );\r\n\r\n\t\t\t\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\r\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tstart = Math.max( 0, drawRange.start );\r\n\t\t\t\t\t\tend = Math.min( position.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\ta = i;\r\n\t\t\t\t\t\t\tb = i + 1;\r\n\t\t\t\t\t\t\tc = i + 2;\r\n\r\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this$1, material, raycaster, ray, position, uv, a, b, c );\r\n\r\n\t\t\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\r\n\t\t\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( geometry.isGeometry ) {\r\n\r\n\t\t\t\tvar fvA, fvB, fvC;\r\n\t\t\t\tvar isMultiMaterial = Array.isArray( material );\r\n\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\tvar uvs;\r\n\r\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n\t\t\t\tif ( faceVertexUvs.length > 0 ) { uvs = faceVertexUvs; }\r\n\r\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tvar face = faces[ f ];\r\n\t\t\t\t\tvar faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\r\n\r\n\t\t\t\t\tif ( faceMaterial === undefined ) { continue; }\r\n\r\n\t\t\t\t\tfvA = vertices[ face.a ];\r\n\t\t\t\t\tfvB = vertices[ face.b ];\r\n\t\t\t\t\tfvC = vertices[ face.c ];\r\n\r\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\r\n\r\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\tvar morphInfluences = this$1.morphTargetInfluences;\r\n\r\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\r\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\t\tif ( influence === 0 ) { continue; }\r\n\r\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\r\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\r\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\r\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvA.add( fvA );\r\n\t\t\t\t\t\tvB.add( fvB );\r\n\t\t\t\t\t\tvC.add( fvC );\r\n\r\n\t\t\t\t\t\tfvA = vA;\r\n\t\t\t\t\t\tfvB = vB;\r\n\t\t\t\t\t\tfvC = vC;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tintersection = checkIntersection( this$1, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\r\n\r\n\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\tif ( uvs && uvs[ f ] ) {\r\n\r\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\r\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\r\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\r\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\r\n\r\n\t\t\t\t\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tintersection.face = face;\r\n\t\t\t\t\t\tintersection.faceIndex = f;\r\n\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Line( geometry, material, mode ) {\r\n\r\n\tif ( mode === 1 ) {\r\n\r\n\t\tconsole.error( 'Line: parameter LinePieces no longer supported. Use LineSegments instead.' );\r\n\r\n\t}\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'Line';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\r\n\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n}\r\n\r\nLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: Line,\r\n\r\n\tisLine: true,\r\n\r\n\tcomputeLineDistances: ( function () {\r\n\r\n\t\tvar start = new Vector3();\r\n\t\tvar end = new Vector3();\r\n\r\n\t\treturn function computeLineDistances() {\r\n\r\n\t\t\tvar geometry = this.geometry;\r\n\r\n\t\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t// we assume non-indexed geometry\r\n\r\n\t\t\t\tif ( geometry.index === null ) {\r\n\r\n\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\r\n\t\t\t\t\tvar lineDistances = [ 0 ];\r\n\r\n\t\t\t\t\tfor ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tstart.fromBufferAttribute( positionAttribute, i - 1 );\r\n\t\t\t\t\t\tend.fromBufferAttribute( positionAttribute, i );\r\n\r\n\t\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\r\n\t\t\t\t\t\tlineDistances[ i ] += start.distanceTo( end );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( 'Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( geometry.isGeometry ) {\r\n\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar lineDistances = geometry.lineDistances;\r\n\r\n\t\t\t\tlineDistances[ 0 ] = 0;\r\n\r\n\t\t\t\tfor ( var i = 1, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\r\n\t\t\t\t\tlineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\traycast: ( function () {\r\n\r\n\t\tvar inverseMatrix = new Matrix4();\r\n\t\tvar ray = new Ray();\r\n\t\tvar sphere = new Sphere();\r\n\r\n\t\treturn function raycast( raycaster, intersects ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar precision = raycaster.linePrecision;\r\n\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\t\tsphere.radius += precision;\r\n\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }\r\n\r\n\t\t\t//\r\n\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t\tvar localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\t\tvar localPrecisionSq = localPrecision * localPrecision;\r\n\r\n\t\t\tvar vStart = new Vector3();\r\n\t\t\tvar vEnd = new Vector3();\r\n\t\t\tvar interSegment = new Vector3();\r\n\t\t\tvar interRay = new Vector3();\r\n\t\t\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\r\n\r\n\t\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\t\tvar a = indices[ i ];\r\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\r\n\r\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\t\tif ( distSq > localPrecisionSq ) { continue; }\r\n\r\n\t\t\t\t\t\tinterRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) { continue; }\r\n\r\n\t\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this$1.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this$1\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\t\tif ( distSq > localPrecisionSq ) { continue; }\r\n\r\n\t\t\t\t\t\tinterRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) { continue; }\r\n\r\n\t\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this$1.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this$1\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( geometry.isGeometry ) {\r\n\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar nbVertices = vertices.length;\r\n\r\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > localPrecisionSq ) { continue; }\r\n\r\n\t\t\t\t\tinterRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) { continue; }\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this$1.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this$1\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar CCDIKSolver = ( function () {\r\n\t\r\n\tfunction CCDIKSolver( mesh, iks ) {\r\n\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.iks = iks || [];\r\n\r\n\t\tthis._valid();\r\n\r\n\t}\r\n\r\n\tCCDIKSolver.prototype = {\r\n\r\n\t\tconstructor: CCDIKSolver,\r\n\t\t\r\n\t\tupdate: function () {\r\n\r\n\t\t\tvar q = new Quaternion();\r\n\t\t\tvar targetPos = new Vector3();\r\n\t\t\tvar targetVec = new Vector3();\r\n\t\t\tvar effectorPos = new Vector3();\r\n\t\t\tvar effectorVec = new Vector3();\r\n\t\t\tvar linkPos = new Vector3();\r\n\t\t\tvar invLinkQ = new Quaternion();\r\n\t\t\tvar linkScale = new Vector3();\r\n\t\t\tvar axis = new Vector3();\r\n\t\t\tvar vector = new Vector3();\r\n\r\n\t\t\treturn function update() {\r\n\r\n\t\t\t\tvar bones = this.mesh.skeleton.bones;\r\n\t\t\t\tvar iks = this.iks;\r\n\r\n\t\t\t\t// for reference overhead reduction in loop\r\n\t\t\t\tvar math = Math;\r\n\r\n\t\t\t\tfor ( var i = 0, il = iks.length; i < il; i++ ) {\r\n\r\n\t\t\t\t\tvar ik = iks[ i ];\r\n\t\t\t\t\tvar effector = bones[ ik.effector ];\r\n\t\t\t\t\tvar target = bones[ ik.target ];\r\n\r\n\t\t\t\t\t// don't use getWorldPosition() here for the performance\r\n\t\t\t\t\t// because it calls updateMatrixWorld( true ) inside.\r\n\t\t\t\t\ttargetPos.setFromMatrixPosition( target.matrixWorld );\r\n\r\n\t\t\t\t\tvar links = ik.links;\r\n\t\t\t\t\tvar iteration = ik.iteration !== undefined ? ik.iteration : 1;\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < iteration; j++ ) {\r\n\r\n\t\t\t\t\t\tvar rotated = false;\r\n\r\n\t\t\t\t\t\tfor ( var k = 0, kl = links.length; k < kl; k++ ) {\r\n\r\n\t\t\t\t\t\t\tvar link = bones[ links[ k ].index ];\r\n\r\n\t\t\t\t\t\t\t// skip this link and following links.\r\n\t\t\t\t\t\t\t// this skip is used for MMD performance optimization.\r\n\t\t\t\t\t\t\tif ( links[ k ].enabled === false ) { break; }\r\n\r\n\t\t\t\t\t\t\tvar limitation = links[ k ].limitation;\r\n\t\t\t\t\t\t\tvar rotationMin = links[ k ].rotationMin;\r\n\t\t\t\t\t\t\tvar rotationMax = links[ k ].rotationMax;\r\n\r\n\t\t\t\t\t\t\t// don't use getWorldPosition/Quaternion() here for the performance\r\n\t\t\t\t\t\t\t// because they call updateMatrixWorld( true ) inside.\r\n\t\t\t\t\t\t\tlink.matrixWorld.decompose( linkPos, invLinkQ, linkScale );\r\n\t\t\t\t\t\t\tinvLinkQ.inverse();\r\n\t\t\t\t\t\t\teffectorPos.setFromMatrixPosition( effector.matrixWorld );\r\n\r\n\t\t\t\t\t\t\t// work in link world\r\n\t\t\t\t\t\t\teffectorVec.subVectors( effectorPos, linkPos );\r\n\t\t\t\t\t\t\teffectorVec.applyQuaternion( invLinkQ );\r\n\t\t\t\t\t\t\teffectorVec.normalize();\r\n\r\n\t\t\t\t\t\t\ttargetVec.subVectors( targetPos, linkPos );\r\n\t\t\t\t\t\t\ttargetVec.applyQuaternion( invLinkQ );\r\n\t\t\t\t\t\t\ttargetVec.normalize();\r\n\r\n\t\t\t\t\t\t\tvar angle = targetVec.dot( effectorVec );\r\n\r\n\t\t\t\t\t\t\tif ( angle > 1.0 ) {\r\n\r\n\t\t\t\t\t\t\t\tangle = 1.0;\r\n\r\n\t\t\t\t\t\t\t} else if ( angle < -1.0 ) {\r\n\r\n\t\t\t\t\t\t\t\tangle = -1.0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tangle = math.acos( angle );\r\n\r\n\t\t\t\t\t\t\t// skip if changing angle is too small to prevent vibration of bone\r\n\t\t\t\t\t\t\t// Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\r\n\t\t\t\t\t\t\tif ( angle < 1e-5 ) { continue; }\r\n\r\n\t\t\t\t\t\t\tif ( ik.minAngle !== undefined && angle < ik.minAngle ) {\r\n\r\n\t\t\t\t\t\t\t\tangle = ik.minAngle;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( ik.maxAngle !== undefined && angle > ik.maxAngle ) {\r\n\r\n\t\t\t\t\t\t\t\tangle = ik.maxAngle;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\taxis.crossVectors( effectorVec, targetVec );\r\n\t\t\t\t\t\t\taxis.normalize();\r\n\r\n\t\t\t\t\t\t\tq.setFromAxisAngle( axis, angle );\r\n\t\t\t\t\t\t\tlink.quaternion.multiply( q );\r\n\r\n\t\t\t\t\t\t\t// TODO: re-consider the limitation specification\r\n\t\t\t\t\t\t\tif ( limitation !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tvar c = link.quaternion.w;\r\n\r\n\t\t\t\t\t\t\t\tif ( c > 1.0 ) { c = 1.0; }\r\n\r\n\t\t\t\t\t\t\t\tvar c2 = math.sqrt( 1 - c * c );\r\n\t\t\t\t\t\t\t\tlink.quaternion.set( limitation.x * c2,\r\n\t\t\t\t\t\t\t\t                     limitation.y * c2,\r\n\t\t\t\t\t\t\t\t                     limitation.z * c2,\r\n\t\t\t\t\t\t\t\t                     c );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( rotationMin !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tlink.rotation.setFromVector3(\r\n\t\t\t\t\t\t\t\t\tlink.rotation\r\n\t\t\t\t\t\t\t\t\t\t.toVector3( vector )\r\n\t\t\t\t\t\t\t\t\t\t.max( rotationMin ) );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( rotationMax !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tlink.rotation.setFromVector3(\r\n\t\t\t\t\t\t\t\t\tlink.rotation\r\n\t\t\t\t\t\t\t\t\t\t.toVector3( vector )\r\n\t\t\t\t\t\t\t\t\t\t.min( rotationMax ) );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tlink.updateMatrixWorld( true );\r\n\r\n\t\t\t\t\t\t\trotated = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( ! rotated ) { break; }\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t};\r\n\r\n\t\t}(),\r\n\t\t\r\n\t\tcreateHelper: function () {\r\n\r\n\t\t\treturn new CCDIKHelper( this.mesh, this.mesh.geometry.userData.MMD.iks );\r\n\r\n\t\t},\r\n\r\n\t\t// private methods\r\n\r\n\t\t_valid: function () {\r\n\r\n\t\t\tvar iks = this.iks;\r\n\t\t\tvar bones = this.mesh.skeleton.bones;\r\n\r\n\t\t\tfor ( var i = 0, il = iks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar ik = iks[ i ];\r\n\t\t\t\tvar effector = bones[ ik.effector ];\r\n\t\t\t\tvar links = ik.links;\r\n\t\t\t\tvar link0, link1;\r\n\r\n\t\t\t\tlink0 = effector;\r\n\r\n\t\t\t\tfor ( var j = 0, jl = links.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tlink1 = bones[ links[ j ].index ];\r\n\r\n\t\t\t\t\tif ( link0.parent !== link1 ) {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'CCDIKSolver: bone ' + link0.name + ' is not the child of bone ' + link1.name );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlink0 = link1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n\tfunction CCDIKHelper( mesh, iks ) {\r\n\r\n\t\tObject3D.call( this );\r\n\r\n\t\tthis.root = mesh;\r\n\t\tthis.iks = iks || [];\r\n\r\n\t\tthis.matrix.copy( mesh.matrixWorld );\r\n\t\tthis.matrixAutoUpdate = false;\r\n\r\n\t\tthis.sphereGeometry = new SphereBufferGeometry( 0.25, 16, 8 );\r\n\r\n\t\tthis.targetSphereMaterial = new MeshBasicMaterial( {\r\n\t\t\tcolor: new Color( 0xff8888 ),\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\ttransparent: true\r\n\t\t} );\r\n\r\n\t\tthis.effectorSphereMaterial = new MeshBasicMaterial( {\r\n\t\t\tcolor: new Color( 0x88ff88 ),\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\ttransparent: true\r\n\t\t} );\r\n\r\n\t\tthis.linkSphereMaterial = new MeshBasicMaterial( {\r\n\t\t\tcolor: new Color( 0x8888ff ),\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\ttransparent: true\r\n\t\t} );\r\n\r\n\t\tthis.lineMaterial = new LineBasicMaterial( {\r\n\t\t\tcolor: new Color( 0xff0000 ),\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\ttransparent: true\r\n\t\t} );\r\n\r\n\t\tthis._init();\r\n\r\n\t}\r\n\r\n\tCCDIKHelper.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\t\tconstructor: CCDIKHelper,\r\n\t\t\r\n\t\tupdateMatrixWorld: function () {\r\n\r\n\t\t\tvar matrix = new Matrix4();\r\n\t\t\tvar vector = new Vector3();\r\n\r\n\t\t\tfunction getPosition( bone, matrixWorldInv ) {\r\n\r\n\t\t\t\treturn vector\r\n\t\t\t\t\t.setFromMatrixPosition( bone.matrixWorld )\r\n\t\t\t\t\t.applyMatrix4( matrixWorldInv );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction setPositionOfBoneToAttributeArray( array, index, bone, matrixWorldInv ) {\r\n\r\n\t\t\t\tvar v = getPosition( bone, matrixWorldInv );\r\n\r\n\t\t\t\tarray[ index * 3 + 0 ] = v.x;\r\n\t\t\t\tarray[ index * 3 + 1 ] = v.y;\r\n\t\t\t\tarray[ index * 3 + 2 ] = v.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn function updateMatrixWorld( force ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tvar mesh = this.root;\r\n\r\n\t\t\t\tif ( this.visible ) {\r\n\r\n\t\t\t\t\tvar offset = 0;\r\n\r\n\t\t\t\t\tvar iks = this.iks;\r\n\t\t\t\t\tvar bones = mesh.skeleton.bones;\r\n\r\n\t\t\t\t\tmatrix.getInverse( mesh.matrixWorld );\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = iks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar ik = iks[ i ];\r\n\r\n\t\t\t\t\t\tvar targetBone = bones[ ik.target ];\r\n\t\t\t\t\t\tvar effectorBone = bones[ ik.effector ];\r\n\r\n\t\t\t\t\t\tvar targetMesh = this$1.children[ offset ++ ];\r\n\t\t\t\t\t\tvar effectorMesh = this$1.children[ offset ++ ];\r\n\r\n\t\t\t\t\t\ttargetMesh.position.copy( getPosition( targetBone, matrix ) );\r\n\t\t\t\t\t\teffectorMesh.position.copy( getPosition( effectorBone, matrix ) );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar link = ik.links[ j ];\r\n\t\t\t\t\t\t\tvar linkBone = bones[ link.index ];\r\n\r\n\t\t\t\t\t\t\tvar linkMesh = this$1.children[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tlinkMesh.position.copy( getPosition( linkBone, matrix ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar line = this$1.children[ offset ++ ];\r\n\t\t\t\t\t\tvar array = line.geometry.attributes.position.array;\r\n\r\n\t\t\t\t\t\tsetPositionOfBoneToAttributeArray( array, 0, targetBone, matrix );\r\n\t\t\t\t\t\tsetPositionOfBoneToAttributeArray( array, 1, effectorBone, matrix );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar link = ik.links[ j ];\r\n\t\t\t\t\t\t\tvar linkBone = bones[ link.index ];\r\n\t\t\t\t\t\t\tsetPositionOfBoneToAttributeArray( array, j + 2, linkBone, matrix );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tline.geometry.attributes.position.needsUpdate = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.matrix.copy( mesh.matrixWorld );\r\n\r\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\t\t};\r\n\r\n\t\t}(),\r\n\r\n\t\t// private method\r\n\r\n\t\t_init: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tvar iks = this.iks;\r\n\r\n\t\t\tfunction createLineGeometry( ik ) {\r\n\r\n\t\t\t\tvar geometry = new BufferGeometry();\r\n\t\t\t\tvar vertices = new Float32Array( ( 2 + ik.links.length ) * 3 );\r\n\t\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\r\n\r\n\t\t\t\treturn geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction createTargetMesh() {\r\n\r\n\t\t\t\treturn new Mesh( self.sphereGeometry, self.targetSphereMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction createEffectorMesh() {\r\n\r\n\t\t\t\treturn new Mesh( self.sphereGeometry, self.effectorSphereMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction createLinkMesh() {\r\n\r\n\t\t\t\treturn new Mesh( self.sphereGeometry, self.linkSphereMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction createLine( ik ) {\r\n\r\n\t\t\t\treturn new Line( createLineGeometry( ik ), self.lineMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, il = iks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar ik = iks[ i ];\r\n\r\n\t\t\t\tthis$1.add( createTargetMesh() );\r\n\t\t\t\tthis$1.add( createEffectorMesh() );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tthis$1.add( createLinkMesh() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis$1.add( createLine( ik ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn CCDIKSolver;\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AnimationAction( mixer, clip, localRoot ) {\r\n\r\n\tthis._mixer = mixer;\r\n\tthis._clip = clip;\r\n\tthis._localRoot = localRoot || null;\r\n\r\n\tvar tracks = clip.tracks,\r\n\t\tnTracks = tracks.length,\r\n\t\tinterpolants = new Array( nTracks );\r\n\r\n\tvar interpolantSettings = {\r\n\t\tendingStart: ZeroCurvatureEnding,\r\n\t\tendingEnd: ZeroCurvatureEnding\r\n\t};\r\n\r\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\r\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\r\n\t\tinterpolants[ i ] = interpolant;\r\n\t\tinterpolant.settings = interpolantSettings;\r\n\r\n\t}\r\n\r\n\tthis._interpolantSettings = interpolantSettings;\r\n\r\n\tthis._interpolants = interpolants;\t// bound by the mixer\r\n\r\n\t// inside: PropertyMixer (managed by the mixer)\r\n\tthis._propertyBindings = new Array( nTracks );\r\n\r\n\tthis._cacheIndex = null;\t\t\t// for the memory manager\r\n\tthis._byClipCacheIndex = null;\t\t// for the memory manager\r\n\r\n\tthis._timeScaleInterpolant = null;\r\n\tthis._weightInterpolant = null;\r\n\r\n\tthis.loop = LoopRepeat;\r\n\tthis._loopCount = - 1;\r\n\r\n\t// global mixer time when the action is to be started\r\n\t// it's set back to 'null' upon start of the action\r\n\tthis._startTime = null;\r\n\r\n\t// scaled local time of the action\r\n\t// gets clamped or wrapped to 0..clip.duration according to loop\r\n\tthis.time = 0;\r\n\r\n\tthis.timeScale = 1;\r\n\tthis._effectiveTimeScale = 1;\r\n\r\n\tthis.weight = 1;\r\n\tthis._effectiveWeight = 1;\r\n\r\n\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\r\n\r\n\tthis.paused = false;\t\t\t\t// true -> zero effective time scale\r\n\tthis.enabled = true;\t\t\t\t// false -> zero effective weight\r\n\r\n\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\r\n\r\n\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\r\n\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\r\n\r\n}\r\n\r\nObject.assign( AnimationAction.prototype, {\r\n\r\n\t// State & Scheduling\r\n\r\n\tplay: function () {\r\n\r\n\t\tthis._mixer._activateAction( this );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis._mixer._deactivateAction( this );\r\n\r\n\t\treturn this.reset();\r\n\r\n\t},\r\n\r\n\treset: function () {\r\n\r\n\t\tthis.paused = false;\r\n\t\tthis.enabled = true;\r\n\r\n\t\tthis.time = 0;\t\t\t// restart clip\r\n\t\tthis._loopCount = - 1;\t// forget previous loops\r\n\t\tthis._startTime = null;\t// forget scheduling\r\n\r\n\t\treturn this.stopFading().stopWarping();\r\n\r\n\t},\r\n\r\n\tisRunning: function () {\r\n\r\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\r\n\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\r\n\r\n\t},\r\n\r\n\t// return true when play has been called\r\n\tisScheduled: function () {\r\n\r\n\t\treturn this._mixer._isActiveAction( this );\r\n\r\n\t},\r\n\r\n\tstartAt: function ( time ) {\r\n\r\n\t\tthis._startTime = time;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetLoop: function ( mode, repetitions ) {\r\n\r\n\t\tthis.loop = mode;\r\n\t\tthis.repetitions = repetitions;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Weight\r\n\r\n\t// set the weight stopping any scheduled fading\r\n\t// although .enabled = false yields an effective weight of zero, this\r\n\t// method does *not* change .enabled, because it would be confusing\r\n\tsetEffectiveWeight: function ( weight ) {\r\n\r\n\t\tthis.weight = weight;\r\n\r\n\t\t// note: same logic as when updated at runtime\r\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\r\n\r\n\t\treturn this.stopFading();\r\n\r\n\t},\r\n\r\n\t// return the weight considering fading and .enabled\r\n\tgetEffectiveWeight: function () {\r\n\r\n\t\treturn this._effectiveWeight;\r\n\r\n\t},\r\n\r\n\tfadeIn: function ( duration ) {\r\n\r\n\t\treturn this._scheduleFading( duration, 0, 1 );\r\n\r\n\t},\r\n\r\n\tfadeOut: function ( duration ) {\r\n\r\n\t\treturn this._scheduleFading( duration, 1, 0 );\r\n\r\n\t},\r\n\r\n\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\r\n\r\n\t\tfadeOutAction.fadeOut( duration );\r\n\t\tthis.fadeIn( duration );\r\n\r\n\t\tif ( warp ) {\r\n\r\n\t\t\tvar fadeInDuration = this._clip.duration,\r\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\r\n\r\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\r\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\r\n\r\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\r\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\r\n\r\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\r\n\r\n\t},\r\n\r\n\tstopFading: function () {\r\n\r\n\t\tvar weightInterpolant = this._weightInterpolant;\r\n\r\n\t\tif ( weightInterpolant !== null ) {\r\n\r\n\t\t\tthis._weightInterpolant = null;\r\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Time Scale Control\r\n\r\n\t// set the time scale stopping any scheduled warping\r\n\t// although .paused = true yields an effective time scale of zero, this\r\n\t// method does *not* change .paused, because it would be confusing\r\n\tsetEffectiveTimeScale: function ( timeScale ) {\r\n\r\n\t\tthis.timeScale = timeScale;\r\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\t// return the time scale considering warping and .paused\r\n\tgetEffectiveTimeScale: function () {\r\n\r\n\t\treturn this._effectiveTimeScale;\r\n\r\n\t},\r\n\r\n\tsetDuration: function ( duration ) {\r\n\r\n\t\tthis.timeScale = this._clip.duration / duration;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\tsyncWith: function ( action ) {\r\n\r\n\t\tthis.time = action.time;\r\n\t\tthis.timeScale = action.timeScale;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\thalt: function ( duration ) {\r\n\r\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\r\n\r\n\t},\r\n\r\n\twarp: function ( startTimeScale, endTimeScale, duration ) {\r\n\r\n\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\tinterpolant = this._timeScaleInterpolant,\r\n\r\n\t\t\ttimeScale = this.timeScale;\r\n\r\n\t\tif ( interpolant === null ) {\r\n\r\n\t\t\tinterpolant = mixer._lendControlInterpolant();\r\n\t\t\tthis._timeScaleInterpolant = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = interpolant.parameterPositions,\r\n\t\t\tvalues = interpolant.sampleValues;\r\n\r\n\t\ttimes[ 0 ] = now;\r\n\t\ttimes[ 1 ] = now + duration;\r\n\r\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\r\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tstopWarping: function () {\r\n\r\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\r\n\r\n\t\tif ( timeScaleInterpolant !== null ) {\r\n\r\n\t\t\tthis._timeScaleInterpolant = null;\r\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Object Accessors\r\n\r\n\tgetMixer: function () {\r\n\r\n\t\treturn this._mixer;\r\n\r\n\t},\r\n\r\n\tgetClip: function () {\r\n\r\n\t\treturn this._clip;\r\n\r\n\t},\r\n\r\n\tgetRoot: function () {\r\n\r\n\t\treturn this._localRoot || this._mixer._root;\r\n\r\n\t},\r\n\r\n\t// Interna\r\n\r\n\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\r\n\r\n\t\t// called by the mixer\r\n\r\n\t\tif ( ! this.enabled ) {\r\n\r\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\r\n\r\n\t\t\tthis._updateWeight( time );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar startTime = this._startTime;\r\n\r\n\t\tif ( startTime !== null ) {\r\n\r\n\t\t\t// check for scheduled start of action\r\n\r\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\r\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\r\n\r\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// start\r\n\r\n\t\t\tthis._startTime = null; // unschedule\r\n\t\t\tdeltaTime = timeDirection * timeRunning;\r\n\r\n\t\t}\r\n\r\n\t\t// apply time scale and advance time\r\n\r\n\t\tdeltaTime *= this._updateTimeScale( time );\r\n\t\tvar clipTime = this._updateTime( deltaTime );\r\n\r\n\t\t// note: _updateTime may disable the action resulting in\r\n\t\t// an effective weight of 0\r\n\r\n\t\tvar weight = this._updateWeight( time );\r\n\r\n\t\tif ( weight > 0 ) {\r\n\r\n\t\t\tvar interpolants = this._interpolants;\r\n\t\t\tvar propertyMixers = this._propertyBindings;\r\n\r\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\r\n\r\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\r\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_updateWeight: function ( time ) {\r\n\r\n\t\tvar weight = 0;\r\n\r\n\t\tif ( this.enabled ) {\r\n\r\n\t\t\tweight = this.weight;\r\n\t\t\tvar interpolant = this._weightInterpolant;\r\n\r\n\t\t\tif ( interpolant !== null ) {\r\n\r\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\r\n\t\t\t\tweight *= interpolantValue;\r\n\r\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\r\n\t\t\t\t\tthis.stopFading();\r\n\r\n\t\t\t\t\tif ( interpolantValue === 0 ) {\r\n\r\n\t\t\t\t\t\t// faded out, disable\r\n\t\t\t\t\t\tthis.enabled = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis._effectiveWeight = weight;\r\n\t\treturn weight;\r\n\r\n\t},\r\n\r\n\t_updateTimeScale: function ( time ) {\r\n\r\n\t\tvar timeScale = 0;\r\n\r\n\t\tif ( ! this.paused ) {\r\n\r\n\t\t\ttimeScale = this.timeScale;\r\n\r\n\t\t\tvar interpolant = this._timeScaleInterpolant;\r\n\r\n\t\t\tif ( interpolant !== null ) {\r\n\r\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\r\n\t\t\t\ttimeScale *= interpolantValue;\r\n\r\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\r\n\t\t\t\t\tthis.stopWarping();\r\n\r\n\t\t\t\t\tif ( timeScale === 0 ) {\r\n\r\n\t\t\t\t\t\t// motion has halted, pause\r\n\t\t\t\t\t\tthis.paused = true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// warp done - apply final time scale\r\n\t\t\t\t\t\tthis.timeScale = timeScale;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis._effectiveTimeScale = timeScale;\r\n\t\treturn timeScale;\r\n\r\n\t},\r\n\r\n\t_updateTime: function ( deltaTime ) {\r\n\r\n\t\tvar time = this.time + deltaTime;\r\n\t\tvar duration = this._clip.duration;\r\n\t\tvar loop = this.loop;\r\n\t\tvar loopCount = this._loopCount;\r\n\r\n\t\tvar pingPong = ( loop === LoopPingPong );\r\n\r\n\t\tif ( deltaTime === 0 ) {\r\n\r\n\t\t\tif ( loopCount === - 1 ) { return time; }\r\n\r\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\r\n\r\n\t\t}\r\n\r\n\t\tif ( loop === LoopOnce ) {\r\n\r\n\t\t\tif ( loopCount === - 1 ) {\r\n\r\n\t\t\t\t// just started\r\n\r\n\t\t\t\tthis._loopCount = 0;\r\n\t\t\t\tthis._setEndings( true, true, false );\r\n\r\n\t\t\t}\r\n\r\n\t\t\thandle_stop: {\r\n\r\n\t\t\t\tif ( time >= duration ) {\r\n\r\n\t\t\t\t\ttime = duration;\r\n\r\n\t\t\t\t} else if ( time < 0 ) {\r\n\r\n\t\t\t\t\ttime = 0;\r\n\r\n\t\t\t\t} else { break handle_stop; }\r\n\r\n\t\t\t\tif ( this.clampWhenFinished ) { this.paused = true; }\r\n\t\t\t\telse { this.enabled = false; }\r\n\r\n\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else { // repetitive Repeat or PingPong\r\n\r\n\t\t\tif ( loopCount === - 1 ) {\r\n\r\n\t\t\t\t// just started\r\n\r\n\t\t\t\tif ( deltaTime >= 0 ) {\r\n\r\n\t\t\t\t\tloopCount = 0;\r\n\r\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// when looping in reverse direction, the initial\r\n\t\t\t\t\t// transition through zero counts as a repetition,\r\n\t\t\t\t\t// so leave loopCount at -1\r\n\r\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( time >= duration || time < 0 ) {\r\n\r\n\t\t\t\t// wrap around\r\n\r\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\r\n\t\t\t\ttime -= duration * loopDelta;\r\n\r\n\t\t\t\tloopCount += Math.abs( loopDelta );\r\n\r\n\t\t\t\tvar pending = this.repetitions - loopCount;\r\n\r\n\t\t\t\tif ( pending <= 0 ) {\r\n\r\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\r\n\r\n\t\t\t\t\tif ( this.clampWhenFinished ) { this.paused = true; }\r\n\t\t\t\t\telse { this.enabled = false; }\r\n\r\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\r\n\r\n\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// keep running\r\n\r\n\t\t\t\t\tif ( pending === 1 ) {\r\n\r\n\t\t\t\t\t\t// entering the last round\r\n\r\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\r\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis._loopCount = loopCount;\r\n\r\n\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\r\n\r\n\t\t\t\t// invert time for the \"pong round\"\r\n\r\n\t\t\t\tthis.time = time;\r\n\t\t\t\treturn duration - time;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.time = time;\r\n\t\treturn time;\r\n\r\n\t},\r\n\r\n\t_setEndings: function ( atStart, atEnd, pingPong ) {\r\n\r\n\t\tvar settings = this._interpolantSettings;\r\n\r\n\t\tif ( pingPong ) {\r\n\r\n\t\t\tsettings.endingStart \t= ZeroSlopeEnding;\r\n\t\t\tsettings.endingEnd\t\t= ZeroSlopeEnding;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\r\n\r\n\t\t\tif ( atStart ) {\r\n\r\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( atEnd ) {\r\n\r\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_scheduleFading: function ( duration, weightNow, weightThen ) {\r\n\r\n\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\tinterpolant = this._weightInterpolant;\r\n\r\n\t\tif ( interpolant === null ) {\r\n\r\n\t\t\tinterpolant = mixer._lendControlInterpolant();\r\n\t\t\tthis._weightInterpolant = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = interpolant.parameterPositions,\r\n\t\t\tvalues = interpolant.sampleValues;\r\n\r\n\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\r\n\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tthis.parameterPositions = parameterPositions;\r\n\tthis._cachedIndex = 0;\r\n\r\n\tthis.resultBuffer = resultBuffer !== undefined ?\r\n\t\tresultBuffer : new sampleValues.constructor( sampleSize );\r\n\tthis.sampleValues = sampleValues;\r\n\tthis.valueSize = sampleSize;\r\n\r\n}\r\n\r\nObject.assign( Interpolant.prototype, {\r\n\r\n\tevaluate: function ( t ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar pp = this.parameterPositions,\r\n\t\t\ti1 = this._cachedIndex,\r\n\r\n\t\t\tt1 = pp[ i1 ],\r\n\t\t\tt0 = pp[ i1 - 1 ];\r\n\r\n\t\tvalidate_interval: {\r\n\r\n\t\t\tseek: {\r\n\r\n\t\t\t\tvar right;\r\n\r\n\t\t\t\tlinear_scan: {\r\n\r\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\r\n\t\t\t\t\t//- slower code:\r\n\t\t\t\t\t//-\r\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\r\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\r\n\r\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ; ) {\r\n\r\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( t < t0 ) { break forward_scan; }\r\n\r\n\t\t\t\t\t\t\t\t// after end\r\n\r\n\t\t\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\t\t\tthis$1._cachedIndex = i1;\r\n\t\t\t\t\t\t\t\treturn this$1.afterEnd_( i1 - 1, t, t0 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) { break; } // this loop\r\n\r\n\t\t\t\t\t\t\tt0 = t1;\r\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\r\n\r\n\t\t\t\t\t\t\tif ( t < t1 ) {\r\n\r\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\tbreak seek;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// prepare binary search on the right side of the index\r\n\t\t\t\t\t\tright = pp.length;\r\n\t\t\t\t\t\tbreak linear_scan;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//- slower code:\r\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\r\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\r\n\r\n\t\t\t\t\t\t// looping?\r\n\r\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\r\n\r\n\t\t\t\t\t\tif ( t < t1global ) {\r\n\r\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\r\n\t\t\t\t\t\t\tt0 = t1global;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// linear reverse scan\r\n\r\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ; ) {\r\n\r\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t// before start\r\n\r\n\t\t\t\t\t\t\t\tthis$1._cachedIndex = 0;\r\n\t\t\t\t\t\t\t\treturn this$1.beforeStart_( 0, t, t1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) { break; } // this loop\r\n\r\n\t\t\t\t\t\t\tt1 = t0;\r\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( t >= t0 ) {\r\n\r\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\tbreak seek;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// prepare binary search on the left side of the index\r\n\t\t\t\t\t\tright = i1;\r\n\t\t\t\t\t\ti1 = 0;\r\n\t\t\t\t\t\tbreak linear_scan;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// the interval is valid\r\n\r\n\t\t\t\t\tbreak validate_interval;\r\n\r\n\t\t\t\t} // linear scan\r\n\r\n\t\t\t\t// binary search\r\n\r\n\t\t\t\twhile ( i1 < right ) {\r\n\r\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\r\n\r\n\t\t\t\t\tif ( t < pp[ mid ] ) {\r\n\r\n\t\t\t\t\t\tright = mid;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ti1 = mid + 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt1 = pp[ i1 ];\r\n\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\r\n\t\t\t\t// check boundary cases, again\r\n\r\n\t\t\t\tif ( t0 === undefined ) {\r\n\r\n\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( t1 === undefined ) {\r\n\r\n\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} // seek\r\n\r\n\t\t\tthis._cachedIndex = i1;\r\n\r\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\r\n\r\n\t\t} // validate_interval\r\n\r\n\t\treturn this.interpolate_( i1, t0, t, t1 );\r\n\r\n\t},\r\n\r\n\tsettings: null, // optional, subclass-specific settings structure\r\n\t// Note: The indirection allows central control of many interpolants.\r\n\r\n\t// --- Protected interface\r\n\r\n\tDefaultSettings_: {},\r\n\r\n\tgetSettings_: function () {\r\n\r\n\t\treturn this.settings || this.DefaultSettings_;\r\n\r\n\t},\r\n\r\n\tcopySampleValue_: function ( index ) {\r\n\r\n\t\t// copies a sample value to the result buffer\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = index * stride;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] = values[ offset + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// Template methods for derived classes:\r\n\r\n\tinterpolate_: function (  ) {\r\n\r\n\t\tthrow new Error( 'call to abstract method' );\r\n\t\t// implementations shall return this.resultBuffer\r\n\r\n\t},\r\n\r\n\tintervalChanged_: function (  ) {\r\n\r\n\t\t// empty\r\n\r\n\t}\r\n\r\n} );\r\n\r\n//!\\ DECLARE ALIAS AFTER assign prototype !\r\nObject.assign( Interpolant.prototype, {\r\n\r\n\t//( 0, t, t0 ), returns this.resultBuffer\r\n\tbeforeStart_: Interpolant.prototype.copySampleValue_,\r\n\r\n\t//( N-1, tN-1, t ), returns this.resultBuffer\r\n\tafterEnd_: Interpolant.prototype.copySampleValue_,\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n}\r\n\r\nLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\r\n\r\n\tconstructor: LinearInterpolant,\r\n\r\n\tinterpolate_: function ( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toffset1 = i1 * stride,\r\n\t\t\toffset0 = offset1 - stride,\r\n\r\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\tweight0 = 1 - weight1;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] =\r\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\r\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// Characters [].:/ are reserved for track binding syntax.\r\nvar RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\r\n\r\nfunction Composite( targetGroup, path, optionalParsedPath ) {\r\n\r\n\tvar parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\r\n\r\n\tthis._targetGroup = targetGroup;\r\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\r\n\r\n}\r\n\r\nObject.assign( Composite.prototype, {\r\n\r\n\tgetValue: function ( array, offset ) {\r\n\r\n\t\tthis.bind(); // bind all binding\r\n\r\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\r\n\t\t\tbinding = this._bindings[ firstValidIndex ];\r\n\r\n\t\t// and only call .getValue on the first\r\n\t\tif ( binding !== undefined ) { binding.getValue( array, offset ); }\r\n\r\n\t},\r\n\r\n\tsetValue: function ( array, offset ) {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t  n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].setValue( array, offset );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tbind: function () {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t  n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].bind();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tunbind: function () {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t  n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].unbind();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nfunction PropertyBinding( rootNode, path, parsedPath ) {\r\n\r\n\tthis.path = path;\r\n\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\r\n\r\n\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\r\n\r\n\tthis.rootNode = rootNode;\r\n\r\n}\r\n\r\nObject.assign( PropertyBinding, {\r\n\r\n\tComposite: Composite,\r\n\r\n\tcreate: function ( root, path, parsedPath ) {\r\n\r\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\r\n\r\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\t\r\n\tsanitizeNodeName: ( function () {\r\n\r\n\t\tvar reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );\r\n\r\n\t\treturn function sanitizeNodeName( name ) {\r\n\r\n\t\t\treturn name.replace( /\\s/g, '_' ).replace( reservedRe, '' );\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tparseTrackName: function () {\r\n\r\n\t\t// Attempts to allow node names from any language. ES5's `\\w` regexp matches\r\n\t\t// only latin characters, and the unicode \\p{L} is not yet supported. So\r\n\t\t// instead, we exclude reserved characters and match everything else.\r\n\t\tvar wordChar = '[^' + RESERVED_CHARS_RE + ']';\r\n\t\tvar wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\r\n\r\n\t\t// Parent directories, delimited by '/' or ':'. Currently unused, but must\r\n\t\t// be matched to parse the rest of the track name.\r\n\t\tvar directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', wordChar );\r\n\r\n\t\t// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\r\n\t\tvar nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );\r\n\r\n\t\t// Object on target node, and accessor. May not contain reserved\r\n\t\t// characters. Accessor may contain any character except closing bracket.\r\n\t\tvar objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', wordChar );\r\n\r\n\t\t// Property and accessor. May not contain reserved characters. Accessor may\r\n\t\t// contain any non-bracket characters.\r\n\t\tvar propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', wordChar );\r\n\r\n\t\tvar trackRe = new RegExp( ''\r\n\t\t\t+ '^'\r\n\t\t\t+ directoryRe\r\n\t\t\t+ nodeRe\r\n\t\t\t+ objectRe\r\n\t\t\t+ propertyRe\r\n\t\t\t+ '$'\r\n\t\t);\r\n\r\n\t\tvar supportedObjectNames = [ 'material', 'materials', 'bones' ];\r\n\r\n\t\treturn function parseTrackName( trackName ) {\r\n\r\n\t\t\tvar matches = trackRe.exec( trackName );\r\n\r\n\t\t\tif ( ! matches ) {\r\n\r\n\t\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar results = {\r\n\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\r\n\t\t\t\tnodeName: matches[ 2 ],\r\n\t\t\t\tobjectName: matches[ 3 ],\r\n\t\t\t\tobjectIndex: matches[ 4 ],\r\n\t\t\t\tpropertyName: matches[ 5 ], // required\r\n\t\t\t\tpropertyIndex: matches[ 6 ]\r\n\t\t\t};\r\n\r\n\t\t\tvar lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\r\n\r\n\t\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\r\n\r\n\t\t\t\tvar objectName = results.nodeName.substring( lastDot + 1 );\r\n\r\n\t\t\t\t// Object names must be checked against a whitelist. Otherwise, there\r\n\t\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\r\n\t\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\r\n\t\t\t\t// include '.' characters).\r\n\t\t\t\tif ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {\r\n\r\n\t\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\r\n\t\t\t\t\tresults.objectName = objectName;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn results;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tfindNode: function ( root, nodeName ) {\r\n\r\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\r\n\r\n\t\t\treturn root;\r\n\r\n\t\t}\r\n\r\n\t\t// search into skeleton bones.\r\n\t\tif ( root.skeleton ) {\r\n\r\n\t\t\tvar bone = root.skeleton.getBoneByName( nodeName );\r\n\r\n\t\t\tif ( bone !== undefined ) {\r\n\r\n\t\t\t\treturn bone;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// search into node subtree.\r\n\t\tif ( root.children ) {\r\n\r\n\t\t\tvar searchNodeSubtree = function ( children ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar childNode = children[ i ];\r\n\r\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\r\n\r\n\t\t\t\t\t\treturn childNode;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\r\n\r\n\t\t\t\t\tif ( result ) { return result; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\r\n\r\n\t\t\tif ( subTreeNode ) {\r\n\r\n\t\t\t\treturn subTreeNode;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( PropertyBinding.prototype, { // prototype, continued\r\n\r\n\t// these are used to \"bind\" a nonexistent property\r\n\t_getValue_unavailable: function () {},\r\n\t_setValue_unavailable: function () {},\r\n\r\n\tBindingType: {\r\n\t\tDirect: 0,\r\n\t\tEntireArray: 1,\r\n\t\tArrayElement: 2,\r\n\t\tHasFromToArray: 3\r\n\t},\r\n\r\n\tVersioning: {\r\n\t\tNone: 0,\r\n\t\tNeedsUpdate: 1,\r\n\t\tMatrixWorldNeedsUpdate: 2\r\n\t},\r\n\r\n\tGetterByBindingType: [\r\n\r\n\t\tfunction getValue_direct( buffer, offset ) {\r\n\r\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_array( buffer, offset ) {\r\n\r\n\t\t\tvar source = this.resolvedProperty;\r\n\r\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_arrayElement( buffer, offset ) {\r\n\r\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_toArray( buffer, offset ) {\r\n\r\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\r\n\r\n\t\t}\r\n\r\n\t],\r\n\r\n\tSetterByBindingTypeAndVersioning: [\r\n\r\n\t\t[\r\n\t\t\t// Direct\r\n\r\n\t\t\tfunction setValue_direct( buffer, offset ) {\r\n\r\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// EntireArray\r\n\r\n\t\t\tfunction setValue_array( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// ArrayElement\r\n\r\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// HasToFromArray\r\n\r\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t]\r\n\r\n\t],\r\n\r\n\tgetValue: function getValue_unbound( targetArray, offset ) {\r\n\r\n\t\tthis.bind();\r\n\t\tthis.getValue( targetArray, offset );\r\n\r\n\t\t// Note: This class uses a State pattern on a per-method basis:\r\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\r\n\t\t// prototype version of these methods with one that represents\r\n\t\t// the bound state. When the property is not found, the methods\r\n\t\t// become no-ops.\r\n\r\n\t},\r\n\r\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\r\n\r\n\t\tthis.bind();\r\n\t\tthis.setValue( sourceArray, offset );\r\n\r\n\t},\r\n\r\n\t// create getter / setter pair for a property in the scene graph\r\n\tbind: function () {\r\n\r\n\t\tvar targetObject = this.node,\r\n\t\t\tparsedPath = this.parsedPath,\r\n\r\n\t\t\tobjectName = parsedPath.objectName,\r\n\t\t\tpropertyName = parsedPath.propertyName,\r\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\r\n\r\n\t\tif ( ! targetObject ) {\r\n\r\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\r\n\r\n\t\t\tthis.node = targetObject;\r\n\r\n\t\t}\r\n\r\n\t\t// set fail state so we can just 'return' on error\r\n\t\tthis.getValue = this._getValue_unavailable;\r\n\t\tthis.setValue = this._setValue_unavailable;\r\n\r\n\t\t// ensure there is a value node\r\n\t\tif ( ! targetObject ) {\r\n\r\n\t\t\tconsole.error( 'PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( objectName ) {\r\n\r\n\t\t\tvar objectIndex = parsedPath.objectIndex;\r\n\r\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\r\n\t\t\tswitch ( objectName ) {\r\n\r\n\t\t\t\tcase 'materials':\r\n\r\n\t\t\t\t\tif ( ! targetObject.material ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'PropertyBinding: Can not bind to material as node does not have a material.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargetObject = targetObject.material.materials;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'bones':\r\n\r\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\r\n\t\t\t\t\t// and convert the integer string to a true integer.\r\n\r\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\r\n\r\n\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\r\n\r\n\t\t\t\t\t\t\tobjectIndex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'PropertyBinding: Can not bind to objectName of node undefined.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( objectIndex !== undefined ) {\r\n\r\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.error( 'PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// resolve property\r\n\t\tvar nodeProperty = targetObject[ propertyName ];\r\n\r\n\t\tif ( nodeProperty === undefined ) {\r\n\r\n\t\t\tvar nodeName = parsedPath.nodeName;\r\n\r\n\t\t\tconsole.error( 'PropertyBinding: Trying to update property for track: ' + nodeName +\r\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// determine versioning scheme\r\n\t\tvar versioning = this.Versioning.None;\r\n\r\n\t\tthis.targetObject = targetObject;\r\n\r\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\r\n\r\n\t\t\tversioning = this.Versioning.NeedsUpdate;\r\n\r\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\r\n\r\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\r\n\r\n\t\t}\r\n\r\n\t\t// determine how the property gets bound\r\n\t\tvar bindingType = this.BindingType.Direct;\r\n\r\n\t\tif ( propertyIndex !== undefined ) {\r\n\r\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\r\n\r\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\r\n\r\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\r\n\r\n\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\tif ( ! targetObject.geometry ) {\r\n\r\n\t\t\t\t\tconsole.error( 'PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( targetObject.geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {\r\n\r\n\t\t\t\t\t\t\tpropertyIndex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\r\n\r\n\t\t\t\t\t\t\tpropertyIndex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbindingType = this.BindingType.ArrayElement;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\t\tthis.propertyIndex = propertyIndex;\r\n\r\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\r\n\r\n\t\t\t// must use copy for Object3D.Euler/Quaternion\r\n\r\n\t\t\tbindingType = this.BindingType.HasFromToArray;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\r\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\r\n\r\n\t\t\tbindingType = this.BindingType.EntireArray;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.propertyName = propertyName;\r\n\r\n\t\t}\r\n\r\n\t\t// select getter / setter\r\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\r\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\r\n\r\n\t},\r\n\r\n\tunbind: function () {\r\n\r\n\t\tthis.node = null;\r\n\r\n\t\t// back to the prototype version of getValue / setValue\r\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\r\n\t\tthis.getValue = this._getValue_unbound;\r\n\t\tthis.setValue = this._setValue_unbound;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n//!\\ DECLARE ALIAS AFTER assign prototype !\r\nObject.assign( PropertyBinding.prototype, {\r\n\r\n\t// initial state of these methods that calls 'bind'\r\n\t_getValue_unbound: PropertyBinding.prototype.getValue,\r\n\t_setValue_unbound: PropertyBinding.prototype.setValue,\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PropertyMixer( binding, typeName, valueSize ) {\r\n\r\n\tthis.binding = binding;\r\n\tthis.valueSize = valueSize;\r\n\r\n\tvar bufferType = Float64Array,\r\n\t\tmixFunction;\r\n\r\n\tswitch ( typeName ) {\r\n\r\n\t\tcase 'quaternion':\r\n\t\t\tmixFunction = this._slerp;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'string':\r\n\t\tcase 'bool':\r\n\t\t\tbufferType = Array;\r\n\t\t\tmixFunction = this._select;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tmixFunction = this._lerp;\r\n\r\n\t}\r\n\r\n\tthis.buffer = new bufferType( valueSize * 4 );\r\n\t// layout: [ incoming | accu0 | accu1 | orig ]\r\n\t//\r\n\t// interpolators can use .buffer as their .result\r\n\t// the data then goes to 'incoming'\r\n\t//\r\n\t// 'accu0' and 'accu1' are used frame-interleaved for\r\n\t// the cumulative result and are compared to detect\r\n\t// changes\r\n\t//\r\n\t// 'orig' stores the original state of the property\r\n\r\n\tthis._mixBufferRegion = mixFunction;\r\n\r\n\tthis.cumulativeWeight = 0;\r\n\r\n\tthis.useCount = 0;\r\n\tthis.referenceCount = 0;\r\n\r\n}\r\n\r\nObject.assign( PropertyMixer.prototype, {\r\n\r\n\t// accumulate data in the 'incoming' region into 'accu<i>'\r\n\taccumulate: function ( accuIndex, weight ) {\r\n\r\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\r\n\t\t// the weight and shouldn't have made the call in the first place\r\n\r\n\t\tvar buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = accuIndex * stride + stride,\r\n\r\n\t\t\tcurrentWeight = this.cumulativeWeight;\r\n\r\n\t\tif ( currentWeight === 0 ) {\r\n\r\n\t\t\t// accuN := incoming * weight\r\n\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentWeight = weight;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// accuN := accuN + incoming * weight\r\n\r\n\t\t\tcurrentWeight += weight;\r\n\t\t\tvar mix = weight / currentWeight;\r\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\r\n\r\n\t\t}\r\n\r\n\t\tthis.cumulativeWeight = currentWeight;\r\n\r\n\t},\r\n\r\n\t// apply the state of 'accu<i>' to the binding when accus differ\r\n\tapply: function ( accuIndex ) {\r\n\r\n\t\tvar stride = this.valueSize,\r\n\t\t\tbuffer = this.buffer,\r\n\t\t\toffset = accuIndex * stride + stride,\r\n\r\n\t\t\tweight = this.cumulativeWeight,\r\n\r\n\t\t\tbinding = this.binding;\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\r\n\t\tif ( weight < 1 ) {\r\n\r\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\r\n\r\n\t\t\tvar originalValueOffset = stride * 3;\r\n\r\n\t\t\tthis._mixBufferRegion(\r\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\r\n\r\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\r\n\r\n\t\t\t\t// value has changed -> update scene graph\r\n\r\n\t\t\t\tbinding.setValue( buffer, offset );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// remember the state of the bound property and copy it to both accus\r\n\tsaveOriginalState: function () {\r\n\r\n\t\tvar binding = this.binding;\r\n\r\n\t\tvar buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toriginalValueOffset = stride * 3;\r\n\r\n\t\tbinding.getValue( buffer, originalValueOffset );\r\n\r\n\t\t// accu[0..1] := orig -- initially detect changes against the original\r\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\r\n\r\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\r\n\r\n\t\t}\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\r\n\t},\r\n\r\n\t// apply the state previously taken via 'saveOriginalState' to the binding\r\n\trestoreOriginalState: function () {\r\n\r\n\t\tvar originalValueOffset = this.valueSize * 3;\r\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\r\n\r\n\t},\r\n\r\n\t// mix functions\r\n\r\n\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tif ( t >= 0.5 ) {\r\n\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\r\n\r\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\r\n\r\n\t},\r\n\r\n\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tvar s = 1 - t;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tvar j = dstOffset + i;\r\n\r\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar AnimationUtils = {\r\n\r\n\t// same as Array.prototype.slice, but also works on typed arrays\r\n\tarraySlice: function ( array, from, to ) {\r\n\r\n\t\tif ( AnimationUtils.isTypedArray( array ) ) {\r\n\r\n\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\r\n\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\r\n\t\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn array.slice( from, to );\r\n\r\n\t},\r\n\r\n\t// converts an array to a specific type\r\n\tconvertArray: function ( array, type, forceClone ) {\r\n\r\n\t\tif ( ! array || // let 'undefined' and 'null' pass\r\n\t\t\t\t! forceClone && array.constructor === type ) { return array; }\r\n\r\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\r\n\r\n\t\t\treturn new type( array ); // create typed array\r\n\r\n\t\t}\r\n\r\n\t\treturn Array.prototype.slice.call( array ); // create Array\r\n\r\n\t},\r\n\r\n\tisTypedArray: function ( object ) {\r\n\r\n\t\treturn ArrayBuffer.isView( object ) &&\r\n\t\t\t\t! ( object instanceof DataView );\r\n\r\n\t},\r\n\r\n\t// returns an array by which times and values can be sorted\r\n\tgetKeyframeOrder: function ( times ) {\r\n\r\n\t\tfunction compareTime( i, j ) {\r\n\r\n\t\t\treturn times[ i ] - times[ j ];\r\n\r\n\t\t}\r\n\r\n\t\tvar n = times.length;\r\n\t\tvar result = new Array( n );\r\n\t\tfor ( var i = 0; i !== n; ++ i ) { result[ i ] = i; }\r\n\r\n\t\tresult.sort( compareTime );\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\r\n\tsortedArray: function ( values, stride, order ) {\r\n\r\n\t\tvar nValues = values.length;\r\n\t\tvar result = new values.constructor( nValues );\r\n\r\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\r\n\r\n\t\t\tvar srcOffset = order[ i ] * stride;\r\n\r\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// function for parsing AOS keyframe formats\r\n\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\r\n\r\n\t\tvar i = 1, key = jsonKeys[ 0 ];\r\n\r\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\r\n\r\n\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( key === undefined ) { return; } // no data\r\n\r\n\t\tvar value = key[ valuePropertyName ];\r\n\t\tif ( value === undefined ) { return; } // no data\r\n\r\n\t\tif ( Array.isArray( value ) ) {\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t} else if ( value.toArray !== undefined ) {\r\n\r\n\t\t\t// ...assume Math-ish\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalue.toArray( values, values.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// otherwise push as-is\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalues.push( value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n\tthis._weightPrev = - 0;\r\n\tthis._offsetPrev = - 0;\r\n\tthis._weightNext = - 0;\r\n\tthis._offsetNext = - 0;\r\n\r\n}\r\n\r\nCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\r\n\r\n\tconstructor: CubicInterpolant,\r\n\r\n\tDefaultSettings_: {\r\n\r\n\t\tendingStart: ZeroCurvatureEnding,\r\n\t\tendingEnd: ZeroCurvatureEnding\r\n\r\n\t},\r\n\r\n\tintervalChanged_: function ( i1, t0, t1 ) {\r\n\r\n\t\tvar pp = this.parameterPositions,\r\n\t\t\tiPrev = i1 - 2,\r\n\t\t\tiNext = i1 + 1,\r\n\r\n\t\t\ttPrev = pp[ iPrev ],\r\n\t\t\ttNext = pp[ iNext ];\r\n\r\n\t\tif ( tPrev === undefined ) {\r\n\r\n\t\t\tswitch ( this.getSettings_().endingStart ) {\r\n\r\n\t\t\t\tcase ZeroSlopeEnding:\r\n\r\n\t\t\t\t\t// f'(t0) = 0\r\n\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\ttPrev = 2 * t0 - t1;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase WrapAroundEnding:\r\n\r\n\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\tiPrev = pp.length - 2;\r\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\r\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\r\n\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\ttPrev = t1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( tNext === undefined ) {\r\n\r\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\r\n\r\n\t\t\t\tcase ZeroSlopeEnding:\r\n\r\n\t\t\t\t\t// f'(tN) = 0\r\n\t\t\t\t\tiNext = i1;\r\n\t\t\t\t\ttNext = 2 * t1 - t0;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase WrapAroundEnding:\r\n\r\n\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\tiNext = 1;\r\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\r\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\r\n\t\t\t\t\tiNext = i1 - 1;\r\n\t\t\t\t\ttNext = t0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\r\n\t\t\tstride = this.valueSize;\r\n\r\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\r\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\r\n\t\tthis._offsetPrev = iPrev * stride;\r\n\t\tthis._offsetNext = iNext * stride;\r\n\r\n\t},\r\n\r\n\tinterpolate_: function ( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\r\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\r\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\r\n\r\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\tpp = p * p,\r\n\t\t\tppp = pp * p;\r\n\r\n\t\t// evaluate polynomials\r\n\r\n\t\tvar sP = - wP * ppp + 2 * wP * pp - wP * p;\r\n\t\tvar s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\r\n\t\tvar s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\r\n\t\tvar sN = wN * ppp - wN * pp;\r\n\r\n\t\t// combine data linearly\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] =\r\n\t\t\t\t\tsP * values[ oP + i ] +\r\n\t\t\t\t\ts0 * values[ o0 + i ] +\r\n\t\t\t\t\ts1 * values[ o1 + i ] +\r\n\t\t\t\t\tsN * values[ oN + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n}\r\n\r\nDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\r\n\r\n\tconstructor: DiscreteInterpolant,\r\n\r\n\tinterpolate_: function ( i1  ) {\r\n\r\n\t\treturn this.copySampleValue_( i1 - 1 );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction KeyframeTrack( name, times, values, interpolation ) {\r\n\r\n\tif ( name === undefined ) { throw new Error( 'KeyframeTrack: track name is undefined' ); }\r\n\tif ( times === undefined || times.length === 0 ) { throw new Error( 'KeyframeTrack: no keyframes in track named ' + name ); }\r\n\r\n\tthis.name = name;\r\n\r\n\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\r\n\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\r\n\r\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\r\n\r\n}\r\n\r\n// Static methods\r\n\r\nObject.assign( KeyframeTrack, {\r\n\r\n\t// Serialization (in static context, because of constructor invocation\r\n\t// and automatic invocation of .toJSON):\r\n\r\n\ttoJSON: function ( track ) {\r\n\r\n\t\tvar trackType = track.constructor;\r\n\r\n\t\tvar json;\r\n\r\n\t\t// derived classes can define a static toJSON method\r\n\t\tif ( trackType.toJSON !== undefined ) {\r\n\r\n\t\t\tjson = trackType.toJSON( track );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// by default, we assume the data can be serialized as-is\r\n\t\t\tjson = {\r\n\r\n\t\t\t\t'name': track.name,\r\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\r\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar interpolation = track.getInterpolation();\r\n\r\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\r\n\r\n\t\t\t\tjson.interpolation = interpolation;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tjson.type = track.ValueTypeName; // mandatory\r\n\r\n\t\treturn json;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( KeyframeTrack.prototype, {\r\n\r\n\tconstructor: KeyframeTrack,\r\n\r\n\tTimeBufferType: Float32Array,\r\n\r\n\tValueBufferType: Float32Array,\r\n\r\n\tDefaultInterpolation: InterpolateLinear,\r\n\r\n\tInterpolantFactoryMethodDiscrete: function ( result ) {\r\n\r\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodLinear: function ( result ) {\r\n\r\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodSmooth: function ( result ) {\r\n\r\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tsetInterpolation: function ( interpolation ) {\r\n\r\n\t\tvar factoryMethod;\r\n\r\n\t\tswitch ( interpolation ) {\r\n\r\n\t\t\tcase InterpolateDiscrete:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase InterpolateLinear:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase InterpolateSmooth:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tif ( factoryMethod === undefined ) {\r\n\r\n\t\t\tvar message = \"unsupported interpolation for \" +\r\n\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\r\n\r\n\t\t\tif ( this.createInterpolant === undefined ) {\r\n\r\n\t\t\t\t// fall back to default, unless the default itself is messed up\r\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\r\n\r\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.warn( 'KeyframeTrack:', message );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.createInterpolant = factoryMethod;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInterpolation: function () {\r\n\r\n\t\tswitch ( this.createInterpolant ) {\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\r\n\r\n\t\t\t\treturn InterpolateDiscrete;\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodLinear:\r\n\r\n\t\t\t\treturn InterpolateLinear;\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\r\n\r\n\t\t\t\treturn InterpolateSmooth;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetValueSize: function () {\r\n\r\n\t\treturn this.values.length / this.times.length;\r\n\r\n\t},\r\n\r\n\t// move all keyframes either forwards or backwards in time\r\n\tshift: function ( timeOffset ) {\r\n\r\n\t\tif ( timeOffset !== 0.0 ) {\r\n\r\n\t\t\tvar times = this.times;\r\n\r\n\t\t\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] += timeOffset;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\r\n\tscale: function ( timeScale ) {\r\n\r\n\t\tif ( timeScale !== 1.0 ) {\r\n\r\n\t\t\tvar times = this.times;\r\n\r\n\t\t\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] *= timeScale;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\r\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\r\n\ttrim: function ( startTime, endTime ) {\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tnKeys = times.length,\r\n\t\t\tfrom = 0,\r\n\t\t\tto = nKeys - 1;\r\n\r\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\r\n\r\n\t\t\t++ from;\r\n\r\n\t\t}\r\n\r\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\r\n\r\n\t\t\t-- to;\r\n\r\n\t\t}\r\n\r\n\t\t++ to; // inclusive -> exclusive bound\r\n\r\n\t\tif ( from !== 0 || to !== nKeys ) {\r\n\r\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\r\n\t\t\tif ( from >= to ) { to = Math.max( to, 1 ), from = to - 1; }\r\n\r\n\t\t\tvar stride = this.getValueSize();\r\n\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\r\n\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\r\n\tvalidate: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar valid = true;\r\n\r\n\t\tvar valueSize = this.getValueSize();\r\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\r\n\r\n\t\t\tconsole.error( 'KeyframeTrack: Invalid value size in track.', this );\r\n\t\t\tvalid = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tvalues = this.values,\r\n\r\n\t\t\tnKeys = times.length;\r\n\r\n\t\tif ( nKeys === 0 ) {\r\n\r\n\t\t\tconsole.error( 'KeyframeTrack: Track is empty.', this );\r\n\t\t\tvalid = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar prevTime = null;\r\n\r\n\t\tfor ( var i = 0; i !== nKeys; i ++ ) {\r\n\r\n\t\t\tvar currTime = times[ i ];\r\n\r\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\r\n\r\n\t\t\t\tconsole.error( 'KeyframeTrack: Time is not a valid number.', this$1, i, currTime );\r\n\t\t\t\tvalid = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\r\n\r\n\t\t\t\tconsole.error( 'KeyframeTrack: Out of order keys.', this$1, i, currTime, prevTime );\r\n\t\t\t\tvalid = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevTime = currTime;\r\n\r\n\t\t}\r\n\r\n\t\tif ( values !== undefined ) {\r\n\r\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\r\n\r\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tvar value = values[ i ];\r\n\r\n\t\t\t\t\tif ( isNaN( value ) ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'KeyframeTrack: Value is not a valid number.', this$1, i, value );\r\n\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn valid;\r\n\r\n\t},\r\n\r\n\t// removes equivalent sequential keys as common in morph target sequences\r\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n\toptimize: function () {\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tvalues = this.values,\r\n\t\t\tstride = this.getValueSize(),\r\n\r\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\r\n\r\n\t\t\twriteIndex = 1,\r\n\t\t\tlastIndex = times.length - 1;\r\n\r\n\t\tfor ( var i = 1; i < lastIndex; ++ i ) {\r\n\r\n\t\t\tvar keep = false;\r\n\r\n\t\t\tvar time = times[ i ];\r\n\t\t\tvar timeNext = times[ i + 1 ];\r\n\r\n\t\t\t// remove adjacent keyframes scheduled at the same time\r\n\r\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\r\n\r\n\t\t\t\tif ( ! smoothInterpolation ) {\r\n\r\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\r\n\r\n\t\t\t\t\tvar offset = i * stride,\r\n\t\t\t\t\t\toffsetP = offset - stride,\r\n\t\t\t\t\t\toffsetN = offset + stride;\r\n\r\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\t\t\tvar value = values[ offset + j ];\r\n\r\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\r\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\r\n\r\n\t\t\t\t\t\t\tkeep = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tkeep = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// in-place compaction\r\n\r\n\t\t\tif ( keep ) {\r\n\r\n\t\t\t\tif ( i !== writeIndex ) {\r\n\r\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\r\n\r\n\t\t\t\t\tvar readOffset = i * stride,\r\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\r\n\r\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++ writeIndex;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// flush last keyframe (compaction looks ahead)\r\n\r\n\t\tif ( lastIndex > 0 ) {\r\n\r\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\r\n\r\n\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t++ writeIndex;\r\n\r\n\t\t}\r\n\r\n\t\tif ( writeIndex !== times.length ) {\r\n\r\n\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\r\n\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction BooleanKeyframeTrack( name, times, values ) {\r\n\r\n\tKeyframeTrack.call( this, name, times, values );\r\n\r\n}\r\n\r\nBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: BooleanKeyframeTrack,\r\n\r\n\tValueTypeName: 'bool',\r\n\tValueBufferType: Array,\r\n\r\n\tDefaultInterpolation: InterpolateDiscrete,\r\n\r\n\tInterpolantFactoryMethodLinear: undefined,\r\n\tInterpolantFactoryMethodSmooth: undefined\r\n\r\n\t// Note: Actually this track could have a optimized / compressed\r\n\t// representation of a single value and a custom interpolant that\r\n\t// computes \"firstValue ^ isOdd( index )\".\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ColorKeyframeTrack( name, times, values, interpolation ) {\r\n\r\n\tKeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n}\r\n\r\nColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: ColorKeyframeTrack,\r\n\r\n\tValueTypeName: 'color'\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n\t// Note: Very basic implementation and nothing special yet.\r\n\t// However, this is the place for color space parameterization.\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction NumberKeyframeTrack( name, times, values, interpolation ) {\r\n\r\n\tKeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n}\r\n\r\nNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: NumberKeyframeTrack,\r\n\r\n\tValueTypeName: 'number'\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n}\r\n\r\nQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\r\n\r\n\tconstructor: QuaternionLinearInterpolant,\r\n\r\n\tinterpolate_: function ( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toffset = i1 * stride,\r\n\r\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\r\n\r\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\r\n\r\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction QuaternionKeyframeTrack$1( name, times, values, interpolation ) {\r\n\r\n\tKeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n}\r\n\r\nQuaternionKeyframeTrack$1.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: QuaternionKeyframeTrack$1,\r\n\r\n\tValueTypeName: 'quaternion',\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\tDefaultInterpolation: InterpolateLinear,\r\n\r\n\tInterpolantFactoryMethodLinear: function ( result ) {\r\n\r\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction StringKeyframeTrack( name, times, values, interpolation ) {\r\n\r\n\tKeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n}\r\n\r\nStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: StringKeyframeTrack,\r\n\r\n\tValueTypeName: 'string',\r\n\tValueBufferType: Array,\r\n\r\n\tDefaultInterpolation: InterpolateDiscrete,\r\n\r\n\tInterpolantFactoryMethodLinear: undefined,\r\n\r\n\tInterpolantFactoryMethodSmooth: undefined\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction VectorKeyframeTrack$1( name, times, values, interpolation ) {\r\n\r\n\tKeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n}\r\n\r\nVectorKeyframeTrack$1.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: VectorKeyframeTrack$1,\r\n\r\n\tValueTypeName: 'vector'\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AnimationClip( name, duration, tracks ) {\r\n\r\n\tthis.name = name;\r\n\tthis.tracks = tracks;\r\n\tthis.duration = ( duration !== undefined ) ? duration : - 1;\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\t// this means it should figure out its duration by scanning the tracks\r\n\tif ( this.duration < 0 ) {\r\n\r\n\t\tthis.resetDuration();\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getTrackTypeForValueTypeName( typeName ) {\r\n\r\n\tswitch ( typeName.toLowerCase() ) {\r\n\r\n\t\tcase 'scalar':\r\n\t\tcase 'double':\r\n\t\tcase 'float':\r\n\t\tcase 'number':\r\n\t\tcase 'integer':\r\n\r\n\t\t\treturn NumberKeyframeTrack;\r\n\r\n\t\tcase 'vector':\r\n\t\tcase 'vector2':\r\n\t\tcase 'vector3':\r\n\t\tcase 'vector4':\r\n\r\n\t\t\treturn VectorKeyframeTrack$1;\r\n\r\n\t\tcase 'color':\r\n\r\n\t\t\treturn ColorKeyframeTrack;\r\n\r\n\t\tcase 'quaternion':\r\n\r\n\t\t\treturn QuaternionKeyframeTrack$1;\r\n\r\n\t\tcase 'bool':\r\n\t\tcase 'boolean':\r\n\r\n\t\t\treturn BooleanKeyframeTrack;\r\n\r\n\t\tcase 'string':\r\n\r\n\t\t\treturn StringKeyframeTrack;\r\n\r\n\t}\r\n\r\n\tthrow new Error( 'KeyframeTrack: Unsupported typeName: ' + typeName );\r\n\r\n}\r\n\r\nfunction parseKeyframeTrack( json ) {\r\n\r\n\tif ( json.type === undefined ) {\r\n\r\n\t\tthrow new Error( 'KeyframeTrack: track type undefined, can not parse' );\r\n\r\n\t}\r\n\r\n\tvar trackType = getTrackTypeForValueTypeName( json.type );\r\n\r\n\tif ( json.times === undefined ) {\r\n\r\n\t\tvar times = [], values = [];\r\n\r\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\r\n\r\n\t\tjson.times = times;\r\n\t\tjson.values = values;\r\n\r\n\t}\r\n\r\n\t// derived classes can define a static parse method\r\n\tif ( trackType.parse !== undefined ) {\r\n\r\n\t\treturn trackType.parse( json );\r\n\r\n\t} else {\r\n\r\n\t\t// by default, we assume a constructor compatible with the base\r\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( AnimationClip, {\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar tracks = [],\r\n\t\t\tjsonTracks = json.tracks,\r\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\r\n\r\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn new AnimationClip( json.name, json.duration, tracks );\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( clip ) {\r\n\r\n\t\tvar tracks = [],\r\n\t\t\tclipTracks = clip.tracks;\r\n\r\n\t\tvar json = {\r\n\r\n\t\t\t'name': clip.name,\r\n\t\t\t'duration': clip.duration,\r\n\t\t\t'tracks': tracks,\r\n\t\t\t'uuid': clip.uuid\r\n\r\n\t\t};\r\n\r\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn json;\r\n\r\n\t},\r\n\r\n\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\r\n\r\n\t\tvar numMorphTargets = morphTargetSequence.length;\r\n\t\tvar tracks = [];\r\n\r\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\r\n\r\n\t\t\tvar times = [];\r\n\t\t\tvar values = [];\r\n\r\n\t\t\ttimes.push(\r\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\r\n\t\t\t\ti,\r\n\t\t\t\t( i + 1 ) % numMorphTargets );\r\n\r\n\t\t\tvalues.push( 0, 1, 0 );\r\n\r\n\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\r\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\r\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\r\n\r\n\t\t\t// if there is a key at the first frame, duplicate it as the\r\n\t\t\t// last frame as well for perfect loop.\r\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\r\n\r\n\t\t\t\ttimes.push( numMorphTargets );\r\n\t\t\t\tvalues.push( values[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttracks.push(\r\n\t\t\t\tnew NumberKeyframeTrack(\r\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\r\n\t\t\t\t\ttimes, values\r\n\t\t\t\t).scale( 1.0 / fps ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn new AnimationClip( name, - 1, tracks );\r\n\r\n\t},\r\n\r\n\tfindByName: function ( objectOrClipArray, name ) {\r\n\r\n\t\tvar clipArray = objectOrClipArray;\r\n\r\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\r\n\r\n\t\t\tvar o = objectOrClipArray;\r\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\r\n\r\n\t\t\tif ( clipArray[ i ].name === name ) {\r\n\r\n\t\t\t\treturn clipArray[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\r\n\r\n\t\tvar animationToMorphTargets = {};\r\n\r\n\t\t// tested with https://regex101.com/ on trick sequences\r\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\r\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\r\n\r\n\t\t// sort morph target names into animation groups based\r\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\r\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morphTarget = morphTargets[ i ];\r\n\t\t\tvar parts = morphTarget.name.match( pattern );\r\n\r\n\t\t\tif ( parts && parts.length > 1 ) {\r\n\r\n\t\t\t\tvar name = parts[ 1 ];\r\n\r\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\r\n\t\t\t\tif ( ! animationMorphTargets ) {\r\n\r\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationMorphTargets.push( morphTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar clips = [];\r\n\r\n\t\tfor ( var name in animationToMorphTargets ) {\r\n\r\n\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn clips;\r\n\r\n\t},\r\n\r\n\t// parse the animation.hierarchy format\r\n\tparseAnimation: function ( animation, bones ) {\r\n\r\n\t\tif ( ! animation ) {\r\n\r\n\t\t\tconsole.error( 'AnimationClip: No animation in JSONLoader data.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\r\n\r\n\t\t\t// only return track if there are actually keys.\r\n\t\t\tif ( animationKeys.length !== 0 ) {\r\n\r\n\t\t\t\tvar times = [];\r\n\t\t\t\tvar values = [];\r\n\r\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\r\n\r\n\t\t\t\t// empty keys are filtered out, so check again\r\n\t\t\t\tif ( times.length !== 0 ) {\r\n\r\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tvar tracks = [];\r\n\r\n\t\tvar clipName = animation.name || 'default';\r\n\t\t// automatic length determination in AnimationClip.\r\n\t\tvar duration = animation.length || - 1;\r\n\t\tvar fps = animation.fps || 30;\r\n\r\n\t\tvar hierarchyTracks = animation.hierarchy || [];\r\n\r\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\r\n\r\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\r\n\r\n\t\t\t// skip empty tracks\r\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) { continue; }\r\n\r\n\t\t\t// process morph targets\r\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\r\n\r\n\t\t\t\t// figure out all morph targets used in this track\r\n\t\t\t\tvar morphTargetNames = {};\r\n\r\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\r\n\r\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// create a track for each morph target with all zero\r\n\t\t\t\t// morphTargetInfluences except for the keys in which\r\n\t\t\t\t// the morphTarget is named.\r\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\r\n\r\n\t\t\t\t\tvar times = [];\r\n\t\t\t\t\tvar values = [];\r\n\r\n\t\t\t\t\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\r\n\r\n\t\t\t\t\t\tvar animationKey = animationKeys[ k ];\r\n\r\n\t\t\t\t\t\ttimes.push( animationKey.time );\r\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// ...assume skeletal animation\r\n\r\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\tVectorKeyframeTrack$1, boneName + '.position',\r\n\t\t\t\t\tanimationKeys, 'pos', tracks );\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\tQuaternionKeyframeTrack$1, boneName + '.quaternion',\r\n\t\t\t\t\tanimationKeys, 'rot', tracks );\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\tVectorKeyframeTrack$1, boneName + '.scale',\r\n\t\t\t\t\tanimationKeys, 'scl', tracks );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( tracks.length === 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar clip = new AnimationClip( clipName, duration, tracks );\r\n\r\n\t\treturn clip;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( AnimationClip.prototype, {\r\n\r\n\tresetDuration: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar tracks = this.tracks, duration = 0;\r\n\r\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar track = this$1.tracks[ i ];\r\n\r\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.duration = duration;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttrim: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tthis$1.tracks[ i ].trim( 0, this$1.duration );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tvalidate: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar valid = true;\r\n\r\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tvalid = valid && this$1.tracks[ i ].validate();\r\n\r\n\t\t}\r\n\r\n\t\treturn valid;\r\n\r\n\t},\r\n\r\n\toptimize: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tthis$1.tracks[ i ].optimize();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AnimationMixer( root ) {\r\n\r\n\tthis._root = root;\r\n\tthis._initMemoryManager();\r\n\tthis._accuIndex = 0;\r\n\r\n\tthis.time = 0;\r\n\r\n\tthis.timeScale = 1.0;\r\n\r\n}\r\n\r\nAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: AnimationMixer,\r\n\r\n\t_bindAction: function ( action, prototypeAction ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar root = action._localRoot || this._root,\r\n\t\t\ttracks = action._clip.tracks,\r\n\t\t\tnTracks = tracks.length,\r\n\t\t\tbindings = action._propertyBindings,\r\n\t\t\tinterpolants = action._interpolants,\r\n\t\t\trootUuid = root.uuid,\r\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingsByName === undefined ) {\r\n\r\n\t\t\tbindingsByName = {};\r\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\r\n\t\t\tvar track = tracks[ i ],\r\n\t\t\t\ttrackName = track.name,\r\n\t\t\t\tbinding = bindingsByName[ trackName ];\r\n\r\n\t\t\tif ( binding !== undefined ) {\r\n\r\n\t\t\t\tbindings[ i ] = binding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbinding = bindings[ i ];\r\n\r\n\t\t\t\tif ( binding !== undefined ) {\r\n\r\n\t\t\t\t\t// existing binding, make sure the cache knows\r\n\r\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\r\n\r\n\t\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\t\tthis$1._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar path = prototypeAction && prototypeAction.\r\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\r\n\r\n\t\t\t\tbinding = new PropertyMixer(\r\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\r\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\r\n\r\n\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\tthis$1._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n\t\t\t\tbindings[ i ] = binding;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_activateAction: function ( action ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( ! this._isActiveAction( action ) ) {\r\n\r\n\t\t\tif ( action._cacheIndex === null ) {\r\n\r\n\t\t\t\t// this action has been forgotten by the cache, but the user\r\n\t\t\t\t// appears to be still using it -> rebind\r\n\r\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\r\n\t\t\t\t\tclipUuid = action._clip.uuid,\r\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\r\n\r\n\t\t\t\tthis._bindAction( action,\r\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\r\n\r\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\r\n\t\t\t// increment reference counts / sort out state\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\r\n\r\n\t\t\t\t\tthis$1._lendBinding( binding );\r\n\t\t\t\t\tbinding.saveOriginalState();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._lendAction( action );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_deactivateAction: function ( action ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( this._isActiveAction( action ) ) {\r\n\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\r\n\t\t\t// decrement reference counts / sort out state\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\t\tif ( -- binding.useCount === 0 ) {\r\n\r\n\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\tthis$1._takeBackBinding( binding );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._takeBackAction( action );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// Memory manager\r\n\r\n\t_initMemoryManager: function () {\r\n\r\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\r\n\t\tthis._nActiveActions = 0;\r\n\r\n\t\tthis._actionsByClip = {};\r\n\t\t// inside:\r\n\t\t// {\r\n\t\t// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\r\n\t\t// \t\tactionByRoot: AnimationAction\t\t\t- lookup\r\n\t\t// }\r\n\r\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\r\n\t\tthis._nActiveBindings = 0;\r\n\r\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\r\n\r\n\t\tthis._controlInterpolants = []; // same game as above\r\n\t\tthis._nActiveControlInterpolants = 0;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tthis.stats = {\r\n\r\n\t\t\tactions: {\r\n\t\t\t\tget total() {\r\n\r\n\t\t\t\t\treturn scope._actions.length;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tget inUse() {\r\n\r\n\t\t\t\t\treturn scope._nActiveActions;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tbindings: {\r\n\t\t\t\tget total() {\r\n\r\n\t\t\t\t\treturn scope._bindings.length;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tget inUse() {\r\n\r\n\t\t\t\t\treturn scope._nActiveBindings;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcontrolInterpolants: {\r\n\t\t\t\tget total() {\r\n\r\n\t\t\t\t\treturn scope._controlInterpolants.length;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tget inUse() {\r\n\r\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t},\r\n\r\n\t// Memory management for AnimationAction objects\r\n\r\n\t_isActiveAction: function ( action ) {\r\n\r\n\t\tvar index = action._cacheIndex;\r\n\t\treturn index !== null && index < this._nActiveActions;\r\n\r\n\t},\r\n\r\n\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\r\n\r\n\t\tif ( actionsForClip === undefined ) {\r\n\r\n\t\t\tactionsForClip = {\r\n\r\n\t\t\t\tknownActions: [ action ],\r\n\t\t\t\tactionByRoot: {}\r\n\r\n\t\t\t};\r\n\r\n\t\t\taction._byClipCacheIndex = 0;\r\n\r\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar knownActions = actionsForClip.knownActions;\r\n\r\n\t\t\taction._byClipCacheIndex = knownActions.length;\r\n\t\t\tknownActions.push( action );\r\n\r\n\t\t}\r\n\r\n\t\taction._cacheIndex = actions.length;\r\n\t\tactions.push( action );\r\n\r\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\r\n\r\n\t},\r\n\r\n\t_removeInactiveAction: function ( action ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\r\n\t\t\tcacheIndex = action._cacheIndex;\r\n\r\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\tactions.pop();\r\n\r\n\t\taction._cacheIndex = null;\r\n\r\n\t\tvar clipUuid = action._clip.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\r\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\r\n\r\n\t\t\tlastKnownAction =\r\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\r\n\r\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\r\n\r\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\r\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\r\n\t\tknownActionsForClip.pop();\r\n\r\n\t\taction._byClipCacheIndex = null;\r\n\r\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\r\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\r\n\r\n\t\tdelete actionByRoot[ rootUuid ];\r\n\r\n\t\tif ( knownActionsForClip.length === 0 ) {\r\n\r\n\t\t\tdelete actionsByClip[ clipUuid ];\r\n\r\n\t\t}\r\n\r\n\t\tthis._removeInactiveBindingsForAction( action );\r\n\r\n\t},\r\n\r\n\t_removeInactiveBindingsForAction: function ( action ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar bindings = action._propertyBindings;\r\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\tif ( -- binding.referenceCount === 0 ) {\r\n\r\n\t\t\t\tthis$1._removeInactiveBinding( binding );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_lendAction: function ( action ) {\r\n\r\n\t\t// [ active actions |  inactive actions  ]\r\n\t\t// [  active actions >| inactive actions ]\r\n\t\t//                 s        a\r\n\t\t//                  <-swap->\r\n\t\t//                 a        s\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tprevIndex = action._cacheIndex,\r\n\r\n\t\t\tlastActiveIndex = this._nActiveActions ++,\r\n\r\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\r\n\r\n\t\taction._cacheIndex = lastActiveIndex;\r\n\t\tactions[ lastActiveIndex ] = action;\r\n\r\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\r\n\t\tactions[ prevIndex ] = firstInactiveAction;\r\n\r\n\t},\r\n\r\n\t_takeBackAction: function ( action ) {\r\n\r\n\t\t// [  active actions  | inactive actions ]\r\n\t\t// [ active actions |< inactive actions  ]\r\n\t\t//        a        s\r\n\t\t//         <-swap->\r\n\t\t//        s        a\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tprevIndex = action._cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\r\n\r\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\r\n\r\n\t\taction._cacheIndex = firstInactiveIndex;\r\n\t\tactions[ firstInactiveIndex ] = action;\r\n\r\n\t\tlastActiveAction._cacheIndex = prevIndex;\r\n\t\tactions[ prevIndex ] = lastActiveAction;\r\n\r\n\t},\r\n\r\n\t// Memory management for PropertyMixer objects\r\n\r\n\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\r\n\r\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n\t\t\tbindings = this._bindings;\r\n\r\n\t\tif ( bindingByName === undefined ) {\r\n\r\n\t\t\tbindingByName = {};\r\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\r\n\r\n\t\t}\r\n\r\n\t\tbindingByName[ trackName ] = binding;\r\n\r\n\t\tbinding._cacheIndex = bindings.length;\r\n\t\tbindings.push( binding );\r\n\r\n\t},\r\n\r\n\t_removeInactiveBinding: function ( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tpropBinding = binding.binding,\r\n\t\t\trootUuid = propBinding.rootNode.uuid,\r\n\t\t\ttrackName = propBinding.path,\r\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\r\n\t\t\tcacheIndex = binding._cacheIndex;\r\n\r\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\r\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\r\n\t\tbindings.pop();\r\n\r\n\t\tdelete bindingByName[ trackName ];\r\n\r\n\t\tremove_empty_map: {\r\n\r\n\t\t\tfor ( var _ in bindingByName ) { break remove_empty_map; } // eslint-disable-line no-unused-vars\r\n\r\n\t\t\tdelete bindingsByRoot[ rootUuid ];\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_lendBinding: function ( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tprevIndex = binding._cacheIndex,\r\n\r\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\r\n\r\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\r\n\r\n\t\tbinding._cacheIndex = lastActiveIndex;\r\n\t\tbindings[ lastActiveIndex ] = binding;\r\n\r\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\r\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\r\n\r\n\t},\r\n\r\n\t_takeBackBinding: function ( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tprevIndex = binding._cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\r\n\r\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\r\n\r\n\t\tbinding._cacheIndex = firstInactiveIndex;\r\n\t\tbindings[ firstInactiveIndex ] = binding;\r\n\r\n\t\tlastActiveBinding._cacheIndex = prevIndex;\r\n\t\tbindings[ prevIndex ] = lastActiveBinding;\r\n\r\n\t},\r\n\r\n\t// Memory management of Interpolants for weight and time scale\r\n\r\n\t_lendControlInterpolant: function () {\r\n\r\n\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\r\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\r\n\r\n\t\tif ( interpolant === undefined ) {\r\n\r\n\t\t\tinterpolant = new LinearInterpolant(\r\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\r\n\t\t\t\t1, this._controlInterpolantsResultBuffer );\r\n\r\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\r\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\treturn interpolant;\r\n\r\n\t},\r\n\r\n\t_takeBackControlInterpolant: function ( interpolant ) {\r\n\r\n\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\tprevIndex = interpolant.__cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\r\n\r\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\r\n\r\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\r\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\r\n\r\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\r\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\r\n\r\n\t},\r\n\r\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\r\n\r\n\t// return an action for a clip optionally using a custom root target\r\n\t// object (this method allocates a lot of dynamic memory in case a\r\n\t// previously unknown clip/root combination is specified)\r\n\tclipAction: function ( clip, optionalRoot ) {\r\n\r\n\t\tvar root = optionalRoot || this._root,\r\n\t\t\trootUuid = root.uuid,\r\n\r\n\t\t\tclipObject = typeof clip === 'string' ?\r\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\r\n\r\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\r\n\r\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\r\n\t\t\tprototypeAction = null;\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\tvar existingAction =\r\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\r\n\r\n\t\t\tif ( existingAction !== undefined ) {\r\n\r\n\t\t\t\treturn existingAction;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// we know the clip, so we don't have to parse all\r\n\t\t\t// the bindings again but can just copy\r\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\r\n\r\n\t\t\t// also, take the clip from the prototype action\r\n\t\t\tif ( clipObject === null )\r\n\t\t\t\t{ clipObject = prototypeAction._clip; }\r\n\r\n\t\t}\r\n\r\n\t\t// clip must be known when specified via string\r\n\t\tif ( clipObject === null ) { return null; }\r\n\r\n\t\t// allocate all resources required to run it\r\n\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\r\n\r\n\t\tthis._bindAction( newAction, prototypeAction );\r\n\r\n\t\t// and make the action known to the memory manager\r\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\r\n\r\n\t\treturn newAction;\r\n\r\n\t},\r\n\r\n\t// get an existing action\r\n\texistingAction: function ( clip, optionalRoot ) {\r\n\r\n\t\tvar root = optionalRoot || this._root,\r\n\t\t\trootUuid = root.uuid,\r\n\r\n\t\t\tclipObject = typeof clip === 'string' ?\r\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\r\n\r\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\r\n\r\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\t// deactivates all previously scheduled actions\r\n\tstopAllAction: function () {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tnActions = this._nActiveActions,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = this._nActiveBindings;\r\n\r\n\t\tthis._nActiveActions = 0;\r\n\t\tthis._nActiveBindings = 0;\r\n\r\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\r\n\t\t\tactions[ i ].reset();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].useCount = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// advance the time and update apply the animation\r\n\tupdate: function ( deltaTime ) {\r\n\r\n\t\tdeltaTime *= this.timeScale;\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tnActions = this._nActiveActions,\r\n\r\n\t\t\ttime = this.time += deltaTime,\r\n\t\t\ttimeDirection = Math.sign( deltaTime ),\r\n\r\n\t\t\taccuIndex = this._accuIndex ^= 1;\r\n\r\n\t\t// run active actions\r\n\r\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\r\n\t\t\tvar action = actions[ i ];\r\n\r\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tnBindings = this._nActiveBindings;\r\n\r\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].apply( accuIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// return this mixer's root target object\r\n\tgetRoot: function () {\r\n\r\n\t\treturn this._root;\r\n\r\n\t},\r\n\r\n\t// free all resources specific to a particular clip\r\n\tuncacheClip: function ( clip ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tclipUuid = clip.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\t// note: just calling _removeInactiveAction would mess up the\r\n\t\t\t// iteration state and also require updating the state we can\r\n\t\t\t// just throw away\r\n\r\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\r\n\r\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar action = actionsToRemove[ i ];\r\n\r\n\t\t\t\tthis$1._deactivateAction( action );\r\n\r\n\t\t\t\tvar cacheIndex = action._cacheIndex,\r\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\r\n\r\n\t\t\t\taction._cacheIndex = null;\r\n\t\t\t\taction._byClipCacheIndex = null;\r\n\r\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\t\tactions.pop();\r\n\r\n\t\t\t\tthis$1._removeInactiveBindingsForAction( action );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete actionsByClip[ clipUuid ];\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// free all resources specific to a particular root target object\r\n\tuncacheRoot: function ( root ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar rootUuid = root.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip;\r\n\r\n\t\tfor ( var clipUuid in actionsByClip ) {\r\n\r\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\r\n\t\t\t\taction = actionByRoot[ rootUuid ];\r\n\r\n\t\t\tif ( action !== undefined ) {\r\n\r\n\t\t\t\tthis$1._deactivateAction( action );\r\n\t\t\t\tthis$1._removeInactiveAction( action );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingByName !== undefined ) {\r\n\r\n\t\t\tfor ( var trackName in bindingByName ) {\r\n\r\n\t\t\t\tvar binding = bindingByName[ trackName ];\r\n\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\tthis$1._removeInactiveBinding( binding );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// remove a targeted clip from the cache\r\n\tuncacheAction: function ( clip, optionalRoot ) {\r\n\r\n\t\tvar action = this.existingAction( clip, optionalRoot );\r\n\r\n\t\tif ( action !== null ) {\r\n\r\n\t\t\tthis._deactivateAction( action );\r\n\t\t\tthis._removeInactiveAction( action );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Bone() {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'Bone';\r\n\r\n}\r\n\r\nBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: Bone,\r\n\r\n\tisBone: true\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// BoxGeometry\r\n\r\nfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'BoxGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdepth: depth,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tdepthSegments: depthSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nBoxGeometry.prototype = Object.create( Geometry.prototype );\r\nBoxGeometry.prototype.constructor = BoxGeometry;\r\n\r\n// BoxBufferGeometry\r\n\r\nfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'BoxBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdepth: depth,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tdepthSegments: depthSegments\r\n\t};\r\n\r\n\tvar scope = this;\r\n\r\n\twidth = width || 1;\r\n\theight = height || 1;\r\n\tdepth = depth || 1;\r\n\r\n\t// segments\r\n\r\n\twidthSegments = Math.floor( widthSegments ) || 1;\r\n\theightSegments = Math.floor( heightSegments ) || 1;\r\n\tdepthSegments = Math.floor( depthSegments ) || 1;\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\t// helper variables\r\n\r\n\tvar numberOfVertices = 0;\r\n\tvar groupStart = 0;\r\n\r\n\t// build each side of the box geometry\r\n\r\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\r\n\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\r\n\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\r\n\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\r\n\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\r\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\r\n\r\n\t\tvar segmentWidth = width / gridX;\r\n\t\tvar segmentHeight = height / gridY;\r\n\r\n\t\tvar widthHalf = width / 2;\r\n\t\tvar heightHalf = height / 2;\r\n\t\tvar depthHalf = depth / 2;\r\n\r\n\t\tvar gridX1 = gridX + 1;\r\n\t\tvar gridY1 = gridY + 1;\r\n\r\n\t\tvar vertexCounter = 0;\r\n\t\tvar groupCount = 0;\r\n\r\n\t\tvar ix, iy;\r\n\r\n\t\tvar vector = new Vector3();\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\tvar y = iy * segmentHeight - heightHalf;\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\r\n\r\n\t\t\t\t// set values to correct vector component\r\n\r\n\t\t\t\tvector[ u ] = x * udir;\r\n\t\t\t\tvector[ v ] = y * vdir;\r\n\t\t\t\tvector[ w ] = depthHalf;\r\n\r\n\t\t\t\t// now apply vector to vertex buffer\r\n\r\n\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\r\n\r\n\t\t\t\t// set values to correct vector component\r\n\r\n\t\t\t\tvector[ u ] = 0;\r\n\t\t\t\tvector[ v ] = 0;\r\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\t\t\t// now apply vector to normal buffer\r\n\r\n\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\r\n\r\n\t\t\t\t// uvs\r\n\r\n\t\t\t\tuvs.push( ix / gridX );\r\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\r\n\r\n\t\t\t\t// counters\r\n\r\n\t\t\t\tvertexCounter += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// indices\r\n\r\n\t\t// 1. you need three indices to draw a single face\r\n\t\t// 2. a single segment consists of two faces\r\n\t\t// 3. so we need to generate six (2*3) indices per segment\r\n\r\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\r\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\t// faces\r\n\r\n\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\tindices.push( b, c, d );\r\n\r\n\t\t\t\t// increase counter\r\n\r\n\t\t\t\tgroupCount += 6;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// add a group to the geometry. this will ensure multi material support\r\n\r\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\r\n\r\n\t\t// calculate new start value for groups\r\n\r\n\t\tgroupStart += groupCount;\r\n\r\n\t\t// update total number of vertices\r\n\r\n\t\tnumberOfVertices += vertexCounter;\r\n\r\n\t}\r\n\r\n}\r\n\r\nBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// CylinderGeometry\r\n\r\nfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'CylinderGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradiusTop: radiusTop,\r\n\t\tradiusBottom: radiusBottom,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nCylinderGeometry.prototype = Object.create( Geometry.prototype );\r\nCylinderGeometry.prototype.constructor = CylinderGeometry;\r\n\r\n// CylinderBufferGeometry\r\n\r\nfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'CylinderBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradiusTop: radiusTop,\r\n\t\tradiusBottom: radiusBottom,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tvar scope = this;\r\n\r\n\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\r\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\r\n\theight = height || 1;\r\n\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\theightSegments = Math.floor( heightSegments ) || 1;\r\n\r\n\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\t// helper variables\r\n\r\n\tvar index = 0;\r\n\tvar indexArray = [];\r\n\tvar halfHeight = height / 2;\r\n\tvar groupStart = 0;\r\n\r\n\t// generate geometry\r\n\r\n\tgenerateTorso();\r\n\r\n\tif ( openEnded === false ) {\r\n\r\n\t\tif ( radiusTop > 0 ) { generateCap( true ); }\r\n\t\tif ( radiusBottom > 0 ) { generateCap( false ); }\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\tfunction generateTorso() {\r\n\r\n\t\tvar x, y;\r\n\t\tvar normal = new Vector3();\r\n\t\tvar vertex = new Vector3();\r\n\r\n\t\tvar groupCount = 0;\r\n\r\n\t\t// this will be used to calculate the normal\r\n\t\tvar slope = ( radiusBottom - radiusTop ) / height;\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\t\tvar indexRow = [];\r\n\r\n\t\t\tvar v = y / heightSegments;\r\n\r\n\t\t\t// calculate the radius of the current row\r\n\r\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t\tvar u = x / radialSegments;\r\n\r\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\r\n\r\n\t\t\t\tvar sinTheta = Math.sin( theta );\r\n\t\t\t\tvar cosTheta = Math.cos( theta );\r\n\r\n\t\t\t\t// vertex\r\n\r\n\t\t\t\tvertex.x = radius * sinTheta;\r\n\t\t\t\tvertex.y = - v * height + halfHeight;\r\n\t\t\t\tvertex.z = radius * cosTheta;\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t// normal\r\n\r\n\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\r\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t// uv\r\n\r\n\t\t\t\tuvs.push( u, 1 - v );\r\n\r\n\t\t\t\t// save index of vertex in respective row\r\n\r\n\t\t\t\tindexRow.push( index ++ );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// now save vertices of the row in our index array\r\n\r\n\t\t\tindexArray.push( indexRow );\r\n\r\n\t\t}\r\n\r\n\t\t// generate indices\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\t\t\t// we use the index array to access the correct indices\r\n\r\n\t\t\t\tvar a = indexArray[ y ][ x ];\r\n\t\t\t\tvar b = indexArray[ y + 1 ][ x ];\r\n\t\t\t\tvar c = indexArray[ y + 1 ][ x + 1 ];\r\n\t\t\t\tvar d = indexArray[ y ][ x + 1 ];\r\n\r\n\t\t\t\t// faces\r\n\r\n\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\tindices.push( b, c, d );\r\n\r\n\t\t\t\t// update group counter\r\n\r\n\t\t\t\tgroupCount += 6;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// add a group to the geometry. this will ensure multi material support\r\n\r\n\t\tscope.addGroup( groupStart, groupCount, 0 );\r\n\r\n\t\t// calculate new start value for groups\r\n\r\n\t\tgroupStart += groupCount;\r\n\r\n\t}\r\n\r\n\tfunction generateCap( top ) {\r\n\r\n\t\tvar x, centerIndexStart, centerIndexEnd;\r\n\r\n\t\tvar uv = new Vector2();\r\n\t\tvar vertex = new Vector3();\r\n\r\n\t\tvar groupCount = 0;\r\n\r\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\r\n\t\tvar sign = ( top === true ) ? 1 : - 1;\r\n\r\n\t\t// save the index of the first center vertex\r\n\t\tcenterIndexStart = index;\r\n\r\n\t\t// first we generate the center vertex data of the cap.\r\n\t\t// because the geometry needs one set of uvs per face,\r\n\t\t// we must generate a center vertex per face/segment\r\n\r\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t// vertex\r\n\r\n\t\t\tvertices.push( 0, halfHeight * sign, 0 );\r\n\r\n\t\t\t// normal\r\n\r\n\t\t\tnormals.push( 0, sign, 0 );\r\n\r\n\t\t\t// uv\r\n\r\n\t\t\tuvs.push( 0.5, 0.5 );\r\n\r\n\t\t\t// increase index\r\n\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// save the index of the last center vertex\r\n\r\n\t\tcenterIndexEnd = index;\r\n\r\n\t\t// now we generate the surrounding vertices, normals and uvs\r\n\r\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / radialSegments;\r\n\t\t\tvar theta = u * thetaLength + thetaStart;\r\n\r\n\t\t\tvar cosTheta = Math.cos( theta );\r\n\t\t\tvar sinTheta = Math.sin( theta );\r\n\r\n\t\t\t// vertex\r\n\r\n\t\t\tvertex.x = radius * sinTheta;\r\n\t\t\tvertex.y = halfHeight * sign;\r\n\t\t\tvertex.z = radius * cosTheta;\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\r\n\t\t\tnormals.push( 0, sign, 0 );\r\n\r\n\t\t\t// uv\r\n\r\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\r\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// generate indices\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tvar c = centerIndexStart + x;\r\n\t\t\tvar i = centerIndexEnd + x;\r\n\r\n\t\t\tif ( top === true ) {\r\n\r\n\t\t\t\t// face top\r\n\r\n\t\t\t\tindices.push( i, i + 1, c );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// face bottom\r\n\r\n\t\t\t\tindices.push( i + 1, i, c );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgroupCount += 3;\r\n\r\n\t\t}\r\n\r\n\t\t// add a group to the geometry. this will ensure multi material support\r\n\r\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\r\n\r\n\t\t// calculate new start value for groups\r\n\r\n\t\tgroupStart += groupCount;\r\n\r\n\t}\r\n\r\n}\r\n\r\nCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MMDPhysics = ( function () {\r\n\t\r\n\tfunction MMDPhysics( mesh, rigidBodyParams, constraintParams, params ) {\r\n\r\n\t\tif ( typeof Ammo === 'undefined' ) {\r\n\r\n\t\t\tthrow new Error( 'MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js' );\r\n\r\n\t\t}\r\n\r\n\t\tconstraintParams = constraintParams || [];\r\n\t\tparams = params || {};\r\n\r\n\t\tthis.manager = new ResourceManager();\r\n\r\n\t\tthis.mesh = mesh;\r\n\t\t\r\n\t\tthis.unitStep = ( params.unitStep !== undefined ) ? params.unitStep : 1 / 65;\r\n\t\tthis.maxStepNum = ( params.maxStepNum !== undefined ) ? params.maxStepNum : 3;\r\n\t\tthis.gravity = new Vector3( 0, - 9.8 * 10, 0 );\r\n\r\n\t\tif ( params.gravity !== undefined ) { this.gravity.copy( gravity ); }\r\n\r\n\t\tthis.world = params.world !== undefined ? params.world : null; // experimental\r\n\r\n\t\tthis.bodies = [];\r\n\t\tthis.constraints = [];\r\n\r\n\t\tthis._init( mesh, rigidBodyParams, constraintParams );\r\n\r\n\t}\r\n\r\n\tMMDPhysics.prototype = {\r\n\r\n\t\tconstructor: MMDPhysics,\r\n\t\t\r\n\t\tupdate: function ( delta ) {\r\n\r\n\t\t\tvar manager = this.manager;\r\n\t\t\tvar mesh = this.mesh;\r\n\r\n\t\t\t// rigid bodies and constrains are for\r\n\t\t\t// mesh's world scale (1, 1, 1).\r\n\t\t\t// Convert to (1, 1, 1) if it isn't.\r\n\r\n\t\t\tvar isNonDefaultScale = false;\r\n\r\n\t\t\tvar position = manager.allocThreeVector3();\r\n\t\t\tvar quaternion = manager.allocThreeQuaternion();\r\n\t\t\tvar scale = manager.allocThreeVector3();\r\n\r\n\t\t\tmesh.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n\t\t\tif ( scale.x !== 1 || scale.y !== 1 || scale.z !== 1 ) {\r\n\r\n\t\t\t\tisNonDefaultScale = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parent;\r\n\r\n\t\t\tif ( isNonDefaultScale ) {\r\n\r\n\t\t\t\tparent = mesh.parent;\r\n\r\n\t\t\t\tif ( parent !== null ) { mesh.parent = null; }\r\n\r\n\t\t\t\tscale.copy( this.mesh.scale );\r\n\r\n\t\t\t\tmesh.scale.set( 1, 1, 1 );\r\n\t\t\t\tmesh.updateMatrixWorld( true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// calculate physics and update bones\r\n\r\n\t\t\tthis._updateRigidBodies();\r\n\t\t\tthis._stepSimulation( delta );\r\n\t\t\tthis._updateBones();\r\n\r\n\t\t\t// restore mesh if converted above\r\n\r\n\t\t\tif ( isNonDefaultScale ) {\r\n\r\n\t\t\t\tif ( parent !== null ) { parent.parent = parent; }\r\n\r\n\t\t\t\tmesh.scale.copy( scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmanager.freeThreeVector3( scale );\r\n\t\t\tmanager.freeThreeQuaternion( quaternion );\r\n\t\t\tmanager.freeThreeVector3( position );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\treset: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tfor ( var i = 0, il = this.bodies.length; i < il; i++ ) {\r\n\r\n\t\t\t\tthis$1.bodies[ i ].reset();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\twarmup: function ( cycles ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tfor ( var i = 0; i < cycles; i++ ) {\r\n\r\n\t\t\t\tthis$1.update( 1 / 60 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tsetGravity: function ( gravity ) {\r\n\r\n\t\t\tthis.world.setGravity( new Ammo.btVector3( gravity.x, gravity.y, gravity.z ) );\r\n\t\t\tthis.gravity.copy( gravity );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tcreateHelper: function () {\r\n\r\n\t\t\treturn new MMDPhysicsHelper( this.mesh, this );\r\n\r\n\t\t},\r\n\r\n\t\t// private methods\r\n\r\n\t\t_init: function ( mesh, rigidBodyParams, constraintParams ) {\r\n\r\n\t\t\tvar manager = this.manager;\r\n\r\n\t\t\t// rigid body/constraint parameters are for\r\n\t\t\t// mesh's default world transform as position(0, 0, 0),\r\n\t\t\t// quaternion(0, 0, 0, 1) and scale(0, 0, 0)\r\n\r\n\t\t\tvar parent = mesh.parent;\r\n\r\n\t\t\tif ( parent !== null ) { parent = null; }\r\n\r\n\t\t\tvar currentPosition = manager.allocThreeVector3();\r\n\t\t\tvar currentQuaternion = manager.allocThreeQuaternion();\r\n\t\t\tvar currentScale = manager.allocThreeVector3();\r\n\r\n\t\t\tcurrentPosition.copy( mesh.position );\r\n\t\t\tcurrentQuaternion.copy( mesh.quaternion );\r\n\t\t\tcurrentScale.copy( mesh.scale );\r\n\r\n\t\t\tmesh.position.set( 0, 0, 0 );\r\n\t\t\tmesh.quaternion.set( 0, 0, 0, 1 );\r\n\t\t\tmesh.scale.set( 1, 1, 1 );\r\n\r\n\t\t\tmesh.updateMatrixWorld( true );\r\n\r\n\t\t\tif ( this.world === null ) {\r\n\r\n\t\t\t\tthis.world = this._createWorld();\r\n\t\t\t\tthis.setGravity( this.gravity );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._initRigidBodies( rigidBodyParams );\r\n\t\t\tthis._initConstraints( constraintParams );\r\n\r\n\t\t\tif ( parent !== null ) { mesh.parent = parent; }\r\n\r\n\t\t\tmesh.position.copy( currentPosition );\r\n\t\t\tmesh.quaternion.copy( currentQuaternion );\r\n\t\t\tmesh.scale.copy( currentScale );\r\n\r\n\t\t\tmesh.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.reset();\r\n\r\n\t\t\tmanager.freeThreeVector3( currentPosition );\r\n\t\t\tmanager.freeThreeQuaternion( currentQuaternion );\r\n\t\t\tmanager.freeThreeVector3( currentScale );\r\n\r\n\t\t},\r\n\r\n\t\t_createWorld: function () {\r\n\r\n\t\t\tvar config = new Ammo.btDefaultCollisionConfiguration();\r\n\t\t\tvar dispatcher = new Ammo.btCollisionDispatcher( config );\r\n\t\t\tvar cache = new Ammo.btDbvtBroadphase();\r\n\t\t\tvar solver = new Ammo.btSequentialImpulseConstraintSolver();\r\n\t\t\tvar world = new Ammo.btDiscreteDynamicsWorld( dispatcher, cache, solver, config );\r\n\t\t\treturn world;\r\n\r\n\t\t},\r\n\r\n\t\t_initRigidBodies: function ( rigidBodies ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tfor ( var i = 0, il = rigidBodies.length; i < il; i++ ) {\r\n\r\n\t\t\t\tthis$1.bodies.push( new RigidBody(\r\n\t\t\t\t\tthis$1.mesh, this$1.world, rigidBodies[ i ], this$1.manager ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t_initConstraints: function ( constraints ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tfor ( var i = 0, il = constraints.length; i < il; i++ ) {\r\n\r\n\t\t\t\tvar params = constraints[ i ];\r\n\t\t\t\tvar bodyA = this$1.bodies[ params.rigidBodyIndex1 ];\r\n\t\t\t\tvar bodyB = this$1.bodies[ params.rigidBodyIndex2 ];\r\n\t\t\t\tthis$1.constraints.push( new Constraint(\r\n\t\t\t\t\tthis$1.mesh, this$1.world, bodyA, bodyB, params, this$1.manager ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t_stepSimulation: function ( delta ) {\r\n\r\n\t\t\tvar unitStep = this.unitStep;\r\n\t\t\tvar stepTime = delta;\r\n\t\t\tvar maxStepNum = ( ( delta / unitStep ) | 0 ) + 1;\r\n\r\n\t\t\tif ( stepTime < unitStep ) {\r\n\r\n\t\t\t\tstepTime = unitStep;\r\n\t\t\t\tmaxStepNum = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( maxStepNum > this.maxStepNum ) {\r\n\r\n\t\t\t\tmaxStepNum = this.maxStepNum;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.world.stepSimulation( stepTime, maxStepNum, unitStep );\r\n\r\n\t\t},\r\n\r\n\t\t_updateRigidBodies: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tfor ( var i = 0, il = this.bodies.length; i < il; i++ ) {\r\n\r\n\t\t\t\tthis$1.bodies[ i ].updateFromBone();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t_updateBones: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tfor ( var i = 0, il = this.bodies.length; i < il; i++ ) {\r\n\r\n\t\t\t\tthis$1.bodies[ i ].updateBone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n\tfunction ResourceManager() {\r\n\r\n\t\t// for Three.js\r\n\t\tthis.threeVector3s = [];\r\n\t\tthis.threeMatrix4s = [];\r\n\t\tthis.threeQuaternions = [];\r\n\t\tthis.threeEulers = [];\r\n\r\n\t\t// for Ammo.js\r\n\t\tthis.transforms = [];\r\n\t\tthis.quaternions = [];\r\n\t\tthis.vector3s = [];\r\n\r\n\t}\r\n\r\n\tResourceManager.prototype = {\r\n\r\n\t\tconstructor: ResourceManager,\r\n\r\n\t\tallocThreeVector3: function () {\r\n\r\n\t\t\treturn ( this.threeVector3s.length > 0 )\r\n\t\t\t\t? this.threeVector3s.pop()\r\n\t\t\t\t: new Vector3();\r\n\r\n\t\t},\r\n\r\n\t\tfreeThreeVector3: function ( v ) {\r\n\r\n\t\t\tthis.threeVector3s.push( v );\r\n\r\n\t\t},\r\n\r\n\t\tallocThreeMatrix4: function () {\r\n\r\n\t\t\treturn ( this.threeMatrix4s.length > 0 )\r\n\t\t\t\t? this.threeMatrix4s.pop()\r\n\t\t\t\t: new Matrix4();\r\n\r\n\t\t},\r\n\r\n\t\tfreeThreeMatrix4: function ( m ) {\r\n\r\n\t\t\tthis.threeMatrix4s.push( m );\r\n\r\n\t\t},\r\n\r\n\t\tallocThreeQuaternion: function () {\r\n\r\n\t\t\treturn ( this.threeQuaternions.length > 0 )\r\n\t\t\t\t? this.threeQuaternions.pop()\r\n\t\t\t\t: new Quaternion();\r\n\r\n\t\t},\r\n\r\n\t\tfreeThreeQuaternion: function ( q ) {\r\n\r\n\t\t\tthis.threeQuaternions.push( q );\r\n\r\n\t\t},\r\n\r\n\t\tallocThreeEuler: function () {\r\n\r\n\t\t\treturn ( this.threeEulers.length > 0 )\r\n\t\t\t\t? this.threeEulers.pop()\r\n\t\t\t\t: new Euler();\r\n\r\n\t\t},\r\n\r\n\t\tfreeThreeEuler: function ( e ) {\r\n\r\n\t\t\tthis.threeEulers.push( e );\r\n\r\n\t\t},\r\n\r\n\t\tallocTransform: function () {\r\n\r\n\t\t\treturn ( this.transforms.length > 0 )\r\n\t\t\t\t? this.transforms.pop()\r\n\t\t\t\t: new Ammo.btTransform();\r\n\r\n\t\t},\r\n\r\n\t\tfreeTransform: function ( t ) {\r\n\r\n\t\t\tthis.transforms.push( t );\r\n\r\n\t\t},\r\n\r\n\t\tallocQuaternion: function () {\r\n\r\n\t\t\treturn ( this.quaternions.length > 0 )\r\n\t\t\t\t? this.quaternions.pop()\r\n\t\t\t\t: new Ammo.btQuaternion();\r\n\r\n\t\t},\r\n\r\n\t\tfreeQuaternion: function ( q ) {\r\n\r\n\t\t\tthis.quaternions.push( q );\r\n\r\n\t\t},\r\n\r\n\t\tallocVector3: function () {\r\n\r\n\t\t\treturn ( this.vector3s.length > 0 )\r\n\t\t\t\t? this.vector3s.pop()\r\n\t\t\t\t: new Ammo.btVector3();\r\n\r\n\t\t},\r\n\r\n\t\tfreeVector3: function ( v ) {\r\n\r\n\t\t\tthis.vector3s.push( v );\r\n\r\n\t\t},\r\n\r\n\t\tsetIdentity: function ( t ) {\r\n\r\n\t\t\tt.setIdentity();\r\n\r\n\t\t},\r\n\r\n\t\tgetBasis: function ( t ) {\r\n\r\n\t\t\tvar q = this.allocQuaternion();\r\n\t\t\tt.getBasis().getRotation( q );\r\n\t\t\treturn q;\r\n\r\n\t\t},\r\n\r\n\t\tgetBasisAsMatrix3: function ( t ) {\r\n\r\n\t\t\tvar q = this.getBasis( t );\r\n\t\t\tvar m = this.quaternionToMatrix3( q );\r\n\t\t\tthis.freeQuaternion( q );\r\n\t\t\treturn m;\r\n\r\n\t\t},\r\n\r\n\t\tgetOrigin: function( t ) {\r\n\r\n\t\t\treturn t.getOrigin();\r\n\r\n\t\t},\r\n\r\n\t\tsetOrigin: function( t, v ) {\r\n\r\n\t\t\tt.getOrigin().setValue( v.x(), v.y(), v.z() );\r\n\r\n\t\t},\r\n\r\n\t\tcopyOrigin: function( t1, t2 ) {\r\n\r\n\t\t\tvar o = t2.getOrigin();\r\n\t\t\tthis.setOrigin( t1, o );\r\n\r\n\t\t},\r\n\r\n\t\tsetBasis: function( t, q ) {\r\n\r\n\t\t\tt.setRotation( q );\r\n\r\n\t\t},\r\n\r\n\t\tsetBasisFromMatrix3: function( t, m ) {\r\n\r\n\t\t\tvar q = this.matrix3ToQuaternion( m );\r\n\t\t\tthis.setBasis( t, q );\r\n\t\t\tthis.freeQuaternion( q );\r\n\r\n\t\t},\r\n\r\n\t\tsetOriginFromArray3: function ( t, a ) {\r\n\r\n\t\t\tt.getOrigin().setValue( a[ 0 ], a[ 1 ], a[ 2 ] );\r\n\r\n\t\t},\r\n\r\n\t\tsetOriginFromThreeVector3: function ( t, v ) {\r\n\r\n\t\t\tt.getOrigin().setValue( v.x, v.y, v.z );\r\n\r\n\t\t},\r\n\r\n\t\tsetBasisFromArray3: function ( t, a ) {\r\n\r\n\t\t\tvar thQ = this.allocThreeQuaternion();\r\n\t\t\tvar thE = this.allocThreeEuler();\r\n\t\t\tthE.set( a[ 0 ], a[ 1 ], a[ 2 ] );\r\n\t\t\tthis.setBasisFromThreeQuaternion( t, thQ.setFromEuler( thE ) );\r\n\r\n\t\t\tthis.freeThreeEuler( thE );\r\n\t\t\tthis.freeThreeQuaternion( thQ );\r\n\r\n\t\t},\r\n\r\n\t\tsetBasisFromThreeQuaternion: function ( t, a ) {\r\n\r\n\t\t\tvar q = this.allocQuaternion();\r\n\r\n\t\t\tq.setX( a.x );\r\n\t\t\tq.setY( a.y );\r\n\t\t\tq.setZ( a.z );\r\n\t\t\tq.setW( a.w );\r\n\t\t\tthis.setBasis( t, q );\r\n\r\n\t\t\tthis.freeQuaternion( q );\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyTransforms: function ( t1, t2 ) {\r\n\r\n\t\t\tvar t = this.allocTransform();\r\n\t\t\tthis.setIdentity( t );\r\n\r\n\t\t\tvar m1 = this.getBasisAsMatrix3( t1 );\r\n\t\t\tvar m2 = this.getBasisAsMatrix3( t2 );\r\n\r\n\t\t\tvar o1 = this.getOrigin( t1 );\r\n\t\t\tvar o2 = this.getOrigin( t2 );\r\n\r\n\t\t\tvar v1 = this.multiplyMatrix3ByVector3( m1, o2 );\r\n\t\t\tvar v2 = this.addVector3( v1, o1 );\r\n\t\t\tthis.setOrigin( t, v2 );\r\n\r\n\t\t\tvar m3 = this.multiplyMatrices3( m1, m2 );\r\n\t\t\tthis.setBasisFromMatrix3( t, m3 );\r\n\r\n\t\t\tthis.freeVector3( v1 );\r\n\t\t\tthis.freeVector3( v2 );\r\n\r\n\t\t\treturn t;\r\n\r\n\t\t},\r\n\r\n\t\tinverseTransform: function ( t ) {\r\n\r\n\t\t\tvar t2 = this.allocTransform();\r\n\r\n\t\t\tvar m1 = this.getBasisAsMatrix3( t );\r\n\t\t\tvar o = this.getOrigin( t );\r\n\r\n\t\t\tvar m2 = this.transposeMatrix3( m1 );\r\n\t\t\tvar v1 = this.negativeVector3( o );\r\n\t\t\tvar v2 = this.multiplyMatrix3ByVector3( m2, v1 );\r\n\r\n\t\t\tthis.setOrigin( t2, v2 );\r\n\t\t\tthis.setBasisFromMatrix3( t2, m2 );\r\n\r\n\t\t\tthis.freeVector3( v1 );\r\n\t\t\tthis.freeVector3( v2 );\r\n\r\n\t\t\treturn t2;\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyMatrices3: function ( m1, m2 ) {\r\n\r\n\t\t\tvar m3 = [];\r\n\r\n\t\t\tvar v10 = this.rowOfMatrix3( m1, 0 );\r\n\t\t\tvar v11 = this.rowOfMatrix3( m1, 1 );\r\n\t\t\tvar v12 = this.rowOfMatrix3( m1, 2 );\r\n\r\n\t\t\tvar v20 = this.columnOfMatrix3( m2, 0 );\r\n\t\t\tvar v21 = this.columnOfMatrix3( m2, 1 );\r\n\t\t\tvar v22 = this.columnOfMatrix3( m2, 2 );\r\n\r\n\t\t\tm3[ 0 ] = this.dotVectors3( v10, v20 );\r\n\t\t\tm3[ 1 ] = this.dotVectors3( v10, v21 );\r\n\t\t\tm3[ 2 ] = this.dotVectors3( v10, v22 );\r\n\t\t\tm3[ 3 ] = this.dotVectors3( v11, v20 );\r\n\t\t\tm3[ 4 ] = this.dotVectors3( v11, v21 );\r\n\t\t\tm3[ 5 ] = this.dotVectors3( v11, v22 );\r\n\t\t\tm3[ 6 ] = this.dotVectors3( v12, v20 );\r\n\t\t\tm3[ 7 ] = this.dotVectors3( v12, v21 );\r\n\t\t\tm3[ 8 ] = this.dotVectors3( v12, v22 );\r\n\r\n\t\t\tthis.freeVector3( v10 );\r\n\t\t\tthis.freeVector3( v11 );\r\n\t\t\tthis.freeVector3( v12 );\r\n\t\t\tthis.freeVector3( v20 );\r\n\t\t\tthis.freeVector3( v21 );\r\n\t\t\tthis.freeVector3( v22 );\r\n\r\n\t\t\treturn m3;\r\n\r\n\t\t},\r\n\r\n\t\taddVector3: function( v1, v2 ) {\r\n\r\n\t\t\tvar v = this.allocVector3();\r\n\t\t\tv.setValue( v1.x() + v2.x(), v1.y() + v2.y(), v1.z() + v2.z() );\r\n\t\t\treturn v;\r\n\r\n\t\t},\r\n\r\n\t\tdotVectors3: function( v1, v2 ) {\r\n\r\n\t\t\treturn v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z();\r\n\r\n\t\t},\r\n\r\n\t\trowOfMatrix3: function( m, i ) {\r\n\r\n\t\t\tvar v = this.allocVector3();\r\n\t\t\tv.setValue( m[ i * 3 + 0 ], m[ i * 3 + 1 ], m[ i * 3 + 2 ] );\r\n\t\t\treturn v;\r\n\r\n\t\t},\r\n\r\n\t\tcolumnOfMatrix3: function( m, i ) {\r\n\r\n\t\t\tvar v = this.allocVector3();\r\n\t\t\tv.setValue( m[ i + 0 ], m[ i + 3 ], m[ i + 6 ] );\r\n\t\t\treturn v;\r\n\r\n\t\t},\r\n\r\n\t\tnegativeVector3: function( v ) {\r\n\r\n\t\t\tvar v2 = this.allocVector3();\r\n\t\t\tv2.setValue( -v.x(), -v.y(), -v.z() );\r\n\t\t\treturn v2;\r\n\r\n\t\t},\r\n\r\n\t\tmultiplyMatrix3ByVector3: function ( m, v ) {\r\n\r\n\t\t\tvar v4 = this.allocVector3();\r\n\r\n\t\t\tvar v0 = this.rowOfMatrix3( m, 0 );\r\n\t\t\tvar v1 = this.rowOfMatrix3( m, 1 );\r\n\t\t\tvar v2 = this.rowOfMatrix3( m, 2 );\r\n\t\t\tvar x = this.dotVectors3( v0, v );\r\n\t\t\tvar y = this.dotVectors3( v1, v );\r\n\t\t\tvar z = this.dotVectors3( v2, v );\r\n\r\n\t\t\tv4.setValue( x, y, z );\r\n\r\n\t\t\tthis.freeVector3( v0 );\r\n\t\t\tthis.freeVector3( v1 );\r\n\t\t\tthis.freeVector3( v2 );\r\n\r\n\t\t\treturn v4;\r\n\r\n\t\t},\r\n\r\n\t\ttransposeMatrix3: function( m ) {\r\n\r\n\t\t\tvar m2 = [];\r\n\t\t\tm2[ 0 ] = m[ 0 ];\r\n\t\t\tm2[ 1 ] = m[ 3 ];\r\n\t\t\tm2[ 2 ] = m[ 6 ];\r\n\t\t\tm2[ 3 ] = m[ 1 ];\r\n\t\t\tm2[ 4 ] = m[ 4 ];\r\n\t\t\tm2[ 5 ] = m[ 7 ];\r\n\t\t\tm2[ 6 ] = m[ 2 ];\r\n\t\t\tm2[ 7 ] = m[ 5 ];\r\n\t\t\tm2[ 8 ] = m[ 8 ];\r\n\t\t\treturn m2;\r\n\r\n\t\t},\r\n\r\n\t\tquaternionToMatrix3: function ( q ) {\r\n\r\n\t\t\tvar m = [];\r\n\r\n\t\t\tvar x = q.x();\r\n\t\t\tvar y = q.y();\r\n\t\t\tvar z = q.z();\r\n\t\t\tvar w = q.w();\r\n\r\n\t\t\tvar xx = x * x;\r\n\t\t\tvar yy = y * y;\r\n\t\t\tvar zz = z * z;\r\n\r\n\t\t\tvar xy = x * y;\r\n\t\t\tvar yz = y * z;\r\n\t\t\tvar zx = z * x;\r\n\r\n\t\t\tvar xw = x * w;\r\n\t\t\tvar yw = y * w;\r\n\t\t\tvar zw = z * w;\r\n\r\n\t\t\tm[ 0 ] = 1 - 2 * ( yy + zz );\r\n\t\t\tm[ 1 ] = 2 * ( xy - zw );\r\n\t\t\tm[ 2 ] = 2 * ( zx + yw );\r\n\t\t\tm[ 3 ] = 2 * ( xy + zw );\r\n\t\t\tm[ 4 ] = 1 - 2 * ( zz + xx );\r\n\t\t\tm[ 5 ] = 2 * ( yz - xw );\r\n\t\t\tm[ 6 ] = 2 * ( zx - yw );\r\n\t\t\tm[ 7 ] = 2 * ( yz + xw );\r\n\t\t\tm[ 8 ] = 1 - 2 * ( xx + yy );\r\n\r\n\t\t\treturn m;\r\n\r\n\t\t},\r\n\r\n\t\tmatrix3ToQuaternion: function( m ) {\r\n\r\n\t\t\tvar t = m[ 0 ] + m[ 4 ] + m[ 8 ];\r\n\t\t\tvar s, x, y, z, w;\r\n\r\n\t\t\tif( t > 0 ) {\r\n\r\n\t\t\t\ts = Math.sqrt( t + 1.0 ) * 2;\r\n\t\t\t\tw = 0.25 * s;\r\n\t\t\t\tx = ( m[ 7 ] - m[ 5 ] ) / s;\r\n\t\t\t\ty = ( m[ 2 ] - m[ 6 ] ) / s;\r\n\t\t\t\tz = ( m[ 3 ] - m[ 1 ] ) / s;\r\n\r\n\t\t\t} else if( ( m[ 0 ] > m[ 4 ] ) && ( m[ 0 ] > m[ 8 ] ) ) {\r\n\r\n\t\t\t\ts = Math.sqrt( 1.0 + m[ 0 ] - m[ 4 ] - m[ 8 ] ) * 2;\r\n\t\t\t\tw = ( m[ 7 ] - m[ 5 ] ) / s;\r\n\t\t\t\tx = 0.25 * s;\r\n\t\t\t\ty = ( m[ 1 ] + m[ 3 ] ) / s;\r\n\t\t\t\tz = ( m[ 2 ] + m[ 6 ] ) / s;\r\n\r\n\t\t\t} else if( m[ 4 ] > m[ 8 ] ) {\r\n\r\n\t\t\t\ts = Math.sqrt( 1.0 + m[ 4 ] - m[ 0 ] - m[ 8 ] ) * 2;\r\n\t\t\t\tw = ( m[ 2 ] - m[ 6 ] ) / s;\r\n\t\t\t\tx = ( m[ 1 ] + m[ 3 ] ) / s;\r\n\t\t\t\ty = 0.25 * s;\r\n\t\t\t\tz = ( m[ 5 ] + m[ 7 ] ) / s;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ts = Math.sqrt( 1.0 + m[ 8 ] - m[ 0 ] - m[ 4 ] ) * 2;\r\n\t\t\t\tw = ( m[ 3 ] - m[ 1 ] ) / s;\r\n\t\t\t\tx = ( m[ 2 ] + m[ 6 ] ) / s;\r\n\t\t\t\ty = ( m[ 5 ] + m[ 7 ] ) / s;\r\n\t\t\t\tz = 0.25 * s;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar q = this.allocQuaternion();\r\n\t\t\tq.setX( x );\r\n\t\t\tq.setY( y );\r\n\t\t\tq.setZ( z );\r\n\t\t\tq.setW( w );\r\n\t\t\treturn q;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n\tfunction RigidBody( mesh, world, params, manager ) {\r\n\r\n\t\tthis.mesh  = mesh;\r\n\t\tthis.world = world;\r\n\t\tthis.params = params;\r\n\t\tthis.manager = manager;\r\n\r\n\t\tthis.body = null;\r\n\t\tthis.bone = null;\r\n\t\tthis.boneOffsetForm = null;\r\n\t\tthis.boneOffsetFormInverse = null;\r\n\r\n\t\tthis._init();\r\n\r\n\t}\r\n\r\n\tRigidBody.prototype = {\r\n\r\n\t\tconstructor: MMDPhysics.RigidBody,\r\n\t\t\r\n\t\treset: function () {\r\n\r\n\t\t\tthis._setTransformFromBone();\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tupdateFromBone: function () {\r\n\r\n\t\t\tif ( this.params.boneIndex !== - 1 &&\r\n\t\t\t\tthis.params.type === 0 ) {\r\n\r\n\t\t\t\tthis._setTransformFromBone();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tupdateBone: function () {\r\n\r\n\t\t\tif ( this.params.type === 0 ||\r\n\t\t\t\tthis.params.boneIndex === - 1 ) {\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._updateBoneRotation();\r\n\r\n\t\t\tif ( this.params.type === 1 ) {\r\n\r\n\t\t\t\tthis._updateBonePosition();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.bone.updateMatrixWorld( true );\r\n\r\n\t\t\tif ( this.params.type === 2 ) {\r\n\r\n\t\t\t\tthis._setPositionFromBone();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// private methods\r\n\r\n\t\t_init: function () {\r\n\r\n\t\t\tfunction generateShape( p ) {\r\n\r\n\t\t\t\tswitch( p.shapeType ) {\r\n\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\treturn new Ammo.btSphereShape( p.width );\r\n\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\treturn new Ammo.btBoxShape( new Ammo.btVector3( p.width, p.height, p.depth ) );\r\n\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\treturn new Ammo.btCapsuleShape( p.width, p.height );\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow 'unknown shape type ' + p.shapeType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar manager = this.manager;\r\n\t\t\tvar params = this.params;\r\n\t\t\tvar bones = this.mesh.skeleton.bones;\r\n\t\t\tvar bone = ( params.boneIndex === - 1 )\r\n\t\t\t\t? new Bone()\r\n\t\t\t\t: bones[ params.boneIndex ];\r\n\r\n\t\t\tvar shape = generateShape( params );\r\n\t\t\tvar weight = ( params.type === 0 ) ? 0 : params.weight;\r\n\t\t\tvar localInertia = manager.allocVector3();\r\n\t\t\tlocalInertia.setValue( 0, 0, 0 );\r\n\r\n\t\t\tif( weight !== 0 ) {\r\n\r\n\t\t\t\tshape.calculateLocalInertia( weight, localInertia );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar boneOffsetForm = manager.allocTransform();\r\n\t\t\tmanager.setIdentity( boneOffsetForm );\r\n\t\t\tmanager.setOriginFromArray3( boneOffsetForm, params.position );\r\n\t\t\tmanager.setBasisFromArray3( boneOffsetForm, params.rotation );\r\n\r\n\t\t\tvar vector = manager.allocThreeVector3();\r\n\t\t\tvar boneForm = manager.allocTransform();\r\n\t\t\tmanager.setIdentity( boneForm );\r\n\t\t\tmanager.setOriginFromThreeVector3( boneForm, bone.getWorldPosition( vector ) );\r\n\r\n\t\t\tvar form = manager.multiplyTransforms( boneForm, boneOffsetForm );\r\n\t\t\tvar state = new Ammo.btDefaultMotionState( form );\r\n\r\n\t\t\tvar info = new Ammo.btRigidBodyConstructionInfo( weight, state, shape, localInertia );\r\n\t\t\tinfo.set_m_friction( params.friction );\r\n\t\t\tinfo.set_m_restitution( params.restitution );\r\n\r\n\t\t\tvar body = new Ammo.btRigidBody( info );\r\n\r\n\t\t\tif ( params.type === 0 ) {\r\n\r\n\t\t\t\tbody.setCollisionFlags( body.getCollisionFlags() | 2 );\r\n\t\t\t\t\r\n\t\t\t\tbody.setActivationState( 4 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbody.setDamping( params.positionDamping, params.rotationDamping );\r\n\t\t\tbody.setSleepingThresholds( 0, 0 );\r\n\r\n\t\t\tthis.world.addRigidBody( body, 1 << params.groupIndex, params.groupTarget );\r\n\r\n\t\t\tthis.body = body;\r\n\t\t\tthis.bone = bone;\r\n\t\t\tthis.boneOffsetForm = boneOffsetForm;\r\n\t\t\tthis.boneOffsetFormInverse = manager.inverseTransform( boneOffsetForm );\r\n\r\n\t\t\tmanager.freeVector3( localInertia );\r\n\t\t\tmanager.freeTransform( form );\r\n\t\t\tmanager.freeTransform( boneForm );\r\n\t\t\tmanager.freeThreeVector3( vector );\r\n\r\n\t\t},\r\n\r\n\t\t_getBoneTransform: function () {\r\n\r\n\t\t\tvar manager = this.manager;\r\n\t\t\tvar p = manager.allocThreeVector3();\r\n\t\t\tvar q = manager.allocThreeQuaternion();\r\n\t\t\tvar s = manager.allocThreeVector3();\r\n\r\n\t\t\tthis.bone.matrixWorld.decompose( p, q, s );\r\n\r\n\t\t\tvar tr = manager.allocTransform();\r\n\t\t\tmanager.setOriginFromThreeVector3( tr, p );\r\n\t\t\tmanager.setBasisFromThreeQuaternion( tr, q );\r\n\r\n\t\t\tvar form = manager.multiplyTransforms( tr, this.boneOffsetForm );\r\n\r\n\t\t\tmanager.freeTransform( tr );\r\n\t\t\tmanager.freeThreeVector3( s );\r\n\t\t\tmanager.freeThreeQuaternion( q );\r\n\t\t\tmanager.freeThreeVector3( p );\r\n\r\n\t\t\treturn form;\r\n\r\n\t\t},\r\n\r\n\t\t_getWorldTransformForBone: function () {\r\n\r\n\t\t\tvar manager = this.manager;\r\n\r\n\t\t\tvar tr = manager.allocTransform();\r\n\t\t\tthis.body.getMotionState().getWorldTransform( tr );\r\n\t\t\tvar tr2 = manager.multiplyTransforms( tr, this.boneOffsetFormInverse );\r\n\r\n\t\t\tmanager.freeTransform( tr );\r\n\r\n\t\t\treturn tr2;\r\n\r\n\t\t},\r\n\r\n\t\t_setTransformFromBone: function () {\r\n\r\n\t\t\tvar manager = this.manager;\r\n\t\t\tvar form = this._getBoneTransform();\r\n\r\n\t\t\t// TODO: check the most appropriate way to set\r\n\t\t\t//this.body.setWorldTransform( form );\r\n\t\t\tthis.body.setCenterOfMassTransform( form );\r\n\t\t\tthis.body.getMotionState().setWorldTransform( form );\r\n\r\n\t\t\tmanager.freeTransform( form );\r\n\r\n\t\t},\r\n\r\n\t\t_setPositionFromBone: function () {\r\n\r\n\t\t\tvar manager = this.manager;\r\n\t\t\tvar form = this._getBoneTransform();\r\n\r\n\t\t\tvar tr = manager.allocTransform();\r\n\t\t\tthis.body.getMotionState().getWorldTransform( tr );\r\n\t\t\tmanager.copyOrigin( tr, form );\r\n\r\n\t\t\t// TODO: check the most appropriate way to set\r\n\t\t\t//this.body.setWorldTransform( tr );\r\n\t\t\tthis.body.setCenterOfMassTransform( tr );\r\n\t\t\tthis.body.getMotionState().setWorldTransform( tr );\r\n\r\n\t\t\tmanager.freeTransform( tr );\r\n\t\t\tmanager.freeTransform( form );\r\n\r\n\t\t},\r\n\r\n\t\t_updateBoneRotation: function () {\r\n\r\n\t\t\tvar manager = this.manager;\r\n\r\n\t\t\tvar tr = this._getWorldTransformForBone();\r\n\t\t\tvar q = manager.getBasis( tr );\r\n\r\n\t\t\tvar thQ = manager.allocThreeQuaternion();\r\n\t\t\tvar thQ2 = manager.allocThreeQuaternion();\r\n\t\t\tvar thQ3 = manager.allocThreeQuaternion();\r\n\r\n\t\t\tthQ.set( q.x(), q.y(), q.z(), q.w() );\r\n\t\t\tthQ2.setFromRotationMatrix( this.bone.matrixWorld );\r\n\t\t\tthQ2.conjugate();\r\n\t\t\tthQ2.multiply( thQ );\r\n\r\n\t\t\t//this.bone.quaternion.multiply( thQ2 );\r\n\r\n\t\t\tthQ3.setFromRotationMatrix( this.bone.matrix );\r\n\t\t\tthis.bone.quaternion.copy( thQ2.multiply( thQ3 ) );\r\n\r\n\t\t\tmanager.freeThreeQuaternion( thQ );\r\n\t\t\tmanager.freeThreeQuaternion( thQ2 );\r\n\t\t\tmanager.freeThreeQuaternion( thQ3 );\r\n\r\n\t\t\tmanager.freeQuaternion( q );\r\n\t\t\tmanager.freeTransform( tr );\r\n\r\n\t\t},\r\n\r\n\t\t_updateBonePosition: function () {\r\n\r\n\t\t\tvar manager = this.manager;\r\n\r\n\t\t\tvar tr = this._getWorldTransformForBone();\r\n\r\n\t\t\tvar thV = manager.allocThreeVector3();\r\n\r\n\t\t\tvar o = manager.getOrigin( tr );\r\n\t\t\tthV.set( o.x(), o.y(), o.z() );\r\n\r\n\t\t\tvar v = this.bone.worldToLocal( thV );\r\n\t\t\tthis.bone.position.add( v );\r\n\r\n\t\t\tmanager.freeThreeVector3( thV );\r\n\r\n\t\t\tmanager.freeTransform( tr );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n\tfunction Constraint( mesh, world, bodyA, bodyB, params, manager ) {\r\n\r\n\t\tthis.mesh  = mesh;\r\n\t\tthis.world = world;\r\n\t\tthis.bodyA = bodyA;\r\n\t\tthis.bodyB = bodyB;\r\n\t\tthis.params = params;\r\n\t\tthis.manager = manager;\r\n\r\n\t\tthis.constraint = null;\r\n\r\n\t\tthis._init();\r\n\r\n\t}\r\n\r\n\tConstraint.prototype = {\r\n\r\n\t\tconstructor: Constraint,\r\n\r\n\t\t// private method\r\n\r\n\t\t_init: function () {\r\n\r\n\t\t\tvar manager = this.manager;\r\n\t\t\tvar params = this.params;\r\n\t\t\tvar bodyA = this.bodyA;\r\n\t\t\tvar bodyB = this.bodyB;\r\n\r\n\t\t\tvar form = manager.allocTransform();\r\n\t\t\tmanager.setIdentity( form );\r\n\t\t\tmanager.setOriginFromArray3( form, params.position );\r\n\t\t\tmanager.setBasisFromArray3( form, params.rotation );\r\n\r\n\t\t\tvar formA = manager.allocTransform();\r\n\t\t\tvar formB = manager.allocTransform();\r\n\r\n\t\t\tbodyA.body.getMotionState().getWorldTransform( formA );\r\n\t\t\tbodyB.body.getMotionState().getWorldTransform( formB );\r\n\r\n\t\t\tvar formInverseA = manager.inverseTransform( formA );\r\n\t\t\tvar formInverseB = manager.inverseTransform( formB );\r\n\r\n\t\t\tvar formA2 = manager.multiplyTransforms( formInverseA, form );\r\n\t\t\tvar formB2 = manager.multiplyTransforms( formInverseB, form );\r\n\r\n\t\t\tvar constraint = new Ammo.btGeneric6DofSpringConstraint( bodyA.body, bodyB.body, formA2, formB2, true );\r\n\r\n\t\t\tvar lll = manager.allocVector3();\r\n\t\t\tvar lul = manager.allocVector3();\r\n\t\t\tvar all = manager.allocVector3();\r\n\t\t\tvar aul = manager.allocVector3();\r\n\r\n\t\t\tlll.setValue( params.translationLimitation1[ 0 ],\r\n\t\t\t              params.translationLimitation1[ 1 ],\r\n\t\t\t              params.translationLimitation1[ 2 ] );\r\n\t\t\tlul.setValue( params.translationLimitation2[ 0 ],\r\n\t\t\t              params.translationLimitation2[ 1 ],\r\n\t\t\t              params.translationLimitation2[ 2 ] );\r\n\t\t\tall.setValue( params.rotationLimitation1[ 0 ],\r\n\t\t\t              params.rotationLimitation1[ 1 ],\r\n\t\t\t              params.rotationLimitation1[ 2 ] );\r\n\t\t\taul.setValue( params.rotationLimitation2[ 0 ],\r\n\t\t\t              params.rotationLimitation2[ 1 ],\r\n\t\t\t              params.rotationLimitation2[ 2 ] );\r\n\r\n\t\t\tconstraint.setLinearLowerLimit( lll );\r\n\t\t\tconstraint.setLinearUpperLimit( lul );\r\n\t\t\tconstraint.setAngularLowerLimit( all );\r\n\t\t\tconstraint.setAngularUpperLimit( aul );\r\n\r\n\t\t\tfor ( var i = 0; i < 3; i++ ) {\r\n\r\n\t\t\t\tif( params.springPosition[ i ] !== 0 ) {\r\n\r\n\t\t\t\t\tconstraint.enableSpring( i, true );\r\n\t\t\t\t\tconstraint.setStiffness( i, params.springPosition[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < 3; i++ ) {\r\n\r\n\t\t\t\tif( params.springRotation[ i ] !== 0 ) {\r\n\r\n\t\t\t\t\tconstraint.enableSpring( i + 3, true );\r\n\t\t\t\t\tconstraint.setStiffness( i + 3, params.springRotation[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( constraint.setParam !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\t// this parameter is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\r\n\t\t\t\t\tconstraint.setParam( 2, 0.475, i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.world.addConstraint( constraint, true );\r\n\t\t\tthis.constraint = constraint;\r\n\r\n\t\t\tmanager.freeTransform( form );\r\n\t\t\tmanager.freeTransform( formA );\r\n\t\t\tmanager.freeTransform( formB );\r\n\t\t\tmanager.freeTransform( formInverseA );\r\n\t\t\tmanager.freeTransform( formInverseB );\r\n\t\t\tmanager.freeTransform( formA2 );\r\n\t\t\tmanager.freeTransform( formB2 );\r\n\t\t\tmanager.freeVector3( lll );\r\n\t\t\tmanager.freeVector3( lul );\r\n\t\t\tmanager.freeVector3( all );\r\n\t\t\tmanager.freeVector3( aul );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n\tfunction MMDPhysicsHelper( mesh, physics ) {\r\n\r\n\t\tObject3D.call( this );\r\n\r\n\t\tthis.root = mesh;\r\n\t\tthis.physics = physics;\r\n\r\n\t\tthis.matrix.copy( mesh.matrixWorld );\r\n\t\tthis.matrixAutoUpdate = false;\r\n\r\n\t\tthis.materials = [];\r\n\r\n\t\tthis.materials.push(\r\n\t\t\tnew MeshBasicMaterial( {\r\n\t\t\t\tcolor: new Color( 0xff8888 ),\r\n\t\t\t\twireframe: true,\r\n\t\t\t\tdepthTest: false,\r\n\t\t\t\tdepthWrite: false,\r\n\t\t\t\topacity: 0.25,\r\n\t\t\t\ttransparent: true\r\n\t\t\t} )\r\n\t\t);\r\n\r\n\t\tthis.materials.push(\r\n\t\t\tnew MeshBasicMaterial( {\r\n\t\t\t\tcolor: new Color( 0x88ff88 ),\r\n\t\t\t\twireframe: true,\r\n\t\t\t\tdepthTest: false,\r\n\t\t\t\tdepthWrite: false,\r\n\t\t\t\topacity: 0.25,\r\n\t\t\t\ttransparent: true\r\n\t\t\t} )\r\n\t\t);\r\n\r\n\t\tthis.materials.push(\r\n\t\t\tnew MeshBasicMaterial( {\r\n\t\t\t\tcolor: new Color( 0x8888ff ),\r\n\t\t\t\twireframe: true,\r\n\t\t\t\tdepthTest: false,\r\n\t\t\t\tdepthWrite: false,\r\n\t\t\t\topacity: 0.25,\r\n\t\t\t\ttransparent: true\r\n\t\t\t} )\r\n\t\t);\r\n\r\n\t\tthis._init();\r\n\r\n\t}\r\n\r\n\tMMDPhysicsHelper.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\t\tconstructor: MMDPhysicsHelper,\r\n\t\t\r\n\t\tupdateMatrixWorld: function () {\r\n\r\n\t\t\tvar position = new Vector3();\r\n\t\t\tvar quaternion = new Quaternion();\r\n\t\t\tvar scale = new Vector3();\r\n\t\t\tvar matrixWorldInv = new Matrix4();\r\n\r\n\t\t\treturn function updateMatrixWorld( force ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tvar mesh = this.root;\r\n\r\n\t\t\t\tif ( this.visible ) {\r\n\r\n\t\t\t\t\tvar bodies = this.physics.bodies;\r\n\r\n\t\t\t\t\tmatrixWorldInv\r\n\t\t\t\t\t\t.copy( mesh.matrixWorld )\r\n\t\t\t\t\t\t.decompose( position, quaternion, scale )\r\n\t\t\t\t\t\t.compose( position, quaternion, scale.set( 1, 1, 1 ) )\r\n\t\t\t\t\t\t.getInverse( matrixWorldInv );\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = bodies.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar body = bodies[ i ].body;\r\n\t\t\t\t\t\tvar child = this$1.children[ i ];\r\n\r\n\t\t\t\t\t\tvar tr = body.getCenterOfMassTransform();\r\n\t\t\t\t\t\tvar origin = tr.getOrigin();\r\n\t\t\t\t\t\tvar rotation = tr.getRotation();\r\n\r\n\t\t\t\t\t\tchild.position\r\n\t\t\t\t\t\t\t.set( origin.x(), origin.y(), origin.z() )\r\n\t\t\t\t\t\t\t.applyMatrix4( matrixWorldInv );\r\n\r\n\t\t\t\t\t\tchild.quaternion\r\n\t\t\t\t\t\t\t.setFromRotationMatrix( matrixWorldInv )\r\n\t\t\t\t\t\t\t.multiply(\r\n\t\t\t\t\t\t\t\tquaternion.set(\r\n\t\t\t\t\t\t\t\t\trotation.x(), rotation.y(), rotation.z(), rotation.w() )\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.matrix\r\n\t\t\t\t\t.copy( mesh.matrixWorld )\r\n\t\t\t\t\t.decompose( position, quaternion, scale )\r\n\t\t\t\t\t.compose( position, quaternion, scale.set( 1, 1, 1 ) );\r\n\r\n\t\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\t\t};\r\n\r\n\t\t}(),\r\n\r\n\t\t// private method\r\n\r\n\t\t_init: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar bodies = this.physics.bodies;\r\n\r\n\t\t\tfunction createGeometry( param ) {\r\n\r\n\t\t\t\tswitch ( param.shapeType ) {\r\n\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\treturn new SphereBufferGeometry( param.width, 16, 8 );\r\n\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\treturn new BoxBufferGeometry( param.width * 2, param.height * 2, param.depth * 2, 8, 8, 8 );\r\n\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\treturn new createCapsuleGeometry( param.width, param.height, 16, 8 );\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// copy from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mytest37.js?ver=20160815\r\n\t\t\tfunction createCapsuleGeometry( radius, cylinderHeight, segmentsRadius, segmentsHeight ) {\r\n\r\n\t\t\t\tvar geometry = new CylinderBufferGeometry( radius, radius, cylinderHeight, segmentsRadius, segmentsHeight, true );\r\n\t\t\t\tvar upperSphere = new Mesh( new SphereBufferGeometry( radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, 0, Math.PI / 2 ) );\r\n\t\t\t\tvar lowerSphere = new Mesh( new SphereBufferGeometry( radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2 ) );\r\n\r\n\t\t\t\tupperSphere.position.set( 0, cylinderHeight / 2, 0 );\r\n\t\t\t\tlowerSphere.position.set( 0, - cylinderHeight / 2, 0 );\r\n\r\n\t\t\t\tupperSphere.updateMatrix();\r\n\t\t\t\tlowerSphere.updateMatrix();\r\n\r\n\t\t\t\tgeometry.merge( upperSphere.geometry, upperSphere.matrix );\r\n\t\t\t\tgeometry.merge( lowerSphere.geometry, lowerSphere.matrix );\r\n\r\n\t\t\t\treturn geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, il = bodies.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar param = bodies[ i ].params;\r\n\t\t\t\tthis$1.add( new Mesh( createGeometry( param ), this$1.materials[ param.type ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn MMDPhysics;\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MMDAnimationHelper = ( function () {\r\n\t\r\n\tfunction MMDAnimationHelper( params ) {\r\n\r\n\t\tparams = params || {};\r\n\r\n\t\tthis.meshes = [];\r\n\r\n\t\tthis.camera = null;\r\n\t\tthis.cameraTarget = new Object3D();\r\n\t\tthis.cameraTarget.name = 'target';\r\n\r\n\t\tthis.audio = null;\r\n\t\tthis.audioManager = null;\r\n\r\n\t\tthis.objects = new WeakMap();\r\n\r\n\t\tthis.configuration = {\r\n\t\t\tsync: params.sync !== undefined\r\n\t\t\t\t? params.sync : true,\r\n\t\t\tafterglow: params.afterglow !== undefined\r\n\t\t\t\t? params.afterglow : 0.0,\r\n\t\t\tresetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined\r\n\t\t\t\t? params.resetPhysicsOnLoop : true\r\n\t\t};\r\n\r\n\t\tthis.enabled = {\r\n\t\t\tanimation: true,\r\n\t\t\tik: true,\r\n\t\t\tgrant: true,\r\n\t\t\tphysics: true,\r\n\t\t\tcameraAnimation: true\r\n\t\t};\r\n\r\n\t\tthis.onBeforePhysics = function ( mesh ) {};\r\n\r\n\t\t// experimental\r\n\t\tthis.sharedPhysics = false;\r\n\t\tthis.masterPhysics = null;\r\n\r\n\t}\r\n\r\n\tMMDAnimationHelper.prototype = {\r\n\r\n\t\tconstructor: MMDAnimationHelper,\r\n\t\t\r\n\t\tadd: function ( object, params ) {\r\n\r\n\t\t\tparams = params || {};\r\n\r\n\t\t\tif ( object.isSkinnedMesh ) {\r\n\r\n\t\t\t\tthis._addMesh( object, params );\r\n\r\n\t\t\t} else if ( object.isCamera ) {\r\n\r\n\t\t\t\tthis._setupCamera( object, params );\r\n\r\n\t\t\t} else if ( object.type === 'Audio' ) {\r\n\r\n\t\t\t\tthis._setupAudio( object, params );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'MMDAnimationHelper.add: '\r\n\t\t\t\t\t+ 'accepts only '\r\n\t\t\t\t\t+ 'SkinnedMesh or '\r\n\t\t\t\t\t+ 'Camera or '\r\n\t\t\t\t\t+ 'Audio instance.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.configuration.sync ) { this._syncDuration(); }\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tremove: function ( object ) {\r\n\r\n\t\t\tif ( object.isSkinnedMesh ) {\r\n\r\n\t\t\t\tthis._removeMesh( object );\r\n\r\n\t\t\t} else if ( object.isCamera ) {\r\n\r\n\t\t\t\tthis._clearCamera( object );\r\n\r\n\t\t\t} else if ( object.type === 'Audio' ) {\r\n\r\n\t\t\t\tthis._clearAudio( object );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'MMDAnimationHelper.remove: '\r\n\t\t\t\t\t+ 'accepts only '\r\n\t\t\t\t\t+ 'SkinnedMesh or '\r\n\t\t\t\t\t+ 'Camera or '\r\n\t\t\t\t\t+ 'Audio instance.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.configuration.sync ) { this._syncDuration(); }\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tupdate: function ( delta ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tif ( this.audioManager !== null ) { this.audioManager.control( delta ); }\r\n\r\n\t\t\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\r\n\r\n\t\t\t\tthis$1._animateMesh( this$1.meshes[ i ], delta );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.sharedPhysics ) { this._updateSharedPhysics( delta ); }\r\n\r\n\t\t\tif ( this.camera !== null ) { this._animateCamera( this.camera, delta ); }\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tpose: function ( mesh, vpd, params ) {\r\n\r\n\t\t\tparams = params || {};\r\n\r\n\t\t\tif ( params.resetPose !== false ) { mesh.pose(); }\r\n\r\n\t\t\tvar bones = mesh.skeleton.bones;\r\n\t\t\tvar boneParams = vpd.bones;\r\n\r\n\t\t\tvar boneNameDictionary = {};\r\n\r\n\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tboneNameDictionary[ bones[ i ].name ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vector = new Vector3();\r\n\t\t\tvar quaternion = new Quaternion();\r\n\r\n\t\t\tfor ( var i = 0, il = boneParams.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar boneParam = boneParams[ i ];\r\n\t\t\t\tvar boneIndex = boneNameDictionary[ boneParam.name ];\r\n\r\n\t\t\t\tif ( boneIndex === undefined ) { continue; }\r\n\r\n\t\t\t\tvar bone = bones[ boneIndex ];\r\n\t\t\t\tbone.position.add( vector.fromArray( boneParam.translation ) );\r\n\t\t\t\tbone.quaternion.multiply( quaternion.fromArray( boneParam.quaternion ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmesh.updateMatrixWorld( true );\r\n\r\n\t\t\tif ( params.ik !== false ) {\r\n\r\n\t\t\t\tthis._createCCDIKSolver( mesh ).update( params.saveOriginalBonesBeforeIK ); // this param is experimental\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( params.grant !== false ) {\r\n\r\n\t\t\t\tthis.createGrantSolver( mesh ).update();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tenable: function ( key, enabled ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tif ( this.enabled[ key ] === undefined ) {\r\n\r\n\t\t\t\tthrow new Error( 'MMDAnimationHelper.enable: '\r\n\t\t\t\t\t+ 'unknown key ' + key );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.enabled[ key ] = enabled;\r\n\r\n\t\t\tif ( key === 'physics' ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = this.meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tthis$1._optimizeIK( this$1.meshes[ i ], enabled );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tcreateGrantSolver: function ( mesh ) {\r\n\r\n\t\t\treturn new GrantSolver( mesh, mesh.geometry.userData.MMD.grants );\r\n\r\n\t\t},\r\n\r\n\t\t// private methods\r\n\r\n\t\t_addMesh: function ( mesh, params ) {\r\n\r\n\t\t\tif ( this.meshes.indexOf( mesh ) >= 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'MMDAnimationHelper._addMesh: '\r\n\t\t\t\t\t+ 'SkinnedMesh \\'' + mesh.name + '\\' has already been added.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.meshes.push( mesh );\r\n\t\t\tthis.objects.set( mesh, { looped: false } );\r\n\r\n\t\t\tthis._setupMeshAnimation( mesh, params.animation );\r\n\r\n\t\t\tif ( params.physics !== false ) {\r\n\r\n\t\t\t\tthis._setupMeshPhysics( mesh, params );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t_setupCamera: function ( camera, params ) {\r\n\r\n\t\t\tif ( this.camera === camera ) {\r\n\r\n\t\t\t\tthrow new Error( 'MMDAnimationHelper._setupCamera: '\r\n\t\t\t\t\t+ 'Camera \\'' + camera.name + '\\' has already been set.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.camera ) { this.clearCamera( this.camera ); }\r\n\r\n\t\t\tthis.camera = camera;\r\n\r\n\t\t\tcamera.add( this.cameraTarget );\r\n\r\n\t\t\tthis.objects.set( camera, {} );\r\n\r\n\t\t\tif ( params.animation !== undefined ) {\r\n\r\n\t\t\t\tthis._setupCameraAnimation( camera, params.animation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t_setupAudio: function ( audio, params ) {\r\n\r\n\t\t\tif ( this.audio === audio ) {\r\n\r\n\t\t\t\tthrow new Error( 'MMDAnimationHelper._setupAudio: '\r\n\t\t\t\t\t+ 'Audio \\'' + audio.name + '\\' has already been set.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.audio ) { this.clearAudio( this.audio ); }\r\n\r\n\t\t\tthis.audio = audio;\r\n\t\t\tthis.audioManager = new AudioManager( audio, params );\r\n\r\n\t\t\tthis.objects.set( this.audioManager, {\r\n\t\t\t\tduration: this.audioManager.duration\r\n\t\t\t} );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t_removeMesh: function ( mesh ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar found = false;\r\n\t\t\tvar writeIndex = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = this.meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( this$1.meshes[ i ] === mesh ) {\r\n\r\n\t\t\t\t\tthis$1.objects.delete( mesh );\r\n\t\t\t\t\tfound = true;\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis$1.meshes[ writeIndex ++ ] = this$1.meshes[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! found ) {\r\n\r\n\t\t\t\tthrow new Error( 'MMDAnimationHelper._removeMesh: '\r\n\t\t\t\t\t+ 'SkinnedMesh \\'' + mesh.name + '\\' has not been added yet.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.meshes.length = writeIndex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t_clearCamera: function ( camera ) {\r\n\r\n\t\t\tif ( camera !== this.camera ) {\r\n\r\n\t\t\t\tthrow new Error( 'MMDAnimationHelper._clearCamera: '\r\n\t\t\t\t\t+ 'Camera \\'' + camera.name + '\\' has not been set yet.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.camera.remove( this.cameraTarget );\r\n\r\n\t\t\tthis.objects.delete( this.camera );\r\n\t\t\tthis.camera = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t_clearAudio: function ( audio ) {\r\n\r\n\t\t\tif ( audio !== this.audio ) {\r\n\r\n\t\t\t\tthrow new Error( 'MMDAnimationHelper._clearAudio: '\r\n\t\t\t\t\t+ 'Audio \\'' + audio.name + '\\' has not been set yet.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.objects.delete( this.audioManager );\r\n\r\n\t\t\tthis.audio = null;\r\n\t\t\tthis.audioManager = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t_setupMeshAnimation: function ( mesh, animation ) {\r\n\r\n\t\t\tvar objects = this.objects.get( mesh );\r\n\r\n\t\t\tif ( animation !== undefined ) {\r\n\r\n\t\t\t\tvar animations = Array.isArray( animation )\r\n\t\t\t\t\t? animation : [ animation ];\r\n\r\n\t\t\t\tobjects.mixer = new AnimationMixer( mesh );\r\n\r\n\t\t\t\tfor ( var i = 0, il = animations.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tobjects.mixer.clipAction( animations[ i ] ).play();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: find a workaround not to access ._clip looking like a private property\r\n\t\t\t\tobjects.mixer.addEventListener( 'loop', function ( event ) {\r\n\r\n\t\t\t\t\tvar tracks = event.action._clip.tracks;\r\n\r\n\t\t\t\t\tif ( tracks.length > 0 &&\r\n\t\t\t\t\t     tracks[ 0 ].name.slice( 0, 6 ) !== '.bones' ) { return; }\r\n\r\n\t\t\t\t\tobjects.looped = true;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobjects.ikSolver = this._createCCDIKSolver( mesh );\r\n\t\t\tobjects.grantSolver = this.createGrantSolver( mesh );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t_setupCameraAnimation: function ( camera, animation ) {\r\n\r\n\t\t\tvar animations = Array.isArray( animation )\r\n\t\t\t\t? animation : [ animation ];\r\n\r\n\t\t\tvar objects = this.objects.get( camera );\r\n\r\n\t\t\tobjects.mixer = new AnimationMixer( camera );\r\n\r\n\t\t\tfor ( var i = 0, il = animations.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tobjects.mixer.clipAction( animations[ i ] ).play();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t_setupMeshPhysics: function ( mesh, params ) {\r\n\r\n\t\t\tvar objects = this.objects.get( mesh );\r\n\r\n\t\t\t// shared physics is experimental\r\n\r\n\t\t\tif ( params.world === undefined && this.sharedPhysics ) {\r\n\r\n\t\t\t\tvar masterPhysics = this._getMasterPhysics();\r\n\r\n\t\t\t\tif ( masterPhysics !== null ) { world = masterPhysics.world; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobjects.physics = this._createMMDPhysics( mesh, params );\r\n\r\n\t\t\tif ( objects.mixer && params.animationWarmup !== false ) {\r\n\r\n\t\t\t\tthis._animateMesh( mesh, 0 );\r\n\t\t\t\tobjects.physics.reset();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobjects.physics.warmup( params.warmup !== undefined ? params.warmup : 60 );\r\n\r\n\t\t\tthis._optimizeIK( mesh, true );\r\n\r\n\t\t},\r\n\r\n\t\t_animateMesh: function ( mesh, delta ) {\r\n\r\n\t\t\tvar objects = this.objects.get( mesh );\r\n\r\n\t\t\tvar mixer = objects.mixer;\r\n\t\t\tvar ikSolver = objects.ikSolver;\r\n\t\t\tvar grantSolver = objects.grantSolver;\r\n\t\t\tvar physics = objects.physics;\r\n\t\t\tvar looped = objects.looped;\r\n\r\n\t\t\t// alternate solution to save/restore bones but less performant?\r\n\t\t\t//mesh.pose();\r\n\t\t\t//this._updatePropertyMixersBuffer( mesh );\r\n\r\n\t\t\tif ( mixer && this.enabled.animation ) {\r\n\r\n\t\t\t\tthis._restoreBones( mesh );\r\n\r\n\t\t\t\tmixer.update( delta );\r\n\r\n\t\t\t\tthis._saveBones( mesh );\r\n\r\n\t\t\t\tif ( ikSolver && this.enabled.ik ) {\r\n\r\n\t\t\t\t\tmesh.updateMatrixWorld( true );\r\n\t\t\t\t\tikSolver.update();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( grantSolver && this.enabled.grant ) {\r\n\r\n\t\t\t\t\tgrantSolver.update();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( looped === true && this.enabled.physics ) {\r\n\r\n\t\t\t\tif ( physics && this.configuration.resetPhysicsOnLoop ) { physics.reset(); }\r\n\r\n\t\t\t\tobjects.looped = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( physics && this.enabled.physics && ! this.sharedPhysics ) {\r\n\r\n\t\t\t\tthis.onBeforePhysics( mesh );\r\n\t\t\t\tphysics.update( delta );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t_animateCamera: function ( camera, delta ) {\r\n\r\n\t\t\tvar mixer = this.objects.get( camera ).mixer;\r\n\r\n\t\t\tif ( mixer && this.enabled.cameraAnimation ) {\r\n\r\n\t\t\t\tmixer.update( delta );\r\n\r\n\t\t\t\tcamera.updateProjectionMatrix();\r\n\r\n\t\t\t\tcamera.up.set( 0, 1, 0 );\r\n\t\t\t\tcamera.up.applyQuaternion( camera.quaternion );\r\n\t\t\t\tcamera.lookAt( this.cameraTarget.position );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t_optimizeIK: function ( mesh, physicsEnabled ) {\r\n\r\n\t\t\tvar iks = mesh.geometry.userData.MMD.iks;\r\n\t\t\tvar bones = mesh.geometry.userData.MMD.bones;\r\n\r\n\t\t\tfor ( var i = 0, il = iks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar ik = iks[ i ];\r\n\t\t\t\tvar links = ik.links;\r\n\r\n\t\t\t\tfor ( var j = 0, jl = links.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar link = links[ j ];\r\n\r\n\t\t\t\t\tif ( physicsEnabled === true ) {\r\n\r\n\t\t\t\t\t\t// disable IK of the bone the corresponding rigidBody type of which is 1 or 2\r\n\t\t\t\t\t\t// because its rotation will be overriden by physics\r\n\t\t\t\t\t\tlink.enabled = bones[ link.index ].rigidBodyType > 0 ? false : true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tlink.enabled = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t_createCCDIKSolver: function ( mesh ) {\r\n\r\n\t\t\tif ( CCDIKSolver === undefined ) {\r\n\r\n\t\t\t\tthrow new Error( 'MMDAnimationHelper: Import CCDIKSolver.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new CCDIKSolver( mesh, mesh.geometry.userData.MMD.iks );\r\n\r\n\t\t},\r\n\r\n\t\t_createMMDPhysics: function ( mesh, params ) {\r\n\r\n\t\t\tif ( MMDPhysics === undefined ) {\r\n\r\n\t\t\t\tthrow new Error( 'MMDPhysics: Import MMDPhysics.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new MMDPhysics(\r\n\t\t\t\tmesh,\r\n\t\t\t\tmesh.geometry.userData.MMD.rigidBodies,\r\n\t\t\t\tmesh.geometry.userData.MMD.constraints,\r\n\t\t\t\tparams );\r\n\r\n\t\t},\r\n\t\t\r\n\t\t_syncDuration: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar max = 0.0;\r\n\r\n\t\t\tvar objects = this.objects;\r\n\t\t\tvar meshes = this.meshes;\r\n\t\t\tvar camera = this.camera;\r\n\t\t\tvar audioManager = this.audioManager;\r\n\r\n\t\t\t// get the longest duration\r\n\r\n\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar mixer = this$1.objects.get( meshes[ i ] ).mixer;\r\n\r\n\t\t\t\tif ( mixer === undefined ) { continue; }\r\n\r\n\t\t\t\tfor ( var j = 0; j < mixer._actions.length; j ++ ) {\r\n\r\n\t\t\t\t\tvar clip = mixer._actions[ j ]._clip;\r\n\r\n\t\t\t\t\tif ( ! objects.has( clip ) ) {\r\n\r\n\t\t\t\t\t\tobjects.set( clip, {\r\n\t\t\t\t\t\t\tduration: clip.duration\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmax = Math.max( max, objects.get( clip ).duration );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( camera !== null ) {\r\n\r\n\t\t\t\tvar mixer = this.objects.get( camera ).mixer;\r\n\r\n\t\t\t\tif ( mixer !== undefined ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = mixer._actions.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar clip = mixer._actions[ i ]._clip;\r\n\r\n\t\t\t\t\t\tif ( ! objects.has( clip ) ) {\r\n\r\n\t\t\t\t\t\t\tobjects.set( clip, {\r\n\t\t\t\t\t\t\t\tduration: clip.duration\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmax = Math.max( max, objects.get( clip ).duration );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( audioManager !== null ) {\r\n\r\n\t\t\t\tmax = Math.max( max, objects.get( audioManager ).duration );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmax += this.configuration.afterglow;\r\n\r\n\t\t\t// update the duration\r\n\r\n\t\t\tfor ( var i = 0, il = this.meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar mixer = this$1.objects.get( this$1.meshes[ i ] ).mixer;\r\n\r\n\t\t\t\tif ( mixer === undefined ) { continue; }\r\n\r\n\t\t\t\tfor ( var j = 0, jl = mixer._actions.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tmixer._actions[ j ]._clip.duration = max;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( camera !== null ) {\r\n\r\n\t\t\t\tvar mixer = this.objects.get( camera ).mixer;\r\n\r\n\t\t\t\tif ( mixer !== undefined ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = mixer._actions.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tmixer._actions[ i ]._clip.duration = max;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( audioManager !== null ) {\r\n\r\n\t\t\t\taudioManager.duration = max;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// workaround\r\n\r\n\t\t_updatePropertyMixersBuffer: function ( mesh ) {\r\n\r\n\t\t\tvar mixer = this.objects.get( mesh ).mixer;\r\n\r\n\t\t\tvar propertyMixers = mixer._bindings;\r\n\t\t\tvar accuIndex = mixer._accuIndex;\r\n\r\n\t\t\tfor ( var i = 0, il = propertyMixers.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar propertyMixer = propertyMixers[ i ];\r\n\t\t\t\tvar buffer = propertyMixer.buffer;\r\n\t\t\t\tvar stride = propertyMixer.valueSize;\r\n\t\t\t\tvar offset = ( accuIndex + 1 ) * stride;\r\n\r\n\t\t\t\tpropertyMixer.binding.getValue( buffer, offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\t\t\r\n\t\t_saveBones: function ( mesh ) {\r\n\r\n\t\t\tvar objects = this.objects.get( mesh );\r\n\r\n\t\t\tvar bones = mesh.skeleton.bones;\r\n\r\n\t\t\tvar backupBones = objects.backupBones;\r\n\r\n\t\t\tif ( backupBones === undefined ) {\r\n\r\n\t\t\t\tbackupBones = new Float32Array( bones.length * 7 );\r\n\t\t\t\tobjects.backupBones = backupBones;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar bone = bones[ i ];\r\n\t\t\t\tbone.position.toArray( backupBones, i * 7 );\r\n\t\t\t\tbone.quaternion.toArray( backupBones, i * 7 + 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t_restoreBones: function ( mesh ) {\r\n\r\n\t\t\tvar objects = this.objects.get( mesh );\r\n\r\n\t\t\tvar backupBones = objects.backupBones;\r\n\r\n\t\t\tif ( backupBones === undefined ) { return; }\r\n\r\n\t\t\tvar bones = mesh.skeleton.bones;\r\n\r\n\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar bone = bones[ i ];\r\n\t\t\t\tbone.position.fromArray( backupBones, i * 7 );\r\n\t\t\t\tbone.quaternion.fromArray( backupBones, i * 7 + 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// experimental\r\n\r\n\t\t_getMasterPhysics: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tif ( this.masterPhysics !== null ) { return this.masterPhysics; }\r\n\r\n\t\t\tfor ( var i = 0, il = this.meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar physics = this$1.meshes[ i ].physics;\r\n\r\n\t\t\t\tif ( physics !== undefined && physics !== null ) {\r\n\r\n\t\t\t\t\tthis$1.masterPhysics = physics;\r\n\t\t\t\t\treturn this$1.masterPhysics;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t},\r\n\r\n\t\t_updateSharedPhysics: function ( delta ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tif ( this.meshes.length === 0 || ! this.enabled.physics || ! this.sharedPhysics ) { return; }\r\n\r\n\t\t\tvar physics = this._getMasterPhysics();\r\n\r\n\t\t\tif ( physics === null ) { return; }\r\n\r\n\t\t\tfor ( var i = 0, il = this.meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar p = this$1.meshes[ i ].physics;\r\n\r\n\t\t\t\tif ( p !== null && p !== undefined ) {\r\n\r\n\t\t\t\t\tp.updateRigidBodies();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tphysics.stepSimulation( delta );\r\n\r\n\t\t\tfor ( var i = 0, il = this.meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar p = this$1.meshes[ i ].physics;\r\n\r\n\t\t\t\tif ( p !== null && p !== undefined ) {\r\n\r\n\t\t\t\t\tp.updateBones();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\t\r\n\tfunction AudioManager( audio, params ) {\r\n\r\n\t\tparams = params || {};\r\n\r\n\t\tthis.audio = audio;\r\n\r\n\t\tthis.elapsedTime = 0.0;\r\n\t\tthis.currentTime = 0.0;\r\n\t\tthis.delayTime = params.delayTime !== undefined\r\n\t\t\t? params.delayTime : 0.0;\r\n\r\n\t\tthis.audioDuration = this.audio.buffer.duration;\r\n\t\tthis.duration = this.audioDuration + this.delayTime;\r\n\r\n\t}\r\n\r\n\tAudioManager.prototype = {\r\n\r\n\t\tconstructor: AudioManager,\r\n\t\t\r\n\t\tcontrol: function ( delta ) {\r\n\r\n\t\t\tthis.elapsed += delta;\r\n\t\t\tthis.currentTime += delta;\r\n\r\n\t\t\tif ( this._shouldStopAudio() ) { this.audio.stop(); }\r\n\t\t\tif ( this._shouldStartAudio() ) { this.audio.play(); }\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// private methods\r\n\r\n\t\t_shouldStartAudio: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tif ( this.audio.isPlaying ) { return false; }\r\n\r\n\t\t\twhile ( this.currentTime >= this.duration ) {\r\n\r\n\t\t\t\tthis$1.currentTime -= this$1.duration;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.currentTime < this.delayTime ) { return false; }\r\n\r\n\t\t\tthis.audio.startTime = this.currentTime - this.delayTime;\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t},\r\n\r\n\t\t_shouldStopAudio: function () {\r\n\r\n\t\t\treturn this.audio.isPlaying &&\r\n\t\t\t\tthis.currentTime >= this.duration;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n\tfunction GrantSolver( mesh, grants ) {\r\n\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.grants = grants || [];\r\n\r\n\t}\r\n\r\n\tGrantSolver.prototype = {\r\n\r\n\t\tconstructor: GrantSolver,\r\n\t\t\r\n\t\tupdate: function () {\r\n\r\n\t\t\tvar quaternion = new Quaternion();\r\n\r\n\t\t\treturn function () {\r\n\r\n\t\t\t\tvar bones = this.mesh.skeleton.bones;\r\n\t\t\t\tvar grants = this.grants;\r\n\r\n\t\t\t\tfor ( var i = 0, il = grants.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar grant = grants[ i ];\r\n\t\t\t\t\tvar bone = bones[ grant.index ];\r\n\t\t\t\t\tvar parentBone = bones[ grant.parentIndex ];\r\n\r\n\t\t\t\t\tif ( grant.isLocal ) {\r\n\r\n\t\t\t\t\t\t// TODO: implement\r\n\t\t\t\t\t\tif ( grant.affectPosition ) ;\r\n\r\n\t\t\t\t\t\t// TODO: implement\r\n\t\t\t\t\t\tif ( grant.affectRotation ) ;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// TODO: implement\r\n\t\t\t\t\t\tif ( grant.affectPosition ) ;\r\n\r\n\t\t\t\t\t\tif ( grant.affectRotation ) {\r\n\r\n\t\t\t\t\t\t\tquaternion.set( 0, 0, 0, 1 );\r\n\t\t\t\t\t\t\tquaternion.slerp( parentBone.quaternion, grant.ratio );\r\n\t\t\t\t\t\t\tbone.quaternion.multiply( quaternion );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t};\r\n\r\n\t\t}()\r\n\r\n\t};\r\n\r\n\treturn MMDAnimationHelper;\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar AnimationClipCreator = function () {};\r\n\r\nAnimationClipCreator.CreateRotationAnimation = function ( period, axis ) {\r\n\r\n\tvar times = [ 0, period ], values = [ 0, 360 ];\r\n\r\n\taxis = axis || 'x';\r\n\tvar trackName = '.rotation[' + axis + ']';\r\n\r\n\tvar track = new NumberKeyframeTrack( trackName, times, values );\r\n\r\n\treturn new AnimationClip( null, period, [ track ] );\r\n\r\n};\r\n\r\nAnimationClipCreator.CreateScaleAxisAnimation = function ( period, axis ) {\r\n\r\n\tvar times = [ 0, period ], values = [ 0, 1 ];\r\n\r\n\taxis = axis || 'x';\r\n\tvar trackName = '.scale[' + axis + ']';\r\n\r\n\tvar track = new NumberKeyframeTrack( trackName, times, values );\r\n\r\n\treturn new AnimationClip( null, period, [ track ] );\r\n\r\n};\r\n\r\nAnimationClipCreator.CreateShakeAnimation = function ( duration, shakeScale ) {\r\n\r\n\tvar times = [], values = [], tmp = new Vector3();\r\n\r\n\tfor ( var i = 0; i < duration * 10; i ++ ) {\r\n\r\n\t\ttimes.push( i / 10 );\r\n\r\n\t\ttmp.set( Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0 ).\r\n\t\t\tmultiply( shakeScale ).\r\n\t\t\ttoArray( values, values.length );\r\n\r\n\t}\r\n\r\n\tvar trackName = '.position';\r\n\r\n\tvar track = new VectorKeyframeTrack$1( trackName, times, values );\r\n\r\n\treturn new AnimationClip( null, duration, [ track ] );\r\n\r\n};\r\n\r\nAnimationClipCreator.CreatePulsationAnimation = function ( duration, pulseScale ) {\r\n\r\n\tvar times = [], values = [], tmp = new Vector3();\r\n\r\n\tfor ( var i = 0; i < duration * 10; i ++ ) {\r\n\r\n\t\ttimes.push( i / 10 );\r\n\r\n\t\tvar scaleFactor = Math.random() * pulseScale;\r\n\t\ttmp.set( scaleFactor, scaleFactor, scaleFactor ).\r\n\t\t\ttoArray( values, values.length );\r\n\r\n\t}\r\n\r\n\tvar trackName = '.scale';\r\n\r\n\tvar track = new VectorKeyframeTrack$1( trackName, times, values );\r\n\r\n\treturn new AnimationClip( null, duration, [ track ] );\r\n\r\n};\r\n\r\nAnimationClipCreator.CreateVisibilityAnimation = function ( duration ) {\r\n\r\n\tvar times = [ 0, duration / 2, duration ], values = [ true, false, true ];\r\n\r\n\tvar trackName = '.visible';\r\n\r\n\tvar track = new BooleanKeyframeTrack( trackName, times, values );\r\n\r\n\treturn new AnimationClip( null, duration, [ track ] );\r\n\r\n};\r\n\r\nAnimationClipCreator.CreateMaterialColorAnimation = function ( duration, colors ) {\r\n\r\n\tvar times = [], values = [],\r\n\t\ttimeStep = duration / colors.length;\r\n\r\n\tfor ( var i = 0; i <= colors.length; i ++ ) {\r\n\r\n\t\ttimes.push( i * timeStep );\r\n\t\tvalues.push( colors[ i % colors.length ] );\r\n\r\n\t}\r\n\r\n\tvar trackName = '.material[0].color';\r\n\r\n\tvar track = new ColorKeyframeTrack( trackName, times, values );\r\n\r\n\treturn new AnimationClip( null, duration, [ track ] );\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Camera() {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'Camera';\r\n\r\n\tthis.matrixWorldInverse = new Matrix4();\r\n\r\n\tthis.projectionMatrix = new Matrix4();\r\n\tthis.projectionMatrixInverse = new Matrix4();\r\n\r\n}\r\n\r\nCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: Camera,\r\n\r\n\tisCamera: true,\r\n\r\n\tcopy: function ( source, recursive ) {\r\n\r\n\t\tObject3D.prototype.copy.call( this, source, recursive );\r\n\r\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\r\n\r\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\r\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetWorldDirection: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Camera: .getWorldDirection() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\tvar e = this.matrixWorld.elements;\r\n\r\n\t\treturn target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PerspectiveCamera( fov, aspect, near, far ) {\r\n\r\n\tCamera.call( this );\r\n\r\n\tthis.type = 'PerspectiveCamera';\r\n\r\n\tthis.fov = fov !== undefined ? fov : 50;\r\n\tthis.zoom = 1;\r\n\r\n\tthis.near = near !== undefined ? near : 0.1;\r\n\tthis.far = far !== undefined ? far : 2000;\r\n\tthis.focus = 10;\r\n\r\n\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\tthis.view = null;\r\n\r\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\r\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n}\r\n\r\nPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\r\n\r\n\tconstructor: PerspectiveCamera,\r\n\r\n\tisPerspectiveCamera: true,\r\n\r\n\tcopy: function ( source, recursive ) {\r\n\r\n\t\tCamera.prototype.copy.call( this, source, recursive );\r\n\r\n\t\tthis.fov = source.fov;\r\n\t\tthis.zoom = source.zoom;\r\n\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\t\tthis.focus = source.focus;\r\n\r\n\t\tthis.aspect = source.aspect;\r\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\r\n\r\n\t\tthis.filmGauge = source.filmGauge;\r\n\t\tthis.filmOffset = source.filmOffset;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\t\r\n\tsetFocalLength: function ( focalLength ) {\r\n\r\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\r\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\r\n\r\n\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t},\r\n\t\r\n\tgetFocalLength: function () {\r\n\r\n\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\r\n\r\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\r\n\r\n\t},\r\n\r\n\tgetEffectiveFOV: function () {\r\n\r\n\t\treturn _Math.RAD2DEG * 2 * Math.atan(\r\n\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\r\n\r\n\t},\r\n\r\n\tgetFilmWidth: function () {\r\n\r\n\t\t// film not completely covered in portrait format (aspect < 1)\r\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\r\n\r\n\t},\r\n\r\n\tgetFilmHeight: function () {\r\n\r\n\t\t// film not completely covered in landscape format (aspect > 1)\r\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\r\n\r\n\t},\r\n\t\r\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\t\tthis.aspect = fullWidth / fullHeight;\r\n\r\n\t\tif ( this.view === null ) {\r\n\r\n\t\t\tthis.view = {\r\n\t\t\t\tenabled: true,\r\n\t\t\t\tfullWidth: 1,\r\n\t\t\t\tfullHeight: 1,\r\n\t\t\t\toffsetX: 0,\r\n\t\t\t\toffsetY: 0,\r\n\t\t\t\twidth: 1,\r\n\t\t\t\theight: 1\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tthis.view.enabled = true;\r\n\t\tthis.view.fullWidth = fullWidth;\r\n\t\tthis.view.fullHeight = fullHeight;\r\n\t\tthis.view.offsetX = x;\r\n\t\tthis.view.offsetY = y;\r\n\t\tthis.view.width = width;\r\n\t\tthis.view.height = height;\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t},\r\n\r\n\tclearViewOffset: function () {\r\n\r\n\t\tif ( this.view !== null ) {\r\n\r\n\t\t\tthis.view.enabled = false;\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t},\r\n\r\n\tupdateProjectionMatrix: function () {\r\n\r\n\t\tvar near = this.near,\r\n\t\t\ttop = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\r\n\t\t\theight = 2 * top,\r\n\t\t\twidth = this.aspect * height,\r\n\t\t\tleft = - 0.5 * width,\r\n\t\t\tview = this.view;\r\n\r\n\t\tif ( this.view !== null && this.view.enabled ) {\r\n\r\n\t\t\tvar fullWidth = view.fullWidth,\r\n\t\t\t\tfullHeight = view.fullHeight;\r\n\r\n\t\t\tleft += view.offsetX * width / fullWidth;\r\n\t\t\ttop -= view.offsetY * height / fullHeight;\r\n\t\t\twidth *= view.width / fullWidth;\r\n\t\t\theight *= view.height / fullHeight;\r\n\r\n\t\t}\r\n\r\n\t\tvar skew = this.filmOffset;\r\n\t\tif ( skew !== 0 ) { left += near * skew / this.getFilmWidth(); }\r\n\r\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\r\n\r\n\t\tthis.projectionMatrixInverse.getInverse( this.projectionMatrix );\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\t\tdata.object.fov = this.fov;\r\n\t\tdata.object.zoom = this.zoom;\r\n\r\n\t\tdata.object.near = this.near;\r\n\t\tdata.object.far = this.far;\r\n\t\tdata.object.focus = this.focus;\r\n\r\n\t\tdata.object.aspect = this.aspect;\r\n\r\n\t\tif ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }\r\n\r\n\t\tdata.object.filmGauge = this.filmGauge;\r\n\t\tdata.object.filmOffset = this.filmOffset;\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar UniformsUtils = {\r\n\r\n\tmerge: function ( uniforms ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar merged = {};\r\n\r\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\r\n\t\t\tvar tmp = this$1.clone( uniforms[ u ] );\r\n\r\n\t\t\tfor ( var p in tmp ) {\r\n\r\n\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn merged;\r\n\r\n\t},\r\n\r\n\tclone: function ( uniforms_src ) {\r\n\r\n\t\tvar uniforms_dst = {};\r\n\r\n\t\tfor ( var u in uniforms_src ) {\r\n\r\n\t\t\tuniforms_dst[ u ] = {};\r\n\r\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\r\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\r\n\t\t\t\tif ( parameter_src && ( parameter_src.isColor ||\r\n\t\t\t\t\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\r\n\t\t\t\t\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\r\n\t\t\t\t\tparameter_src.isTexture ) ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms_dst;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ShaderMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'ShaderMaterial';\r\n\r\n\tthis.defines = {};\r\n\tthis.uniforms = {};\r\n\r\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false; // set to use scene fog\r\n\tthis.lights = false; // set to use scene lights\r\n\tthis.clipping = false; // set to use user-defined clipping planes\r\n\r\n\tthis.skinning = false; // set to use skinning attribute streams\r\n\tthis.morphTargets = false; // set to use morph targets\r\n\tthis.morphNormals = false; // set to use morph normals\r\n\r\n\tthis.extensions = {\r\n\t\tderivatives: false, // set to use derivatives\r\n\t\tfragDepth: false, // set to use fragment depth values\r\n\t\tdrawBuffers: false, // set to use draw buffers\r\n\t\tshaderTextureLOD: false // set to use shader texture LOD\r\n\t};\r\n\r\n\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\tthis.defaultAttributeValues = {\r\n\t\t'color': [ 1, 1, 1 ],\r\n\t\t'uv': [ 0, 0 ],\r\n\t\t'uv2': [ 0, 0 ]\r\n\t};\r\n\r\n\tthis.index0AttributeName = undefined;\r\n\tthis.uniformsNeedUpdate = false;\r\n\r\n\tif ( parameters !== undefined ) {\r\n\r\n\t\tif ( parameters.attributes !== undefined ) {\r\n\r\n\t\t\tconsole.error( 'ShaderMaterial: attributes should now be defined in BufferGeometry instead.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n}\r\n\r\nShaderMaterial.prototype = Object.create( Material.prototype );\r\nShaderMaterial.prototype.constructor = ShaderMaterial;\r\n\r\nShaderMaterial.prototype.isShaderMaterial = true;\r\n\r\nShaderMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.fragmentShader = source.fragmentShader;\r\n\tthis.vertexShader = source.vertexShader;\r\n\r\n\tthis.uniforms = UniformsUtils.clone( source.uniforms );\r\n\r\n\tthis.defines = Object.assign( {}, source.defines );\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\tthis.lights = source.lights;\r\n\tthis.clipping = source.clipping;\r\n\r\n\tthis.skinning = source.skinning;\r\n\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\tthis.extensions = source.extensions;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nShaderMaterial.prototype.toJSON = function ( meta ) {\n\tvar this$1 = this;\n\r\n\r\n\tvar data = Material.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.uniforms = {};\r\n\r\n\tfor ( var name in this$1.uniforms ) {\r\n\r\n\t\tvar uniform = this$1.uniforms[ name ];\r\n\t\tvar value = uniform.value;\r\n\r\n\t\tif ( value.isTexture ) {\r\n\r\n\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\ttype: 't',\r\n\t\t\t\tvalue: value.toJSON( meta ).uuid\r\n\t\t\t};\r\n\r\n\t\t} else if ( value.isColor ) {\r\n\r\n\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\ttype: 'c',\r\n\t\t\t\tvalue: value.getHex()\r\n\t\t\t};\r\n\r\n\t\t} else if ( value.isVector2 ) {\r\n\r\n\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\ttype: 'v2',\r\n\t\t\t\tvalue: value.toArray()\r\n\t\t\t};\r\n\r\n\t\t} else if ( value.isVector3 ) {\r\n\r\n\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\ttype: 'v3',\r\n\t\t\t\tvalue: value.toArray()\r\n\t\t\t};\r\n\r\n\t\t} else if ( value.isVector4 ) {\r\n\r\n\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\ttype: 'v4',\r\n\t\t\t\tvalue: value.toArray()\r\n\t\t\t};\r\n\r\n\t\t} else if ( value.isMatrix4 ) {\r\n\r\n\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\ttype: 'm4',\r\n\t\t\t\tvalue: value.toArray()\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\tvalue: value\r\n\t\t\t};\r\n\r\n\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( Object.keys( this.defines ).length > 0 ) { data.defines = this.defines; }\r\n\r\n\tdata.vertexShader = this.vertexShader;\r\n\tdata.fragmentShader = this.fragmentShader;\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Scene() {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'Scene';\r\n\r\n\tthis.background = null;\r\n\tthis.fog = null;\r\n\tthis.overrideMaterial = null;\r\n\r\n\tthis.autoUpdate = true; // checked by the renderer\r\n\r\n}\r\n\r\nScene.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: Scene,\r\n\r\n\tcopy: function ( source, recursive ) {\r\n\r\n\t\tObject3D.prototype.copy.call( this, source, recursive );\r\n\r\n\t\tif ( source.background !== null ) { this.background = source.background.clone(); }\r\n\t\tif ( source.fog !== null ) { this.fog = source.fog.clone(); }\r\n\t\tif ( source.overrideMaterial !== null ) { this.overrideMaterial = source.overrideMaterial.clone(); }\r\n\r\n\t\tthis.autoUpdate = source.autoUpdate;\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\t\tif ( this.background !== null ) { data.object.background = this.background.toJSON( meta ); }\r\n\t\tif ( this.fog !== null ) { data.object.fog = this.fog.toJSON(); }\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction OrthographicCamera( left, right, top, bottom, near, far ) {\r\n\r\n\tCamera.call( this );\r\n\r\n\tthis.type = 'OrthographicCamera';\r\n\r\n\tthis.zoom = 1;\r\n\tthis.view = null;\r\n\r\n\tthis.left = left;\r\n\tthis.right = right;\r\n\tthis.top = top;\r\n\tthis.bottom = bottom;\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n}\r\n\r\nOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\r\n\r\n\tconstructor: OrthographicCamera,\r\n\r\n\tisOrthographicCamera: true,\r\n\r\n\tcopy: function ( source, recursive ) {\r\n\r\n\t\tCamera.prototype.copy.call( this, source, recursive );\r\n\r\n\t\tthis.left = source.left;\r\n\t\tthis.right = source.right;\r\n\t\tthis.top = source.top;\r\n\t\tthis.bottom = source.bottom;\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\r\n\t\tthis.zoom = source.zoom;\r\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\t\tif ( this.view === null ) {\r\n\r\n\t\t\tthis.view = {\r\n\t\t\t\tenabled: true,\r\n\t\t\t\tfullWidth: 1,\r\n\t\t\t\tfullHeight: 1,\r\n\t\t\t\toffsetX: 0,\r\n\t\t\t\toffsetY: 0,\r\n\t\t\t\twidth: 1,\r\n\t\t\t\theight: 1\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tthis.view.enabled = true;\r\n\t\tthis.view.fullWidth = fullWidth;\r\n\t\tthis.view.fullHeight = fullHeight;\r\n\t\tthis.view.offsetX = x;\r\n\t\tthis.view.offsetY = y;\r\n\t\tthis.view.width = width;\r\n\t\tthis.view.height = height;\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t},\r\n\r\n\tclearViewOffset: function () {\r\n\r\n\t\tif ( this.view !== null ) {\r\n\r\n\t\t\tthis.view.enabled = false;\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t},\r\n\r\n\tupdateProjectionMatrix: function () {\r\n\r\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\t\tvar cx = ( this.right + this.left ) / 2;\r\n\t\tvar cy = ( this.top + this.bottom ) / 2;\r\n\r\n\t\tvar left = cx - dx;\r\n\t\tvar right = cx + dx;\r\n\t\tvar top = cy + dy;\r\n\t\tvar bottom = cy - dy;\r\n\r\n\t\tif ( this.view !== null && this.view.enabled ) {\r\n\r\n\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\r\n\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\r\n\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\r\n\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\r\n\r\n\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\r\n\t\t\tright = left + scaleW * ( this.view.width / zoomW );\r\n\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\r\n\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\r\n\r\n\t\t}\r\n\r\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\r\n\r\n\t\tthis.projectionMatrixInverse.getInverse( this.projectionMatrix );\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\t\tdata.object.zoom = this.zoom;\r\n\t\tdata.object.left = this.left;\r\n\t\tdata.object.right = this.right;\r\n\t\tdata.object.top = this.top;\r\n\t\tdata.object.bottom = this.bottom;\r\n\t\tdata.object.near = this.near;\r\n\t\tdata.object.far = this.far;\r\n\r\n\t\tif ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ImageUtils = {\r\n\r\n\tgetDataURL: function ( image ) {\r\n\r\n\t\tvar canvas;\r\n\r\n\t\tif ( image instanceof HTMLCanvasElement ) {\r\n\r\n\t\t\tcanvas = image;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\r\n\t\t\tcanvas.width = image.width;\r\n\t\t\tcanvas.height = image.height;\r\n\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\r\n\t\t\tif ( image instanceof ImageData ) {\r\n\r\n\t\t\t\tcontext.putImageData( image, 0, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\r\n\r\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn canvas.toDataURL( 'image/png' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar textureId = 0;\r\n\r\nfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\r\n\r\n\tObject.defineProperty( this, 'id', { value: textureId ++ } );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\r\n\tthis.mipmaps = [];\r\n\r\n\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\r\n\r\n\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\r\n\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n\tthis.format = format !== undefined ? format : RGBAFormat;\r\n\tthis.type = type !== undefined ? type : UnsignedByteType;\r\n\r\n\tthis.offset = new Vector2( 0, 0 );\r\n\tthis.repeat = new Vector2( 1, 1 );\r\n\tthis.center = new Vector2( 0, 0 );\r\n\tthis.rotation = 0;\r\n\r\n\tthis.matrixAutoUpdate = true;\r\n\tthis.matrix = new Matrix3();\r\n\r\n\tthis.generateMipmaps = true;\r\n\tthis.premultiplyAlpha = false;\r\n\tthis.flipY = true;\r\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n\t// Values of encoding !== LinearEncoding only supported on map, envMap and emissiveMap.\r\n\t//\r\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\r\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\r\n\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\r\n\r\n\tthis.version = 0;\r\n\tthis.onUpdate = null;\r\n\r\n}\r\n\r\nTexture.DEFAULT_IMAGE = undefined;\r\nTexture.DEFAULT_MAPPING = UVMapping;\r\n\r\nTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: Texture,\r\n\r\n\tisTexture: true,\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.image = source.image;\r\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\r\n\r\n\t\tthis.mapping = source.mapping;\r\n\r\n\t\tthis.wrapS = source.wrapS;\r\n\t\tthis.wrapT = source.wrapT;\r\n\r\n\t\tthis.magFilter = source.magFilter;\r\n\t\tthis.minFilter = source.minFilter;\r\n\r\n\t\tthis.anisotropy = source.anisotropy;\r\n\r\n\t\tthis.format = source.format;\r\n\t\tthis.type = source.type;\r\n\r\n\t\tthis.offset.copy( source.offset );\r\n\t\tthis.repeat.copy( source.repeat );\r\n\t\tthis.center.copy( source.center );\r\n\t\tthis.rotation = source.rotation;\r\n\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\tthis.matrix.copy( source.matrix );\r\n\r\n\t\tthis.generateMipmaps = source.generateMipmaps;\r\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\r\n\t\tthis.flipY = source.flipY;\r\n\t\tthis.unpackAlignment = source.unpackAlignment;\r\n\t\tthis.encoding = source.encoding;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\r\n\r\n\t\t\treturn meta.textures[ this.uuid ];\r\n\r\n\t\t}\r\n\r\n\t\tvar output = {\r\n\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Texture',\r\n\t\t\t\tgenerator: 'Texture.toJSON'\r\n\t\t\t},\r\n\r\n\t\t\tuuid: this.uuid,\r\n\t\t\tname: this.name,\r\n\r\n\t\t\tmapping: this.mapping,\r\n\r\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\r\n\t\t\toffset: [ this.offset.x, this.offset.y ],\r\n\t\t\tcenter: [ this.center.x, this.center.y ],\r\n\t\t\trotation: this.rotation,\r\n\r\n\t\t\twrap: [ this.wrapS, this.wrapT ],\r\n\r\n\t\t\tformat: this.format,\r\n\t\t\tminFilter: this.minFilter,\r\n\t\t\tmagFilter: this.magFilter,\r\n\t\t\tanisotropy: this.anisotropy,\r\n\r\n\t\t\tflipY: this.flipY\r\n\r\n\t\t};\r\n\r\n\t\tif ( this.image !== undefined ) {\r\n\r\n\t\t\t// TODO: Move to Image\r\n\r\n\t\t\tvar image = this.image;\r\n\r\n\t\t\tif ( image.uuid === undefined ) {\r\n\r\n\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\r\n\r\n\t\t\t\tvar url;\r\n\r\n\t\t\t\tif ( Array.isArray( image ) ) {\r\n\r\n\t\t\t\t\t// process array of images e.g. CubeTexture\r\n\r\n\t\t\t\t\turl = [];\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = image.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\turl.push( ImageUtils.getDataURL( image[ i ] ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// process single image\r\n\r\n\t\t\t\t\turl = ImageUtils.getDataURL( image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmeta.images[ image.uuid ] = {\r\n\t\t\t\t\tuuid: image.uuid,\r\n\t\t\t\t\turl: url\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutput.image = image.uuid;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! isRootObject ) {\r\n\r\n\t\t\tmeta.textures[ this.uuid ] = output;\r\n\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t},\r\n\r\n\ttransformUv: function ( uv ) {\r\n\r\n\t\tif ( this.mapping !== UVMapping ) { return uv; }\r\n\r\n\t\tuv.applyMatrix3( this.matrix );\r\n\r\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\r\n\r\n\t\t\tswitch ( this.wrapS ) {\r\n\r\n\t\t\t\tcase RepeatWrapping:\r\n\r\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase ClampToEdgeWrapping:\r\n\r\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase MirroredRepeatWrapping:\r\n\r\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\r\n\r\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\r\n\r\n\t\t\tswitch ( this.wrapT ) {\r\n\r\n\t\t\t\tcase RepeatWrapping:\r\n\r\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase ClampToEdgeWrapping:\r\n\r\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase MirroredRepeatWrapping:\r\n\r\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\r\n\r\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.flipY ) {\r\n\r\n\t\t\tuv.y = 1 - uv.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.defineProperty( Texture.prototype, \"needsUpdate\", {\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value === true ) { this.version ++; }\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLRenderTarget( width, height, options ) {\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.scissor = new Vector4( 0, 0, width, height );\r\n\tthis.scissorTest = false;\r\n\r\n\tthis.viewport = new Vector4( 0, 0, width, height );\r\n\r\n\toptions = options || {};\r\n\r\n\tif ( options.minFilter === undefined ) { options.minFilter = LinearFilter; }\r\n\r\n\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\r\n\r\n\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : true;\r\n\r\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\r\n\r\n}\r\n\r\nWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\r\n\r\n\tconstructor: WebGLRenderTarget,\r\n\r\n\tisWebGLRenderTarget: true,\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tif ( this.width !== width || this.height !== height ) {\r\n\r\n\t\t\tthis.width = width;\r\n\t\t\tthis.height = height;\r\n\r\n\t\t\tthis.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.viewport.set( 0, 0, width, height );\r\n\t\tthis.scissor.set( 0, 0, width, height );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.width = source.width;\r\n\t\tthis.height = source.height;\r\n\r\n\t\tthis.viewport.copy( source.viewport );\r\n\r\n\t\tthis.texture = source.texture.clone();\r\n\r\n\t\tthis.depthBuffer = source.depthBuffer;\r\n\t\tthis.stencilBuffer = source.stencilBuffer;\r\n\t\tthis.depthTexture = source.depthTexture;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// PlaneGeometry\r\n\r\nfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'PlaneGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nPlaneGeometry.prototype = Object.create( Geometry.prototype );\r\nPlaneGeometry.prototype.constructor = PlaneGeometry;\r\n\r\n// PlaneBufferGeometry\r\n\r\nfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'PlaneBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\twidth = width || 1;\r\n\theight = height || 1;\r\n\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\r\n\tvar gridX = Math.floor( widthSegments ) || 1;\r\n\tvar gridY = Math.floor( heightSegments ) || 1;\r\n\r\n\tvar gridX1 = gridX + 1;\r\n\tvar gridY1 = gridY + 1;\r\n\r\n\tvar segment_width = width / gridX;\r\n\tvar segment_height = height / gridY;\r\n\r\n\tvar ix, iy;\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\tvar y = iy * segment_height - height_half;\r\n\r\n\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\tvar x = ix * segment_width - width_half;\r\n\r\n\t\t\tvertices.push( x, - y, 0 );\r\n\r\n\t\t\tnormals.push( 0, 0, 1 );\r\n\r\n\t\t\tuvs.push( ix / gridX );\r\n\t\t\tuvs.push( 1 - ( iy / gridY ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// indices\r\n\r\n\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t// faces\r\n\r\n\t\t\tindices.push( a, b, d );\r\n\t\t\tindices.push( b, c, d );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n}\r\n\r\nPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BokehShader = {\r\n\r\n\tdefines: {\r\n\t\t\"DEPTH_PACKING\": 1,\r\n\t\t\"PERSPECTIVE_CAMERA\": 1,\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tColor\":   { value: null },\r\n\t\t\"tDepth\":   { value: null },\r\n\t\t\"focus\":    { value: 1.0 },\r\n\t\t\"aspect\":   { value: 1.0 },\r\n\t\t\"aperture\": { value: 0.025 },\r\n\t\t\"maxblur\":  { value: 1.0 },\r\n\t\t\"nearClip\":  { value: 1.0 },\r\n\t\t\"farClip\":  { value: 1000.0 },\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\t\t\"#include <common>\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"uniform sampler2D tColor;\",\r\n\t\t\"uniform sampler2D tDepth;\",\r\n\r\n\t\t\"uniform float maxblur;\",  // max blur amount\r\n\t\t\"uniform float aperture;\", // aperture - bigger values for shallower depth of field\r\n\r\n\t\t\"uniform float nearClip;\",\r\n\t\t\"uniform float farClip;\",\r\n\r\n\t\t\"uniform float focus;\",\r\n\t\t\"uniform float aspect;\",\r\n\r\n\t\t\"#include <packing>\",\r\n\r\n\t\t\"float getDepth( const in vec2 screenPosition ) {\",\r\n\t\t\"\t#if DEPTH_PACKING == 1\",\r\n\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\r\n\t\t\"\t#else\",\r\n\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\r\n\t\t\"\t#endif\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float getViewZ( const in float depth ) {\",\r\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\r\n\t\t\"\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\",\r\n\t\t\"\t#else\",\r\n\t\t\"\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\",\r\n\t\t\"\t#endif\",\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 aspectcorrect = vec2( 1.0, aspect );\",\r\n\t\r\n\t\t\t\"float viewZ = getViewZ( getDepth( vUv ) );\",\r\n\r\n\t\t\t\"float factor = ( focus + viewZ );\",  // viewZ is <= 0, so this is a difference equation\r\n\r\n\t\t\t\"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\",\r\n\r\n\t\t\t\"vec2 dofblur9 = dofblur * 0.9;\",\r\n\t\t\t\"vec2 dofblur7 = dofblur * 0.7;\",\r\n\t\t\t\"vec2 dofblur4 = dofblur * 0.4;\",\r\n\r\n\t\t\t\"vec4 col = vec4( 0.0 );\",\r\n\r\n\t\t\t\"col += texture2D( tColor, vUv.xy );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\r\n\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\r\n\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\",\r\n\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\r\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\",\r\n\r\n\t\t\t\"gl_FragColor = col / 41.0;\",\r\n\t\t\t\"gl_FragColor.a = 1.0;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BokehShader2 = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"textureWidth\":  { value: 1.0 },\r\n\t\t\"textureHeight\":  { value: 1.0 },\r\n\r\n\t\t\"focalDepth\":   { value: 1.0 },\r\n\t\t\"focalLength\":   { value: 24.0 },\r\n\t\t\"fstop\": { value: 0.9 },\r\n\r\n\t\t\"tColor\":   { value: null },\r\n\t\t\"tDepth\":   { value: null },\r\n\r\n\t\t\"maxblur\":  { value: 1.0 },\r\n\r\n\t\t\"showFocus\":   { value: 0 },\r\n\t\t\"manualdof\":   { value: 0 },\r\n\t\t\"vignetting\":   { value: 0 },\r\n\t\t\"depthblur\":   { value: 0 },\r\n\r\n\t\t\"threshold\":  { value: 0.5 },\r\n\t\t\"gain\":  { value: 2.0 },\r\n\t\t\"bias\":  { value: 0.5 },\r\n\t\t\"fringe\":  { value: 0.7 },\r\n\r\n\t\t\"znear\":  { value: 0.1 },\r\n\t\t\"zfar\":  { value: 100 },\r\n\r\n\t\t\"noise\":  { value: 1 },\r\n\t\t\"dithering\":  { value: 0.0001 },\r\n\t\t\"pentagon\": { value: 0 },\r\n\r\n\t\t\"shaderFocus\":  { value: 1 },\r\n\t\t\"focusCoords\":  { value: new Vector2() }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"#include <common>\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"uniform sampler2D tColor;\",\r\n\t\t\"uniform sampler2D tDepth;\",\r\n\t\t\"uniform float textureWidth;\",\r\n\t\t\"uniform float textureHeight;\",\r\n\r\n\t\t\"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\",\r\n\t\t\"uniform float focalLength; //focal length in mm\",\r\n\t\t\"uniform float fstop; //f-stop value\",\r\n\t\t\"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\",\r\n\r\n\t\t\"\",\r\n\r\n\t\t\"uniform float znear; // camera clipping start\",\r\n\t\t\"uniform float zfar; // camera clipping end\",\r\n\r\n\t\t\"//------------------------------------------\",\r\n\t\t\"//user variables\",\r\n\r\n\t\t\"const int samples = SAMPLES; //samples on the first ring\",\r\n\t\t\"const int rings = RINGS; //ring count\",\r\n\r\n\t\t\"const int maxringsamples = rings * samples;\",\r\n\r\n\t\t\"uniform bool manualdof; // manual dof calculation\",\r\n\t\t\"float ndofstart = 1.0; // near dof blur start\",\r\n\t\t\"float ndofdist = 2.0; // near dof blur falloff distance\",\r\n\t\t\"float fdofstart = 1.0; // far dof blur start\",\r\n\t\t\"float fdofdist = 3.0; // far dof blur falloff distance\",\r\n\r\n\t\t\"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\",\r\n\r\n\t\t\"uniform bool vignetting; // use optical lens vignetting\",\r\n\r\n\t\t\"float vignout = 1.3; // vignetting outer border\",\r\n\t\t\"float vignin = 0.0; // vignetting inner border\",\r\n\t\t\"float vignfade = 22.0; // f-stops till vignete fades\",\r\n\r\n\t\t\"uniform bool shaderFocus;\",\r\n\t\t\"// disable if you use external focalDepth value\",\r\n\r\n\t\t\"uniform vec2 focusCoords;\",\r\n\t\t\"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\",\r\n\t\t\"// if center of screen use vec2(0.5, 0.5);\",\r\n\r\n\t\t\"uniform float maxblur;\",\r\n\t\t\"//clamp value of max blur (0.0 = no blur, 1.0 default)\",\r\n\r\n\t\t\"uniform float threshold; // highlight threshold;\",\r\n\t\t\"uniform float gain; // highlight gain;\",\r\n\r\n\t\t\"uniform float bias; // bokeh edge bias\",\r\n\t\t\"uniform float fringe; // bokeh chromatic aberration / fringing\",\r\n\r\n\t\t\"uniform bool noise; //use noise instead of pattern for sample dithering\",\r\n\r\n\t\t\"uniform float dithering;\",\r\n\r\n\t\t\"uniform bool depthblur; // blur the depth buffer\",\r\n\t\t\"float dbsize = 1.25; // depth blur size\",\r\n\r\n\t\t\"\",\r\n\r\n\t\t\"uniform bool pentagon; //use pentagon as bokeh shape?\",\r\n\t\t\"float feather = 0.4; //pentagon shape feather\",\r\n\r\n\t\t\"//------------------------------------------\",\r\n\r\n\t\t\"float penta(vec2 coords) {\",\r\n\t\t\t\"//pentagonal shape\",\r\n\t\t\t\"float scale = float(rings) - 1.3;\",\r\n\t\t\t\"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\",\r\n\t\t\t\"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\",\r\n\t\t\t\"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\",\r\n\t\t\t\"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\",\r\n\t\t\t\"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\",\r\n\t\t\t\"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\",\r\n\r\n\t\t\t\"vec4  one = vec4( 1.0 );\",\r\n\r\n\t\t\t\"vec4 P = vec4((coords),vec2(scale, scale));\",\r\n\r\n\t\t\t\"vec4 dist = vec4(0.0);\",\r\n\t\t\t\"float inorout = -4.0;\",\r\n\r\n\t\t\t\"dist.x = dot( P, HS0 );\",\r\n\t\t\t\"dist.y = dot( P, HS1 );\",\r\n\t\t\t\"dist.z = dot( P, HS2 );\",\r\n\t\t\t\"dist.w = dot( P, HS3 );\",\r\n\r\n\t\t\t\"dist = smoothstep( -feather, feather, dist );\",\r\n\r\n\t\t\t\"inorout += dot( dist, one );\",\r\n\r\n\t\t\t\"dist.x = dot( P, HS4 );\",\r\n\t\t\t\"dist.y = HS5.w - abs( P.z );\",\r\n\r\n\t\t\t\"dist = smoothstep( -feather, feather, dist );\",\r\n\t\t\t\"inorout += dist.x;\",\r\n\r\n\t\t\t\"return clamp( inorout, 0.0, 1.0 );\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float bdepth(vec2 coords) {\",\r\n\t\t\t\"// Depth buffer blur\",\r\n\t\t\t\"float d = 0.0;\",\r\n\t\t\t\"float kernel[9];\",\r\n\t\t\t\"vec2 offset[9];\",\r\n\r\n\t\t\t\"vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\",\r\n\r\n\t\t\t\"offset[0] = vec2(-wh.x,-wh.y);\",\r\n\t\t\t\"offset[1] = vec2( 0.0, -wh.y);\",\r\n\t\t\t\"offset[2] = vec2( wh.x -wh.y);\",\r\n\r\n\t\t\t\"offset[3] = vec2(-wh.x,  0.0);\",\r\n\t\t\t\"offset[4] = vec2( 0.0,   0.0);\",\r\n\t\t\t\"offset[5] = vec2( wh.x,  0.0);\",\r\n\r\n\t\t\t\"offset[6] = vec2(-wh.x, wh.y);\",\r\n\t\t\t\"offset[7] = vec2( 0.0,  wh.y);\",\r\n\t\t\t\"offset[8] = vec2( wh.x, wh.y);\",\r\n\r\n\t\t\t\"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\",\r\n\t\t\t\"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\",\r\n\t\t\t\"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\",\r\n\r\n\t\t\t\"for( int i=0; i<9; i++ ) {\",\r\n\t\t\t\t\"float tmp = texture2D(tDepth, coords + offset[i]).r;\",\r\n\t\t\t\t\"d += tmp * kernel[i];\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"return d;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"vec3 color(vec2 coords,float blur) {\",\r\n\t\t\t\"//processing the sample\",\r\n\r\n\t\t\t\"vec3 col = vec3(0.0);\",\r\n\t\t\t\"vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\",\r\n\r\n\t\t\t\"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\",\r\n\t\t\t\"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\",\r\n\t\t\t\"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\",\r\n\r\n\t\t\t\"vec3 lumcoeff = vec3(0.299,0.587,0.114);\",\r\n\t\t\t\"float lum = dot(col.rgb, lumcoeff);\",\r\n\t\t\t\"float thresh = max((lum-threshold)*gain, 0.0);\",\r\n\t\t\t\"return col+mix(vec3(0.0),col,thresh*blur);\",\r\n\t\t\"}\",\r\n\r\n\t\t\"vec3 debugFocus(vec3 col, float blur, float depth) {\",\r\n\t\t\t\"float edge = 0.002*depth; //distance based edge smoothing\",\r\n\t\t\t\"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\",\r\n\t\t\t\"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\",\r\n\r\n\t\t\t\"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\",\r\n\t\t\t\"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\",\r\n\r\n\t\t\t\"return col;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float linearize(float depth) {\",\r\n\t\t\t\"return -zfar * znear / (depth * (zfar - znear) - zfar);\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float vignette() {\",\r\n\t\t\t\"float dist = distance(vUv.xy, vec2(0.5,0.5));\",\r\n\t\t\t\"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\",\r\n\t\t\t\"return clamp(dist,0.0,1.0);\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\",\r\n\t\t\t\"float rings2 = float(rings);\",\r\n\t\t\t\"float step = PI*2.0 / float(ringsamples);\",\r\n\t\t\t\"float pw = cos(j*step)*i;\",\r\n\t\t\t\"float ph = sin(j*step)*i;\",\r\n\t\t\t\"float p = 1.0;\",\r\n\t\t\t\"if (pentagon) {\",\r\n\t\t\t\t\"p = penta(vec2(pw,ph));\",\r\n\t\t\t\"}\",\r\n\t\t\t\"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\",\r\n\t\t\t\"return 1.0 * mix(1.0, i /rings2, bias) * p;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\t\t\t\"//scene depth calculation\",\r\n\r\n\t\t\t\"float depth = linearize(texture2D(tDepth,vUv.xy).x);\",\r\n\r\n\t\t\t\"// Blur depth?\",\r\n\t\t\t\"if ( depthblur ) {\",\r\n\t\t\t\t\"depth = linearize(bdepth(vUv.xy));\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"//focal plane calculation\",\r\n\r\n\t\t\t\"float fDepth = focalDepth;\",\r\n\r\n\t\t\t\"if (shaderFocus) {\",\r\n\r\n\t\t\t\t\"fDepth = linearize(texture2D(tDepth,focusCoords).x);\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"// dof blur factor calculation\",\r\n\r\n\t\t\t\"float blur = 0.0;\",\r\n\r\n\t\t\t\"if (manualdof) {\",\r\n\t\t\t\t\"float a = depth-fDepth; // Focal plane\",\r\n\t\t\t\t\"float b = (a-fdofstart)/fdofdist; // Far DoF\",\r\n\t\t\t\t\"float c = (-a-ndofstart)/ndofdist; // Near Dof\",\r\n\t\t\t\t\"blur = (a>0.0) ? b : c;\",\r\n\t\t\t\"} else {\",\r\n\t\t\t\t\"float f = focalLength; // focal length in mm\",\r\n\t\t\t\t\"float d = fDepth*1000.0; // focal plane in mm\",\r\n\t\t\t\t\"float o = depth*1000.0; // depth in mm\",\r\n\r\n\t\t\t\t\"float a = (o*f)/(o-f);\",\r\n\t\t\t\t\"float b = (d*f)/(d-f);\",\r\n\t\t\t\t\"float c = (d-f)/(d*fstop*CoC);\",\r\n\r\n\t\t\t\t\"blur = abs(a-b)*c;\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"blur = clamp(blur,0.0,1.0);\",\r\n\r\n\t\t\t\"// calculation of pattern for dithering\",\r\n\r\n\t\t\t\"vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\",\r\n\r\n\t\t\t\"// getting blur x and y step factor\",\r\n\r\n\t\t\t\"float w = (1.0/textureWidth)*blur*maxblur+noise.x;\",\r\n\t\t\t\"float h = (1.0/textureHeight)*blur*maxblur+noise.y;\",\r\n\r\n\t\t\t\"// calculation of final color\",\r\n\r\n\t\t\t\"vec3 col = vec3(0.0);\",\r\n\r\n\t\t\t\"if(blur < 0.05) {\",\r\n\t\t\t\t\"//some optimization thingy\",\r\n\t\t\t\t\"col = texture2D(tColor, vUv.xy).rgb;\",\r\n\t\t\t\"} else {\",\r\n\t\t\t\t\"col = texture2D(tColor, vUv.xy).rgb;\",\r\n\t\t\t\t\"float s = 1.0;\",\r\n\t\t\t\t\"int ringsamples;\",\r\n\r\n\t\t\t\t\"for (int i = 1; i <= rings; i++) {\",\r\n\t\t\t\t\t\"\",\r\n\t\t\t\t\t\"ringsamples = i * samples;\",\r\n\r\n\t\t\t\t\t\"for (int j = 0 ; j < maxringsamples ; j++) {\",\r\n\t\t\t\t\t\t\"if (j >= ringsamples) break;\",\r\n\t\t\t\t\t\t\"s += gather(float(i), float(j), ringsamples, col, w, h, blur);\",\r\n\t\t\t\t\t\"}\",\r\n\t\t\t\t\t\"\",\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"col /= s; //divide by sample count\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"if (showFocus) {\",\r\n\t\t\t\t\"col = debugFocus(col, blur, depth);\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"if (vignetting) {\",\r\n\t\t\t\t\"col *= vignette();\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor.rgb = col;\",\r\n\t\t\t\"gl_FragColor.a = 1.0;\",\r\n\t\t\"} \"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\r\n\r\nvar BokehDepthShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"mNear\": { value: 1.0 },\r\n\t\t\"mFar\": { value: 1000.0 },\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying float vViewZDepth;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\"\t#include <begin_vertex>\",\r\n\t\t\"\t#include <project_vertex>\",\r\n\r\n\t\t\"\tvViewZDepth = - mvPosition.z;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float mNear;\",\r\n\t\t\"uniform float mFar;\",\r\n\r\n\t\t\"varying float vViewZDepth;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\"\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\",\r\n\t\t\"\tgl_FragColor = vec4( vec3( color ), 1.0 );\",\r\n\r\n\t\t\"} \"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar CinematicCamera = function ( fov, aspect, near, far ) {\r\n\r\n\tPerspectiveCamera.call( this, fov, aspect, near, far );\r\n\r\n\tthis.type = 'CinematicCamera';\r\n\r\n\tthis.postprocessing = { enabled: true };\r\n\tthis.shaderSettings = {\r\n\t\trings: 3,\r\n\t\tsamples: 4\r\n\t};\r\n\r\n\tvar depthShader = BokehDepthShader;\r\n\r\n\tthis.materialDepth = new ShaderMaterial( {\r\n\t\tuniforms: depthShader.uniforms,\r\n\t\tvertexShader: depthShader.vertexShader,\r\n\t\tfragmentShader: depthShader.fragmentShader\r\n\t} );\r\n\r\n\tthis.materialDepth.uniforms[ 'mNear' ].value = near;\r\n\tthis.materialDepth.uniforms[ 'mFar' ].value = far;\r\n\r\n\t// In case of cinematicCamera, having a default lens set is important\r\n\tthis.setLens();\r\n\r\n\tthis.initPostProcessing();\r\n\r\n};\r\n\r\nCinematicCamera.prototype = Object.create( PerspectiveCamera.prototype );\r\nCinematicCamera.prototype.constructor = CinematicCamera;\r\n\r\n// providing fnumber and coc(Circle of Confusion) as extra arguments\r\nCinematicCamera.prototype.setLens = function ( focalLength, filmGauge, fNumber, coc ) {\r\n\r\n\t// In case of cinematicCamera, having a default lens set is important\r\n\tif ( focalLength === undefined ) { focalLength = 35; }\r\n\tif ( filmGauge !== undefined ) { this.filmGauge = filmGauge; }\r\n\r\n\tthis.setFocalLength( focalLength );\r\n\r\n\t// if fnumber and coc are not provided, cinematicCamera tries to act as a basic PerspectiveCamera\r\n\tif ( fNumber === undefined ) { fNumber = 8; }\r\n\tif ( coc === undefined ) { coc = 0.019; }\r\n\r\n\tthis.fNumber = fNumber;\r\n\tthis.coc = coc;\r\n\r\n\t// fNumber is focalLength by aperture\r\n\tthis.aperture = focalLength / this.fNumber;\r\n\r\n\t// hyperFocal is required to calculate depthOfField when a lens tries to focus at a distance with given fNumber and focalLength\r\n\tthis.hyperFocal = ( focalLength * focalLength ) / ( this.aperture * this.coc );\r\n\r\n};\r\n\r\nCinematicCamera.prototype.linearize = function ( depth ) {\r\n\r\n\tvar zfar = this.far;\r\n\tvar znear = this.near;\r\n\treturn - zfar * znear / ( depth * ( zfar - znear ) - zfar );\r\n\r\n};\r\n\r\nCinematicCamera.prototype.smoothstep = function ( near, far, depth ) {\r\n\r\n\tvar x = this.saturate( ( depth - near ) / ( far - near ) );\r\n\treturn x * x * ( 3 - 2 * x );\r\n\r\n};\r\n\r\nCinematicCamera.prototype.saturate = function ( x ) {\r\n\r\n\treturn Math.max( 0, Math.min( 1, x ) );\r\n\r\n};\r\n\r\n// function for focusing at a distance from the camera\r\nCinematicCamera.prototype.focusAt = function ( focusDistance ) {\r\n\r\n\tif ( focusDistance === undefined ) { focusDistance = 20; }\r\n\r\n\tvar focalLength = this.getFocalLength();\r\n\r\n\t// distance from the camera (normal to frustrum) to focus on\r\n\tthis.focus = focusDistance;\r\n\r\n\t// the nearest point from the camera which is in focus (unused)\r\n\tthis.nearPoint = ( this.hyperFocal * this.focus ) / ( this.hyperFocal + ( this.focus - focalLength ) );\r\n\r\n\t// the farthest point from the camera which is in focus (unused)\r\n\tthis.farPoint = ( this.hyperFocal * this.focus ) / ( this.hyperFocal - ( this.focus - focalLength ) );\r\n\r\n\t// the gap or width of the space in which is everything is in focus (unused)\r\n\tthis.depthOfField = this.farPoint - this.nearPoint;\r\n\r\n\t// Considering minimum distance of focus for a standard lens (unused)\r\n\tif ( this.depthOfField < 0 ) { this.depthOfField = 0; }\r\n\r\n\tthis.sdistance = this.smoothstep( this.near, this.far, this.focus );\r\n\r\n\tthis.ldistance = this.linearize( 1 -\tthis.sdistance );\r\n\r\n\tthis.postprocessing.bokeh_uniforms[ 'focalDepth' ].value = this.ldistance;\r\n\r\n};\r\n\r\nCinematicCamera.prototype.initPostProcessing = function () {\r\n\r\n\tif ( this.postprocessing.enabled ) {\r\n\r\n\t\tthis.postprocessing.scene = new Scene();\r\n\r\n\t\tthis.postprocessing.camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2,\twindow.innerHeight / 2, window.innerHeight / - 2, - 10000, 10000 );\r\n\r\n\t\tthis.postprocessing.scene.add( this.postprocessing.camera );\r\n\r\n\t\tvar pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBFormat };\r\n\t\tthis.postprocessing.rtTextureDepth = new WebGLRenderTarget( window.innerWidth, window.innerHeight, pars );\r\n\t\tthis.postprocessing.rtTextureColor = new WebGLRenderTarget( window.innerWidth, window.innerHeight, pars );\r\n\r\n\t\tvar bokeh_shader = BokehShader;\r\n\r\n\t\tthis.postprocessing.bokeh_uniforms = UniformsUtils.clone( bokeh_shader.uniforms );\r\n\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"tColor\" ].value = this.postprocessing.rtTextureColor.texture;\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"tDepth\" ].value = this.postprocessing.rtTextureDepth.texture;\r\n\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"manualdof\" ].value = 0;\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"shaderFocus\" ].value = 0;\r\n\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"fstop\" ].value = 2.8;\r\n\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"showFocus\" ].value = 1;\r\n\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"focalDepth\" ].value = 0.1;\r\n\r\n\t\t//console.log( this.postprocessing.bokeh_uniforms[ \"focalDepth\" ].value );\r\n\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"znear\" ].value = this.near;\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"zfar\" ].value = this.near;\r\n\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"textureWidth\" ].value = window.innerWidth;\r\n\r\n\t\tthis.postprocessing.bokeh_uniforms[ \"textureHeight\" ].value = window.innerHeight;\r\n\r\n\t\tthis.postprocessing.materialBokeh = new ShaderMaterial( {\r\n\t\t\tuniforms: this.postprocessing.bokeh_uniforms,\r\n\t\t\tvertexShader: bokeh_shader.vertexShader,\r\n\t\t\tfragmentShader: bokeh_shader.fragmentShader,\r\n\t\t\tdefines: {\r\n\t\t\t\tRINGS: this.shaderSettings.rings,\r\n\t\t\t\tSAMPLES: this.shaderSettings.samples,\r\n\t\t\t\tDEPTH_PACKING: 1\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t\tthis.postprocessing.quad = new Mesh( new PlaneBufferGeometry( window.innerWidth, window.innerHeight ), this.postprocessing.materialBokeh );\r\n\t\tthis.postprocessing.quad.position.z = - 500;\r\n\t\tthis.postprocessing.scene.add( this.postprocessing.quad );\r\n\r\n\t}\r\n\r\n};\r\n\r\nCinematicCamera.prototype.renderCinematic = function ( scene, renderer ) {\r\n\r\n\tif ( this.postprocessing.enabled ) {\r\n\r\n\t\trenderer.clear();\r\n\r\n\t\t// Render scene into texture\r\n\r\n\t\tscene.overrideMaterial = null;\r\n\t\trenderer.render( scene, camera, this.postprocessing.rtTextureColor, true );\r\n\r\n\t\t// Render depth into texture\r\n\r\n\t\tscene.overrideMaterial = this.materialDepth;\r\n\t\trenderer.render( scene, camera, this.postprocessing.rtTextureDepth, true );\r\n\r\n\t\t// Render bokeh composite\r\n\r\n\t\trenderer.render( this.postprocessing.scene, this.postprocessing.camera );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Cache = {\r\n\r\n\tenabled: false,\r\n\r\n\tfiles: {},\r\n\r\n\tadd: function ( key, file ) {\r\n\r\n\t\tif ( this.enabled === false ) { return; }\r\n\r\n\t\t// console.log( 'Cache', 'Adding key:', key );\r\n\r\n\t\tthis.files[ key ] = file;\r\n\r\n\t},\r\n\r\n\tget: function ( key ) {\r\n\r\n\t\tif ( this.enabled === false ) { return; }\r\n\r\n\t\t// console.log( 'Cache', 'Checking key:', key );\r\n\r\n\t\treturn this.files[ key ];\r\n\r\n\t},\r\n\r\n\tremove: function ( key ) {\r\n\r\n\t\tdelete this.files[ key ];\r\n\r\n\t},\r\n\r\n\tclear: function () {\r\n\r\n\t\tthis.files = {};\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LoadingManager( onLoad, onProgress, onError ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar isLoading = false;\r\n\tvar itemsLoaded = 0;\r\n\tvar itemsTotal = 0;\r\n\tvar urlModifier = undefined;\r\n\r\n\t// Refer to #5689 for the reason why we don't set .onStart\r\n\t// in the constructor\r\n\r\n\tthis.onStart = undefined;\r\n\tthis.onLoad = onLoad;\r\n\tthis.onProgress = onProgress;\r\n\tthis.onError = onError;\r\n\r\n\tthis.itemStart = function ( url ) {\r\n\r\n\t\titemsTotal ++;\r\n\r\n\t\tif ( isLoading === false ) {\r\n\r\n\t\t\tif ( scope.onStart !== undefined ) {\r\n\r\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tisLoading = true;\r\n\r\n\t};\r\n\r\n\tthis.itemEnd = function ( url ) {\r\n\r\n\t\titemsLoaded ++;\r\n\r\n\t\tif ( scope.onProgress !== undefined ) {\r\n\r\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\r\n\r\n\t\t}\r\n\r\n\t\tif ( itemsLoaded === itemsTotal ) {\r\n\r\n\t\t\tisLoading = false;\r\n\r\n\t\t\tif ( scope.onLoad !== undefined ) {\r\n\r\n\t\t\t\tscope.onLoad();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.itemError = function ( url ) {\r\n\r\n\t\tif ( scope.onError !== undefined ) {\r\n\r\n\t\t\tscope.onError( url );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.resolveURL = function ( url ) {\r\n\r\n\t\tif ( urlModifier ) {\r\n\r\n\t\t\treturn urlModifier( url );\r\n\r\n\t\t}\r\n\r\n\t\treturn url;\r\n\r\n\t};\r\n\r\n\tthis.setURLModifier = function ( transform ) {\r\n\r\n\t\turlModifier = transform;\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n}\r\n\r\nvar DefaultLoadingManager = new LoadingManager();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar loading = {};\r\n\r\nfunction FileLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n}\r\n\r\nObject.assign( FileLoader.prototype, {\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( url === undefined ) { url = ''; }\r\n\r\n\t\tif ( this.path !== undefined ) { url = this.path + url; }\r\n\r\n\t\turl = this.manager.resolveURL( url );\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\tif ( onLoad ) { onLoad( cached ); }\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t}, 0 );\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\t// Check if request is duplicate\r\n\r\n\t\tif ( loading[ url ] !== undefined ) {\r\n\r\n\t\t\tloading[ url ].push( {\r\n\r\n\t\t\t\tonLoad: onLoad,\r\n\t\t\t\tonProgress: onProgress,\r\n\t\t\t\tonError: onError\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// Check for data: URI\r\n\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\r\n\t\tvar dataUriRegexResult = url.match( dataUriRegex );\r\n\r\n\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\r\n\t\tif ( dataUriRegexResult ) {\r\n\r\n\t\t\tvar mimeType = dataUriRegexResult[ 1 ];\r\n\t\t\tvar isBase64 = !! dataUriRegexResult[ 2 ];\r\n\t\t\tvar data = dataUriRegexResult[ 3 ];\r\n\r\n\t\t\tdata = window.decodeURIComponent( data );\r\n\r\n\t\t\tif ( isBase64 ) { data = window.atob( data ); }\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tvar response;\r\n\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\r\n\r\n\t\t\t\tswitch ( responseType ) {\r\n\r\n\t\t\t\t\tcase 'arraybuffer':\r\n\t\t\t\t\tcase 'blob':\r\n\r\n\t\t\t\t\t\tvar view = new Uint8Array( data.length );\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( responseType === 'blob' ) {\r\n\r\n\t\t\t\t\t\t\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tresponse = view.buffer;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'document':\r\n\r\n\t\t\t\t\t\tvar parser = new DOMParser();\r\n\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'json':\r\n\r\n\t\t\t\t\t\tresponse = JSON.parse( data );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault: // 'text' or other\r\n\r\n\t\t\t\t\t\tresponse = data;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\r\n\t\t\t\twindow.setTimeout( function () {\r\n\r\n\t\t\t\t\tif ( onLoad ) { onLoad( response ); }\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t}, 0 );\r\n\r\n\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\r\n\t\t\t\twindow.setTimeout( function () {\r\n\r\n\t\t\t\t\tif ( onError ) { onError( error ); }\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t\t}, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Initialise array for duplicate requests\r\n\r\n\t\t\tloading[ url ] = [];\r\n\r\n\t\t\tloading[ url ].push( {\r\n\r\n\t\t\t\tonLoad: onLoad,\r\n\t\t\t\tonProgress: onProgress,\r\n\t\t\t\tonError: onError\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\t\trequest.open( 'GET', url, true );\r\n\r\n\t\t\trequest.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\t\tvar response = this.response;\r\n\r\n\t\t\t\tCache.add( url, response );\r\n\r\n\t\t\t\tvar callbacks = loading[ url ];\r\n\r\n\t\t\t\tdelete loading[ url ];\r\n\r\n\t\t\t\tif ( this.status === 200 || this.status === 0 ) {\r\n\r\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\r\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\r\n\r\n\t\t\t\t\tif ( this.status === 0 ) { console.warn( 'FileLoader: HTTP Status 0 received.' ); }\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar callback = callbacks[ i ];\r\n\t\t\t\t\t\tif ( callback.onLoad ) { callback.onLoad( response ); }\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar callback = callbacks[ i ];\r\n\t\t\t\t\t\tif ( callback.onError ) { callback.onError( event ); }\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tvar callbacks = loading[ url ];\r\n\r\n\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar callback = callbacks[ i ];\r\n\t\t\t\t\tif ( callback.onProgress ) { callback.onProgress( event ); }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t\trequest.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\t\tvar callbacks = loading[ url ];\r\n\r\n\t\t\t\tdelete loading[ url ];\r\n\r\n\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar callback = callbacks[ i ];\r\n\t\t\t\t\tif ( callback.onError ) { callback.onError( event ); }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t\trequest.addEventListener( 'abort', function ( event ) {\r\n\r\n\t\t\t\tvar callbacks = loading[ url ];\r\n\r\n\t\t\t\tdelete loading[ url ];\r\n\r\n\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar callback = callbacks[ i ];\r\n\t\t\t\t\tif ( callback.onError ) { callback.onError( event ); }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t\tif ( this.responseType !== undefined ) { request.responseType = this.responseType; }\r\n\t\t\tif ( this.withCredentials !== undefined ) { request.withCredentials = this.withCredentials; }\r\n\r\n\t\t\tif ( request.overrideMimeType ) { request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' ); }\r\n\r\n\t\t\tfor ( var header in this$1.requestHeader ) {\r\n\r\n\t\t\t\trequest.setRequestHeader( header, this$1.requestHeader[ header ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\trequest.send( null );\r\n\r\n\t\t}\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\treturn request;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetResponseType: function ( value ) {\r\n\r\n\t\tthis.responseType = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetWithCredentials: function ( value ) {\r\n\r\n\t\tthis.withCredentials = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetMimeType: function ( value ) {\r\n\r\n\t\tthis.mimeType = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRequestHeader: function ( value ) {\r\n\r\n\t\tthis.requestHeader = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LineDashedMaterial( parameters ) {\r\n\r\n\tLineBasicMaterial.call( this );\r\n\r\n\tthis.type = 'LineDashedMaterial';\r\n\r\n\tthis.scale = 1;\r\n\tthis.dashSize = 3;\r\n\tthis.gapSize = 1;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nLineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );\r\nLineDashedMaterial.prototype.constructor = LineDashedMaterial;\r\n\r\nLineDashedMaterial.prototype.isLineDashedMaterial = true;\r\n\r\nLineDashedMaterial.prototype.copy = function ( source ) {\r\n\r\n\tLineBasicMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.scale = source.scale;\r\n\tthis.dashSize = source.dashSize;\r\n\tthis.gapSize = source.gapSize;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshDepthMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'MeshDepthMaterial';\r\n\r\n\tthis.depthPacking = BasicDepthPacking;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false;\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nMeshDepthMaterial.prototype = Object.create( Material.prototype );\r\nMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\r\n\r\nMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\r\n\r\nMeshDepthMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.depthPacking = source.depthPacking;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshDistanceMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'MeshDistanceMaterial';\r\n\r\n\tthis.referencePosition = new Vector3();\r\n\tthis.nearDistance = 1;\r\n\tthis.farDistance = 1000;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.fog = false;\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nMeshDistanceMaterial.prototype = Object.create( Material.prototype );\r\nMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\r\n\r\nMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\r\n\r\nMeshDistanceMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.referencePosition.copy( source.referencePosition );\r\n\tthis.nearDistance = source.nearDistance;\r\n\tthis.farDistance = source.farDistance;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshLambertMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'MeshLambertMaterial';\r\n\r\n\tthis.color = new Color( 0xffffff ); // diffuse\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nMeshLambertMaterial.prototype = Object.create( Material.prototype );\r\nMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\r\n\r\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\r\n\r\nMeshLambertMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshNormalMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'MeshNormalMaterial';\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalMapType = TangentSpaceNormalMap;\r\n\tthis.normalScale = new Vector2( 1, 1 );\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false;\r\n\tthis.lights = false;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nMeshNormalMaterial.prototype = Object.create( Material.prototype );\r\nMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\r\n\r\nMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\r\n\r\nMeshNormalMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.bumpMap = source.bumpMap;\r\n\tthis.bumpScale = source.bumpScale;\r\n\r\n\tthis.normalMap = source.normalMap;\r\n\tthis.normalMapType = source.normalMapType;\r\n\tthis.normalScale.copy( source.normalScale );\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshPhongMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'MeshPhongMaterial';\r\n\r\n\tthis.color = new Color( 0xffffff ); // diffuse\r\n\tthis.specular = new Color( 0x111111 );\r\n\tthis.shininess = 30;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalMapType = TangentSpaceNormalMap;\r\n\tthis.normalScale = new Vector2( 1, 1 );\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nMeshPhongMaterial.prototype = Object.create( Material.prototype );\r\nMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\r\n\r\nMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\r\n\r\nMeshPhongMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.specular.copy( source.specular );\r\n\tthis.shininess = source.shininess;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.bumpMap = source.bumpMap;\r\n\tthis.bumpScale = source.bumpScale;\r\n\r\n\tthis.normalMap = source.normalMap;\r\n\tthis.normalMapType = source.normalMapType;\r\n\tthis.normalScale.copy( source.normalScale );\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshStandardMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.defines = { 'STANDARD': '' };\r\n\r\n\tthis.type = 'MeshStandardMaterial';\r\n\r\n\tthis.color = new Color( 0xffffff ); // diffuse\r\n\tthis.roughness = 0.5;\r\n\tthis.metalness = 0.5;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalMapType = TangentSpaceNormalMap;\r\n\tthis.normalScale = new Vector2( 1, 1 );\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.roughnessMap = null;\r\n\r\n\tthis.metalnessMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.envMapIntensity = 1.0;\r\n\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nMeshStandardMaterial.prototype = Object.create( Material.prototype );\r\nMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\r\n\r\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\r\n\r\nMeshStandardMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.defines = { 'STANDARD': '' };\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.roughness = source.roughness;\r\n\tthis.metalness = source.metalness;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.bumpMap = source.bumpMap;\r\n\tthis.bumpScale = source.bumpScale;\r\n\r\n\tthis.normalMap = source.normalMap;\r\n\tthis.normalMapType = source.normalMapType;\r\n\tthis.normalScale.copy( source.normalScale );\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.roughnessMap = source.roughnessMap;\r\n\r\n\tthis.metalnessMap = source.metalnessMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.envMapIntensity = source.envMapIntensity;\r\n\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshPhysicalMaterial( parameters ) {\r\n\r\n\tMeshStandardMaterial.call( this );\r\n\r\n\tthis.defines = { 'PHYSICAL': '' };\r\n\r\n\tthis.type = 'MeshPhysicalMaterial';\r\n\r\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\r\n\r\n\tthis.clearCoat = 0.0;\r\n\tthis.clearCoatRoughness = 0.0;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\r\nMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\r\n\r\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\r\n\r\nMeshPhysicalMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMeshStandardMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.defines = { 'PHYSICAL': '' };\r\n\r\n\tthis.reflectivity = source.reflectivity;\r\n\r\n\tthis.clearCoat = source.clearCoat;\r\n\tthis.clearCoatRoughness = source.clearCoatRoughness;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshToonMaterial( parameters ) {\r\n\r\n\tMeshPhongMaterial.call( this );\r\n\r\n\tthis.defines = { 'TOON': '' };\r\n\r\n\tthis.type = 'MeshToonMaterial';\r\n\r\n\tthis.gradientMap = null;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nMeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );\r\nMeshToonMaterial.prototype.constructor = MeshToonMaterial;\r\n\r\nMeshToonMaterial.prototype.isMeshToonMaterial = true;\r\n\r\nMeshToonMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMeshPhongMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.gradientMap = source.gradientMap;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PointsMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'PointsMaterial';\r\n\r\n\tthis.color = new Color( 0xffffff );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.size = 1;\r\n\tthis.sizeAttenuation = true;\r\n\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nPointsMaterial.prototype = Object.create( Material.prototype );\r\nPointsMaterial.prototype.constructor = PointsMaterial;\r\n\r\nPointsMaterial.prototype.isPointsMaterial = true;\r\n\r\nPointsMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.size = source.size;\r\n\tthis.sizeAttenuation = source.sizeAttenuation;\r\n\r\n\tthis.morphTargets = source.morphTargets;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction RawShaderMaterial( parameters ) {\r\n\r\n\tShaderMaterial.call( this, parameters );\r\n\r\n\tthis.type = 'RawShaderMaterial';\r\n\r\n}\r\n\r\nRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\r\nRawShaderMaterial.prototype.constructor = RawShaderMaterial;\r\n\r\nRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ShadowMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'ShadowMaterial';\r\n\r\n\tthis.color = new Color( 0x000000 );\r\n\tthis.transparent = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nShadowMaterial.prototype = Object.create( Material.prototype );\r\nShadowMaterial.prototype.constructor = ShadowMaterial;\r\n\r\nShadowMaterial.prototype.isShadowMaterial = true;\r\n\r\nShadowMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction SpriteMaterial( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'SpriteMaterial';\r\n\r\n\tthis.color = new Color( 0xffffff );\r\n\tthis.map = null;\r\n\r\n\tthis.rotation = 0;\r\n\r\n\tthis.sizeAttenuation = true;\r\n\r\n\tthis.lights = false;\r\n\tthis.transparent = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n}\r\n\r\nSpriteMaterial.prototype = Object.create( Material.prototype );\r\nSpriteMaterial.prototype.constructor = SpriteMaterial;\r\nSpriteMaterial.prototype.isSpriteMaterial = true;\r\n\r\nSpriteMaterial.prototype.copy = function ( source ) {\r\n\r\n\tMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.map = source.map;\r\n\r\n\tthis.rotation = source.rotation;\r\n\r\n\tthis.sizeAttenuation = source.sizeAttenuation;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MaterialLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\tthis.textures = {};\r\n\r\n}\r\n\r\nObject.assign( MaterialLoader.prototype, {\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTextures: function ( value ) {\r\n\r\n\t\tthis.textures = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar textures = this.textures;\r\n\r\n\t\tfunction getTexture( name ) {\r\n\r\n\t\t\tif ( textures[ name ] === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'MaterialLoader: Undefined texture', name );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn textures[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tvar Materials = {\r\n            LineBasicMaterial: LineBasicMaterial,\r\n            LineDashedMaterial: LineDashedMaterial,\r\n            MeshBasicMaterial: MeshBasicMaterial,\r\n            MeshDepthMaterial: MeshDepthMaterial,\r\n            MeshDistanceMaterial: MeshDistanceMaterial,\r\n            MeshLambertMaterial: MeshLambertMaterial,\r\n            MeshNormalMaterial: MeshNormalMaterial,\r\n            MeshPhongMaterial: MeshPhongMaterial,\r\n            MeshPhysicalMaterial: MeshPhysicalMaterial,\r\n            MeshStandardMaterial: MeshStandardMaterial,\r\n            MeshToonMaterial: MeshToonMaterial,\r\n            PointsMaterial: PointsMaterial,\r\n            RawShaderMaterial: RawShaderMaterial,\r\n            ShaderMaterial: ShaderMaterial,\r\n            ShadowMaterial: ShadowMaterial,\r\n            SpriteMaterial: SpriteMaterial\r\n\t\t};\r\n\t\tvar material = new Materials[ json.type ]();\r\n\r\n\t\tif ( json.uuid !== undefined ) { material.uuid = json.uuid; }\r\n\t\tif ( json.name !== undefined ) { material.name = json.name; }\r\n\t\tif ( json.color !== undefined ) { material.color.setHex( json.color ); }\r\n\t\tif ( json.roughness !== undefined ) { material.roughness = json.roughness; }\r\n\t\tif ( json.metalness !== undefined ) { material.metalness = json.metalness; }\r\n\t\tif ( json.emissive !== undefined ) { material.emissive.setHex( json.emissive ); }\r\n\t\tif ( json.specular !== undefined ) { material.specular.setHex( json.specular ); }\r\n\t\tif ( json.shininess !== undefined ) { material.shininess = json.shininess; }\r\n\t\tif ( json.clearCoat !== undefined ) { material.clearCoat = json.clearCoat; }\r\n\t\tif ( json.clearCoatRoughness !== undefined ) { material.clearCoatRoughness = json.clearCoatRoughness; }\r\n\t\tif ( json.vertexColors !== undefined ) { material.vertexColors = json.vertexColors; }\r\n\t\tif ( json.fog !== undefined ) { material.fog = json.fog; }\r\n\t\tif ( json.flatShading !== undefined ) { material.flatShading = json.flatShading; }\r\n\t\tif ( json.blending !== undefined ) { material.blending = json.blending; }\r\n\t\tif ( json.side !== undefined ) { material.side = json.side; }\r\n\t\tif ( json.opacity !== undefined ) { material.opacity = json.opacity; }\r\n\t\tif ( json.transparent !== undefined ) { material.transparent = json.transparent; }\r\n\t\tif ( json.alphaTest !== undefined ) { material.alphaTest = json.alphaTest; }\r\n\t\tif ( json.depthTest !== undefined ) { material.depthTest = json.depthTest; }\r\n\t\tif ( json.depthWrite !== undefined ) { material.depthWrite = json.depthWrite; }\r\n\t\tif ( json.colorWrite !== undefined ) { material.colorWrite = json.colorWrite; }\r\n\t\tif ( json.wireframe !== undefined ) { material.wireframe = json.wireframe; }\r\n\t\tif ( json.wireframeLinewidth !== undefined ) { material.wireframeLinewidth = json.wireframeLinewidth; }\r\n\t\tif ( json.wireframeLinecap !== undefined ) { material.wireframeLinecap = json.wireframeLinecap; }\r\n\t\tif ( json.wireframeLinejoin !== undefined ) { material.wireframeLinejoin = json.wireframeLinejoin; }\r\n\r\n\t\tif ( json.rotation !== undefined ) { material.rotation = json.rotation; }\r\n\r\n\t\tif ( json.linewidth !== 1 ) { material.linewidth = json.linewidth; }\r\n\t\tif ( json.dashSize !== undefined ) { material.dashSize = json.dashSize; }\r\n\t\tif ( json.gapSize !== undefined ) { material.gapSize = json.gapSize; }\r\n\t\tif ( json.scale !== undefined ) { material.scale = json.scale; }\r\n\r\n\t\tif ( json.polygonOffset !== undefined ) { material.polygonOffset = json.polygonOffset; }\r\n\t\tif ( json.polygonOffsetFactor !== undefined ) { material.polygonOffsetFactor = json.polygonOffsetFactor; }\r\n\t\tif ( json.polygonOffsetUnits !== undefined ) { material.polygonOffsetUnits = json.polygonOffsetUnits; }\r\n\r\n\t\tif ( json.skinning !== undefined ) { material.skinning = json.skinning; }\r\n\t\tif ( json.morphTargets !== undefined ) { material.morphTargets = json.morphTargets; }\r\n\t\tif ( json.dithering !== undefined ) { material.dithering = json.dithering; }\r\n\r\n\t\tif ( json.visible !== undefined ) { material.visible = json.visible; }\r\n\t\tif ( json.userData !== undefined ) { material.userData = json.userData; }\r\n\r\n\t\t// Shader Material\r\n\r\n\t\tif ( json.uniforms !== undefined ) {\r\n\r\n\t\t\tfor ( var name in json.uniforms ) {\r\n\r\n\t\t\t\tvar uniform = json.uniforms[ name ];\r\n\r\n\t\t\t\tmaterial.uniforms[ name ] = {};\r\n\r\n\t\t\t\tswitch ( uniform.type ) {\r\n\r\n\t\t\t\t\tcase 't':\r\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'c':\r\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v2':\r\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v3':\r\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v4':\r\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'm4':\r\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.defines !== undefined ) { material.defines = json.defines; }\r\n\t\tif ( json.vertexShader !== undefined ) { material.vertexShader = json.vertexShader; }\r\n\t\tif ( json.fragmentShader !== undefined ) { material.fragmentShader = json.fragmentShader; }\r\n\r\n\t\t// Deprecated\r\n\r\n\t\tif ( json.shading !== undefined ) { material.flatShading = json.shading === 1; } // FlatShading\r\n\r\n\t\t// for PointsMaterial\r\n\r\n\t\tif ( json.size !== undefined ) { material.size = json.size; }\r\n\t\tif ( json.sizeAttenuation !== undefined ) { material.sizeAttenuation = json.sizeAttenuation; }\r\n\r\n\t\t// maps\r\n\r\n\t\tif ( json.map !== undefined ) { material.map = getTexture( json.map ); }\r\n\r\n\t\tif ( json.alphaMap !== undefined ) {\r\n\r\n\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\r\n\t\t\tmaterial.transparent = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.bumpMap !== undefined ) { material.bumpMap = getTexture( json.bumpMap ); }\r\n\t\tif ( json.bumpScale !== undefined ) { material.bumpScale = json.bumpScale; }\r\n\r\n\t\tif ( json.normalMap !== undefined ) { material.normalMap = getTexture( json.normalMap ); }\r\n\t\tif ( json.normalMapType !== undefined ) { material.normalMapType = json.normalMapType; }\r\n\t\tif ( json.normalScale !== undefined ) {\r\n\r\n\t\t\tvar normalScale = json.normalScale;\r\n\r\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\r\n\r\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\r\n\r\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.displacementMap !== undefined ) { material.displacementMap = getTexture( json.displacementMap ); }\r\n\t\tif ( json.displacementScale !== undefined ) { material.displacementScale = json.displacementScale; }\r\n\t\tif ( json.displacementBias !== undefined ) { material.displacementBias = json.displacementBias; }\r\n\r\n\t\tif ( json.roughnessMap !== undefined ) { material.roughnessMap = getTexture( json.roughnessMap ); }\r\n\t\tif ( json.metalnessMap !== undefined ) { material.metalnessMap = getTexture( json.metalnessMap ); }\r\n\r\n\t\tif ( json.emissiveMap !== undefined ) { material.emissiveMap = getTexture( json.emissiveMap ); }\r\n\t\tif ( json.emissiveIntensity !== undefined ) { material.emissiveIntensity = json.emissiveIntensity; }\r\n\r\n\t\tif ( json.specularMap !== undefined ) { material.specularMap = getTexture( json.specularMap ); }\r\n\r\n\t\tif ( json.envMap !== undefined ) { material.envMap = getTexture( json.envMap ); }\r\n\r\n\t\tif ( json.reflectivity !== undefined ) { material.reflectivity = json.reflectivity; }\r\n\r\n\t\tif ( json.lightMap !== undefined ) { material.lightMap = getTexture( json.lightMap ); }\r\n\t\tif ( json.lightMapIntensity !== undefined ) { material.lightMapIntensity = json.lightMapIntensity; }\r\n\r\n\t\tif ( json.aoMap !== undefined ) { material.aoMap = getTexture( json.aoMap ); }\r\n\t\tif ( json.aoMapIntensity !== undefined ) { material.aoMapIntensity = json.aoMapIntensity; }\r\n\r\n\t\tif ( json.gradientMap !== undefined ) { material.gradientMap = getTexture( json.gradientMap ); }\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ImageLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n}\r\n\r\nObject.assign( ImageLoader.prototype, {\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( url === undefined ) { url = ''; }\r\n\r\n\t\tif ( this.path !== undefined ) { url = this.path + url; }\r\n\r\n\t\turl = this.manager.resolveURL( url );\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\tif ( onLoad ) { onLoad( cached ); }\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t}, 0 );\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\r\n\r\n\t\tfunction onImageLoad() {\r\n\r\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\r\n\t\t\timage.removeEventListener( 'error', onImageError, false );\r\n\r\n\t\t\tCache.add( url, this );\r\n\r\n\t\t\tif ( onLoad ) { onLoad( this ); }\r\n\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t}\r\n\r\n\t\tfunction onImageError( event ) {\r\n\r\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\r\n\t\t\timage.removeEventListener( 'error', onImageError, false );\r\n\r\n\t\t\tif ( onError ) { onError( event ); }\r\n\r\n\t\t\tscope.manager.itemEnd( url );\r\n\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t}\r\n\r\n\t\timage.addEventListener( 'load', onImageLoad, false );\r\n\t\timage.addEventListener( 'error', onImageError, false );\r\n\r\n\t\tif ( url.substr( 0, 5 ) !== 'data:' ) {\r\n\r\n\t\t\tif ( this.crossOrigin !== undefined ) { image.crossOrigin = this.crossOrigin; }\r\n\r\n\t\t}\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\timage.src = url;\r\n\r\n\t\treturn image;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction TextureLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n}\r\n\r\nObject.assign( TextureLoader.prototype, {\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar texture = new Texture();\r\n\r\n\t\tvar loader = new ImageLoader( this.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.setPath( this.path );\r\n\r\n\t\tloader.load( url, function ( image ) {\r\n\r\n\t\t\ttexture.image = image;\r\n\r\n\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\r\n\t\t\tvar isJPEG = url.search( /\\.jpe?g$/i ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\r\n\r\n\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\t\tonLoad( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Loader$1() {}\r\n\r\nLoader$1.Handlers = {\r\n\r\n\thandlers: [],\r\n\r\n\tadd: function ( regex, loader ) {\r\n\r\n\t\tthis.handlers.push( regex, loader );\r\n\r\n\t},\r\n\r\n\tget: function ( file ) {\r\n\r\n\t\tvar handlers = this.handlers;\r\n\r\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\r\n\r\n\t\t\tvar regex = handlers[ i ];\r\n\t\t\tvar loader = handlers[ i + 1 ];\r\n\r\n\t\t\tif ( regex.test( file ) ) {\r\n\r\n\t\t\t\treturn loader;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n};\r\n\r\nObject.assign( Loader$1.prototype, {\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tonLoadStart: function () {},\r\n\r\n\tonLoadProgress: function () {},\r\n\r\n\tonLoadComplete: function () {},\r\n\r\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = this$1.createMaterial( materials[ i ], texturePath, crossOrigin );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: ( function () {\r\n\r\n\t\tvar BlendingMode = {\r\n\t\t\tNoBlending: NoBlending,\r\n\t\t\tNormalBlending: NormalBlending,\r\n\t\t\tAdditiveBlending: AdditiveBlending,\r\n\t\t\tSubtractiveBlending: SubtractiveBlending,\r\n\t\t\tMultiplyBlending: MultiplyBlending,\r\n\t\t\tCustomBlending: CustomBlending\r\n\t\t};\r\n\r\n\t\tvar color = new Color();\r\n\t\tvar textureLoader = new TextureLoader();\r\n\t\tvar materialLoader = new MaterialLoader();\r\n\r\n\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\r\n\r\n\t\t\t// convert from old material format\r\n\r\n\t\t\tvar textures = {};\r\n\r\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\t\tvar fullPath = texturePath + path;\r\n\t\t\t\tvar loader = Loader$1.Handlers.get( fullPath );\r\n\r\n\t\t\t\tvar texture;\r\n\r\n\t\t\t\tif ( loader !== null ) {\r\n\r\n\t\t\t\t\ttexture = loader.load( fullPath );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\r\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( repeat !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\r\n\r\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) { texture.wrapS = RepeatWrapping; }\r\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) { texture.wrapT = RepeatWrapping; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.offset.fromArray( offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrap !== undefined ) {\r\n\r\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) { texture.wrapS = RepeatWrapping; }\r\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) { texture.wrapS = MirroredRepeatWrapping; }\r\n\r\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) { texture.wrapT = RepeatWrapping; }\r\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) { texture.wrapT = MirroredRepeatWrapping; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( anisotropy !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.anisotropy = anisotropy;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar uuid = _Math.generateUUID();\r\n\r\n\t\t\t\ttextures[ uuid ] = texture;\r\n\r\n\t\t\t\treturn uuid;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tvar json = {\r\n\t\t\t\tuuid: _Math.generateUUID(),\r\n\t\t\t\ttype: 'MeshLambertMaterial'\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var name in m ) {\r\n\r\n\t\t\t\tvar value = m[ name ];\r\n\r\n\t\t\t\tswitch ( name ) {\r\n\r\n\t\t\t\t\tcase 'DbgColor':\r\n\t\t\t\t\tcase 'DbgIndex':\r\n\t\t\t\t\tcase 'opticalDensity':\r\n\t\t\t\t\tcase 'illumination':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'DbgName':\r\n\t\t\t\t\t\tjson.name = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'blending':\r\n\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorAmbient':\r\n\t\t\t\t\tcase 'mapAmbient':\r\n\t\t\t\t\t\tconsole.warn( 'Loader.createMaterial:', name, 'is no longer supported.' );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorDiffuse':\r\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorSpecular':\r\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorEmissive':\r\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'specularCoef':\r\n\t\t\t\t\t\tjson.shininess = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'shading':\r\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) { json.type = 'MeshBasicMaterial'; }\r\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) { json.type = 'MeshPhongMaterial'; }\r\n\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) { json.type = 'MeshStandardMaterial'; }\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapDiffuse':\r\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapDiffuseRepeat':\r\n\t\t\t\t\tcase 'mapDiffuseOffset':\r\n\t\t\t\t\tcase 'mapDiffuseWrap':\r\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapEmissive':\r\n\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapEmissiveRepeat':\r\n\t\t\t\t\tcase 'mapEmissiveOffset':\r\n\t\t\t\t\tcase 'mapEmissiveWrap':\r\n\t\t\t\t\tcase 'mapEmissiveAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapLight':\r\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapLightRepeat':\r\n\t\t\t\t\tcase 'mapLightOffset':\r\n\t\t\t\t\tcase 'mapLightWrap':\r\n\t\t\t\t\tcase 'mapLightAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAO':\r\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAORepeat':\r\n\t\t\t\t\tcase 'mapAOOffset':\r\n\t\t\t\t\tcase 'mapAOWrap':\r\n\t\t\t\t\tcase 'mapAOAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBump':\r\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBumpScale':\r\n\t\t\t\t\t\tjson.bumpScale = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBumpRepeat':\r\n\t\t\t\t\tcase 'mapBumpOffset':\r\n\t\t\t\t\tcase 'mapBumpWrap':\r\n\t\t\t\t\tcase 'mapBumpAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormal':\r\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormalFactor':\r\n\t\t\t\t\t\tjson.normalScale = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormalRepeat':\r\n\t\t\t\t\tcase 'mapNormalOffset':\r\n\t\t\t\t\tcase 'mapNormalWrap':\r\n\t\t\t\t\tcase 'mapNormalAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapSpecular':\r\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapSpecularRepeat':\r\n\t\t\t\t\tcase 'mapSpecularOffset':\r\n\t\t\t\t\tcase 'mapSpecularWrap':\r\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapMetalness':\r\n\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapMetalnessRepeat':\r\n\t\t\t\t\tcase 'mapMetalnessOffset':\r\n\t\t\t\t\tcase 'mapMetalnessWrap':\r\n\t\t\t\t\tcase 'mapMetalnessAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapRoughness':\r\n\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapRoughnessRepeat':\r\n\t\t\t\t\tcase 'mapRoughnessOffset':\r\n\t\t\t\t\tcase 'mapRoughnessWrap':\r\n\t\t\t\t\tcase 'mapRoughnessAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAlpha':\r\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAlphaRepeat':\r\n\t\t\t\t\tcase 'mapAlphaOffset':\r\n\t\t\t\t\tcase 'mapAlphaWrap':\r\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'flipSided':\r\n\t\t\t\t\t\tjson.side = BackSide;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'doubleSided':\r\n\t\t\t\t\t\tjson.side = DoubleSide;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'transparency':\r\n\t\t\t\t\t\tconsole.warn( 'Loader.createMaterial: transparency has been renamed to opacity' );\r\n\t\t\t\t\t\tjson.opacity = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'depthTest':\r\n\t\t\t\t\tcase 'depthWrite':\r\n\t\t\t\t\tcase 'colorWrite':\r\n\t\t\t\t\tcase 'opacity':\r\n\t\t\t\t\tcase 'reflectivity':\r\n\t\t\t\t\tcase 'transparent':\r\n\t\t\t\t\tcase 'visible':\r\n\t\t\t\t\tcase 'wireframe':\r\n\t\t\t\t\t\tjson[ name ] = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'vertexColors':\r\n\t\t\t\t\t\tif ( value === true ) { json.vertexColors = VertexColors; }\r\n\t\t\t\t\t\tif ( value === 'face' ) { json.vertexColors = FaceColors; }\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.error( 'Loader.createMaterial: Unsupported', name, value );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) { delete json.emissive; }\r\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) { delete json.specular; }\r\n\r\n\t\t\tif ( json.opacity < 1 ) { json.transparent = true; }\r\n\r\n\t\t\tmaterialLoader.setTextures( textures );\r\n\r\n\t\t\treturn materialLoader.parse( json );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar LoaderUtils = {\r\n\r\n\tdecodeText: function ( array ) {\r\n\r\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\r\n\r\n\t\t\treturn new TextDecoder().decode( array );\r\n\r\n\t\t}\r\n\r\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\r\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\r\n\r\n\t\tvar s = '';\r\n\r\n\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\t// Implicitly assumes little-endian.\r\n\t\t\ts += String.fromCharCode( array[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// Merges multi-byte utf-8 characters.\r\n\t\treturn decodeURIComponent( escape( s ) );\r\n\r\n\t},\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar index = url.lastIndexOf( '/' );\r\n\r\n\t\tif ( index === - 1 ) { return './'; }\r\n\r\n\t\treturn url.substr( 0, index + 1 );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction JSONLoader( manager ) {\r\n\r\n\tif ( typeof manager === 'boolean' ) {\r\n\r\n\t\tconsole.warn( 'JSONLoader: showStatus parameter has been removed from constructor.' );\r\n\t\tmanager = undefined;\r\n\r\n\t}\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\tthis.withCredentials = false;\r\n\r\n}\r\n\r\nObject.assign( JSONLoader.prototype, {\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tvar json = JSON.parse( text );\r\n\t\t\tvar metadata = json.metadata;\r\n\r\n\t\t\tif ( metadata !== undefined ) {\r\n\r\n\t\t\t\tvar type = metadata.type;\r\n\r\n\t\t\t\tif ( type !== undefined ) {\r\n\r\n\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'JSONLoader: ' + url + ' should be loaded with ObjectLoader instead.' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar object = scope.parse( json, texturePath );\r\n\t\t\tonLoad( object.geometry, object.materials );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tparse: ( function () {\r\n\r\n\t\tfunction parseModel( json, geometry ) {\r\n\r\n\t\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar i, j, fi,\r\n\r\n\t\t\t\toffset, zLength,\r\n\r\n\t\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\t\t\ttype,\r\n\t\t\t\tisQuad,\r\n\t\t\t\thasMaterial,\r\n\t\t\t\thasFaceVertexUv,\r\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\t\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\t\t\tvertex, face, faceA, faceB, hex, normal,\r\n\r\n\t\t\t\tuvLayer, uv, u, v,\r\n\r\n\t\t\t\tfaces = json.faces,\r\n\t\t\t\tvertices = json.vertices,\r\n\t\t\t\tnormals = json.normals,\r\n\t\t\t\tcolors = json.colors,\r\n\r\n\t\t\t\tscale = json.scale,\r\n\r\n\t\t\t\tnUvLayers = 0;\r\n\r\n\t\t\tif ( json.uvs !== undefined ) {\r\n\r\n\t\t\t\t// disregard empty arrays\r\n\r\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\r\n\t\t\t\t\tif ( json.uvs[ i ].length ) { nUvLayers ++; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = vertices.length;\r\n\r\n\t\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\t\tvertex = new Vector3();\r\n\r\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = faces.length;\r\n\r\n\t\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\t\ttype = faces[ offset ++ ];\r\n\r\n\t\t\t\tisQuad = isBitSet( type, 0 );\r\n\t\t\t\thasMaterial = isBitSet( type, 1 );\r\n\t\t\t\thasFaceVertexUv = isBitSet( type, 3 );\r\n\t\t\t\thasFaceNormal = isBitSet( type, 4 );\r\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\t\thasFaceColor = isBitSet( type, 6 );\r\n\t\t\t\thasFaceVertexColor = isBitSet( type, 7 );\r\n\r\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\t\tfaceA = new Face3();\r\n\t\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\t\tfaceB = new Face3();\r\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\r\n\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\t\tif ( j !== 2 ) { geometry.faceVertexUvs[ i ][ fi ].push( uv ); }\r\n\t\t\t\t\t\t\t\tif ( j !== 0 ) { geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv ); }\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\t\tnormal = new Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tif ( i !== 2 ) { faceA.vertexNormals.push( normal ); }\r\n\t\t\t\t\t\t\tif ( i !== 0 ) { faceB.vertexNormals.push( normal ); }\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\t\tfaceB.color.setHex( hex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\t\tif ( i !== 2 ) { faceA.vertexColors.push( new Color( hex ) ); }\r\n\t\t\t\t\t\t\tif ( i !== 0 ) { faceB.vertexColors.push( new Color( hex ) ); }\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\t\tgeometry.faces.push( faceB );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface = new Face3();\r\n\t\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\t\tuv = new Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\t\tnormal = new Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseSkin( json, geometry ) {\r\n\r\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\r\n\t\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\t\tvar x = json.skinWeights[ i ];\r\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\r\n\t\t\t\t\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\t\tvar a = json.skinIndices[ i ];\r\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\r\n\t\t\t\t\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.bones = json.bones;\r\n\r\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseMorphing( json, geometry ) {\r\n\r\n\t\t\tvar scale = json.scale;\r\n\r\n\t\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\r\n\r\n\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\t\tvar vertex = new Vector3();\r\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\r\n\r\n\t\t\t\tconsole.warn( 'JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\r\n\r\n\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\r\n\r\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseAnimations( json, geometry ) {\r\n\r\n\t\t\tvar outputAnimations = [];\r\n\r\n\t\t\t// parse old style Bone/Hierarchy animations\r\n\t\t\tvar animations = [];\r\n\r\n\t\t\tif ( json.animation !== undefined ) {\r\n\r\n\t\t\t\tanimations.push( json.animation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.animations !== undefined ) {\r\n\r\n\t\t\t\tif ( json.animations.length ) {\r\n\r\n\t\t\t\t\tanimations = animations.concat( json.animations );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tanimations.push( json.animations );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\r\n\r\n\t\t\t\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\r\n\t\t\t\tif ( clip ) { outputAnimations.push( clip ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// parse implicit morph animations\r\n\t\t\tif ( geometry.morphTargets ) {\r\n\r\n\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\r\n\t\t\t\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\r\n\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( outputAnimations.length > 0 ) { geometry.animations = outputAnimations; }\r\n\r\n\t\t}\r\n\r\n\t\treturn function parse( json, texturePath ) {\r\n\r\n\t\t\tif ( json.data !== undefined ) {\r\n\r\n\t\t\t\t// Geometry 4.0 spec\r\n\t\t\t\tjson = json.data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.scale !== undefined ) {\r\n\r\n\t\t\t\tjson.scale = 1.0 / json.scale;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tjson.scale = 1.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometry = new Geometry();\r\n\r\n\t\t\tparseModel( json, geometry );\r\n\t\t\tparseSkin( json, geometry );\r\n\t\t\tparseMorphing( json, geometry );\r\n\t\t\tparseAnimations( json, geometry );\r\n\r\n\t\t\tgeometry.computeFaceNormals();\r\n\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\r\n\t\t\t\treturn { geometry: geometry };\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar materials = Loader$1.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\r\n\r\n\t\t\t\treturn { geometry: geometry, materials: materials };\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BinaryLoader = function ( manager ) {\r\n\r\n\tif ( typeof manager === 'boolean' ) {\r\n\r\n\t\tconsole.warn( 'BinaryLoader: showStatus parameter has been removed from constructor.' );\r\n\t\tmanager = undefined;\r\n\r\n\t}\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nBinaryLoader.prototype = {\r\n\r\n\tconstructor: BinaryLoader,\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\t// Load models generated by slim OBJ converter with BINARY option (converter_obj_three_slim.py -t binary)\r\n\t//  - binary models consist of two files: JS and BIN\r\n\t//  - parameters\r\n\t//\t\t- url (required)\r\n\t//\t\t- callback (required)\r\n\t//\t\t- texturePath (optional: if not specified, textures will be assumed to be in the same folder as JS model file)\r\n\t//\t\t- binaryPath (optional: if not specified, binary file will be assumed to be in the same folder as JS model file)\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t// todo: unify load API to for easier SceneLoader use\r\n\r\n\t\tvar texturePath = this.texturePath || LoaderUtils.extractUrlBase( url );\r\n\t\tvar binaryPath = this.binaryPath || LoaderUtils.extractUrlBase( url );\r\n\r\n\t\t// #1 load JS part via web worker\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar jsonloader = new FileLoader( this.manager );\r\n\t\tjsonloader.load( url, function ( data ) {\r\n\r\n\t\t\tvar json = JSON.parse( data );\r\n\r\n\t\t\tvar bufferUrl = binaryPath + json.buffers;\r\n\r\n\t\t\tvar bufferLoader = new FileLoader( scope.manager );\r\n\t\t\tbufferLoader.setResponseType( 'arraybuffer' );\r\n\t\t\tbufferLoader.load( bufferUrl, function ( bufData ) {\r\n\r\n\t\t\t\t// IEWEBGL needs this ???\r\n\t\t\t\t//buffer = ( new Uint8Array( xhr.responseBody ) ).buffer;\r\n\r\n\t\t\t\t//// iOS and other XMLHttpRequest level 1 ???\r\n\r\n\t\t\t\tscope.parse( bufData, onLoad, texturePath, json.materials );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetBinaryPath: function ( value ) {\r\n\r\n\t\tthis.binaryPath = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tparse: function ( data, callback, texturePath, jsonMaterials ) {\r\n\r\n\t\tvar Model = function () {\r\n\r\n\t\t\tvar scope = this,\r\n\t\t\t\tcurrentOffset = 0,\r\n\t\t\t\tmd,\r\n\t\t\t\tnormals = [],\r\n\t\t\t\tuvs = [],\r\n\t\t\t\tstart_tri_flat, start_tri_smooth, start_tri_flat_uv, start_tri_smooth_uv,\r\n\t\t\t\tstart_quad_flat, start_quad_smooth, start_quad_flat_uv, start_quad_smooth_uv,\r\n\t\t\t\ttri_size, quad_size,\r\n\t\t\t\tlen_tri_flat, len_tri_smooth, len_tri_flat_uv, len_tri_smooth_uv,\r\n\t\t\t\tlen_quad_flat, len_quad_smooth, len_quad_flat_uv;\r\n\r\n\t\t\tGeometry.call( this );\r\n\r\n\t\t\tmd = parseMetaData( data, currentOffset );\r\n\r\n\t\t\tcurrentOffset += md.header_bytes;\r\n\t\t\t\r\n\t\t\t// buffers sizes\r\n\r\n\t\t\ttri_size = md.vertex_index_bytes * 3 + md.material_index_bytes;\r\n\t\t\tquad_size = md.vertex_index_bytes * 4 + md.material_index_bytes;\r\n\r\n\t\t\tlen_tri_flat = md.ntri_flat * ( tri_size );\r\n\t\t\tlen_tri_smooth = md.ntri_smooth * ( tri_size + md.normal_index_bytes * 3 );\r\n\t\t\tlen_tri_flat_uv = md.ntri_flat_uv * ( tri_size + md.uv_index_bytes * 3 );\r\n\t\t\tlen_tri_smooth_uv = md.ntri_smooth_uv * ( tri_size + md.normal_index_bytes * 3 + md.uv_index_bytes * 3 );\r\n\r\n\t\t\tlen_quad_flat = md.nquad_flat * ( quad_size );\r\n\t\t\tlen_quad_smooth = md.nquad_smooth * ( quad_size + md.normal_index_bytes * 4 );\r\n\t\t\tlen_quad_flat_uv = md.nquad_flat_uv * ( quad_size + md.uv_index_bytes * 4 );\r\n\r\n\t\t\t// read buffers\r\n\r\n\t\t\tcurrentOffset += init_vertices( currentOffset );\r\n\r\n\t\t\tcurrentOffset += init_normals( currentOffset );\r\n\t\t\tcurrentOffset += handlePadding( md.nnormals * 3 );\r\n\r\n\t\t\tcurrentOffset += init_uvs( currentOffset );\r\n\r\n\t\t\tstart_tri_flat = currentOffset;\r\n\t\t\tstart_tri_smooth = start_tri_flat + len_tri_flat + handlePadding( md.ntri_flat * 2 );\r\n\t\t\tstart_tri_flat_uv = start_tri_smooth + len_tri_smooth + handlePadding( md.ntri_smooth * 2 );\r\n\t\t\tstart_tri_smooth_uv = start_tri_flat_uv + len_tri_flat_uv + handlePadding( md.ntri_flat_uv * 2 );\r\n\r\n\t\t\tstart_quad_flat = start_tri_smooth_uv + len_tri_smooth_uv + handlePadding( md.ntri_smooth_uv * 2 );\r\n\t\t\tstart_quad_smooth = start_quad_flat + len_quad_flat\t+ handlePadding( md.nquad_flat * 2 );\r\n\t\t\tstart_quad_flat_uv = start_quad_smooth + len_quad_smooth + handlePadding( md.nquad_smooth * 2 );\r\n\t\t\tstart_quad_smooth_uv = start_quad_flat_uv + len_quad_flat_uv + handlePadding( md.nquad_flat_uv * 2 );\r\n\r\n\t\t\t// have to first process faces with uvs\r\n\t\t\t// so that face and uv indices match\r\n\r\n\t\t\tinit_triangles_flat_uv( start_tri_flat_uv );\r\n\t\t\tinit_triangles_smooth_uv( start_tri_smooth_uv );\r\n\r\n\t\t\tinit_quads_flat_uv( start_quad_flat_uv );\r\n\t\t\tinit_quads_smooth_uv( start_quad_smooth_uv );\r\n\r\n\t\t\t// now we can process untextured faces\r\n\r\n\t\t\tinit_triangles_flat( start_tri_flat );\r\n\t\t\tinit_triangles_smooth( start_tri_smooth );\r\n\r\n\t\t\tinit_quads_flat( start_quad_flat );\r\n\t\t\tinit_quads_smooth( start_quad_smooth );\r\n\r\n\t\t\tthis.computeFaceNormals();\r\n\r\n\t\t\tfunction handlePadding( n ) {\r\n\r\n\t\t\t\treturn ( n % 4 ) ? ( 4 - n % 4 ) : 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseMetaData( data, offset ) {\r\n\r\n\t\t\t\tvar metaData = {\r\n\r\n\t\t\t\t\t'signature': parseString( data, offset, 12 ),\r\n\t\t\t\t\t'header_bytes': parseUChar8( data, offset + 12 ),\r\n\r\n\t\t\t\t\t'vertex_coordinate_bytes': parseUChar8( data, offset + 13 ),\r\n\t\t\t\t\t'normal_coordinate_bytes': parseUChar8( data, offset + 14 ),\r\n\t\t\t\t\t'uv_coordinate_bytes': parseUChar8( data, offset + 15 ),\r\n\r\n\t\t\t\t\t'vertex_index_bytes': parseUChar8( data, offset + 16 ),\r\n\t\t\t\t\t'normal_index_bytes': parseUChar8( data, offset + 17 ),\r\n\t\t\t\t\t'uv_index_bytes': parseUChar8( data, offset + 18 ),\r\n\t\t\t\t\t'material_index_bytes': parseUChar8( data, offset + 19 ),\r\n\r\n\t\t\t\t\t'nvertices': parseUInt32( data, offset + 20 ),\r\n\t\t\t\t\t'nnormals': parseUInt32( data, offset + 20 + 4 * 1 ),\r\n\t\t\t\t\t'nuvs': parseUInt32( data, offset + 20 + 4 * 2 ),\r\n\r\n\t\t\t\t\t'ntri_flat': parseUInt32( data, offset + 20 + 4 * 3 ),\r\n\t\t\t\t\t'ntri_smooth': parseUInt32( data, offset + 20 + 4 * 4 ),\r\n\t\t\t\t\t'ntri_flat_uv': parseUInt32( data, offset + 20 + 4 * 5 ),\r\n\t\t\t\t\t'ntri_smooth_uv': parseUInt32( data, offset + 20 + 4 * 6 ),\r\n\r\n\t\t\t\t\t'nquad_flat': parseUInt32( data, offset + 20 + 4 * 7 ),\r\n\t\t\t\t\t'nquad_smooth': parseUInt32( data, offset + 20 + 4 * 8 ),\r\n\t\t\t\t\t'nquad_flat_uv': parseUInt32( data, offset + 20 + 4 * 9 ),\r\n\t\t\t\t\t'nquad_smooth_uv': parseUInt32( data, offset + 20 + 4 * 10 )\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\treturn metaData;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseString( data, offset, length ) {\r\n\r\n\t\t\t\treturn LoaderUtils.decodeText( new Uint8Array( data, offset, length ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseUChar8( data, offset ) {\r\n\r\n\t\t\t\tvar charArray = new Uint8Array( data, offset, 1 );\r\n\r\n\t\t\t\treturn charArray[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseUInt32( data, offset ) {\r\n\r\n\t\t\t\tvar intArray = new Uint32Array( data, offset, 1 );\r\n\r\n\t\t\t\treturn intArray[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_vertices( start ) {\r\n\r\n\t\t\t\tvar nElements = md.nvertices;\r\n\r\n\t\t\t\tvar coordArray = new Float32Array( data, start, nElements * 3 );\r\n\r\n\t\t\t\tvar i, x, y, z;\r\n\r\n\t\t\t\tfor ( i = 0; i < nElements; i ++ ) {\r\n\r\n\t\t\t\t\tx = coordArray[ i * 3 ];\r\n\t\t\t\t\ty = coordArray[ i * 3 + 1 ];\r\n\t\t\t\t\tz = coordArray[ i * 3 + 2 ];\r\n\r\n\t\t\t\t\tscope.vertices.push( new Vector3( x, y, z ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn nElements * 3 * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_normals( start ) {\r\n\r\n\t\t\t\tvar nElements = md.nnormals;\r\n\r\n\t\t\t\tif ( nElements ) {\r\n\r\n\t\t\t\t\tvar normalArray = new Int8Array( data, start, nElements * 3 );\r\n\r\n\t\t\t\t\tvar i, x, y, z;\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nElements; i ++ ) {\r\n\r\n\t\t\t\t\t\tx = normalArray[ i * 3 ];\r\n\t\t\t\t\t\ty = normalArray[ i * 3 + 1 ];\r\n\t\t\t\t\t\tz = normalArray[ i * 3 + 2 ];\r\n\r\n\t\t\t\t\t\tnormals.push( x / 127, y / 127, z / 127 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn nElements * 3 * Int8Array.BYTES_PER_ELEMENT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_uvs( start ) {\r\n\r\n\t\t\t\tvar nElements = md.nuvs;\r\n\r\n\t\t\t\tif ( nElements ) {\r\n\r\n\t\t\t\t\tvar uvArray = new Float32Array( data, start, nElements * 2 );\r\n\r\n\t\t\t\t\tvar i, u, v;\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nElements; i ++ ) {\r\n\r\n\t\t\t\t\t\tu = uvArray[ i * 2 ];\r\n\t\t\t\t\t\tv = uvArray[ i * 2 + 1 ];\r\n\r\n\t\t\t\t\t\tuvs.push( u, v );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn nElements * 2 * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_uvs3( nElements, offset ) {\r\n\r\n\t\t\t\tvar i, uva, uvb, uvc, u1, u2, u3, v1, v2, v3;\r\n\r\n\t\t\t\tvar uvIndexBuffer = new Uint32Array( data, offset, 3 * nElements );\r\n\r\n\t\t\t\tfor ( i = 0; i < nElements; i ++ ) {\r\n\r\n\t\t\t\t\tuva = uvIndexBuffer[ i * 3 ];\r\n\t\t\t\t\tuvb = uvIndexBuffer[ i * 3 + 1 ];\r\n\t\t\t\t\tuvc = uvIndexBuffer[ i * 3 + 2 ];\r\n\r\n\t\t\t\t\tu1 = uvs[ uva * 2 ];\r\n\t\t\t\t\tv1 = uvs[ uva * 2 + 1 ];\r\n\r\n\t\t\t\t\tu2 = uvs[ uvb * 2 ];\r\n\t\t\t\t\tv2 = uvs[ uvb * 2 + 1 ];\r\n\r\n\t\t\t\t\tu3 = uvs[ uvc * 2 ];\r\n\t\t\t\t\tv3 = uvs[ uvc * 2 + 1 ];\r\n\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\t\t\tnew Vector2( u1, v1 ),\r\n\t\t\t\t\t\tnew Vector2( u2, v2 ),\r\n\t\t\t\t\t\tnew Vector2( u3, v3 )\r\n\t\t\t\t\t] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_uvs4( nElements, offset ) {\r\n\r\n\t\t\t\tvar i, uva, uvb, uvc, uvd, u1, u2, u3, u4, v1, v2, v3, v4;\r\n\r\n\t\t\t\tvar uvIndexBuffer = new Uint32Array( data, offset, 4 * nElements );\r\n\r\n\t\t\t\tfor ( i = 0; i < nElements; i ++ ) {\r\n\r\n\t\t\t\t\tuva = uvIndexBuffer[ i * 4 ];\r\n\t\t\t\t\tuvb = uvIndexBuffer[ i * 4 + 1 ];\r\n\t\t\t\t\tuvc = uvIndexBuffer[ i * 4 + 2 ];\r\n\t\t\t\t\tuvd = uvIndexBuffer[ i * 4 + 3 ];\r\n\r\n\t\t\t\t\tu1 = uvs[ uva * 2 ];\r\n\t\t\t\t\tv1 = uvs[ uva * 2 + 1 ];\r\n\r\n\t\t\t\t\tu2 = uvs[ uvb * 2 ];\r\n\t\t\t\t\tv2 = uvs[ uvb * 2 + 1 ];\r\n\r\n\t\t\t\t\tu3 = uvs[ uvc * 2 ];\r\n\t\t\t\t\tv3 = uvs[ uvc * 2 + 1 ];\r\n\r\n\t\t\t\t\tu4 = uvs[ uvd * 2 ];\r\n\t\t\t\t\tv4 = uvs[ uvd * 2 + 1 ];\r\n\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\t\t\tnew Vector2( u1, v1 ),\r\n\t\t\t\t\t\tnew Vector2( u2, v2 ),\r\n\t\t\t\t\t\tnew Vector2( u4, v4 )\r\n\t\t\t\t\t] );\r\n\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\t\t\tnew Vector2( u2, v2 ),\r\n\t\t\t\t\t\tnew Vector2( u3, v3 ),\r\n\t\t\t\t\t\tnew Vector2( u4, v4 )\r\n\t\t\t\t\t] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_faces3_flat( nElements, offsetVertices, offsetMaterials ) {\r\n\r\n\t\t\t\tvar i, a, b, c, m;\r\n\r\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 3 * nElements );\r\n\t\t\t\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\r\n\r\n\t\t\t\tfor ( i = 0; i < nElements; i ++ ) {\r\n\r\n\t\t\t\t\ta = vertexIndexBuffer[ i * 3 ];\r\n\t\t\t\t\tb = vertexIndexBuffer[ i * 3 + 1 ];\r\n\t\t\t\t\tc = vertexIndexBuffer[ i * 3 + 2 ];\r\n\r\n\t\t\t\t\tm = materialIndexBuffer[ i ];\r\n\r\n\t\t\t\t\tscope.faces.push( new Face3( a, b, c, null, null, m ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_faces4_flat( nElements, offsetVertices, offsetMaterials ) {\r\n\r\n\t\t\t\tvar i, a, b, c, d, m;\r\n\r\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 4 * nElements );\r\n\t\t\t\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\r\n\r\n\t\t\t\tfor ( i = 0; i < nElements; i ++ ) {\r\n\r\n\t\t\t\t\ta = vertexIndexBuffer[ i * 4 ];\r\n\t\t\t\t\tb = vertexIndexBuffer[ i * 4 + 1 ];\r\n\t\t\t\t\tc = vertexIndexBuffer[ i * 4 + 2 ];\r\n\t\t\t\t\td = vertexIndexBuffer[ i * 4 + 3 ];\r\n\r\n\t\t\t\t\tm = materialIndexBuffer[ i ];\r\n\r\n\t\t\t\t\tscope.faces.push( new Face3( a, b, d, null, null, m ) );\r\n\t\t\t\t\tscope.faces.push( new Face3( b, c, d, null, null, m ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_faces3_smooth( nElements, offsetVertices, offsetNormals, offsetMaterials ) {\r\n\r\n\t\t\t\tvar i, a, b, c, m;\r\n\t\t\t\tvar na, nb, nc;\r\n\r\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 3 * nElements );\r\n\t\t\t\tvar normalIndexBuffer = new Uint32Array( data, offsetNormals, 3 * nElements );\r\n\t\t\t\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\r\n\r\n\t\t\t\tfor ( i = 0; i < nElements; i ++ ) {\r\n\r\n\t\t\t\t\ta = vertexIndexBuffer[ i * 3 ];\r\n\t\t\t\t\tb = vertexIndexBuffer[ i * 3 + 1 ];\r\n\t\t\t\t\tc = vertexIndexBuffer[ i * 3 + 2 ];\r\n\r\n\t\t\t\t\tna = normalIndexBuffer[ i * 3 ];\r\n\t\t\t\t\tnb = normalIndexBuffer[ i * 3 + 1 ];\r\n\t\t\t\t\tnc = normalIndexBuffer[ i * 3 + 2 ];\r\n\r\n\t\t\t\t\tm = materialIndexBuffer[ i ];\r\n\r\n\t\t\t\t\tvar nax = normals[ na * 3 ],\r\n\t\t\t\t\t\tnay = normals[ na * 3 + 1 ],\r\n\t\t\t\t\t\tnaz = normals[ na * 3 + 2 ],\r\n\r\n\t\t\t\t\t\tnbx = normals[ nb * 3 ],\r\n\t\t\t\t\t\tnby = normals[ nb * 3 + 1 ],\r\n\t\t\t\t\t\tnbz = normals[ nb * 3 + 2 ],\r\n\r\n\t\t\t\t\t\tncx = normals[ nc * 3 ],\r\n\t\t\t\t\t\tncy = normals[ nc * 3 + 1 ],\r\n\t\t\t\t\t\tncz = normals[ nc * 3 + 2 ];\r\n\r\n\t\t\t\t\tscope.faces.push( new Face3( a, b, c, [\r\n\t\t\t\t\t\tnew Vector3( nax, nay, naz ),\r\n\t\t\t\t\t\tnew Vector3( nbx, nby, nbz ),\r\n\t\t\t\t\t\tnew Vector3( ncx, ncy, ncz )\r\n\t\t\t\t\t], null, m ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_faces4_smooth( nElements, offsetVertices, offsetNormals, offsetMaterials ) {\r\n\r\n\t\t\t\tvar i, a, b, c, d, m;\r\n\t\t\t\tvar na, nb, nc, nd;\r\n\r\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array( data, offsetVertices, 4 * nElements );\r\n\t\t\t\tvar normalIndexBuffer = new Uint32Array( data, offsetNormals, 4 * nElements );\r\n\t\t\t\tvar materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );\r\n\r\n\t\t\t\tfor ( i = 0; i < nElements; i ++ ) {\r\n\r\n\t\t\t\t\ta = vertexIndexBuffer[ i * 4 ];\r\n\t\t\t\t\tb = vertexIndexBuffer[ i * 4 + 1 ];\r\n\t\t\t\t\tc = vertexIndexBuffer[ i * 4 + 2 ];\r\n\t\t\t\t\td = vertexIndexBuffer[ i * 4 + 3 ];\r\n\r\n\t\t\t\t\tna = normalIndexBuffer[ i * 4 ];\r\n\t\t\t\t\tnb = normalIndexBuffer[ i * 4 + 1 ];\r\n\t\t\t\t\tnc = normalIndexBuffer[ i * 4 + 2 ];\r\n\t\t\t\t\tnd = normalIndexBuffer[ i * 4 + 3 ];\r\n\r\n\t\t\t\t\tm = materialIndexBuffer[ i ];\r\n\r\n\t\t\t\t\tvar nax = normals[ na * 3 ],\r\n\t\t\t\t\t\tnay = normals[ na * 3 + 1 ],\r\n\t\t\t\t\t\tnaz = normals[ na * 3 + 2 ],\r\n\r\n\t\t\t\t\t\tnbx = normals[ nb * 3 ],\r\n\t\t\t\t\t\tnby = normals[ nb * 3 + 1 ],\r\n\t\t\t\t\t\tnbz = normals[ nb * 3 + 2 ],\r\n\r\n\t\t\t\t\t\tncx = normals[ nc * 3 ],\r\n\t\t\t\t\t\tncy = normals[ nc * 3 + 1 ],\r\n\t\t\t\t\t\tncz = normals[ nc * 3 + 2 ],\r\n\r\n\t\t\t\t\t\tndx = normals[ nd * 3 ],\r\n\t\t\t\t\t\tndy = normals[ nd * 3 + 1 ],\r\n\t\t\t\t\t\tndz = normals[ nd * 3 + 2 ];\r\n\r\n\t\t\t\t\tscope.faces.push( new Face3( a, b, d, [\r\n\t\t\t\t\t\tnew Vector3( nax, nay, naz ),\r\n\t\t\t\t\t\tnew Vector3( nbx, nby, nbz ),\r\n\t\t\t\t\t\tnew Vector3( ndx, ndy, ndz )\r\n\t\t\t\t\t], null, m ) );\r\n\r\n\t\t\t\t\tscope.faces.push( new Face3( b, c, d, [\r\n\t\t\t\t\t\tnew Vector3( nbx, nby, nbz ),\r\n\t\t\t\t\t\tnew Vector3( ncx, ncy, ncz ),\r\n\t\t\t\t\t\tnew Vector3( ndx, ndy, ndz )\r\n\t\t\t\t\t], null, m ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_triangles_flat( start ) {\r\n\r\n\t\t\t\tvar nElements = md.ntri_flat;\r\n\r\n\t\t\t\tif ( nElements ) {\r\n\r\n\t\t\t\t\tvar offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\r\n\t\t\t\t\tinit_faces3_flat( nElements, start, offsetMaterials );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_triangles_flat_uv( start ) {\r\n\r\n\t\t\t\tvar nElements = md.ntri_flat_uv;\r\n\r\n\t\t\t\tif ( nElements ) {\r\n\r\n\t\t\t\t\tvar offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\r\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\r\n\r\n\t\t\t\t\tinit_faces3_flat( nElements, start, offsetMaterials );\r\n\t\t\t\t\tinit_uvs3( nElements, offsetUvs );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_triangles_smooth( start ) {\r\n\r\n\t\t\t\tvar nElements = md.ntri_smooth;\r\n\r\n\t\t\t\tif ( nElements ) {\r\n\r\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\r\n\t\t\t\t\tvar offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\r\n\r\n\t\t\t\t\tinit_faces3_smooth( nElements, start, offsetNormals, offsetMaterials );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_triangles_smooth_uv( start ) {\r\n\r\n\t\t\t\tvar nElements = md.ntri_smooth_uv;\r\n\r\n\t\t\t\tif ( nElements ) {\r\n\r\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\r\n\t\t\t\t\tvar offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\r\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\r\n\r\n\t\t\t\t\tinit_faces3_smooth( nElements, start, offsetNormals, offsetMaterials );\r\n\t\t\t\t\tinit_uvs3( nElements, offsetUvs );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_quads_flat( start ) {\r\n\r\n\t\t\t\tvar nElements = md.nquad_flat;\r\n\r\n\t\t\t\tif ( nElements ) {\r\n\r\n\t\t\t\t\tvar offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\r\n\t\t\t\t\tinit_faces4_flat( nElements, start, offsetMaterials );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_quads_flat_uv( start ) {\r\n\r\n\t\t\t\tvar nElements = md.nquad_flat_uv;\r\n\r\n\t\t\t\tif ( nElements ) {\r\n\r\n\t\t\t\t\tvar offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\r\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\r\n\r\n\t\t\t\t\tinit_faces4_flat( nElements, start, offsetMaterials );\r\n\t\t\t\t\tinit_uvs4( nElements, offsetUvs );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_quads_smooth( start ) {\r\n\r\n\t\t\t\tvar nElements = md.nquad_smooth;\r\n\r\n\t\t\t\tif ( nElements ) {\r\n\r\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\r\n\t\t\t\t\tvar offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\r\n\r\n\t\t\t\t\tinit_faces4_smooth( nElements, start, offsetNormals, offsetMaterials );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction init_quads_smooth_uv( start ) {\r\n\r\n\t\t\t\tvar nElements = md.nquad_smooth_uv;\r\n\r\n\t\t\t\tif ( nElements ) {\r\n\r\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\r\n\t\t\t\t\tvar offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\r\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\r\n\r\n\t\t\t\t\tinit_faces4_smooth( nElements, start, offsetNormals, offsetMaterials );\r\n\t\t\t\t\tinit_uvs4( nElements, offsetUvs );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tModel.prototype = Object.create( Geometry.prototype );\r\n\t\tModel.prototype.constructor = Model;\r\n\r\n\t\tvar geometry = new Model();\r\n\t\tvar materials = Loader$1.prototype.initMaterials( jsonMaterials, texturePath, this.crossOrigin );\r\n\r\n\t\tcallback( geometry, materials );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Car = function () {\r\n\r\n\tvar scope = this;\r\n\r\n\t// car geometry manual parameters\r\n\r\n\tthis.modelScale = 1;\r\n\r\n\tthis.backWheelOffset = 2;\r\n\r\n\tthis.autoWheelGeometry = true;\r\n\r\n\t// car geometry parameters automatically set from wheel mesh\r\n\t// \t- assumes wheel mesh is front left wheel in proper global\r\n\t//    position with respect to body mesh\r\n\t//\t- other wheels are mirrored against car root\r\n\t//\t- if necessary back wheels can be offset manually\r\n\r\n\tthis.wheelOffset = new Vector3();\r\n\r\n\tthis.wheelDiameter = 1;\r\n\r\n\t// car \"feel\" parameters\r\n\r\n\tthis.MAX_SPEED = 2200;\r\n\tthis.MAX_REVERSE_SPEED = - 1500;\r\n\r\n\tthis.MAX_WHEEL_ROTATION = 0.6;\r\n\r\n\tthis.FRONT_ACCELERATION = 1250;\r\n\tthis.BACK_ACCELERATION = 1500;\r\n\r\n\tthis.WHEEL_ANGULAR_ACCELERATION = 1.5;\r\n\r\n\tthis.FRONT_DECCELERATION = 750;\r\n\tthis.WHEEL_ANGULAR_DECCELERATION = 1.0;\r\n\r\n\tthis.STEERING_RADIUS_RATIO = 0.0023;\r\n\r\n\tthis.MAX_TILT_SIDES = 0.05;\r\n\tthis.MAX_TILT_FRONTBACK = 0.015;\r\n\r\n\t// internal control variables\r\n\r\n\tthis.speed = 0;\r\n\tthis.acceleration = 0;\r\n\r\n\tthis.wheelOrientation = 0;\r\n\tthis.carOrientation = 0;\r\n\r\n\t// car rigging\r\n\r\n\tthis.root = new Object3D();\r\n\r\n\tthis.frontLeftWheelRoot = new Object3D();\r\n\tthis.frontRightWheelRoot = new Object3D();\r\n\r\n\tthis.bodyMesh = null;\r\n\r\n\tthis.frontLeftWheelMesh = null;\r\n\tthis.frontRightWheelMesh = null;\r\n\r\n\tthis.backLeftWheelMesh = null;\r\n\tthis.backRightWheelMesh = null;\r\n\r\n\tthis.bodyGeometry = null;\r\n\tthis.wheelGeometry = null;\r\n\r\n\tthis.bodyMaterials = null;\r\n\tthis.wheelMaterials = null;\r\n\r\n\t// internal helper variables\r\n\r\n\tthis.loaded = false;\r\n\r\n\tthis.meshes = [];\r\n\r\n\t// API\r\n\r\n\tthis.enableShadows = function ( enable ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\r\n\r\n\t\t\tthis$1.meshes[ i ].castShadow = enable;\r\n\t\t\tthis$1.meshes[ i ].receiveShadow = enable;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setVisible = function ( enable ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\r\n\r\n\t\t\tthis$1.meshes[ i ].visible = enable;\r\n\t\t\tthis$1.meshes[ i ].visible = enable;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.loadPartsJSON = function ( bodyURL, wheelURL ) {\r\n\r\n\t\tvar loader = new JSONLoader();\r\n\r\n\t\tloader.load( bodyURL, function( geometry, materials ) {\r\n\r\n\t\t\tcreateBody( geometry, materials );\r\n\r\n\t\t} );\r\n\t\tloader.load( wheelURL, function( geometry, materials ) {\r\n\r\n\t\t\tcreateWheels( geometry, materials );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tthis.loadPartsBinary = function ( bodyURL, wheelURL ) {\r\n\r\n\t\tvar loader = new BinaryLoader();\r\n\r\n\t\tloader.load( bodyURL, function( geometry, materials ) {\r\n\r\n\t\t\tcreateBody( geometry, materials );\r\n\r\n\t\t} );\r\n\t\tloader.load( wheelURL, function( geometry, materials ) {\r\n\r\n\t\t\tcreateWheels( geometry, materials );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tthis.updateCarModel = function ( delta, controls ) {\r\n\r\n\t\t// speed and wheels based on controls\r\n\r\n\t\tif ( controls.moveForward ) {\r\n\r\n\t\t\tthis.speed = _Math.clamp( this.speed + delta * this.FRONT_ACCELERATION, this.MAX_REVERSE_SPEED, this.MAX_SPEED );\r\n\t\t\tthis.acceleration = _Math.clamp( this.acceleration + delta, - 1, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( controls.moveBackward ) {\r\n\r\n\t\t\tthis.speed = _Math.clamp( this.speed - delta * this.BACK_ACCELERATION, this.MAX_REVERSE_SPEED, this.MAX_SPEED );\r\n\t\t\tthis.acceleration = _Math.clamp( this.acceleration - delta, - 1, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( controls.moveLeft ) {\r\n\r\n\t\t\tthis.wheelOrientation = _Math.clamp( this.wheelOrientation + delta * this.WHEEL_ANGULAR_ACCELERATION, - this.MAX_WHEEL_ROTATION, this.MAX_WHEEL_ROTATION );\r\n\r\n\t\t}\r\n\r\n\t\tif ( controls.moveRight ) {\r\n\r\n\t\t\tthis.wheelOrientation = _Math.clamp( this.wheelOrientation - delta * this.WHEEL_ANGULAR_ACCELERATION, - this.MAX_WHEEL_ROTATION, this.MAX_WHEEL_ROTATION );\r\n\r\n\t\t}\r\n\r\n\t\t// speed decay\r\n\r\n\t\tif ( ! ( controls.moveForward || controls.moveBackward ) ) {\r\n\r\n\t\t\tif ( this.speed > 0 ) {\r\n\r\n\t\t\t\tvar k = exponentialEaseOut( this.speed / this.MAX_SPEED );\r\n\r\n\t\t\t\tthis.speed = _Math.clamp( this.speed - k * delta * this.FRONT_DECCELERATION, 0, this.MAX_SPEED );\r\n\t\t\t\tthis.acceleration = _Math.clamp( this.acceleration - k * delta, 0, 1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar k = exponentialEaseOut( this.speed / this.MAX_REVERSE_SPEED );\r\n\r\n\t\t\t\tthis.speed = _Math.clamp( this.speed + k * delta * this.BACK_ACCELERATION, this.MAX_REVERSE_SPEED, 0 );\r\n\t\t\t\tthis.acceleration = _Math.clamp( this.acceleration + k * delta, - 1, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// steering decay\r\n\r\n\t\tif ( ! ( controls.moveLeft || controls.moveRight ) ) {\r\n\r\n\t\t\tif ( this.wheelOrientation > 0 ) {\r\n\r\n\t\t\t\tthis.wheelOrientation = _Math.clamp( this.wheelOrientation - delta * this.WHEEL_ANGULAR_DECCELERATION, 0, this.MAX_WHEEL_ROTATION );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.wheelOrientation = _Math.clamp( this.wheelOrientation + delta * this.WHEEL_ANGULAR_DECCELERATION, - this.MAX_WHEEL_ROTATION, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// car update\r\n\r\n\t\tvar forwardDelta = this.speed * delta;\r\n\r\n\t\tthis.carOrientation += ( forwardDelta * this.STEERING_RADIUS_RATIO ) * this.wheelOrientation;\r\n\r\n\t\t// displacement\r\n\r\n\t\tthis.root.position.x += Math.sin( this.carOrientation ) * forwardDelta;\r\n\t\tthis.root.position.z += Math.cos( this.carOrientation ) * forwardDelta;\r\n\r\n\t\t// steering\r\n\r\n\t\tthis.root.rotation.y = this.carOrientation;\r\n\r\n\t\t// tilt\r\n\r\n\t\tif ( this.loaded ) {\r\n\r\n\t\t\tthis.bodyMesh.rotation.z = this.MAX_TILT_SIDES * this.wheelOrientation * ( this.speed / this.MAX_SPEED );\r\n\t\t\tthis.bodyMesh.rotation.x = - this.MAX_TILT_FRONTBACK * this.acceleration;\r\n\r\n\t\t}\r\n\r\n\t\t// wheels rolling\r\n\r\n\t\tvar angularSpeedRatio = 1 / ( this.modelScale * ( this.wheelDiameter / 2 ) );\r\n\r\n\t\tvar wheelDelta = forwardDelta * angularSpeedRatio;\r\n\r\n\t\tif ( this.loaded ) {\r\n\r\n\t\t\tthis.frontLeftWheelMesh.rotation.x += wheelDelta;\r\n\t\t\tthis.frontRightWheelMesh.rotation.x += wheelDelta;\r\n\t\t\tthis.backLeftWheelMesh.rotation.x += wheelDelta;\r\n\t\t\tthis.backRightWheelMesh.rotation.x += wheelDelta;\r\n\r\n\t\t}\r\n\r\n\t\t// front wheels steering\r\n\r\n\t\tthis.frontLeftWheelRoot.rotation.y = this.wheelOrientation;\r\n\t\tthis.frontRightWheelRoot.rotation.y = this.wheelOrientation;\r\n\r\n\t};\r\n\r\n\t// internal helper methods\r\n\r\n\tfunction createBody ( geometry, materials ) {\r\n\r\n\t\tscope.bodyGeometry = geometry;\r\n\t\tscope.bodyMaterials = materials;\r\n\r\n\t\tcreateCar();\r\n\r\n\t}\r\n\r\n\tfunction createWheels ( geometry, materials ) {\r\n\r\n\t\tscope.wheelGeometry = geometry;\r\n\t\tscope.wheelMaterials = materials;\r\n\r\n\t\tcreateCar();\r\n\r\n\t}\r\n\r\n\tfunction createCar () {\r\n\r\n\t\tif ( scope.bodyGeometry && scope.wheelGeometry ) {\r\n\r\n\t\t\t// compute wheel geometry parameters\r\n\r\n\t\t\tif ( scope.autoWheelGeometry ) {\r\n\r\n\t\t\t\tscope.wheelGeometry.computeBoundingBox();\r\n\r\n\t\t\t\tvar bb = scope.wheelGeometry.boundingBox;\r\n\r\n\t\t\t\tscope.wheelOffset.addVectors( bb.min, bb.max );\r\n\t\t\t\tscope.wheelOffset.multiplyScalar( 0.5 );\r\n\r\n\t\t\t\tscope.wheelDiameter = bb.max.y - bb.min.y;\r\n\r\n\t\t\t\tscope.wheelGeometry.center();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// rig the car\r\n\r\n\t\t\tvar s = scope.modelScale,\r\n\t\t\t\tdelta = new Vector3();\r\n\r\n\t\t\tvar bodyFaceMaterial = scope.bodyMaterials;\r\n\t\t\tvar wheelFaceMaterial = scope.wheelMaterials;\r\n\r\n\t\t\t// body\r\n\r\n\t\t\tscope.bodyMesh = new Mesh( scope.bodyGeometry, bodyFaceMaterial );\r\n\t\t\tscope.bodyMesh.scale.set( s, s, s );\r\n\r\n\t\t\tscope.root.add( scope.bodyMesh );\r\n\r\n\t\t\t// front left wheel\r\n\r\n\t\t\tdelta.multiplyVectors( scope.wheelOffset, new Vector3( s, s, s ) );\r\n\r\n\t\t\tscope.frontLeftWheelRoot.position.add( delta );\r\n\r\n\t\t\tscope.frontLeftWheelMesh = new Mesh( scope.wheelGeometry, wheelFaceMaterial );\r\n\t\t\tscope.frontLeftWheelMesh.scale.set( s, s, s );\r\n\r\n\t\t\tscope.frontLeftWheelRoot.add( scope.frontLeftWheelMesh );\r\n\t\t\tscope.root.add( scope.frontLeftWheelRoot );\r\n\r\n\t\t\t// front right wheel\r\n\r\n\t\t\tdelta.multiplyVectors( scope.wheelOffset, new Vector3( - s, s, s ) );\r\n\r\n\t\t\tscope.frontRightWheelRoot.position.add( delta );\r\n\r\n\t\t\tscope.frontRightWheelMesh = new Mesh( scope.wheelGeometry, wheelFaceMaterial );\r\n\r\n\t\t\tscope.frontRightWheelMesh.scale.set( s, s, s );\r\n\t\t\tscope.frontRightWheelMesh.rotation.z = Math.PI;\r\n\r\n\t\t\tscope.frontRightWheelRoot.add( scope.frontRightWheelMesh );\r\n\t\t\tscope.root.add( scope.frontRightWheelRoot );\r\n\r\n\t\t\t// back left wheel\r\n\r\n\t\t\tdelta.multiplyVectors( scope.wheelOffset, new Vector3( s, s, - s ) );\r\n\t\t\tdelta.z -= scope.backWheelOffset;\r\n\r\n\t\t\tscope.backLeftWheelMesh = new Mesh( scope.wheelGeometry, wheelFaceMaterial );\r\n\r\n\t\t\tscope.backLeftWheelMesh.position.add( delta );\r\n\t\t\tscope.backLeftWheelMesh.scale.set( s, s, s );\r\n\r\n\t\t\tscope.root.add( scope.backLeftWheelMesh );\r\n\r\n\t\t\t// back right wheel\r\n\r\n\t\t\tdelta.multiplyVectors( scope.wheelOffset, new Vector3( - s, s, - s ) );\r\n\t\t\tdelta.z -= scope.backWheelOffset;\r\n\r\n\t\t\tscope.backRightWheelMesh = new Mesh( scope.wheelGeometry, wheelFaceMaterial );\r\n\r\n\t\t\tscope.backRightWheelMesh.position.add( delta );\r\n\t\t\tscope.backRightWheelMesh.scale.set( s, s, s );\r\n\t\t\tscope.backRightWheelMesh.rotation.z = Math.PI;\r\n\r\n\t\t\tscope.root.add( scope.backRightWheelMesh );\r\n\r\n\t\t\t// cache meshes\r\n\r\n\t\t\tscope.meshes = [ scope.bodyMesh, scope.frontLeftWheelMesh, scope.frontRightWheelMesh, scope.backLeftWheelMesh, scope.backRightWheelMesh ];\r\n\r\n\t\t\t// callback\r\n\r\n\t\t\tscope.loaded = true;\r\n\r\n\t\t\tif ( scope.callback ) {\r\n\r\n\t\t\t\tscope.callback( scope );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\tfunction exponentialEaseOut( k ) {\r\n\r\n\t\treturn k === 1 ? 1 : - Math.pow( 2, - 10 * k ) + 1;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar DeviceOrientationControls = function ( object ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.object = object;\r\n\tthis.object.rotation.reorder( 'YXZ' );\r\n\r\n\tthis.enabled = true;\r\n\r\n\tthis.deviceOrientation = {};\r\n\tthis.screenOrientation = 0;\r\n\r\n\tthis.alphaOffset = 0; // radians\r\n\r\n\tvar onDeviceOrientationChangeEvent = function ( event ) {\r\n\r\n\t\tscope.deviceOrientation = event;\r\n\r\n\t};\r\n\r\n\tvar onScreenOrientationChangeEvent = function () {\r\n\r\n\t\tscope.screenOrientation = window.orientation || 0;\r\n\r\n\t};\r\n\r\n\t// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''\r\n\r\n\tvar setObjectQuaternion = function () {\r\n\r\n\t\tvar zee = new Vector3( 0, 0, 1 );\r\n\r\n\t\tvar euler = new Euler();\r\n\r\n\t\tvar q0 = new Quaternion();\r\n\r\n\t\tvar q1 = new Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis\r\n\r\n\t\treturn function ( quaternion, alpha, beta, gamma, orient ) {\r\n\r\n\t\t\teuler.set( beta, alpha, - gamma, 'YXZ' ); // 'ZXY' for the device, but 'YXZ' for us\r\n\r\n\t\t\tquaternion.setFromEuler( euler ); // orient the device\r\n\r\n\t\t\tquaternion.multiply( q1 ); // camera looks out the back of the device, not the top\r\n\r\n\t\t\tquaternion.multiply( q0.setFromAxisAngle( zee, - orient ) ); // adjust for screen orientation\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tthis.connect = function () {\r\n\r\n\t\tonScreenOrientationChangeEvent(); // run once on load\r\n\r\n\t\twindow.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\r\n\t\twindow.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\r\n\r\n\t\tscope.enabled = true;\r\n\r\n\t};\r\n\r\n\tthis.disconnect = function () {\r\n\r\n\t\twindow.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );\r\n\t\twindow.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );\r\n\r\n\t\tscope.enabled = false;\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tvar device = scope.deviceOrientation;\r\n\r\n\t\tif ( device ) {\r\n\r\n\t\t\tvar alpha = device.alpha ? _Math.degToRad( device.alpha ) + scope.alphaOffset : 0; // Z\r\n\r\n\t\t\tvar beta = device.beta ? _Math.degToRad( device.beta ) : 0; // X'\r\n\r\n\t\t\tvar gamma = device.gamma ? _Math.degToRad( device.gamma ) : 0; // Y''\r\n\r\n\t\t\tvar orient = scope.screenOrientation ? _Math.degToRad( scope.screenOrientation ) : 0; // O\r\n\r\n\t\t\tsetObjectQuaternion( scope.object.quaternion, alpha, beta, gamma, orient );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tscope.disconnect();\r\n\r\n\t};\r\n\r\n\tthis.connect();\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Plane( normal, constant ) {\r\n\r\n\t// normal is assumed to be normalized\r\n\r\n\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\r\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n}\r\n\r\nObject.assign( Plane.prototype, {\r\n\r\n\tset: function ( normal, constant ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\tthis.normal.set( x, y, z );\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = - point.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCoplanarPoints: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar v2 = new Vector3();\r\n\r\n\t\treturn function setFromCoplanarPoints( a, b, c ) {\r\n\r\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( plane ) {\r\n\r\n\t\tthis.normal.copy( plane.normal );\r\n\t\tthis.constant = plane.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.constant *= - 1;\r\n\t\tthis.normal.negate();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t},\r\n\r\n\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t},\r\n\r\n\tprojectPoint: function ( point, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Plane: .projectPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\r\n\r\n\t},\r\n\r\n\tintersectLine: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\r\n\t\treturn function intersectLine( line, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'Plane: .intersectLine() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar direction = line.delta( v1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\r\n\t\t\t\t\treturn target.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif ( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsLine: function ( line ) {\r\n\r\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsPlane( this );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\treturn sphere.intersectsPlane( this );\r\n\r\n\t},\r\n\r\n\tcoplanarPoint: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Plane: .coplanarPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar m1 = new Matrix3();\r\n\r\n\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\r\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\r\n\r\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tthis.constant = - referencePoint.dot( normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.constant -= offset.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( plane ) {\r\n\r\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Raycaster( origin, direction, near, far ) {\r\n\r\n\tthis.ray = new Ray( origin, direction );\r\n\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\tthis.near = near || 0;\r\n\tthis.far = far || Infinity;\r\n\r\n\tthis.params = {\r\n\t\tMesh: {},\r\n\t\tLine: {},\r\n\t\tLOD: {},\r\n\t\tPoints: { threshold: 1 },\r\n\t\tSprite: {}\r\n\t};\r\n\r\n\tObject.defineProperties( this.params, {\r\n\t\tPointCloud: {\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\tconsole.warn( 'Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n\t\t\t\treturn this.Points;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\r\n}\r\n\r\nfunction ascSort( a, b ) {\r\n\r\n\treturn a.distance - b.distance;\r\n\r\n}\r\n\r\nfunction intersectObject( object, raycaster, intersects, recursive ) {\r\n\r\n\tif ( object.visible === false ) { return; }\r\n\r\n\tobject.raycast( raycaster, intersects );\r\n\r\n\tif ( recursive === true ) {\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( Raycaster.prototype, {\r\n\r\n\tlinePrecision: 1,\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.ray.set( origin, direction );\r\n\r\n\t},\r\n\r\n\tsetFromCamera: function ( coords, camera ) {\r\n\r\n\t\tif ( ( camera && camera.isPerspectiveCamera ) ) {\r\n\r\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\r\n\t\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\r\n\r\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\r\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( 'Raycaster: Unsupported camera type.' );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tintersectObject: function ( object, recursive, optionalTarget ) {\r\n\r\n\t\tvar intersects = optionalTarget || [];\r\n\r\n\t\tintersectObject( object, this, intersects, recursive );\r\n\r\n\t\tintersects.sort( ascSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t},\r\n\r\n\tintersectObjects: function ( objects, recursive, optionalTarget ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar intersects = optionalTarget || [];\r\n\r\n\t\tif ( Array.isArray( objects ) === false ) {\r\n\r\n\t\t\tconsole.warn( 'Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\treturn intersects;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( objects[ i ], this$1, intersects, recursive );\r\n\r\n\t\t}\r\n\r\n\t\tintersects.sort( ascSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar DragControls = function ( _objects, _camera, _domElement ) {\r\n\r\n\tif ( _objects instanceof Camera ) {\r\n\r\n\t\tconsole.warn( 'DragControls: Constructor now expects ( objects, camera, domElement )' );\r\n\t\tvar temp = _objects; _objects = _camera; _camera = temp;\r\n\r\n\t}\r\n\r\n\tvar _plane = new Plane();\r\n\tvar _raycaster = new Raycaster();\r\n\r\n\tvar _mouse = new Vector2();\r\n\tvar _offset = new Vector3();\r\n\tvar _intersection = new Vector3();\r\n\r\n\tvar _selected = null, _hovered = null;\r\n\r\n\t//\r\n\r\n\tvar scope = this;\r\n\r\n\tfunction activate() {\r\n\r\n\t\t_domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );\r\n\t\t_domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );\r\n\t\t_domElement.addEventListener( 'mouseup', onDocumentMouseCancel, false );\r\n\t\t_domElement.addEventListener( 'mouseleave', onDocumentMouseCancel, false );\r\n\t\t_domElement.addEventListener( 'touchmove', onDocumentTouchMove, false );\r\n\t\t_domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );\r\n\t\t_domElement.addEventListener( 'touchend', onDocumentTouchEnd, false );\r\n\r\n\t}\r\n\r\n\tfunction deactivate() {\r\n\r\n\t\t_domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );\r\n\t\t_domElement.removeEventListener( 'mousedown', onDocumentMouseDown, false );\r\n\t\t_domElement.removeEventListener( 'mouseup', onDocumentMouseCancel, false );\r\n\t\t_domElement.removeEventListener( 'mouseleave', onDocumentMouseCancel, false );\r\n\t\t_domElement.removeEventListener( 'touchmove', onDocumentTouchMove, false );\r\n\t\t_domElement.removeEventListener( 'touchstart', onDocumentTouchStart, false );\r\n\t\t_domElement.removeEventListener( 'touchend', onDocumentTouchEnd, false );\r\n\r\n\t}\r\n\r\n\tfunction dispose() {\r\n\r\n\t\tdeactivate();\r\n\r\n\t}\r\n\r\n\tfunction onDocumentMouseMove( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tvar rect = _domElement.getBoundingClientRect();\r\n\r\n\t\t_mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;\r\n\t\t_mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;\r\n\r\n\t\t_raycaster.setFromCamera( _mouse, _camera );\r\n\r\n\t\tif ( _selected && scope.enabled ) {\r\n\r\n\t\t\tif ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {\r\n\r\n\t\t\t\t_selected.position.copy( _intersection.sub( _offset ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'drag', object: _selected } );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t_raycaster.setFromCamera( _mouse, _camera );\r\n\r\n\t\tvar intersects = _raycaster.intersectObjects( _objects );\r\n\r\n\t\tif ( intersects.length > 0 ) {\r\n\r\n\t\t\tvar object = intersects[ 0 ].object;\r\n\r\n\t\t\t_plane.setFromNormalAndCoplanarPoint( _camera.getWorldDirection( _plane.normal ), object.position );\r\n\r\n\t\t\tif ( _hovered !== object ) {\r\n\r\n\t\t\t\tscope.dispatchEvent( { type: 'hoveron', object: object } );\r\n\r\n\t\t\t\t_domElement.style.cursor = 'pointer';\r\n\t\t\t\t_hovered = object;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( _hovered !== null ) {\r\n\r\n\t\t\t\tscope.dispatchEvent( { type: 'hoveroff', object: _hovered } );\r\n\r\n\t\t\t\t_domElement.style.cursor = 'auto';\r\n\t\t\t\t_hovered = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onDocumentMouseDown( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\t_raycaster.setFromCamera( _mouse, _camera );\r\n\r\n\t\tvar intersects = _raycaster.intersectObjects( _objects );\r\n\r\n\t\tif ( intersects.length > 0 ) {\r\n\r\n\t\t\t_selected = intersects[ 0 ].object;\r\n\r\n\t\t\tif ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {\r\n\r\n\t\t\t\t_offset.copy( _intersection ).sub( _selected.position );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_domElement.style.cursor = 'move';\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'dragstart', object: _selected } );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onDocumentMouseCancel( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tif ( _selected ) {\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'dragend', object: _selected } );\r\n\r\n\t\t\t_selected = null;\r\n\r\n\t\t}\r\n\r\n\t\t_domElement.style.cursor = _hovered ? 'pointer' : 'auto';\r\n\r\n\t}\r\n\r\n\tfunction onDocumentTouchMove( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent = event.changedTouches[ 0 ];\r\n\r\n\t\tvar rect = _domElement.getBoundingClientRect();\r\n\r\n\t\t_mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;\r\n\t\t_mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;\r\n\r\n\t\t_raycaster.setFromCamera( _mouse, _camera );\r\n\r\n\t\tif ( _selected && scope.enabled ) {\r\n\r\n\t\t\tif ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {\r\n\r\n\t\t\t\t_selected.position.copy( _intersection.sub( _offset ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'drag', object: _selected } );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onDocumentTouchStart( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent = event.changedTouches[ 0 ];\r\n\r\n\t\tvar rect = _domElement.getBoundingClientRect();\r\n\r\n\t\t_mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;\r\n\t\t_mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;\r\n\r\n\t\t_raycaster.setFromCamera( _mouse, _camera );\r\n\r\n\t\tvar intersects = _raycaster.intersectObjects( _objects );\r\n\r\n\t\tif ( intersects.length > 0 ) {\r\n\r\n\t\t\t_selected = intersects[ 0 ].object;\r\n\r\n\t\t\t_plane.setFromNormalAndCoplanarPoint( _camera.getWorldDirection( _plane.normal ), _selected.position );\r\n\r\n\t\t\tif ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {\r\n\r\n\t\t\t\t_offset.copy( _intersection ).sub( _selected.position );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_domElement.style.cursor = 'move';\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'dragstart', object: _selected } );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onDocumentTouchEnd( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tif ( _selected ) {\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'dragend', object: _selected } );\r\n\r\n\t\t\t_selected = null;\r\n\r\n\t\t}\r\n\r\n\t\t_domElement.style.cursor = 'auto';\r\n\r\n\t}\r\n\r\n\tactivate();\r\n\r\n\t// API\r\n\r\n\tthis.enabled = true;\r\n\r\n\tthis.activate = activate;\r\n\tthis.deactivate = deactivate;\r\n\tthis.dispose = dispose;\r\n\r\n\t// Backward compatibility\r\n\r\n\tthis.setObjects = function () {\r\n\r\n\t\tconsole.error( 'DragControls: setObjects() has been removed.' );\r\n\r\n\t};\r\n\r\n\tthis.on = function ( type, listener ) {\r\n\r\n\t\tconsole.warn( 'DragControls: on() has been deprecated. Use addEventListener() instead.' );\r\n\t\tscope.addEventListener( type, listener );\r\n\r\n\t};\r\n\r\n\tthis.off = function ( type, listener ) {\r\n\r\n\t\tconsole.warn( 'DragControls: off() has been deprecated. Use removeEventListener() instead.' );\r\n\t\tscope.removeEventListener( type, listener );\r\n\r\n\t};\r\n\r\n\tthis.notify = function ( type ) {\r\n\r\n\t\tconsole.error( 'DragControls: notify() has been deprecated. Use dispatchEvent() instead.' );\r\n\t\tscope.dispatchEvent( { type: type } );\r\n\r\n\t};\r\n\r\n};\r\n\r\nDragControls.prototype = Object.create( EventDispatcher.prototype );\r\nDragControls.prototype.constructor = DragControls;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Spherical( radius, phi, theta ) {\r\n\r\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\r\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // polar angle\r\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle\r\n\r\n\treturn this;\r\n\r\n}\r\n\r\nObject.assign( Spherical.prototype, {\r\n\r\n\tset: function ( radius, phi, theta ) {\r\n\r\n\t\tthis.radius = radius;\r\n\t\tthis.phi = phi;\r\n\t\tthis.theta = theta;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( other ) {\r\n\r\n\t\tthis.radius = other.radius;\r\n\t\tthis.phi = other.phi;\r\n\t\tthis.theta = other.theta;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// restrict phi to be betwee EPS and PI-EPS\r\n\tmakeSafe: function () {\r\n\r\n\t\tvar EPS = 0.000001;\r\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromVector3: function ( v ) {\r\n\r\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\r\n\r\n\t},\r\n\r\n\tsetFromCartesianCoords: function ( x, y, z ) {\r\n\r\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\tif ( this.radius === 0 ) {\r\n\r\n\t\t\tthis.theta = 0;\r\n\t\t\tthis.phi = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.theta = Math.atan2( x, z );\r\n\t\t\tthis.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar EditorControls = function ( object, domElement ) {\r\n\r\n\tdomElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// API\r\n\r\n\tthis.enabled = true;\r\n\tthis.center = new Vector3();\r\n\tthis.panSpeed = 0.001;\r\n\tthis.zoomSpeed = 0.1;\r\n\tthis.rotationSpeed = 0.005;\r\n\r\n\t// internals\r\n\r\n\tvar scope = this;\r\n\tvar vector = new Vector3();\r\n\tvar delta = new Vector3();\r\n\tvar box = new Box3();\r\n\r\n\tvar STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2 };\r\n\tvar state = STATE.NONE;\r\n\r\n\tvar center = this.center;\r\n\tvar normalMatrix = new Matrix3();\r\n\tvar pointer = new Vector2();\r\n\tvar pointerOld = new Vector2();\r\n\tvar spherical = new Spherical();\r\n\r\n\t// events\r\n\r\n\tvar changeEvent = { type: 'change' };\r\n\r\n\tthis.focus = function ( target ) {\r\n\r\n\t\tvar distance;\r\n\r\n\t\tbox.setFromObject( target );\r\n\r\n\t\tif ( box.isEmpty() === false ) {\r\n\r\n\t\t\tcenter.copy( box.getCenter() );\r\n\t\t\tdistance = box.getBoundingSphere().radius;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Focusing on an Group, AmbientLight, etc\r\n\r\n\t\t\tcenter.setFromMatrixPosition( target.matrixWorld );\r\n\t\t\tdistance = 0.1;\r\n\r\n\t\t}\r\n\r\n\t\tdelta.set( 0, 0, 1 );\r\n\t\tdelta.applyQuaternion( object.quaternion );\r\n\t\tdelta.multiplyScalar( distance * 4 );\r\n\r\n\t\tobject.position.copy( center ).add( delta );\r\n\r\n\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t};\r\n\r\n\tthis.pan = function ( delta ) {\r\n\r\n\t\tvar distance = object.position.distanceTo( center );\r\n\r\n\t\tdelta.multiplyScalar( distance * scope.panSpeed );\r\n\t\tdelta.applyMatrix3( normalMatrix.getNormalMatrix( object.matrix ) );\r\n\r\n\t\tobject.position.add( delta );\r\n\t\tcenter.add( delta );\r\n\r\n\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t};\r\n\r\n\tthis.zoom = function ( delta ) {\r\n\r\n\t\tvar distance = object.position.distanceTo( center );\r\n\r\n\t\tdelta.multiplyScalar( distance * scope.zoomSpeed );\r\n\r\n\t\tif ( delta.length() > distance ) { return; }\r\n\r\n\t\tdelta.applyMatrix3( normalMatrix.getNormalMatrix( object.matrix ) );\r\n\r\n\t\tobject.position.add( delta );\r\n\r\n\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t};\r\n\r\n\tthis.rotate = function ( delta ) {\r\n\r\n\t\tvector.copy( object.position ).sub( center );\r\n\r\n\t\tspherical.setFromVector3( vector );\r\n\r\n\t\tspherical.theta += delta.x;\r\n\t\tspherical.phi += delta.y;\r\n\r\n\t\tspherical.makeSafe();\r\n\r\n\t\tvector.setFromSpherical( spherical );\r\n\r\n\t\tobject.position.copy( center ).add( vector );\r\n\r\n\t\tobject.lookAt( center );\r\n\r\n\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t};\r\n\r\n\t// mouse\r\n\r\n\tfunction onMouseDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tif ( event.button === 0 ) {\r\n\r\n\t\t\tstate = STATE.ROTATE;\r\n\r\n\t\t} else if ( event.button === 1 ) {\r\n\r\n\t\t\tstate = STATE.ZOOM;\r\n\r\n\t\t} else if ( event.button === 2 ) {\r\n\r\n\t\t\tstate = STATE.PAN;\r\n\r\n\t\t}\r\n\r\n\t\tpointerOld.set( event.clientX, event.clientY );\r\n\r\n\t\tdomElement.addEventListener( 'mousemove', onMouseMove, false );\r\n\t\tdomElement.addEventListener( 'mouseup', onMouseUp, false );\r\n\t\tdomElement.addEventListener( 'mouseout', onMouseUp, false );\r\n\t\tdomElement.addEventListener( 'dblclick', onMouseUp, false );\r\n\r\n\t}\r\n\r\n\tfunction onMouseMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tpointer.set( event.clientX, event.clientY );\r\n\r\n\t\tvar movementX = pointer.x - pointerOld.x;\r\n\t\tvar movementY = pointer.y - pointerOld.y;\r\n\r\n\t\tif ( state === STATE.ROTATE ) {\r\n\r\n\t\t\tscope.rotate( delta.set( - movementX * scope.rotationSpeed, - movementY * scope.rotationSpeed, 0 ) );\r\n\r\n\t\t} else if ( state === STATE.ZOOM ) {\r\n\r\n\t\t\tscope.zoom( delta.set( 0, 0, movementY ) );\r\n\r\n\t\t} else if ( state === STATE.PAN ) {\r\n\r\n\t\t\tscope.pan( delta.set( - movementX, movementY, 0 ) );\r\n\r\n\t\t}\r\n\r\n\t\tpointerOld.set( event.clientX, event.clientY );\r\n\r\n\t}\r\n\r\n\tfunction onMouseUp( event ) {\r\n\r\n\t\tdomElement.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tdomElement.removeEventListener( 'mouseup', onMouseUp, false );\r\n\t\tdomElement.removeEventListener( 'mouseout', onMouseUp, false );\r\n\t\tdomElement.removeEventListener( 'dblclick', onMouseUp, false );\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onMouseWheel( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\t// Normalize deltaY due to https://bugzilla.mozilla.org/show_bug.cgi?id=1392460\r\n\t\tscope.zoom( delta.set( 0, 0, event.deltaY > 0 ? 1 : - 1 ) );\r\n\r\n\t}\r\n\r\n\tfunction contextmenu( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t}\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tdomElement.removeEventListener( 'contextmenu', contextmenu, false );\r\n\t\tdomElement.removeEventListener( 'mousedown', onMouseDown, false );\r\n\t\tdomElement.removeEventListener( 'wheel', onMouseWheel, false );\r\n\r\n\t\tdomElement.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tdomElement.removeEventListener( 'mouseup', onMouseUp, false );\r\n\t\tdomElement.removeEventListener( 'mouseout', onMouseUp, false );\r\n\t\tdomElement.removeEventListener( 'dblclick', onMouseUp, false );\r\n\r\n\t\tdomElement.removeEventListener( 'touchstart', touchStart, false );\r\n\t\tdomElement.removeEventListener( 'touchmove', touchMove, false );\r\n\r\n\t};\r\n\r\n\tdomElement.addEventListener( 'contextmenu', contextmenu, false );\r\n\tdomElement.addEventListener( 'mousedown', onMouseDown, false );\r\n\tdomElement.addEventListener( 'wheel', onMouseWheel, false );\r\n\r\n\t// touch\r\n\r\n\tvar touches = [ new Vector3(), new Vector3(), new Vector3() ];\r\n\tvar prevTouches = [ new Vector3(), new Vector3(), new Vector3() ];\r\n\r\n\tvar prevDistance = null;\r\n\r\n\tfunction touchStart( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\r\n\t\t\t\ttouches[ 1 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\r\n\t\t\t\ttouches[ 1 ].set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY, 0 );\r\n\t\t\t\tprevDistance = touches[ 0 ].distanceTo( touches[ 1 ] );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tprevTouches[ 0 ].copy( touches[ 0 ] );\r\n\t\tprevTouches[ 1 ].copy( touches[ 1 ] );\r\n\r\n\t}\r\n\r\n\tfunction touchMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tfunction getClosest( touch, touches ) {\r\n\r\n\t\t\tvar closest = touches[ 0 ];\r\n\r\n\t\t\tfor ( var i in touches ) {\r\n\r\n\t\t\t\tif ( closest.distanceTo( touch ) > touches[ i ].distanceTo( touch ) ) { closest = touches[ i ]; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn closest;\r\n\r\n\t\t}\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\r\n\t\t\t\ttouches[ 1 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\r\n\t\t\t\tscope.rotate( touches[ 0 ].sub( getClosest( touches[ 0 ], prevTouches ) ).multiplyScalar( - scope.rotationSpeed ) );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\ttouches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );\r\n\t\t\t\ttouches[ 1 ].set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY, 0 );\r\n\t\t\t\tvar distance = touches[ 0 ].distanceTo( touches[ 1 ] );\r\n\t\t\t\tscope.zoom( delta.set( 0, 0, prevDistance - distance ) );\r\n\t\t\t\tprevDistance = distance;\r\n\r\n\t\t\t\tvar offset0 = touches[ 0 ].clone().sub( getClosest( touches[ 0 ], prevTouches ) );\r\n\t\t\t\tvar offset1 = touches[ 1 ].clone().sub( getClosest( touches[ 1 ], prevTouches ) );\r\n\t\t\t\toffset0.x = - offset0.x;\r\n\t\t\t\toffset1.x = - offset1.x;\r\n\r\n\t\t\t\tscope.pan( offset0.add( offset1 ).multiplyScalar( 0.5 ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tprevTouches[ 0 ].copy( touches[ 0 ] );\r\n\t\tprevTouches[ 1 ].copy( touches[ 1 ] );\r\n\r\n\t}\r\n\r\n\tdomElement.addEventListener( 'touchstart', touchStart, false );\r\n\tdomElement.addEventListener( 'touchmove', touchMove, false );\r\n\r\n};\r\n\r\nEditorControls.prototype = Object.create( EventDispatcher.prototype );\r\nEditorControls.prototype.constructor = EditorControls;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar FirstPersonControls = function ( object, domElement ) {\r\n\r\n\tthis.object = object;\r\n\tthis.target = new Vector3( 0, 0, 0 );\r\n\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\tthis.enabled = true;\r\n\r\n\tthis.movementSpeed = 1.0;\r\n\tthis.lookSpeed = 0.005;\r\n\r\n\tthis.lookVertical = true;\r\n\tthis.autoForward = false;\r\n\r\n\tthis.activeLook = true;\r\n\r\n\tthis.heightSpeed = false;\r\n\tthis.heightCoef = 1.0;\r\n\tthis.heightMin = 0.0;\r\n\tthis.heightMax = 1.0;\r\n\r\n\tthis.constrainVertical = false;\r\n\tthis.verticalMin = 0;\r\n\tthis.verticalMax = Math.PI;\r\n\r\n\tthis.autoSpeedFactor = 0.0;\r\n\r\n\tthis.mouseX = 0;\r\n\tthis.mouseY = 0;\r\n\r\n\tthis.lat = 0;\r\n\tthis.lon = 0;\r\n\tthis.phi = 0;\r\n\tthis.theta = 0;\r\n\r\n\tthis.moveForward = false;\r\n\tthis.moveBackward = false;\r\n\tthis.moveLeft = false;\r\n\tthis.moveRight = false;\r\n\r\n\tthis.mouseDragOn = false;\r\n\r\n\tthis.viewHalfX = 0;\r\n\tthis.viewHalfY = 0;\r\n\r\n\tif ( this.domElement !== document ) {\r\n\r\n\t\tthis.domElement.setAttribute( 'tabindex', - 1 );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tthis.handleResize = function () {\r\n\r\n\t\tif ( this.domElement === document ) {\r\n\r\n\t\t\tthis.viewHalfX = window.innerWidth / 2;\r\n\t\t\tthis.viewHalfY = window.innerHeight / 2;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.viewHalfX = this.domElement.offsetWidth / 2;\r\n\t\t\tthis.viewHalfY = this.domElement.offsetHeight / 2;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.onMouseDown = function ( event ) {\r\n\r\n\t\tif ( this.domElement !== document ) {\r\n\r\n\t\t\tthis.domElement.focus();\r\n\r\n\t\t}\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tif ( this.activeLook ) {\r\n\r\n\t\t\tswitch ( event.button ) {\r\n\r\n\t\t\t\tcase 0: this.moveForward = true; break;\r\n\t\t\t\tcase 2: this.moveBackward = true; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.mouseDragOn = true;\r\n\r\n\t};\r\n\r\n\tthis.onMouseUp = function ( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tif ( this.activeLook ) {\r\n\r\n\t\t\tswitch ( event.button ) {\r\n\r\n\t\t\t\tcase 0: this.moveForward = false; break;\r\n\t\t\t\tcase 2: this.moveBackward = false; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.mouseDragOn = false;\r\n\r\n\t};\r\n\r\n\tthis.onMouseMove = function ( event ) {\r\n\r\n\t\tif ( this.domElement === document ) {\r\n\r\n\t\t\tthis.mouseX = event.pageX - this.viewHalfX;\r\n\t\t\tthis.mouseY = event.pageY - this.viewHalfY;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;\r\n\t\t\tthis.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.onKeyDown = function ( event ) {\r\n\r\n\t\t//event.preventDefault();\r\n\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase 38: \r\n\t\t\tcase 87:  this.moveForward = true; break;\r\n\r\n\t\t\tcase 37: \r\n\t\t\tcase 65:  this.moveLeft = true; break;\r\n\r\n\t\t\tcase 40: \r\n\t\t\tcase 83:  this.moveBackward = true; break;\r\n\r\n\t\t\tcase 39: \r\n\t\t\tcase 68:  this.moveRight = true; break;\r\n\r\n\t\t\tcase 82:  this.moveUp = true; break;\r\n\t\t\tcase 70:  this.moveDown = true; break;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.onKeyUp = function ( event ) {\r\n\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase 38: \r\n\t\t\tcase 87:  this.moveForward = false; break;\r\n\r\n\t\t\tcase 37: \r\n\t\t\tcase 65:  this.moveLeft = false; break;\r\n\r\n\t\t\tcase 40: \r\n\t\t\tcase 83:  this.moveBackward = false; break;\r\n\r\n\t\t\tcase 39: \r\n\t\t\tcase 68:  this.moveRight = false; break;\r\n\r\n\t\t\tcase 82:  this.moveUp = false; break;\r\n\t\t\tcase 70:  this.moveDown = false; break;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.update = function ( delta ) {\r\n\r\n\t\tif ( this.enabled === false ) { return; }\r\n\r\n\t\tif ( this.heightSpeed ) {\r\n\r\n\t\t\tvar y = _Math.clamp( this.object.position.y, this.heightMin, this.heightMax );\r\n\t\t\tvar heightDelta = y - this.heightMin;\r\n\r\n\t\t\tthis.autoSpeedFactor = delta * ( heightDelta * this.heightCoef );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.autoSpeedFactor = 0.0;\r\n\r\n\t\t}\r\n\r\n\t\tvar actualMoveSpeed = delta * this.movementSpeed;\r\n\r\n\t\tif ( this.moveForward || ( this.autoForward && ! this.moveBackward ) ) { this.object.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) ); }\r\n\t\tif ( this.moveBackward ) { this.object.translateZ( actualMoveSpeed ); }\r\n\r\n\t\tif ( this.moveLeft ) { this.object.translateX( - actualMoveSpeed ); }\r\n\t\tif ( this.moveRight ) { this.object.translateX( actualMoveSpeed ); }\r\n\r\n\t\tif ( this.moveUp ) { this.object.translateY( actualMoveSpeed ); }\r\n\t\tif ( this.moveDown ) { this.object.translateY( - actualMoveSpeed ); }\r\n\r\n\t\tvar actualLookSpeed = delta * this.lookSpeed;\r\n\r\n\t\tif ( ! this.activeLook ) {\r\n\r\n\t\t\tactualLookSpeed = 0;\r\n\r\n\t\t}\r\n\r\n\t\tvar verticalLookRatio = 1;\r\n\r\n\t\tif ( this.constrainVertical ) {\r\n\r\n\t\t\tverticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );\r\n\r\n\t\t}\r\n\r\n\t\tthis.lon += this.mouseX * actualLookSpeed;\r\n\t\tif ( this.lookVertical ) { this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio; }\r\n\r\n\t\tthis.lat = Math.max( - 85, Math.min( 85, this.lat ) );\r\n\t\tthis.phi = _Math.degToRad( 90 - this.lat );\r\n\r\n\t\tthis.theta = _Math.degToRad( this.lon );\r\n\r\n\t\tif ( this.constrainVertical ) {\r\n\r\n\t\t\tthis.phi = _Math.mapLinear( this.phi, 0, Math.PI, this.verticalMin, this.verticalMax );\r\n\r\n\t\t}\r\n\r\n\t\tvar targetPosition = this.target,\r\n\t\t\tposition = this.object.position;\r\n\r\n\t\ttargetPosition.x = position.x + 100 * Math.sin( this.phi ) * Math.cos( this.theta );\r\n\t\ttargetPosition.y = position.y + 100 * Math.cos( this.phi );\r\n\t\ttargetPosition.z = position.z + 100 * Math.sin( this.phi ) * Math.sin( this.theta );\r\n\r\n\t\tthis.object.lookAt( targetPosition );\r\n\r\n\t};\r\n\r\n\tfunction contextmenu( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t}\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tthis.domElement.removeEventListener( 'contextmenu', contextmenu, false );\r\n\t\tthis.domElement.removeEventListener( 'mousedown', _onMouseDown, false );\r\n\t\tthis.domElement.removeEventListener( 'mousemove', _onMouseMove, false );\r\n\t\tthis.domElement.removeEventListener( 'mouseup', _onMouseUp, false );\r\n\r\n\t\twindow.removeEventListener( 'keydown', _onKeyDown, false );\r\n\t\twindow.removeEventListener( 'keyup', _onKeyUp, false );\r\n\r\n\t};\r\n\r\n\tvar _onMouseMove = bind( this, this.onMouseMove );\r\n\tvar _onMouseDown = bind( this, this.onMouseDown );\r\n\tvar _onMouseUp = bind( this, this.onMouseUp );\r\n\tvar _onKeyDown = bind( this, this.onKeyDown );\r\n\tvar _onKeyUp = bind( this, this.onKeyUp );\r\n\r\n\tthis.domElement.addEventListener( 'contextmenu', contextmenu, false );\r\n\tthis.domElement.addEventListener( 'mousemove', _onMouseMove, false );\r\n\tthis.domElement.addEventListener( 'mousedown', _onMouseDown, false );\r\n\tthis.domElement.addEventListener( 'mouseup', _onMouseUp, false );\r\n\r\n\twindow.addEventListener( 'keydown', _onKeyDown, false );\r\n\twindow.addEventListener( 'keyup', _onKeyUp, false );\r\n\r\n\tfunction bind( scope, fn ) {\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tfn.apply( scope, arguments );\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tthis.handleResize();\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar FlyControls = function ( object, domElement ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\tif ( domElement ) { this.domElement.setAttribute( 'tabindex', - 1 ); }\r\n\r\n\t// API\r\n\r\n\tthis.movementSpeed = 1.0;\r\n\tthis.rollSpeed = 0.005;\r\n\r\n\tthis.dragToLook = false;\r\n\tthis.autoForward = false;\r\n\r\n\t// disable default target object behavior\r\n\r\n\t// internals\r\n\r\n\tthis.tmpQuaternion = new Quaternion();\r\n\r\n\tthis.mouseStatus = 0;\r\n\r\n\tthis.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };\r\n\tthis.moveVector = new Vector3( 0, 0, 0 );\r\n\tthis.rotationVector = new Vector3( 0, 0, 0 );\r\n\r\n\tthis.keydown = function ( event ) {\r\n\r\n\t\tif ( event.altKey ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t//event.preventDefault();\r\n\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase 16:  this.movementSpeedMultiplier = .1; break;\r\n\r\n\t\t\tcase 87:  this.moveState.forward = 1; break;\r\n\t\t\tcase 83:  this.moveState.back = 1; break;\r\n\r\n\t\t\tcase 65:  this.moveState.left = 1; break;\r\n\t\t\tcase 68:  this.moveState.right = 1; break;\r\n\r\n\t\t\tcase 82:  this.moveState.up = 1; break;\r\n\t\t\tcase 70:  this.moveState.down = 1; break;\r\n\r\n\t\t\tcase 38:  this.moveState.pitchUp = 1; break;\r\n\t\t\tcase 40:  this.moveState.pitchDown = 1; break;\r\n\r\n\t\t\tcase 37:  this.moveState.yawLeft = 1; break;\r\n\t\t\tcase 39:  this.moveState.yawRight = 1; break;\r\n\r\n\t\t\tcase 81:  this.moveState.rollLeft = 1; break;\r\n\t\t\tcase 69:  this.moveState.rollRight = 1; break;\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMovementVector();\r\n\t\tthis.updateRotationVector();\r\n\r\n\t};\r\n\r\n\tthis.keyup = function ( event ) {\r\n\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase 16:  this.movementSpeedMultiplier = 1; break;\r\n\r\n\t\t\tcase 87:  this.moveState.forward = 0; break;\r\n\t\t\tcase 83:  this.moveState.back = 0; break;\r\n\r\n\t\t\tcase 65:  this.moveState.left = 0; break;\r\n\t\t\tcase 68:  this.moveState.right = 0; break;\r\n\r\n\t\t\tcase 82:  this.moveState.up = 0; break;\r\n\t\t\tcase 70:  this.moveState.down = 0; break;\r\n\r\n\t\t\tcase 38:  this.moveState.pitchUp = 0; break;\r\n\t\t\tcase 40:  this.moveState.pitchDown = 0; break;\r\n\r\n\t\t\tcase 37:  this.moveState.yawLeft = 0; break;\r\n\t\t\tcase 39:  this.moveState.yawRight = 0; break;\r\n\r\n\t\t\tcase 81:  this.moveState.rollLeft = 0; break;\r\n\t\t\tcase 69:  this.moveState.rollRight = 0; break;\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMovementVector();\r\n\t\tthis.updateRotationVector();\r\n\r\n\t};\r\n\r\n\tthis.mousedown = function ( event ) {\r\n\r\n\t\tif ( this.domElement !== document ) {\r\n\r\n\t\t\tthis.domElement.focus();\r\n\r\n\t\t}\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tif ( this.dragToLook ) {\r\n\r\n\t\t\tthis.mouseStatus ++;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tswitch ( event.button ) {\r\n\r\n\t\t\t\tcase 0: this.moveState.forward = 1; break;\r\n\t\t\t\tcase 2: this.moveState.back = 1; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateMovementVector();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.mousemove = function ( event ) {\r\n\r\n\t\tif ( ! this.dragToLook || this.mouseStatus > 0 ) {\r\n\r\n\t\t\tvar container = this.getContainerDimensions();\r\n\t\t\tvar halfWidth = container.size[ 0 ] / 2;\r\n\t\t\tvar halfHeight = container.size[ 1 ] / 2;\r\n\r\n\t\t\tthis.moveState.yawLeft = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth ) / halfWidth;\r\n\t\t\tthis.moveState.pitchDown = ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;\r\n\r\n\t\t\tthis.updateRotationVector();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.mouseup = function ( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tif ( this.dragToLook ) {\r\n\r\n\t\t\tthis.mouseStatus --;\r\n\r\n\t\t\tthis.moveState.yawLeft = this.moveState.pitchDown = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tswitch ( event.button ) {\r\n\r\n\t\t\t\tcase 0: this.moveState.forward = 0; break;\r\n\t\t\t\tcase 2: this.moveState.back = 0; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateMovementVector();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateRotationVector();\r\n\r\n\t};\r\n\r\n\tthis.update = function ( delta ) {\r\n\r\n\t\tvar moveMult = delta * this.movementSpeed;\r\n\t\tvar rotMult = delta * this.rollSpeed;\r\n\r\n\t\tthis.object.translateX( this.moveVector.x * moveMult );\r\n\t\tthis.object.translateY( this.moveVector.y * moveMult );\r\n\t\tthis.object.translateZ( this.moveVector.z * moveMult );\r\n\r\n\t\tthis.tmpQuaternion.set( this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1 ).normalize();\r\n\t\tthis.object.quaternion.multiply( this.tmpQuaternion );\r\n\r\n\t\t// expose the rotation vector for convenience\r\n\t\tthis.object.rotation.setFromQuaternion( this.object.quaternion, this.object.rotation.order );\r\n\r\n\t};\r\n\r\n\tthis.updateMovementVector = function () {\r\n\r\n\t\tvar forward = ( this.moveState.forward || ( this.autoForward && ! this.moveState.back ) ) ? 1 : 0;\r\n\r\n\t\tthis.moveVector.x = ( - this.moveState.left + this.moveState.right );\r\n\t\tthis.moveVector.y = ( - this.moveState.down + this.moveState.up );\r\n\t\tthis.moveVector.z = ( - forward + this.moveState.back );\r\n\r\n\t\t//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );\r\n\r\n\t};\r\n\r\n\tthis.updateRotationVector = function () {\r\n\r\n\t\tthis.rotationVector.x = ( - this.moveState.pitchDown + this.moveState.pitchUp );\r\n\t\tthis.rotationVector.y = ( - this.moveState.yawRight + this.moveState.yawLeft );\r\n\t\tthis.rotationVector.z = ( - this.moveState.rollRight + this.moveState.rollLeft );\r\n\r\n\t\t//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );\r\n\r\n\t};\r\n\r\n\tthis.getContainerDimensions = function () {\r\n\r\n\t\tif ( this.domElement != document ) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tsize: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],\r\n\t\t\t\toffset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tsize: [ window.innerWidth, window.innerHeight ],\r\n\t\t\t\toffset: [ 0, 0 ]\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction bind( scope, fn ) {\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tfn.apply( scope, arguments );\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction contextmenu( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t}\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tthis.domElement.removeEventListener( 'contextmenu', contextmenu, false );\r\n\t\tthis.domElement.removeEventListener( 'mousedown', _mousedown, false );\r\n\t\tthis.domElement.removeEventListener( 'mousemove', _mousemove, false );\r\n\t\tthis.domElement.removeEventListener( 'mouseup', _mouseup, false );\r\n\r\n\t\twindow.removeEventListener( 'keydown', _keydown, false );\r\n\t\twindow.removeEventListener( 'keyup', _keyup, false );\r\n\r\n\t};\r\n\r\n\tvar _mousemove = bind( this, this.mousemove );\r\n\tvar _mousedown = bind( this, this.mousedown );\r\n\tvar _mouseup = bind( this, this.mouseup );\r\n\tvar _keydown = bind( this, this.keydown );\r\n\tvar _keyup = bind( this, this.keyup );\r\n\r\n\tthis.domElement.addEventListener( 'contextmenu', contextmenu, false );\r\n\r\n\tthis.domElement.addEventListener( 'mousemove', _mousemove, false );\r\n\tthis.domElement.addEventListener( 'mousedown', _mousedown, false );\r\n\tthis.domElement.addEventListener( 'mouseup', _mouseup, false );\r\n\r\n\twindow.addEventListener( 'keydown', _keydown, false );\r\n\twindow.addEventListener( 'keyup', _keyup, false );\r\n\r\n\tthis.updateMovementVector();\r\n\tthis.updateRotationVector();\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning.\r\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\r\n// This is very similar to OrbitControls, another set of touch behavior\r\n//\r\n//    Orbit - right mouse, or left mouse + ctrl/metaKey / touch: two-finger rotate\r\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\r\n//    Pan - left mouse, or arrow keys / touch: one-finger move\r\n\r\nvar MapControls = function ( object, domElement ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// Set to false to disable this control\r\n\tthis.enabled = true;\r\n\r\n\t// \"target\" sets the location of focus, where the object orbits around\r\n\tthis.target = new Vector3();\r\n\r\n\t// How far you can dolly in and out ( PerspectiveCamera only )\r\n\tthis.minDistance = 0;\r\n\tthis.maxDistance = Infinity;\r\n\r\n\t// How far you can zoom in and out ( OrthographicCamera only )\r\n\tthis.minZoom = 0;\r\n\tthis.maxZoom = Infinity;\r\n\r\n\t// How far you can orbit vertically, upper and lower limits.\r\n\t// Range is 0 to Math.PI radians.\r\n\tthis.minPolarAngle = 0; // radians\r\n\tthis.maxPolarAngle = Math.PI; // radians\r\n\r\n\t// How far you can orbit horizontally, upper and lower limits.\r\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\r\n\tthis.minAzimuthAngle = - Infinity; // radians\r\n\tthis.maxAzimuthAngle = Infinity; // radians\r\n\r\n\t// Set to true to enable damping (inertia)\r\n\t// If damping is enabled, you must call controls.update() in your animation loop\r\n\tthis.enableDamping = false;\r\n\tthis.dampingFactor = 0.25;\r\n\r\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\r\n\t// Set to false to disable zooming\r\n\tthis.enableZoom = true;\r\n\tthis.zoomSpeed = 1.0;\r\n\r\n\t// Set to false to disable rotating\r\n\tthis.enableRotate = true;\r\n\tthis.rotateSpeed = 1.0;\r\n\r\n\t// Set to false to disable panning\r\n\tthis.enablePan = true;\r\n\tthis.panSpeed = 1.0;\r\n\tthis.screenSpacePanning = false; // if true, pan in screen-space\r\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n\t// Set to true to automatically rotate around the target\r\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\r\n\tthis.autoRotate = false;\r\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n\t// Set to false to disable use of the keys\r\n\tthis.enableKeys = true;\r\n\r\n\t// The four arrow keys\r\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n\t// Mouse buttons\r\n\tthis.mouseButtons = { LEFT: MOUSE.LEFT, MIDDLE: MOUSE.MIDDLE, RIGHT: MOUSE.RIGHT };\r\n\r\n\t// for reset\r\n\tthis.target0 = this.target.clone();\r\n\tthis.position0 = this.object.position.clone();\r\n\tthis.zoom0 = this.object.zoom;\r\n\r\n\t//\r\n\t// public methods\r\n\t//\r\n\r\n\tthis.getPolarAngle = function () {\r\n\r\n\t\treturn spherical.phi;\r\n\r\n\t};\r\n\r\n\tthis.getAzimuthalAngle = function () {\r\n\r\n\t\treturn spherical.theta;\r\n\r\n\t};\r\n\r\n\tthis.saveState = function () {\r\n\r\n\t\tscope.target0.copy( scope.target );\r\n\t\tscope.position0.copy( scope.object.position );\r\n\t\tscope.zoom0 = scope.object.zoom;\r\n\r\n\t};\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tscope.target.copy( scope.target0 );\r\n\t\tscope.object.position.copy( scope.position0 );\r\n\t\tscope.object.zoom = scope.zoom0;\r\n\r\n\t\tscope.object.updateProjectionMatrix();\r\n\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t\tscope.update();\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t};\r\n\r\n\t// this method is exposed, but perhaps it would be better if we can make it private...\r\n\tthis.update = function () {\r\n\r\n\t\tvar offset = new Vector3();\r\n\r\n\t\t// so camera.up is the orbit axis\r\n\t\tvar quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\r\n\t\tvar quatInverse = quat.clone().inverse();\r\n\r\n\t\tvar lastPosition = new Vector3();\r\n\t\tvar lastQuaternion = new Quaternion();\r\n\r\n\t\treturn function update() {\r\n\r\n\t\t\tvar position = scope.object.position;\r\n\r\n\t\t\toffset.copy( position ).sub( scope.target );\r\n\r\n\t\t\t// rotate offset to \"y-axis-is-up\" space\r\n\t\t\toffset.applyQuaternion( quat );\r\n\r\n\t\t\t// angle from z-axis around y-axis\r\n\t\t\tspherical.setFromVector3( offset );\r\n\r\n\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\r\n\r\n\t\t\t\trotateLeft( getAutoRotationAngle() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tspherical.theta += sphericalDelta.theta;\r\n\t\t\tspherical.phi += sphericalDelta.phi;\r\n\r\n\t\t\t// restrict theta to be between desired limits\r\n\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\r\n\r\n\t\t\t// restrict phi to be between desired limits\r\n\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\r\n\r\n\t\t\tspherical.makeSafe();\r\n\r\n\t\t\tspherical.radius *= scale;\r\n\r\n\t\t\t// restrict radius to be between desired limits\r\n\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\r\n\r\n\t\t\t// move target to panned location\r\n\t\t\tscope.target.add( panOffset );\r\n\r\n\t\t\toffset.setFromSpherical( spherical );\r\n\r\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\r\n\t\t\toffset.applyQuaternion( quatInverse );\r\n\r\n\t\t\tposition.copy( scope.target ).add( offset );\r\n\r\n\t\t\tscope.object.lookAt( scope.target );\r\n\r\n\t\t\tif ( scope.enableDamping === true ) {\r\n\r\n\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\r\n\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\r\n\r\n\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsphericalDelta.set( 0, 0, 0 );\r\n\r\n\t\t\t\tpanOffset.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscale = 1;\r\n\r\n\t\t\t// update condition is:\r\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\r\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n\r\n\t\t\tif ( zoomChanged ||\r\n\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\r\n\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\r\n\r\n\t\t\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t\t\t\tlastPosition.copy( scope.object.position );\r\n\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\r\n\t\t\t\tzoomChanged = false;\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\r\n\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\r\n\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\r\n\r\n\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\r\n\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\r\n\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\r\n\r\n\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\r\n\r\n\t};\r\n\r\n\t//\r\n\t// internals\r\n\t//\r\n\r\n\tvar scope = this;\r\n\r\n\tvar changeEvent = { type: 'change' };\r\n\tvar startEvent = { type: 'start' };\r\n\tvar endEvent = { type: 'end' };\r\n\r\n\tvar STATE = {\r\n\t\tNONE: 0,\r\n\t\tROTATE_UP: 1,\r\n\t\tROTATE_LEFT: 2,\r\n\t\tROTATE: 3, // ROTATE_UP | ROTATE_LEFT\r\n\t\tDOLLY: 4,\r\n\t\tDOLLY_ROTATE: 7, // ROTATE | DOLLY\r\n\t\tPAN: 8,\r\n\t\tDOLLY_PAN: 12, // DOLLY | PAN\r\n\t};\r\n\r\n\tvar state = STATE.NONE;\r\n\r\n\tvar EPS = 0.000001;\r\n\r\n\t// current position in spherical coordinates\r\n\tvar spherical = new Spherical();\r\n\tvar sphericalDelta = new Spherical();\r\n\r\n\tvar scale = 1;\r\n\tvar panOffset = new Vector3();\r\n\tvar zoomChanged = false;\r\n\r\n\tvar rotateStart = new Vector2();\r\n\tvar rotateStart2 = new Vector2();\r\n\tvar rotateEnd = new Vector2();\r\n\tvar rotateEnd2 = new Vector2();\r\n\tvar rotateDelta = new Vector2();\r\n\tvar rotateDelta2 = new Vector2();\r\n\tvar rotateDeltaStartFingers = new Vector2();\r\n\tvar rotateDeltaEndFingers = new Vector2();\r\n\r\n\tvar panStart = new Vector2();\r\n\tvar panEnd = new Vector2();\r\n\tvar panDelta = new Vector2();\r\n\r\n\tvar dollyStart = new Vector2();\r\n\tvar dollyEnd = new Vector2();\r\n\tvar dollyDelta = new Vector2();\r\n\r\n\tfunction getAutoRotationAngle() {\r\n\r\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n\t}\r\n\r\n\tfunction getZoomScale() {\r\n\r\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n\t}\r\n\r\n\tfunction rotateLeft( angle ) {\r\n\r\n\t\tsphericalDelta.theta -= angle;\r\n\r\n\t}\r\n\r\n\tfunction rotateUp( angle ) {\r\n\r\n\t\tsphericalDelta.phi -= angle;\r\n\r\n\t}\r\n\r\n\tvar panLeft = function () {\r\n\r\n\t\tvar v = new Vector3();\r\n\r\n\t\treturn function panLeft( distance, objectMatrix ) {\r\n\r\n\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\r\n\t\t\tv.multiplyScalar( - distance );\r\n\r\n\t\t\tpanOffset.add( v );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tvar panUp = function () {\r\n\r\n\t\tvar v = new Vector3();\r\n\r\n\t\treturn function panUp( distance, objectMatrix ) {\r\n\r\n\t\t\tif ( scope.screenSpacePanning === true ) {\r\n\r\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\r\n\t\t\t\tv.crossVectors( scope.object.up, v );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv.multiplyScalar( distance );\r\n\r\n\t\t\tpanOffset.add( v );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\t// deltaX and deltaY are in pixels; right and down are positive\r\n\tvar pan = function () {\r\n\r\n\t\tvar offset = new Vector3();\r\n\r\n\t\treturn function pan( deltaX, deltaY ) {\r\n\r\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\r\n\r\n\t\t\t\t// perspective\r\n\t\t\t\tvar position = scope.object.position;\r\n\t\t\t\toffset.copy( position ).sub( scope.target );\r\n\t\t\t\tvar targetDistance = offset.length();\r\n\r\n\t\t\t\t// half of the fov is center to top of screen\r\n\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\r\n\r\n\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\r\n\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\r\n\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\r\n\r\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\r\n\r\n\t\t\t\t// orthographic\r\n\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\r\n\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// camera neither orthographic nor perspective\r\n\t\t\t\tconsole.warn( 'WARNING: MapControls.js encountered an unknown camera type - pan disabled.' );\r\n\t\t\t\tscope.enablePan = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tfunction dollyIn( dollyScale ) {\r\n\r\n\t\tif ( scope.object.isPerspectiveCamera ) {\r\n\r\n\t\t\tscale /= dollyScale;\r\n\r\n\t\t} else if ( scope.object.isOrthographicCamera ) {\r\n\r\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\r\n\t\t\tscope.object.updateProjectionMatrix();\r\n\t\t\tzoomChanged = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'WARNING: MapControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n\t\t\tscope.enableZoom = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction dollyOut( dollyScale ) {\r\n\r\n\t\tif ( scope.object.isPerspectiveCamera ) {\r\n\r\n\t\t\tscale *= dollyScale;\r\n\r\n\t\t} else if ( scope.object.isOrthographicCamera ) {\r\n\r\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\r\n\t\t\tscope.object.updateProjectionMatrix();\r\n\t\t\tzoomChanged = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'WARNING: MapControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n\t\t\tscope.enableZoom = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\t// event callbacks - update the object state\r\n\t//\r\n\r\n\tfunction handleMouseDownRotate( event ) {\r\n\r\n\t\t//console.log( 'handleMouseDownRotate' );\r\n\r\n\t\trotateStart.set( event.clientX, event.clientY );\r\n\r\n\t}\r\n\r\n\tfunction handleMouseDownDolly( event ) {\r\n\r\n\t\t//console.log( 'handleMouseDownDolly' );\r\n\r\n\t\tdollyStart.set( event.clientX, event.clientY );\r\n\r\n\t}\r\n\r\n\tfunction handleMouseDownPan( event ) {\r\n\r\n\t\t//console.log( 'handleMouseDownPan' );\r\n\r\n\t\tpanStart.set( event.clientX, event.clientY );\r\n\r\n\t}\r\n\r\n\tfunction handleMouseMoveRotate( event ) {\r\n\r\n\t\t//console.log( 'handleMouseMoveRotate' );\r\n\r\n\t\trotateEnd.set( event.clientX, event.clientY );\r\n\r\n\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\r\n\r\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\r\n\r\n\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleMouseMoveDolly( event ) {\r\n\r\n\t\t//console.log( 'handleMouseMoveDolly' );\r\n\r\n\t\tdollyEnd.set( event.clientX, event.clientY );\r\n\r\n\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\tdollyIn( getZoomScale() );\r\n\r\n\t\t} else if ( dollyDelta.y < 0 ) {\r\n\r\n\t\t\tdollyOut( getZoomScale() );\r\n\r\n\t\t}\r\n\r\n\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleMouseMovePan( event ) {\r\n\r\n\t\t//console.log( 'handleMouseMovePan' );\r\n\r\n\t\tpanEnd.set( event.clientX, event.clientY );\r\n\r\n\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\r\n\r\n\t\tpan( panDelta.x, panDelta.y );\r\n\r\n\t\tpanStart.copy( panEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleMouseWheel( event ) {\r\n\r\n\t\t// console.log( 'handleMouseWheel' );\r\n\r\n\t\tif ( event.deltaY < 0 ) {\r\n\r\n\t\t\tdollyOut( getZoomScale() );\r\n\r\n\t\t} else if ( event.deltaY > 0 ) {\r\n\r\n\t\t\tdollyIn( getZoomScale() );\r\n\r\n\t\t}\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleKeyDown( event ) {\r\n\r\n\t\t//console.log( 'handleKeyDown' );\r\n\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase scope.keys.UP:\r\n\t\t\t\tpan( 0, scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.BOTTOM:\r\n\t\t\t\tpan( 0, - scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.LEFT:\r\n\t\t\t\tpan( scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.RIGHT:\r\n\t\t\t\tpan( - scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction handleTouchStartRotate( event ) {\r\n\r\n\t\t// console.log( 'handleTouchStartRotate' );\r\n\r\n\t\t// First finger\r\n\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n\t\t// Second finger\r\n\t\trotateStart2.set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY );\r\n\r\n\t}\r\n\r\n\tfunction handleTouchStartDolly( event ) {\r\n\r\n\t\tif ( scope.enableZoom ) {\r\n\r\n\t\t\t// console.log( 'handleTouchStartDolly' );\r\n\r\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\tdollyStart.set( 0, distance );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction handleTouchStartPan( event ) {\r\n\r\n\t\tif ( scope.enablePan ) {\r\n\r\n\t\t\t// console.log( 'handleTouchStartPan' );\r\n\r\n\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction handleTouchMoveRotate( event ) {\r\n\r\n\t\tif ( scope.enableRotate === false ) { return; }\r\n\t\tif ( ( state & STATE.ROTATE ) === 0 ) { return; }\r\n\r\n\t\t// First finger\r\n\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n\t\t// Second finger\r\n\t\trotateEnd2.set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY );\r\n\r\n\t\trotateDelta.subVectors( rotateEnd, rotateStart );\r\n\t\trotateDelta2.subVectors( rotateEnd2, rotateStart2 );\r\n\t\trotateDeltaStartFingers.subVectors( rotateStart2, rotateStart );\r\n\t\trotateDeltaEndFingers.subVectors( rotateEnd2, rotateEnd );\r\n\r\n\t\tif ( isRotateUp() ) {\r\n\r\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\r\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\r\n\r\n\t\t\t// Start rotateUp ==> disable all movement to prevent flickering\r\n\t\t\tstate = STATE.ROTATE_UP;\r\n\r\n\t\t} else if ( ( state & STATE.ROTATE_LEFT ) !== 0 ) {\r\n\r\n\t\t\trotateLeft( ( rotateDeltaStartFingers.angle() - rotateDeltaEndFingers.angle() ) * scope.rotateSpeed );\r\n\r\n\t\t}\r\n\r\n\t\trotateStart.copy( rotateEnd );\r\n\t\trotateStart2.copy( rotateEnd2 );\r\n\r\n\t}\r\n\r\n\tfunction isRotateUp() {\r\n\r\n\t\t// At start, does the two fingers are aligned horizontally\r\n\t\tif ( ! isHorizontal( rotateDeltaStartFingers ) ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\t// At end, does the two fingers are aligned horizontally\r\n\t\tif ( ! isHorizontal( rotateDeltaEndFingers ) ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\t// does the first finger moved vertically between start and end\r\n\t\tif ( ! isVertical( rotateDelta ) ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\t// does the second finger moved vertically between start and end\r\n\t\tif ( ! isVertical( rotateDelta2 ) ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\t// Does the two finger moved in the same direction (prevent moving one finger vertically up while the other goes down)\r\n\t\treturn rotateDelta.dot( rotateDelta2 ) > 0;\r\n\r\n\t}\r\n\r\n\tvar isHorizontal = function () {\r\n\r\n\t\tvar precision = Math.sin( Math.PI / 6 );\r\n\r\n\t\treturn function isHorizontal( vector ) {\r\n\r\n\t\t\treturn Math.abs( Math.sin( vector.angle() ) ) < precision;\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tvar isVertical = function () {\r\n\r\n\t\tvar precision = Math.cos( Math.PI / 2 - Math.PI / 6 );\r\n\r\n\t\treturn function isVertical( vector ) {\r\n\r\n\t\t\treturn Math.abs( Math.cos( vector.angle() ) ) < precision;\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tfunction handleTouchMoveDolly( event ) {\r\n\r\n\t\tif ( scope.enableZoom === false ) { return; }\r\n\t\tif ( ( state & STATE.DOLLY ) === 0 ) { return; }\r\n\r\n\t\t// console.log( 'handleTouchMoveDolly' );\r\n\r\n\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\tdollyEnd.set( 0, distance );\r\n\r\n\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\r\n\r\n\t\tdollyIn( dollyDelta.y );\r\n\r\n\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t}\r\n\r\n\tfunction handleTouchMovePan( event ) {\r\n\r\n\t\tif ( scope.enablePan === false ) { return; }\r\n\t\tif ( ( state & STATE.PAN ) === 0 ) { return; }\r\n\r\n\t\t// console.log( 'handleTouchMovePan' );\r\n\r\n\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\r\n\r\n\t\tpan( panDelta.x, panDelta.y );\r\n\r\n\t\tpanStart.copy( panEnd );\r\n\r\n\t}\r\n\r\n\t//\r\n\t// event handlers - FSM: listen for events and reset state\r\n\t//\r\n\r\n\tfunction onMouseDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tswitch ( event.button ) {\r\n\r\n\t\t\tcase scope.mouseButtons.LEFT:\r\n\r\n\t\t\t\tif ( event.ctrlKey || event.metaKey ) {\r\n\r\n\t\t\t\t\tif ( scope.enableRotate === false ) { return; }\r\n\r\n\t\t\t\t\thandleMouseDownRotate( event );\r\n\r\n\t\t\t\t\tstate = STATE.ROTATE;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( scope.enablePan === false ) { return; }\r\n\r\n\t\t\t\t\thandleMouseDownPan( event );\r\n\r\n\t\t\t\t\tstate = STATE.PAN;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.mouseButtons.MIDDLE:\r\n\r\n\t\t\t\tif ( scope.enableZoom === false ) { return; }\r\n\r\n\t\t\t\thandleMouseDownDolly( event );\r\n\r\n\t\t\t\tstate = STATE.DOLLY;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.mouseButtons.RIGHT:\r\n\r\n\t\t\t\tif ( scope.enableRotate === false ) { return; }\r\n\r\n\t\t\t\thandleMouseDownRotate( event );\r\n\r\n\t\t\t\tstate = STATE.ROTATE;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tif ( state !== STATE.NONE ) {\r\n\r\n\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\r\n\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\r\n\r\n\t\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onMouseMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tswitch ( state ) {\r\n\r\n\t\t\tcase STATE.ROTATE:\r\n\r\n\t\t\t\tif ( scope.enableRotate === false ) { return; }\r\n\r\n\t\t\t\thandleMouseMoveRotate( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase STATE.DOLLY:\r\n\r\n\t\t\t\tif ( scope.enableZoom === false ) { return; }\r\n\r\n\t\t\t\thandleMouseMoveDolly( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase STATE.PAN:\r\n\r\n\t\t\t\tif ( scope.enablePan === false ) { return; }\r\n\r\n\t\t\t\thandleMouseMovePan( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onMouseUp( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onMouseWheel( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t\thandleMouseWheel( event );\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction onKeyDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) { return; }\r\n\r\n\t\thandleKeyDown( event );\r\n\r\n\t}\r\n\r\n\tfunction onTouchStart( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\t// one-fingered touch: pan\r\n\r\n\t\t\t\tif ( scope.enablePan === false ) { return; }\r\n\r\n\t\t\t\thandleTouchStartPan( event );\r\n\r\n\t\t\t\tstate = STATE.PAN;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\t// two-fingered touch: rotate-dolly\r\n\r\n\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) { return; }\r\n\r\n\t\t\t\thandleTouchStartRotate( event );\r\n\t\t\t\thandleTouchStartDolly( event );\r\n\r\n\t\t\t\tstate = STATE.DOLLY_ROTATE;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t\tif ( state !== STATE.NONE ) {\r\n\r\n\t\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onTouchMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1: // one-fingered touch: pan\r\n\r\n\t\t\t\tif ( scope.enablePan === false ) { return; }\r\n\t\t\t\tif ( state !== STATE.PAN ) { return; } // is this needed?\r\n\r\n\t\t\t\thandleTouchMovePan( event );\r\n\r\n\t\t\t\tscope.update();\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2: // two-fingered touch: rotate-dolly\r\n\r\n\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) { return; }\r\n\t\t\t\tif ( ( state & STATE.DOLLY_ROTATE ) === 0 ) { return; } // is this needed?\r\n\r\n\t\t\t\thandleTouchMoveRotate( event );\r\n\t\t\t\thandleTouchMoveDolly( event );\r\n\r\n\t\t\t\tscope.update();\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onTouchEnd( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onContextMenu( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\r\n\r\n\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\r\n\r\n\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\r\n\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\r\n\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\r\n\r\n\twindow.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n\t// force an update at start\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nMapControls.prototype = Object.create( EventDispatcher.prototype );\r\nMapControls.prototype.constructor = MapControls;\r\n\r\nObject.defineProperties( MapControls.prototype, {\r\n\r\n\tcenter: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .center has been renamed to .target' );\r\n\t\t\treturn this.target;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// backward compatibility\r\n\r\n\tnoZoom: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n\t\t\treturn ! this.enableZoom;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n\t\t\tthis.enableZoom = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnoRotate: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n\t\t\treturn ! this.enableRotate;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n\t\t\tthis.enableRotate = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnoPan: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n\t\t\treturn ! this.enablePan;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n\t\t\tthis.enablePan = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnoKeys: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n\t\t\treturn ! this.enableKeys;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n\t\t\tthis.enableKeys = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tstaticMoving: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n\t\t\treturn ! this.enableDamping;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n\t\t\tthis.enableDamping = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdynamicDampingFactor: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n\t\t\treturn this.dampingFactor;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'MapControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n\t\t\tthis.dampingFactor = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning.\r\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\r\n//\r\n//    Orbit - left mouse / touch: one-finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\r\n//    Pan - right mouse, or left mouse + ctrl/metaKey, or arrow keys / touch: two-finger move\r\n\r\nvar OrbitControls = function ( object, domElement ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// Set to false to disable this control\r\n\tthis.enabled = true;\r\n\r\n\t// \"target\" sets the location of focus, where the object orbits around\r\n\tthis.target = new Vector3();\r\n\r\n\t// How far you can dolly in and out ( PerspectiveCamera only )\r\n\tthis.minDistance = 0;\r\n\tthis.maxDistance = Infinity;\r\n\r\n\t// How far you can zoom in and out ( OrthographicCamera only )\r\n\tthis.minZoom = 0;\r\n\tthis.maxZoom = Infinity;\r\n\r\n\t// How far you can orbit vertically, upper and lower limits.\r\n\t// Range is 0 to Math.PI radians.\r\n\tthis.minPolarAngle = 0; // radians\r\n\tthis.maxPolarAngle = Math.PI; // radians\r\n\r\n\t// How far you can orbit horizontally, upper and lower limits.\r\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\r\n\tthis.minAzimuthAngle = - Infinity; // radians\r\n\tthis.maxAzimuthAngle = Infinity; // radians\r\n\r\n\t// Set to true to enable damping (inertia)\r\n\t// If damping is enabled, you must call controls.update() in your animation loop\r\n\tthis.enableDamping = false;\r\n\tthis.dampingFactor = 0.25;\r\n\r\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\r\n\t// Set to false to disable zooming\r\n\tthis.enableZoom = true;\r\n\tthis.zoomSpeed = 1.0;\r\n\r\n\t// Set to false to disable rotating\r\n\tthis.enableRotate = true;\r\n\tthis.rotateSpeed = 1.0;\r\n\r\n\t// Set to false to disable panning\r\n\tthis.enablePan = true;\r\n\tthis.panSpeed = 1.0;\r\n\tthis.screenSpacePanning = false; // if true, pan in screen-space\r\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n\t// Set to true to automatically rotate around the target\r\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\r\n\tthis.autoRotate = false;\r\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n\t// Set to false to disable use of the keys\r\n\tthis.enableKeys = true;\r\n\r\n\t// The four arrow keys\r\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n\t// Mouse buttons\r\n\tthis.mouseButtons = { LEFT: MOUSE.LEFT, MIDDLE: MOUSE.MIDDLE, RIGHT: MOUSE.RIGHT };\r\n\r\n\t// for reset\r\n\tthis.target0 = this.target.clone();\r\n\tthis.position0 = this.object.position.clone();\r\n\tthis.zoom0 = this.object.zoom;\r\n\r\n\t//\r\n\t// public methods\r\n\t//\r\n\r\n\tthis.getPolarAngle = function () {\r\n\r\n\t\treturn spherical.phi;\r\n\r\n\t};\r\n\r\n\tthis.getAzimuthalAngle = function () {\r\n\r\n\t\treturn spherical.theta;\r\n\r\n\t};\r\n\r\n\tthis.saveState = function () {\r\n\r\n\t\tscope.target0.copy( scope.target );\r\n\t\tscope.position0.copy( scope.object.position );\r\n\t\tscope.zoom0 = scope.object.zoom;\r\n\r\n\t};\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tscope.target.copy( scope.target0 );\r\n\t\tscope.object.position.copy( scope.position0 );\r\n\t\tscope.object.zoom = scope.zoom0;\r\n\r\n\t\tscope.object.updateProjectionMatrix();\r\n\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t\tscope.update();\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t};\r\n\r\n\t// this method is exposed, but perhaps it would be better if we can make it private...\r\n\tthis.update = function () {\r\n\r\n\t\tvar offset = new Vector3();\r\n\r\n\t\t// so camera.up is the orbit axis\r\n\t\tvar quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\r\n\t\tvar quatInverse = quat.clone().inverse();\r\n\r\n\t\tvar lastPosition = new Vector3();\r\n\t\tvar lastQuaternion = new Quaternion();\r\n\r\n\t\treturn function update() {\r\n\r\n\t\t\tvar position = scope.object.position;\r\n\r\n\t\t\toffset.copy( position ).sub( scope.target );\r\n\r\n\t\t\t// rotate offset to \"y-axis-is-up\" space\r\n\t\t\toffset.applyQuaternion( quat );\r\n\r\n\t\t\t// angle from z-axis around y-axis\r\n\t\t\tspherical.setFromVector3( offset );\r\n\r\n\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\r\n\r\n\t\t\t\trotateLeft( getAutoRotationAngle() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tspherical.theta += sphericalDelta.theta;\r\n\t\t\tspherical.phi += sphericalDelta.phi;\r\n\r\n\t\t\t// restrict theta to be between desired limits\r\n\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\r\n\r\n\t\t\t// restrict phi to be between desired limits\r\n\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\r\n\r\n\t\t\tspherical.makeSafe();\r\n\r\n\t\t\tspherical.radius *= scale;\r\n\r\n\t\t\t// restrict radius to be between desired limits\r\n\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\r\n\r\n\t\t\t// move target to panned location\r\n\t\t\tscope.target.add( panOffset );\r\n\r\n\t\t\toffset.setFromSpherical( spherical );\r\n\r\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\r\n\t\t\toffset.applyQuaternion( quatInverse );\r\n\r\n\t\t\tposition.copy( scope.target ).add( offset );\r\n\r\n\t\t\tscope.object.lookAt( scope.target );\r\n\r\n\t\t\tif ( scope.enableDamping === true ) {\r\n\r\n\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\r\n\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\r\n\r\n\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsphericalDelta.set( 0, 0, 0 );\r\n\r\n\t\t\t\tpanOffset.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscale = 1;\r\n\r\n\t\t\t// update condition is:\r\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\r\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n\r\n\t\t\tif ( zoomChanged ||\r\n\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\r\n\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\r\n\r\n\t\t\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t\t\t\tlastPosition.copy( scope.object.position );\r\n\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\r\n\t\t\t\tzoomChanged = false;\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\r\n\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\r\n\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\r\n\r\n\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\r\n\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\r\n\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\r\n\r\n\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\r\n\r\n\t};\r\n\r\n\t//\r\n\t// internals\r\n\t//\r\n\r\n\tvar scope = this;\r\n\r\n\tvar changeEvent = { type: 'change' };\r\n\tvar startEvent = { type: 'start' };\r\n\tvar endEvent = { type: 'end' };\r\n\r\n\tvar STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };\r\n\r\n\tvar state = STATE.NONE;\r\n\r\n\tvar EPS = 0.000001;\r\n\r\n\t// current position in spherical coordinates\r\n\tvar spherical = new Spherical();\r\n\tvar sphericalDelta = new Spherical();\r\n\r\n\tvar scale = 1;\r\n\tvar panOffset = new Vector3();\r\n\tvar zoomChanged = false;\r\n\r\n\tvar rotateStart = new Vector2();\r\n\tvar rotateEnd = new Vector2();\r\n\tvar rotateDelta = new Vector2();\r\n\r\n\tvar panStart = new Vector2();\r\n\tvar panEnd = new Vector2();\r\n\tvar panDelta = new Vector2();\r\n\r\n\tvar dollyStart = new Vector2();\r\n\tvar dollyEnd = new Vector2();\r\n\tvar dollyDelta = new Vector2();\r\n\r\n\tfunction getAutoRotationAngle() {\r\n\r\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n\t}\r\n\r\n\tfunction getZoomScale() {\r\n\r\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n\t}\r\n\r\n\tfunction rotateLeft( angle ) {\r\n\r\n\t\tsphericalDelta.theta -= angle;\r\n\r\n\t}\r\n\r\n\tfunction rotateUp( angle ) {\r\n\r\n\t\tsphericalDelta.phi -= angle;\r\n\r\n\t}\r\n\r\n\tvar panLeft = function () {\r\n\r\n\t\tvar v = new Vector3();\r\n\r\n\t\treturn function panLeft( distance, objectMatrix ) {\r\n\r\n\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\r\n\t\t\tv.multiplyScalar( - distance );\r\n\r\n\t\t\tpanOffset.add( v );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tvar panUp = function () {\r\n\r\n\t\tvar v = new Vector3();\r\n\r\n\t\treturn function panUp( distance, objectMatrix ) {\r\n\r\n\t\t\tif ( scope.screenSpacePanning === true ) {\r\n\r\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\r\n\t\t\t\tv.crossVectors( scope.object.up, v );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv.multiplyScalar( distance );\r\n\r\n\t\t\tpanOffset.add( v );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\t// deltaX and deltaY are in pixels; right and down are positive\r\n\tvar pan = function () {\r\n\r\n\t\tvar offset = new Vector3();\r\n\r\n\t\treturn function pan( deltaX, deltaY ) {\r\n\r\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\r\n\r\n\t\t\t\t// perspective\r\n\t\t\t\tvar position = scope.object.position;\r\n\t\t\t\toffset.copy( position ).sub( scope.target );\r\n\t\t\t\tvar targetDistance = offset.length();\r\n\r\n\t\t\t\t// half of the fov is center to top of screen\r\n\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\r\n\r\n\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\r\n\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\r\n\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\r\n\r\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\r\n\r\n\t\t\t\t// orthographic\r\n\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\r\n\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// camera neither orthographic nor perspective\r\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n\t\t\t\tscope.enablePan = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tfunction dollyIn( dollyScale ) {\r\n\r\n\t\tif ( scope.object.isPerspectiveCamera ) {\r\n\r\n\t\t\tscale /= dollyScale;\r\n\r\n\t\t} else if ( scope.object.isOrthographicCamera ) {\r\n\r\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\r\n\t\t\tscope.object.updateProjectionMatrix();\r\n\t\t\tzoomChanged = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n\t\t\tscope.enableZoom = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction dollyOut( dollyScale ) {\r\n\r\n\t\tif ( scope.object.isPerspectiveCamera ) {\r\n\r\n\t\t\tscale *= dollyScale;\r\n\r\n\t\t} else if ( scope.object.isOrthographicCamera ) {\r\n\r\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\r\n\t\t\tscope.object.updateProjectionMatrix();\r\n\t\t\tzoomChanged = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n\t\t\tscope.enableZoom = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\t// event callbacks - update the object state\r\n\t//\r\n\r\n\tfunction handleMouseDownRotate( event ) {\r\n\r\n\t\t//console.log( 'handleMouseDownRotate' );\r\n\r\n\t\trotateStart.set( event.clientX, event.clientY );\r\n\r\n\t}\r\n\r\n\tfunction handleMouseDownDolly( event ) {\r\n\r\n\t\t//console.log( 'handleMouseDownDolly' );\r\n\r\n\t\tdollyStart.set( event.clientX, event.clientY );\r\n\r\n\t}\r\n\r\n\tfunction handleMouseDownPan( event ) {\r\n\r\n\t\t//console.log( 'handleMouseDownPan' );\r\n\r\n\t\tpanStart.set( event.clientX, event.clientY );\r\n\r\n\t}\r\n\r\n\tfunction handleMouseMoveRotate( event ) {\r\n\r\n\t\t//console.log( 'handleMouseMoveRotate' );\r\n\r\n\t\trotateEnd.set( event.clientX, event.clientY );\r\n\r\n\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\r\n\r\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\r\n\r\n\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleMouseMoveDolly( event ) {\r\n\r\n\t\t//console.log( 'handleMouseMoveDolly' );\r\n\r\n\t\tdollyEnd.set( event.clientX, event.clientY );\r\n\r\n\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n\t\tif ( dollyDelta.y > 0 ) {\r\n\r\n\t\t\tdollyIn( getZoomScale() );\r\n\r\n\t\t} else if ( dollyDelta.y < 0 ) {\r\n\r\n\t\t\tdollyOut( getZoomScale() );\r\n\r\n\t\t}\r\n\r\n\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleMouseMovePan( event ) {\r\n\r\n\t\t//console.log( 'handleMouseMovePan' );\r\n\r\n\t\tpanEnd.set( event.clientX, event.clientY );\r\n\r\n\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\r\n\r\n\t\tpan( panDelta.x, panDelta.y );\r\n\r\n\t\tpanStart.copy( panEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleMouseWheel( event ) {\r\n\r\n\t\t// console.log( 'handleMouseWheel' );\r\n\r\n\t\tif ( event.deltaY < 0 ) {\r\n\r\n\t\t\tdollyOut( getZoomScale() );\r\n\r\n\t\t} else if ( event.deltaY > 0 ) {\r\n\r\n\t\t\tdollyIn( getZoomScale() );\r\n\r\n\t\t}\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleKeyDown( event ) {\r\n\r\n\t\t//console.log( 'handleKeyDown' );\r\n\r\n\t\tswitch ( event.keyCode ) {\r\n\r\n\t\t\tcase scope.keys.UP:\r\n\t\t\t\tpan( 0, scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.BOTTOM:\r\n\t\t\t\tpan( 0, - scope.keyPanSpeed );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.LEFT:\r\n\t\t\t\tpan( scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.keys.RIGHT:\r\n\t\t\t\tpan( - scope.keyPanSpeed, 0 );\r\n\t\t\t\tscope.update();\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction handleTouchStartRotate( event ) {\r\n\r\n\t\t//console.log( 'handleTouchStartRotate' );\r\n\r\n\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n\t}\r\n\r\n\tfunction handleTouchStartDollyPan( event ) {\r\n\r\n\t\t//console.log( 'handleTouchStartDollyPan' );\r\n\r\n\t\tif ( scope.enableZoom ) {\r\n\r\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\tdollyStart.set( 0, distance );\r\n\r\n\t\t}\r\n\r\n\t\tif ( scope.enablePan ) {\r\n\r\n\t\t\tvar x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );\r\n\t\t\tvar y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );\r\n\r\n\t\t\tpanStart.set( x, y );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction handleTouchMoveRotate( event ) {\r\n\r\n\t\t//console.log( 'handleTouchMoveRotate' );\r\n\r\n\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\r\n\r\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\r\n\r\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\r\n\r\n\t\trotateStart.copy( rotateEnd );\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\tfunction handleTouchMoveDollyPan( event ) {\r\n\r\n\t\t//console.log( 'handleTouchMoveDollyPan' );\r\n\r\n\t\tif ( scope.enableZoom ) {\r\n\r\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\tdollyEnd.set( 0, distance );\r\n\r\n\t\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\r\n\r\n\t\t\tdollyIn( dollyDelta.y );\r\n\r\n\t\t\tdollyStart.copy( dollyEnd );\r\n\r\n\t\t}\r\n\r\n\t\tif ( scope.enablePan ) {\r\n\r\n\t\t\tvar x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );\r\n\t\t\tvar y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );\r\n\r\n\t\t\tpanEnd.set( x, y );\r\n\r\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\r\n\r\n\t\t\tpan( panDelta.x, panDelta.y );\r\n\r\n\t\t\tpanStart.copy( panEnd );\r\n\r\n\t\t}\r\n\r\n\t\tscope.update();\r\n\r\n\t}\r\n\r\n\t//\r\n\t// event handlers - FSM: listen for events and reset state\r\n\t//\r\n\r\n\tfunction onMouseDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tswitch ( event.button ) {\r\n\r\n\t\t\tcase scope.mouseButtons.LEFT:\r\n\r\n\t\t\t\tif ( event.ctrlKey || event.metaKey ) {\r\n\r\n\t\t\t\t\tif ( scope.enablePan === false ) { return; }\r\n\r\n\t\t\t\t\thandleMouseDownPan( event );\r\n\r\n\t\t\t\t\tstate = STATE.PAN;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( scope.enableRotate === false ) { return; }\r\n\r\n\t\t\t\t\thandleMouseDownRotate( event );\r\n\r\n\t\t\t\t\tstate = STATE.ROTATE;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.mouseButtons.MIDDLE:\r\n\r\n\t\t\t\tif ( scope.enableZoom === false ) { return; }\r\n\r\n\t\t\t\thandleMouseDownDolly( event );\r\n\r\n\t\t\t\tstate = STATE.DOLLY;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase scope.mouseButtons.RIGHT:\r\n\r\n\t\t\t\tif ( scope.enablePan === false ) { return; }\r\n\r\n\t\t\t\thandleMouseDownPan( event );\r\n\r\n\t\t\t\tstate = STATE.PAN;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tif ( state !== STATE.NONE ) {\r\n\r\n\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\r\n\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\r\n\r\n\t\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onMouseMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tswitch ( state ) {\r\n\r\n\t\t\tcase STATE.ROTATE:\r\n\r\n\t\t\t\tif ( scope.enableRotate === false ) { return; }\r\n\r\n\t\t\t\thandleMouseMoveRotate( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase STATE.DOLLY:\r\n\r\n\t\t\t\tif ( scope.enableZoom === false ) { return; }\r\n\r\n\t\t\t\thandleMouseMoveDolly( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase STATE.PAN:\r\n\r\n\t\t\t\tif ( scope.enablePan === false ) { return; }\r\n\r\n\t\t\t\thandleMouseMovePan( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onMouseUp( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\r\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onMouseWheel( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t\thandleMouseWheel( event );\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction onKeyDown( event ) {\r\n\r\n\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) { return; }\r\n\r\n\t\thandleKeyDown( event );\r\n\r\n\t}\r\n\r\n\tfunction onTouchStart( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\t// one-fingered touch: rotate\r\n\r\n\t\t\t\tif ( scope.enableRotate === false ) { return; }\r\n\r\n\t\t\t\thandleTouchStartRotate( event );\r\n\r\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\t// two-fingered touch: dolly-pan\r\n\r\n\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) { return; }\r\n\r\n\t\t\t\thandleTouchStartDollyPan( event );\r\n\r\n\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t\tif ( state !== STATE.NONE ) {\r\n\r\n\t\t\tscope.dispatchEvent( startEvent );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onTouchMove( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1: // one-fingered touch: rotate\r\n\r\n\t\t\t\tif ( scope.enableRotate === false ) { return; }\r\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) { return; } // is this needed?\r\n\r\n\t\t\t\thandleTouchMoveRotate( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2: // two-fingered touch: dolly-pan\r\n\r\n\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) { return; }\r\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY_PAN ) { return; } // is this needed?\r\n\r\n\t\t\t\thandleTouchMoveDollyPan( event );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tstate = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onTouchEnd( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tscope.dispatchEvent( endEvent );\r\n\r\n\t\tstate = STATE.NONE;\r\n\r\n\t}\r\n\r\n\tfunction onContextMenu( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\r\n\r\n\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\r\n\r\n\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\r\n\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\r\n\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\r\n\r\n\twindow.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n\t// force an update at start\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nOrbitControls.prototype = Object.create( EventDispatcher.prototype );\r\nOrbitControls.prototype.constructor = OrbitControls;\r\n\r\nObject.defineProperties( OrbitControls.prototype, {\r\n\r\n\tcenter: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .center has been renamed to .target' );\r\n\t\t\treturn this.target;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// backward compatibility\r\n\r\n\tnoZoom: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n\t\t\treturn ! this.enableZoom;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n\t\t\tthis.enableZoom = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnoRotate: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n\t\t\treturn ! this.enableRotate;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n\t\t\tthis.enableRotate = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnoPan: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n\t\t\treturn ! this.enablePan;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n\t\t\tthis.enablePan = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnoKeys: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n\t\t\treturn ! this.enableKeys;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n\t\t\tthis.enableKeys = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tstaticMoving: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n\t\t\treturn ! this.enableDamping;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n\t\t\tthis.enableDamping = ! value;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdynamicDampingFactor: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n\t\t\treturn this.dampingFactor;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tconsole.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n\t\t\tthis.dampingFactor = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar OrthographicTrackballControls = function ( object, domElement ) {\r\n\r\n\tvar _this = this;\r\n\tvar STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\r\n\r\n\tthis.object = object;\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// API\r\n\r\n\tthis.enabled = true;\r\n\r\n\tthis.screen = { left: 0, top: 0, width: 0, height: 0 };\r\n\r\n\tthis.radius = 0;\r\n\r\n\tthis.rotateSpeed = 1.0;\r\n\tthis.zoomSpeed = 1.2;\r\n\r\n\tthis.noRotate = false;\r\n\tthis.noZoom = false;\r\n\tthis.noPan = false;\r\n\tthis.noRoll = false;\r\n\r\n\tthis.staticMoving = false;\r\n\tthis.dynamicDampingFactor = 0.2;\r\n\r\n\tthis.keys = [ 65 , 83 , 68  ];\r\n\r\n\t// internals\r\n\r\n\tthis.target = new Vector3();\r\n\r\n\tvar EPS = 0.000001;\r\n\r\n\tvar _changed = true;\r\n\r\n\tvar _state = STATE.NONE,\r\n\t\t_prevState = STATE.NONE,\r\n\r\n\t\t_eye = new Vector3(),\r\n\r\n\t\t_rotateStart = new Vector3(),\r\n\t\t_rotateEnd = new Vector3(),\r\n\r\n\t\t_zoomStart = new Vector2(),\r\n\t\t_zoomEnd = new Vector2(),\r\n\r\n\t\t_touchZoomDistanceStart = 0,\r\n\t\t_touchZoomDistanceEnd = 0,\r\n\r\n\t\t_panStart = new Vector2(),\r\n\t\t_panEnd = new Vector2();\r\n\r\n\t// for reset\r\n\r\n\tthis.target0 = this.target.clone();\r\n\tthis.position0 = this.object.position.clone();\r\n\tthis.up0 = this.object.up.clone();\r\n\r\n\tthis.left0 = this.object.left;\r\n\tthis.right0 = this.object.right;\r\n\tthis.top0 = this.object.top;\r\n\tthis.bottom0 = this.object.bottom;\r\n\r\n\t// events\r\n\r\n\tvar changeEvent = { type: 'change' };\r\n\tvar startEvent = { type: 'start' };\r\n\tvar endEvent = { type: 'end' };\r\n\r\n\t// methods\r\n\r\n\tthis.handleResize = function () {\r\n\r\n\t\tif ( this.domElement === document ) {\r\n\r\n\t\t\tthis.screen.left = 0;\r\n\t\t\tthis.screen.top = 0;\r\n\t\t\tthis.screen.width = window.innerWidth;\r\n\t\t\tthis.screen.height = window.innerHeight;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar box = this.domElement.getBoundingClientRect();\r\n\t\t\t// adjustments come from similar code in the jquery offset() function\r\n\t\t\tvar d = this.domElement.ownerDocument.documentElement;\r\n\t\t\tthis.screen.left = box.left + window.pageXOffset - d.clientLeft;\r\n\t\t\tthis.screen.top = box.top + window.pageYOffset - d.clientTop;\r\n\t\t\tthis.screen.width = box.width;\r\n\t\t\tthis.screen.height = box.height;\r\n\r\n\t\t}\r\n\r\n\t\tthis.radius = 0.5 * Math.min( this.screen.width, this.screen.height );\r\n\r\n\t\tthis.left0 = this.object.left;\r\n\t\tthis.right0 = this.object.right;\r\n\t\tthis.top0 = this.object.top;\r\n\t\tthis.bottom0 = this.object.bottom;\r\n\r\n\t};\r\n\r\n\tvar getMouseOnScreen = ( function () {\r\n\r\n\t\tvar vector = new Vector2();\r\n\r\n\t\treturn function getMouseOnScreen( pageX, pageY ) {\r\n\r\n\t\t\tvector.set(\r\n\t\t\t\t( pageX - _this.screen.left ) / _this.screen.width,\r\n\t\t\t\t( pageY - _this.screen.top ) / _this.screen.height\r\n\t\t\t);\r\n\r\n\t\t\treturn vector;\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tvar getMouseProjectionOnBall = ( function () {\r\n\r\n\t\tvar vector = new Vector3();\r\n\t\tvar objectUp = new Vector3();\r\n\t\tvar mouseOnBall = new Vector3();\r\n\r\n\t\treturn function getMouseProjectionOnBall( pageX, pageY ) {\r\n\r\n\t\t\tmouseOnBall.set(\r\n\t\t\t\t( pageX - _this.screen.width * 0.5 - _this.screen.left ) / _this.radius,\r\n\t\t\t\t( _this.screen.height * 0.5 + _this.screen.top - pageY ) / _this.radius,\r\n\t\t\t\t0.0\r\n\t\t\t);\r\n\r\n\t\t\tvar length = mouseOnBall.length();\r\n\r\n\t\t\tif ( _this.noRoll ) {\r\n\r\n\t\t\t\tif ( length < Math.SQRT1_2 ) {\r\n\r\n\t\t\t\t\tmouseOnBall.z = Math.sqrt( 1.0 - length * length );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmouseOnBall.z = .5 / length;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( length > 1.0 ) {\r\n\r\n\t\t\t\tmouseOnBall.normalize();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmouseOnBall.z = Math.sqrt( 1.0 - length * length );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_eye.copy( _this.object.position ).sub( _this.target );\r\n\r\n\t\t\tvector.copy( _this.object.up ).setLength( mouseOnBall.y );\r\n\t\t\tvector.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );\r\n\t\t\tvector.add( _eye.setLength( mouseOnBall.z ) );\r\n\r\n\t\t\treturn vector;\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tthis.rotateCamera = ( function () {\r\n\r\n\t\tvar axis = new Vector3(),\r\n\t\t\tquaternion = new Quaternion();\r\n\r\n\t\treturn function rotateCamera() {\r\n\r\n\t\t\tvar angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );\r\n\r\n\t\t\tif ( angle ) {\r\n\r\n\t\t\t\taxis.crossVectors( _rotateStart, _rotateEnd ).normalize();\r\n\r\n\t\t\t\tangle *= _this.rotateSpeed;\r\n\r\n\t\t\t\tquaternion.setFromAxisAngle( axis, - angle );\r\n\r\n\t\t\t\t_eye.applyQuaternion( quaternion );\r\n\t\t\t\t_this.object.up.applyQuaternion( quaternion );\r\n\r\n\t\t\t\t_rotateEnd.applyQuaternion( quaternion );\r\n\r\n\t\t\t\tif ( _this.staticMoving ) {\r\n\r\n\t\t\t\t\t_rotateStart.copy( _rotateEnd );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tquaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );\r\n\t\t\t\t\t_rotateStart.applyQuaternion( quaternion );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_changed = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tthis.zoomCamera = function () {\r\n\r\n\t\tif ( _state === STATE.TOUCH_ZOOM_PAN ) {\r\n\r\n\t\t\tvar factor = _touchZoomDistanceEnd / _touchZoomDistanceStart;\r\n\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\r\n\r\n\t\t\t_this.object.zoom *= factor;\r\n\r\n\t\t\t_changed = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;\r\n\r\n\t\t\tif ( Math.abs( factor - 1.0 ) > EPS && factor > 0.0 ) {\r\n\r\n\t\t\t\t_this.object.zoom /= factor;\r\n\r\n\t\t\t\tif ( _this.staticMoving ) {\r\n\r\n\t\t\t\t\t_zoomStart.copy( _zoomEnd );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_changed = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.panCamera = ( function () {\r\n\r\n\t\tvar mouseChange = new Vector2(),\r\n\t\t\tobjectUp = new Vector3(),\r\n\t\t\tpan = new Vector3();\r\n\r\n\t\treturn function panCamera() {\r\n\r\n\t\t\tmouseChange.copy( _panEnd ).sub( _panStart );\r\n\r\n\t\t\tif ( mouseChange.lengthSq() ) {\r\n\r\n\t\t\t\t// Scale movement to keep clicked/dragged position under cursor\r\n\t\t\t\tvar scale_x = ( _this.object.right - _this.object.left ) / _this.object.zoom;\r\n\t\t\t\tvar scale_y = ( _this.object.top - _this.object.bottom ) / _this.object.zoom;\r\n\t\t\t\tmouseChange.x *= scale_x;\r\n\t\t\t\tmouseChange.y *= scale_y;\r\n\r\n\t\t\t\tpan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );\r\n\t\t\t\tpan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );\r\n\r\n\t\t\t\t_this.object.position.add( pan );\r\n\t\t\t\t_this.target.add( pan );\r\n\r\n\t\t\t\tif ( _this.staticMoving ) {\r\n\r\n\t\t\t\t\t_panStart.copy( _panEnd );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_changed = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tthis.update = function () {\r\n\r\n\t\t_eye.subVectors( _this.object.position, _this.target );\r\n\r\n\t\tif ( ! _this.noRotate ) {\r\n\r\n\t\t\t_this.rotateCamera();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _this.noZoom ) {\r\n\r\n\t\t\t_this.zoomCamera();\r\n\r\n\t\t\tif ( _changed ) {\r\n\r\n\t\t\t\t_this.object.updateProjectionMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _this.noPan ) {\r\n\r\n\t\t\t_this.panCamera();\r\n\r\n\t\t}\r\n\r\n\t\t_this.object.position.addVectors( _this.target, _eye );\r\n\r\n\t\t_this.object.lookAt( _this.target );\r\n\r\n\t\tif ( _changed ) {\r\n\r\n\t\t\t_this.dispatchEvent( changeEvent );\r\n\r\n\t\t\t_changed = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\t_state = STATE.NONE;\r\n\t\t_prevState = STATE.NONE;\r\n\r\n\t\t_this.target.copy( _this.target0 );\r\n\t\t_this.object.position.copy( _this.position0 );\r\n\t\t_this.object.up.copy( _this.up0 );\r\n\r\n\t\t_eye.subVectors( _this.object.position, _this.target );\r\n\r\n\t\t_this.object.left = _this.left0;\r\n\t\t_this.object.right = _this.right0;\r\n\t\t_this.object.top = _this.top0;\r\n\t\t_this.object.bottom = _this.bottom0;\r\n\r\n\t\t_this.object.lookAt( _this.target );\r\n\r\n\t\t_this.dispatchEvent( changeEvent );\r\n\r\n\t\t_changed = false;\r\n\r\n\t};\r\n\r\n\t// listeners\r\n\r\n\tfunction keydown( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\twindow.removeEventListener( 'keydown', keydown );\r\n\r\n\t\t_prevState = _state;\r\n\r\n\t\tif ( _state !== STATE.NONE ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && ! _this.noRotate ) {\r\n\r\n\t\t\t_state = STATE.ROTATE;\r\n\r\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && ! _this.noZoom ) {\r\n\r\n\t\t\t_state = STATE.ZOOM;\r\n\r\n\t\t} else if ( event.keyCode === _this.keys[ STATE.PAN ] && ! _this.noPan ) {\r\n\r\n\t\t\t_state = STATE.PAN;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction keyup( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\t_state = _prevState;\r\n\r\n\t\twindow.addEventListener( 'keydown', keydown, false );\r\n\r\n\t}\r\n\r\n\tfunction mousedown( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tif ( _state === STATE.NONE ) {\r\n\r\n\t\t\t_state = event.button;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _state === STATE.ROTATE && ! _this.noRotate ) {\r\n\r\n\t\t\t_rotateStart.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );\r\n\t\t\t_rotateEnd.copy( _rotateStart );\r\n\r\n\t\t} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {\r\n\r\n\t\t\t_zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );\r\n\t\t\t_zoomEnd.copy( _zoomStart );\r\n\r\n\t\t} else if ( _state === STATE.PAN && ! _this.noPan ) {\r\n\r\n\t\t\t_panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );\r\n\t\t\t_panEnd.copy( _panStart );\r\n\r\n\t\t}\r\n\r\n\t\tdocument.addEventListener( 'mousemove', mousemove, false );\r\n\t\tdocument.addEventListener( 'mouseup', mouseup, false );\r\n\r\n\t\t_this.dispatchEvent( startEvent );\r\n\r\n\t}\r\n\r\n\tfunction mousemove( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tif ( _state === STATE.ROTATE && ! _this.noRotate ) {\r\n\r\n\t\t\t_rotateEnd.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );\r\n\r\n\t\t} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {\r\n\r\n\t\t\t_zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );\r\n\r\n\t\t} else if ( _state === STATE.PAN && ! _this.noPan ) {\r\n\r\n\t\t\t_panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction mouseup( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\t_state = STATE.NONE;\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', mousemove );\r\n\t\tdocument.removeEventListener( 'mouseup', mouseup );\r\n\t\t_this.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction mousewheel( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\t_zoomStart.y += event.deltaY * 0.01;\r\n\t\t_this.dispatchEvent( startEvent );\r\n\t\t_this.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction touchstart( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\r\n\t\t\t\t_rotateStart.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\r\n\t\t\t\t_rotateEnd.copy( _rotateStart );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\t_state = STATE.TOUCH_ZOOM_PAN;\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\t\tvar x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;\r\n\t\t\t\tvar y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;\r\n\t\t\t\t_panStart.copy( getMouseOnScreen( x, y ) );\r\n\t\t\t\t_panEnd.copy( _panStart );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t_state = STATE.NONE;\r\n\r\n\t\t}\r\n\t\t_this.dispatchEvent( startEvent );\r\n\r\n\t}\r\n\r\n\tfunction touchmove( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t_rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\t_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\t\tvar x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;\r\n\t\t\t\tvar y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;\r\n\t\t\t\t_panEnd.copy( getMouseOnScreen( x, y ) );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t_state = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction touchend( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t_rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\r\n\t\t\t\t_rotateStart.copy( _rotateEnd );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;\r\n\r\n\t\t\t\tvar x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;\r\n\t\t\t\tvar y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;\r\n\t\t\t\t_panEnd.copy( getMouseOnScreen( x, y ) );\r\n\t\t\t\t_panStart.copy( _panEnd );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\t_state = STATE.NONE;\r\n\t\t_this.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction contextmenu( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t}\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tthis.domElement.removeEventListener( 'contextmenu', contextmenu, false );\r\n\t\tthis.domElement.removeEventListener( 'mousedown', mousedown, false );\r\n\t\tthis.domElement.removeEventListener( 'wheel', mousewheel, false );\r\n\r\n\t\tthis.domElement.removeEventListener( 'touchstart', touchstart, false );\r\n\t\tthis.domElement.removeEventListener( 'touchend', touchend, false );\r\n\t\tthis.domElement.removeEventListener( 'touchmove', touchmove, false );\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', mousemove, false );\r\n\t\tdocument.removeEventListener( 'mouseup', mouseup, false );\r\n\r\n\t\twindow.removeEventListener( 'keydown', keydown, false );\r\n\t\twindow.removeEventListener( 'keyup', keyup, false );\r\n\r\n\t};\r\n\r\n\tthis.domElement.addEventListener( 'contextmenu', contextmenu, false );\r\n\tthis.domElement.addEventListener( 'mousedown', mousedown, false );\r\n\tthis.domElement.addEventListener( 'wheel', mousewheel, false );\r\n\r\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\r\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\r\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\r\n\r\n\twindow.addEventListener( 'keydown', keydown, false );\r\n\twindow.addEventListener( 'keyup', keyup, false );\r\n\r\n\tthis.handleResize();\r\n\r\n\t// force an update at start\r\n\tthis.update();\r\n\r\n};\r\n\r\nOrthographicTrackballControls.prototype = Object.create( EventDispatcher.prototype );\r\nOrthographicTrackballControls.prototype.constructor = OrthographicTrackballControls;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PointerLockControls = function ( camera ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tcamera.rotation.set( 0, 0, 0 );\r\n\r\n\tvar pitchObject = new Object3D();\r\n\tpitchObject.add( camera );\r\n\r\n\tvar yawObject = new Object3D();\r\n\tyawObject.position.y = 10;\r\n\tyawObject.add( pitchObject );\r\n\r\n\tvar PI_2 = Math.PI / 2;\r\n\r\n\tvar onMouseMove = function ( event ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\r\n\t\tvar movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;\r\n\t\tvar movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;\r\n\r\n\t\tyawObject.rotation.y -= movementX * 0.002;\r\n\t\tpitchObject.rotation.x -= movementY * 0.002;\r\n\r\n\t\tpitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, pitchObject.rotation.x ) );\r\n\r\n\t};\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\r\n\r\n\t};\r\n\r\n\tdocument.addEventListener( 'mousemove', onMouseMove, false );\r\n\r\n\tthis.enabled = false;\r\n\r\n\tthis.getObject = function () {\r\n\r\n\t\treturn yawObject;\r\n\r\n\t};\r\n\r\n\tthis.getDirection = function () {\r\n\r\n\t\t// assumes the camera itself is not rotated\r\n\r\n\t\tvar direction = new Vector3( 0, 0, - 1 );\r\n\t\tvar rotation = new Euler( 0, 0, 0, 'YXZ' );\r\n\r\n\t\treturn function ( v ) {\r\n\r\n\t\t\trotation.set( pitchObject.rotation.x, yawObject.rotation.y, 0 );\r\n\r\n\t\t\tv.copy( direction ).applyEuler( rotation );\r\n\r\n\t\t\treturn v;\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TrackballControls = function ( object, domElement ) {\r\n\r\n\tvar _this = this;\r\n\tvar STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\r\n\r\n\tthis.object = object;\r\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\t// API\r\n\r\n\tthis.enabled = true;\r\n\r\n\tthis.screen = { left: 0, top: 0, width: 0, height: 0 };\r\n\r\n\tthis.rotateSpeed = 1.0;\r\n\tthis.zoomSpeed = 1.2;\r\n\tthis.panSpeed = 0.3;\r\n\r\n\tthis.noRotate = false;\r\n\tthis.noZoom = false;\r\n\tthis.noPan = false;\r\n\r\n\tthis.staticMoving = false;\r\n\tthis.dynamicDampingFactor = 0.2;\r\n\r\n\tthis.minDistance = 0;\r\n\tthis.maxDistance = Infinity;\r\n\r\n\tthis.keys = [ 65 , 83 , 68  ];\r\n\r\n\t// internals\r\n\r\n\tthis.target = new Vector3();\r\n\r\n\tvar EPS = 0.000001;\r\n\r\n\tvar lastPosition = new Vector3();\r\n\r\n\tvar _state = STATE.NONE,\r\n\t\t_prevState = STATE.NONE,\r\n\r\n\t\t_eye = new Vector3(),\r\n\r\n\t\t_movePrev = new Vector2(),\r\n\t\t_moveCurr = new Vector2(),\r\n\r\n\t\t_lastAxis = new Vector3(),\r\n\t\t_lastAngle = 0,\r\n\r\n\t\t_zoomStart = new Vector2(),\r\n\t\t_zoomEnd = new Vector2(),\r\n\r\n\t\t_touchZoomDistanceStart = 0,\r\n\t\t_touchZoomDistanceEnd = 0,\r\n\r\n\t\t_panStart = new Vector2(),\r\n\t\t_panEnd = new Vector2();\r\n\r\n\t// for reset\r\n\r\n\tthis.target0 = this.target.clone();\r\n\tthis.position0 = this.object.position.clone();\r\n\tthis.up0 = this.object.up.clone();\r\n\r\n\t// events\r\n\r\n\tvar changeEvent = { type: 'change' };\r\n\tvar startEvent = { type: 'start' };\r\n\tvar endEvent = { type: 'end' };\r\n\r\n\t// methods\r\n\r\n\tthis.handleResize = function () {\r\n\r\n\t\tif ( this.domElement === document ) {\r\n\r\n\t\t\tthis.screen.left = 0;\r\n\t\t\tthis.screen.top = 0;\r\n\t\t\tthis.screen.width = window.innerWidth;\r\n\t\t\tthis.screen.height = window.innerHeight;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar box = this.domElement.getBoundingClientRect();\r\n\t\t\t// adjustments come from similar code in the jquery offset() function\r\n\t\t\tvar d = this.domElement.ownerDocument.documentElement;\r\n\t\t\tthis.screen.left = box.left + window.pageXOffset - d.clientLeft;\r\n\t\t\tthis.screen.top = box.top + window.pageYOffset - d.clientTop;\r\n\t\t\tthis.screen.width = box.width;\r\n\t\t\tthis.screen.height = box.height;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar getMouseOnScreen = ( function () {\r\n\r\n\t\tvar vector = new Vector2();\r\n\r\n\t\treturn function getMouseOnScreen( pageX, pageY ) {\r\n\r\n\t\t\tvector.set(\r\n\t\t\t\t( pageX - _this.screen.left ) / _this.screen.width,\r\n\t\t\t\t( pageY - _this.screen.top ) / _this.screen.height\r\n\t\t\t);\r\n\r\n\t\t\treturn vector;\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tvar getMouseOnCircle = ( function () {\r\n\r\n\t\tvar vector = new Vector2();\r\n\r\n\t\treturn function getMouseOnCircle( pageX, pageY ) {\r\n\r\n\t\t\tvector.set(\r\n\t\t\t\t( ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / ( _this.screen.width * 0.5 ) ),\r\n\t\t\t\t( ( _this.screen.height + 2 * ( _this.screen.top - pageY ) ) / _this.screen.width ) // screen.width intentional\r\n\t\t\t);\r\n\r\n\t\t\treturn vector;\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tthis.rotateCamera = ( function () {\r\n\r\n\t\tvar axis = new Vector3(),\r\n\t\t\tquaternion = new Quaternion(),\r\n\t\t\teyeDirection = new Vector3(),\r\n\t\t\tobjectUpDirection = new Vector3(),\r\n\t\t\tobjectSidewaysDirection = new Vector3(),\r\n\t\t\tmoveDirection = new Vector3(),\r\n\t\t\tangle;\r\n\r\n\t\treturn function rotateCamera() {\r\n\r\n\t\t\tmoveDirection.set( _moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0 );\r\n\t\t\tangle = moveDirection.length();\r\n\r\n\t\t\tif ( angle ) {\r\n\r\n\t\t\t\t_eye.copy( _this.object.position ).sub( _this.target );\r\n\r\n\t\t\t\teyeDirection.copy( _eye ).normalize();\r\n\t\t\t\tobjectUpDirection.copy( _this.object.up ).normalize();\r\n\t\t\t\tobjectSidewaysDirection.crossVectors( objectUpDirection, eyeDirection ).normalize();\r\n\r\n\t\t\t\tobjectUpDirection.setLength( _moveCurr.y - _movePrev.y );\r\n\t\t\t\tobjectSidewaysDirection.setLength( _moveCurr.x - _movePrev.x );\r\n\r\n\t\t\t\tmoveDirection.copy( objectUpDirection.add( objectSidewaysDirection ) );\r\n\r\n\t\t\t\taxis.crossVectors( moveDirection, _eye ).normalize();\r\n\r\n\t\t\t\tangle *= _this.rotateSpeed;\r\n\t\t\t\tquaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\t\t_eye.applyQuaternion( quaternion );\r\n\t\t\t\t_this.object.up.applyQuaternion( quaternion );\r\n\r\n\t\t\t\t_lastAxis.copy( axis );\r\n\t\t\t\t_lastAngle = angle;\r\n\r\n\t\t\t} else if ( ! _this.staticMoving && _lastAngle ) {\r\n\r\n\t\t\t\t_lastAngle *= Math.sqrt( 1.0 - _this.dynamicDampingFactor );\r\n\t\t\t\t_eye.copy( _this.object.position ).sub( _this.target );\r\n\t\t\t\tquaternion.setFromAxisAngle( _lastAxis, _lastAngle );\r\n\t\t\t\t_eye.applyQuaternion( quaternion );\r\n\t\t\t\t_this.object.up.applyQuaternion( quaternion );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_movePrev.copy( _moveCurr );\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tthis.zoomCamera = function () {\r\n\r\n\t\tvar factor;\r\n\r\n\t\tif ( _state === STATE.TOUCH_ZOOM_PAN ) {\r\n\r\n\t\t\tfactor = _touchZoomDistanceStart / _touchZoomDistanceEnd;\r\n\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\r\n\t\t\t_eye.multiplyScalar( factor );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfactor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;\r\n\r\n\t\t\tif ( factor !== 1.0 && factor > 0.0 ) {\r\n\r\n\t\t\t\t_eye.multiplyScalar( factor );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _this.staticMoving ) {\r\n\r\n\t\t\t\t_zoomStart.copy( _zoomEnd );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.panCamera = ( function () {\r\n\r\n\t\tvar mouseChange = new Vector2(),\r\n\t\t\tobjectUp = new Vector3(),\r\n\t\t\tpan = new Vector3();\r\n\r\n\t\treturn function panCamera() {\r\n\r\n\t\t\tmouseChange.copy( _panEnd ).sub( _panStart );\r\n\r\n\t\t\tif ( mouseChange.lengthSq() ) {\r\n\r\n\t\t\t\tmouseChange.multiplyScalar( _eye.length() * _this.panSpeed );\r\n\r\n\t\t\t\tpan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );\r\n\t\t\t\tpan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );\r\n\r\n\t\t\t\t_this.object.position.add( pan );\r\n\t\t\t\t_this.target.add( pan );\r\n\r\n\t\t\t\tif ( _this.staticMoving ) {\r\n\r\n\t\t\t\t\t_panStart.copy( _panEnd );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tthis.checkDistances = function () {\r\n\r\n\t\tif ( ! _this.noZoom || ! _this.noPan ) {\r\n\r\n\t\t\tif ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {\r\n\r\n\t\t\t\t_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );\r\n\t\t\t\t_zoomStart.copy( _zoomEnd );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {\r\n\r\n\t\t\t\t_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );\r\n\t\t\t\t_zoomStart.copy( _zoomEnd );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n\r\n\t\t_eye.subVectors( _this.object.position, _this.target );\r\n\r\n\t\tif ( ! _this.noRotate ) {\r\n\r\n\t\t\t_this.rotateCamera();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _this.noZoom ) {\r\n\r\n\t\t\t_this.zoomCamera();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _this.noPan ) {\r\n\r\n\t\t\t_this.panCamera();\r\n\r\n\t\t}\r\n\r\n\t\t_this.object.position.addVectors( _this.target, _eye );\r\n\r\n\t\t_this.checkDistances();\r\n\r\n\t\t_this.object.lookAt( _this.target );\r\n\r\n\t\tif ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {\r\n\r\n\t\t\t_this.dispatchEvent( changeEvent );\r\n\r\n\t\t\tlastPosition.copy( _this.object.position );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\t_state = STATE.NONE;\r\n\t\t_prevState = STATE.NONE;\r\n\r\n\t\t_this.target.copy( _this.target0 );\r\n\t\t_this.object.position.copy( _this.position0 );\r\n\t\t_this.object.up.copy( _this.up0 );\r\n\r\n\t\t_eye.subVectors( _this.object.position, _this.target );\r\n\r\n\t\t_this.object.lookAt( _this.target );\r\n\r\n\t\t_this.dispatchEvent( changeEvent );\r\n\r\n\t\tlastPosition.copy( _this.object.position );\r\n\r\n\t};\r\n\r\n\t// listeners\r\n\r\n\tfunction keydown( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\twindow.removeEventListener( 'keydown', keydown );\r\n\r\n\t\t_prevState = _state;\r\n\r\n\t\tif ( _state !== STATE.NONE ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && ! _this.noRotate ) {\r\n\r\n\t\t\t_state = STATE.ROTATE;\r\n\r\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && ! _this.noZoom ) {\r\n\r\n\t\t\t_state = STATE.ZOOM;\r\n\r\n\t\t} else if ( event.keyCode === _this.keys[ STATE.PAN ] && ! _this.noPan ) {\r\n\r\n\t\t\t_state = STATE.PAN;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction keyup( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\t_state = _prevState;\r\n\r\n\t\twindow.addEventListener( 'keydown', keydown, false );\r\n\r\n\t}\r\n\r\n\tfunction mousedown( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tif ( _state === STATE.NONE ) {\r\n\r\n\t\t\t_state = event.button;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _state === STATE.ROTATE && ! _this.noRotate ) {\r\n\r\n\t\t\t_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );\r\n\t\t\t_movePrev.copy( _moveCurr );\r\n\r\n\t\t} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {\r\n\r\n\t\t\t_zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );\r\n\t\t\t_zoomEnd.copy( _zoomStart );\r\n\r\n\t\t} else if ( _state === STATE.PAN && ! _this.noPan ) {\r\n\r\n\t\t\t_panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );\r\n\t\t\t_panEnd.copy( _panStart );\r\n\r\n\t\t}\r\n\r\n\t\tdocument.addEventListener( 'mousemove', mousemove, false );\r\n\t\tdocument.addEventListener( 'mouseup', mouseup, false );\r\n\r\n\t\t_this.dispatchEvent( startEvent );\r\n\r\n\t}\r\n\r\n\tfunction mousemove( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tif ( _state === STATE.ROTATE && ! _this.noRotate ) {\r\n\r\n\t\t\t_movePrev.copy( _moveCurr );\r\n\t\t\t_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );\r\n\r\n\t\t} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {\r\n\r\n\t\t\t_zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );\r\n\r\n\t\t} else if ( _state === STATE.PAN && ! _this.noPan ) {\r\n\r\n\t\t\t_panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction mouseup( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\t_state = STATE.NONE;\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', mousemove );\r\n\t\tdocument.removeEventListener( 'mouseup', mouseup );\r\n\t\t_this.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction mousewheel( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tif ( _this.noZoom === true ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tswitch ( event.deltaMode ) {\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\t// Zoom in pages\r\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.025;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t// Zoom in lines\r\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.01;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t// undefined, 0, assume pixels\r\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.00025;\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\t_this.dispatchEvent( startEvent );\r\n\t\t_this.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction touchstart( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\t\t\r\n\t\tevent.preventDefault();\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\r\n\t\t\t\t_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\r\n\t\t\t\t_movePrev.copy( _moveCurr );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault: // 2 or more\r\n\t\t\t\t_state = STATE.TOUCH_ZOOM_PAN;\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\t\tvar x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;\r\n\t\t\t\tvar y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;\r\n\t\t\t\t_panStart.copy( getMouseOnScreen( x, y ) );\r\n\t\t\t\t_panEnd.copy( _panStart );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\t_this.dispatchEvent( startEvent );\r\n\r\n\t}\r\n\r\n\tfunction touchmove( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\t\tevent.stopPropagation();\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t_movePrev.copy( _moveCurr );\r\n\t\t\t\t_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault: // 2 or more\r\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\t\t\t\t_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );\r\n\r\n\t\t\t\tvar x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;\r\n\t\t\t\tvar y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;\r\n\t\t\t\t_panEnd.copy( getMouseOnScreen( x, y ) );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction touchend( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tswitch ( event.touches.length ) {\r\n\r\n\t\t\tcase 0:\r\n\t\t\t\t_state = STATE.NONE;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\r\n\t\t\t\t_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\r\n\t\t\t\t_movePrev.copy( _moveCurr );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\t_this.dispatchEvent( endEvent );\r\n\r\n\t}\r\n\r\n\tfunction contextmenu( event ) {\r\n\r\n\t\tif ( _this.enabled === false ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t}\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tthis.domElement.removeEventListener( 'contextmenu', contextmenu, false );\r\n\t\tthis.domElement.removeEventListener( 'mousedown', mousedown, false );\r\n\t\tthis.domElement.removeEventListener( 'wheel', mousewheel, false );\r\n\r\n\t\tthis.domElement.removeEventListener( 'touchstart', touchstart, false );\r\n\t\tthis.domElement.removeEventListener( 'touchend', touchend, false );\r\n\t\tthis.domElement.removeEventListener( 'touchmove', touchmove, false );\r\n\r\n\t\tdocument.removeEventListener( 'mousemove', mousemove, false );\r\n\t\tdocument.removeEventListener( 'mouseup', mouseup, false );\r\n\r\n\t\twindow.removeEventListener( 'keydown', keydown, false );\r\n\t\twindow.removeEventListener( 'keyup', keyup, false );\r\n\r\n\t};\r\n\r\n\tthis.domElement.addEventListener( 'contextmenu', contextmenu, false );\r\n\tthis.domElement.addEventListener( 'mousedown', mousedown, false );\r\n\tthis.domElement.addEventListener( 'wheel', mousewheel, false );\r\n\r\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\r\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\r\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\r\n\r\n\twindow.addEventListener( 'keydown', keydown, false );\r\n\twindow.addEventListener( 'keyup', keyup, false );\r\n\r\n\tthis.handleResize();\r\n\r\n\t// force an update at start\r\n\tthis.update();\r\n\r\n};\r\n\r\nTrackballControls.prototype = Object.create( EventDispatcher.prototype );\r\nTrackballControls.prototype.constructor = TrackballControls;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// PolyhedronGeometry\r\n\r\nfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'PolyhedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tvertices: vertices,\r\n\t\tindices: indices,\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\r\nPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\r\n\r\n// PolyhedronBufferGeometry\r\n\r\nfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'PolyhedronBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tvertices: vertices,\r\n\t\tindices: indices,\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tradius = radius || 1;\r\n\tdetail = detail || 0;\r\n\r\n\t// default buffer data\r\n\r\n\tvar vertexBuffer = [];\r\n\tvar uvBuffer = [];\r\n\r\n\t// the subdivision creates the vertex buffer data\r\n\r\n\tsubdivide( detail );\r\n\r\n\t// all vertices should lie on a conceptual sphere with a given radius\r\n\r\n\tappplyRadius( radius );\r\n\r\n\t// finally, create the uv data\r\n\r\n\tgenerateUVs();\r\n\r\n\t// build non-indexed geometry\r\n\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\r\n\r\n\tif ( detail === 0 ) {\r\n\r\n\t\tthis.computeVertexNormals(); // flat normals\r\n\r\n\t} else {\r\n\r\n\t\tthis.normalizeNormals(); // smooth normals\r\n\r\n\t}\r\n\r\n\t// helper functions\r\n\r\n\tfunction subdivide( detail ) {\r\n\r\n\t\tvar a = new Vector3();\r\n\t\tvar b = new Vector3();\r\n\t\tvar c = new Vector3();\r\n\r\n\t\t// iterate over all faces and apply a subdivison with the given detail value\r\n\r\n\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t// get the vertices of the face\r\n\r\n\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\r\n\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\r\n\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\r\n\r\n\t\t\t// perform subdivision\r\n\r\n\t\t\tsubdivideFace( a, b, c, detail );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction subdivideFace( a, b, c, detail ) {\r\n\r\n\t\tvar cols = Math.pow( 2, detail );\r\n\r\n\t\t// we use this multidimensional array as a data structure for creating the subdivision\r\n\r\n\t\tvar v = [];\r\n\r\n\t\tvar i, j;\r\n\r\n\t\t// construct all of the vertices for this subdivision\r\n\r\n\t\tfor ( i = 0; i <= cols; i ++ ) {\r\n\r\n\t\t\tv[ i ] = [];\r\n\r\n\t\t\tvar aj = a.clone().lerp( c, i / cols );\r\n\t\t\tvar bj = b.clone().lerp( c, i / cols );\r\n\r\n\t\t\tvar rows = cols - i;\r\n\r\n\t\t\tfor ( j = 0; j <= rows; j ++ ) {\r\n\r\n\t\t\t\tif ( j === 0 && i === cols ) {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = aj;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// construct all of the faces\r\n\r\n\t\tfor ( i = 0; i < cols; i ++ ) {\r\n\r\n\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\r\n\r\n\t\t\t\tvar k = Math.floor( j / 2 );\r\n\r\n\t\t\t\tif ( j % 2 === 0 ) {\r\n\r\n\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\r\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\r\n\t\t\t\t\tpushVertex( v[ i ][ k ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\r\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\r\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction appplyRadius( radius ) {\r\n\r\n\t\tvar vertex = new Vector3();\r\n\r\n\t\t// iterate over the entire buffer and apply the radius to each vertex\r\n\r\n\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\r\n\r\n\t\t\tvertex.x = vertexBuffer[ i + 0 ];\r\n\t\t\tvertex.y = vertexBuffer[ i + 1 ];\r\n\t\t\tvertex.z = vertexBuffer[ i + 2 ];\r\n\r\n\t\t\tvertex.normalize().multiplyScalar( radius );\r\n\r\n\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\r\n\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\r\n\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction generateUVs() {\r\n\r\n\t\tvar vertex = new Vector3();\r\n\r\n\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\r\n\r\n\t\t\tvertex.x = vertexBuffer[ i + 0 ];\r\n\t\t\tvertex.y = vertexBuffer[ i + 1 ];\r\n\t\t\tvertex.z = vertexBuffer[ i + 2 ];\r\n\r\n\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\r\n\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\r\n\t\t\tuvBuffer.push( u, 1 - v );\r\n\r\n\t\t}\r\n\r\n\t\tcorrectUVs();\r\n\r\n\t\tcorrectSeam();\r\n\r\n\t}\r\n\r\n\tfunction correctSeam() {\r\n\r\n\t\t// handle case when face straddles the seam, see #3269\r\n\r\n\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\r\n\r\n\t\t\t// uv data of a single face\r\n\r\n\t\t\tvar x0 = uvBuffer[ i + 0 ];\r\n\t\t\tvar x1 = uvBuffer[ i + 2 ];\r\n\t\t\tvar x2 = uvBuffer[ i + 4 ];\r\n\r\n\t\t\tvar max = Math.max( x0, x1, x2 );\r\n\t\t\tvar min = Math.min( x0, x1, x2 );\r\n\r\n\t\t\t// 0.9 is somewhat arbitrary\r\n\r\n\t\t\tif ( max > 0.9 && min < 0.1 ) {\r\n\r\n\t\t\t\tif ( x0 < 0.2 ) { uvBuffer[ i + 0 ] += 1; }\r\n\t\t\t\tif ( x1 < 0.2 ) { uvBuffer[ i + 2 ] += 1; }\r\n\t\t\t\tif ( x2 < 0.2 ) { uvBuffer[ i + 4 ] += 1; }\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction pushVertex( vertex ) {\r\n\r\n\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t}\r\n\r\n\tfunction getVertexByIndex( index, vertex ) {\r\n\r\n\t\tvar stride = index * 3;\r\n\r\n\t\tvertex.x = vertices[ stride + 0 ];\r\n\t\tvertex.y = vertices[ stride + 1 ];\r\n\t\tvertex.z = vertices[ stride + 2 ];\r\n\r\n\t}\r\n\r\n\tfunction correctUVs() {\r\n\r\n\t\tvar a = new Vector3();\r\n\t\tvar b = new Vector3();\r\n\t\tvar c = new Vector3();\r\n\r\n\t\tvar centroid = new Vector3();\r\n\r\n\t\tvar uvA = new Vector2();\r\n\t\tvar uvB = new Vector2();\r\n\t\tvar uvC = new Vector2();\r\n\r\n\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\r\n\r\n\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\r\n\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\r\n\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\r\n\r\n\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\r\n\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\r\n\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\r\n\r\n\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\r\n\r\n\t\t\tvar azi = azimuth( centroid );\r\n\r\n\t\t\tcorrectUV( uvA, j + 0, a, azi );\r\n\t\t\tcorrectUV( uvB, j + 2, b, azi );\r\n\t\t\tcorrectUV( uvC, j + 4, c, azi );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction correctUV( uv, stride, vector, azimuth ) {\r\n\r\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\r\n\r\n\t\t\tuvBuffer[ stride ] = uv.x - 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\r\n\r\n\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n\tfunction azimuth( vector ) {\r\n\r\n\t\treturn Math.atan2( vector.z, - vector.x );\r\n\r\n\t}\r\n\r\n\t// Angle above the XZ plane.\r\n\r\n\tfunction inclination( vector ) {\r\n\r\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\nPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// OctahedronGeometry\r\n\r\nfunction OctahedronGeometry( radius, detail ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'OctahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nOctahedronGeometry.prototype = Object.create( Geometry.prototype );\r\nOctahedronGeometry.prototype.constructor = OctahedronGeometry;\r\n\r\n// OctahedronBufferGeometry\r\n\r\nfunction OctahedronBufferGeometry( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\r\n\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\r\n\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\r\n\t\t1, 3, 4,\t1, 4, 2\r\n\t];\r\n\r\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'OctahedronBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n}\r\n\r\nOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\r\nOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// TorusGeometry\r\n\r\nfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'TorusGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tarc: arc\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nTorusGeometry.prototype = Object.create( Geometry.prototype );\r\nTorusGeometry.prototype.constructor = TorusGeometry;\r\n\r\n// TorusBufferGeometry\r\n\r\nfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'TorusBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tarc: arc\r\n\t};\r\n\r\n\tradius = radius || 1;\r\n\ttube = tube || 0.4;\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\r\n\tarc = arc || Math.PI * 2;\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\t// helper variables\r\n\r\n\tvar center = new Vector3();\r\n\tvar vertex = new Vector3();\r\n\tvar normal = new Vector3();\r\n\r\n\tvar j, i;\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\r\n\t\t\t// vertex\r\n\r\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\tvertex.z = tube * Math.sin( v );\r\n\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\r\n\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\tcenter.y = radius * Math.sin( u );\r\n\t\t\tnormal.subVectors( vertex, center ).normalize();\r\n\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t// uv\r\n\r\n\t\t\tuvs.push( i / tubularSegments );\r\n\t\t\tuvs.push( j / radialSegments );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\t// indices\r\n\r\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\r\n\t\t\t// faces\r\n\r\n\t\t\tindices.push( a, b, d );\r\n\t\t\tindices.push( b, c, d );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n}\r\n\r\nTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TransformControls = function ( camera, domElement ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tdomElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n\tthis.visible = false;\r\n\r\n\tvar _gizmo = new TransformControlsGizmo();\r\n\tthis.add( _gizmo );\r\n\r\n\tvar _plane = new TransformControlsPlane();\r\n\tthis.add( _plane );\r\n\r\n\tvar scope = this;\r\n\r\n\t// Define properties with getters/setter\r\n\t// Setting the defined property will automatically trigger change event\r\n\t// Defined properties are passed down to gizmo and plane\r\n\r\n\tdefineProperty( \"camera\", camera );\r\n\tdefineProperty( \"object\", undefined );\r\n\tdefineProperty( \"enabled\", true );\r\n\tdefineProperty( \"axis\", null );\r\n\tdefineProperty( \"mode\", \"translate\" );\r\n\tdefineProperty( \"translationSnap\", null );\r\n\tdefineProperty( \"rotationSnap\", null );\r\n\tdefineProperty( \"space\", \"world\" );\r\n\tdefineProperty( \"size\", 1 );\r\n\tdefineProperty( \"dragging\", false );\r\n\tdefineProperty( \"showX\", true );\r\n\tdefineProperty( \"showY\", true );\r\n\tdefineProperty( \"showZ\", true );\r\n\r\n\tvar changeEvent = { type: \"change\" };\r\n\tvar mouseDownEvent = { type: \"mouseDown\" };\r\n\tvar mouseUpEvent = { type: \"mouseUp\", mode: scope.mode };\r\n\tvar objectChangeEvent = { type: \"objectChange\" };\r\n\r\n\t// Reusable utility variables\r\n\r\n\tvar ray = new Raycaster();\r\n\r\n\tvar _tempVector = new Vector3();\r\n\tvar _tempVector2 = new Vector3();\r\n\tvar _tempQuaternion = new Quaternion();\r\n\tvar _unit = {\r\n\t\tX: new Vector3( 1, 0, 0 ),\r\n\t\tY: new Vector3( 0, 1, 0 ),\r\n\t\tZ: new Vector3( 0, 0, 1 )\r\n\t};\r\n\tvar _identityQuaternion = new Quaternion();\r\n\tvar _alignVector = new Vector3();\r\n\r\n\tvar pointStart = new Vector3();\r\n\tvar pointEnd = new Vector3();\r\n\tvar rotationAxis = new Vector3();\r\n\tvar rotationAngle = 0;\r\n\r\n\tvar cameraPosition = new Vector3();\r\n\tvar cameraQuaternion = new Quaternion();\r\n\tvar cameraScale = new Vector3();\r\n\r\n\tvar parentPosition = new Vector3();\r\n\tvar parentQuaternion = new Quaternion();\r\n\tvar parentScale = new Vector3();\r\n\r\n\tvar worldPositionStart = new Vector3();\r\n\tvar worldQuaternionStart = new Quaternion();\r\n\tvar worldScaleStart = new Vector3();\r\n\r\n\tvar worldPosition = new Vector3();\r\n\tvar worldQuaternion = new Quaternion();\r\n\tvar worldScale = new Vector3();\r\n\r\n\tvar eye = new Vector3();\r\n\r\n\tvar _positionStart = new Vector3();\r\n\tvar _quaternionStart = new Quaternion();\r\n\tvar _scaleStart = new Vector3();\r\n\r\n\t// TODO: remove properties unused in plane and gizmo\r\n\r\n\tdefineProperty( \"parentQuaternion\", parentQuaternion );\r\n\tdefineProperty( \"worldPosition\", worldPosition );\r\n\tdefineProperty( \"worldPositionStart\", worldPositionStart );\r\n\tdefineProperty( \"worldQuaternion\", worldQuaternion );\r\n\tdefineProperty( \"worldQuaternionStart\", worldQuaternionStart );\r\n\tdefineProperty( \"cameraPosition\", cameraPosition );\r\n\tdefineProperty( \"cameraQuaternion\", cameraQuaternion );\r\n\tdefineProperty( \"pointStart\", pointStart );\r\n\tdefineProperty( \"pointEnd\", pointEnd );\r\n\tdefineProperty( \"rotationAxis\", rotationAxis );\r\n\tdefineProperty( \"rotationAngle\", rotationAngle );\r\n\tdefineProperty( \"eye\", eye );\r\n\r\n\t{\r\n\r\n\t\tdomElement.addEventListener( \"mousedown\", onPointerDown, false );\r\n\t\tdomElement.addEventListener( \"touchstart\", onPointerDown, false );\r\n\t\tdomElement.addEventListener( \"mousemove\", onPointerHover, false );\r\n\t\tdomElement.addEventListener( \"touchmove\", onPointerHover, false );\r\n\t\tdocument.addEventListener( \"mousemove\", onPointerMove, false );\r\n\t\tdomElement.addEventListener( \"touchmove\", onPointerMove, false );\r\n\t\tdocument.addEventListener( \"mouseup\", onPointerUp, false );\r\n\t\tdomElement.addEventListener( \"touchend\", onPointerUp, false );\r\n\t\tdomElement.addEventListener( \"touchcancel\", onPointerUp, false );\r\n\t\tdomElement.addEventListener( \"touchleave\", onPointerUp, false );\r\n\t\tdomElement.addEventListener( \"contextmenu\", onContext, false );\r\n\r\n\t}\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tdomElement.removeEventListener( \"mousedown\", onPointerDown );\r\n\t\tdomElement.removeEventListener( \"touchstart\", onPointerDown );\r\n\t\tdomElement.removeEventListener( \"mousemove\", onPointerHover );\r\n\t\tdomElement.removeEventListener( \"touchmove\", onPointerHover );\r\n\t\tdocument.removeEventListener( \"mousemove\", onPointerMove );\r\n\t\tdomElement.removeEventListener( \"touchmove\", onPointerMove );\r\n\t\tdocument.removeEventListener( \"mouseup\", onPointerUp );\r\n\t\tdomElement.removeEventListener( \"touchend\", onPointerUp );\r\n\t\tdomElement.removeEventListener( \"touchcancel\", onPointerUp );\r\n\t\tdomElement.removeEventListener( \"touchleave\", onPointerUp );\r\n\t\tdomElement.removeEventListener( \"contextmenu\", onContext );\r\n\r\n\t};\r\n\r\n\t// Set current object\r\n\tthis.attach = function ( object ) {\r\n\r\n\t\tthis.object = object;\r\n\t\tthis.visible = true;\r\n\r\n\t};\r\n\r\n\t// Detatch from object\r\n\tthis.detach = function () {\r\n\r\n\t\tthis.object = undefined;\r\n\t\tthis.visible = false;\r\n\t\tthis.axis = null;\r\n\r\n\t};\r\n\r\n\t// Defined getter, setter and store for a property\r\n\tfunction defineProperty( propName, defaultValue ) {\r\n\r\n\t\tvar propValue = defaultValue;\r\n\r\n\t\tObject.defineProperty( scope, propName, {\r\n\r\n\t\t\tget: function() {\r\n\r\n\t\t\t\treturn propValue !== undefined ? propValue : defaultValue;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function( value ) {\r\n\r\n\t\t\t\tif ( propValue !== value ) {\r\n\r\n\t\t\t\t\tpropValue = value;\r\n\t\t\t\t\t_plane[ propName ] = value;\r\n\t\t\t\t\t_gizmo[ propName ] = value;\r\n\r\n\t\t\t\t\tscope.dispatchEvent( { type: propName + \"-changed\", value: value } );\r\n\t\t\t\t\tscope.dispatchEvent( changeEvent );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t\tscope[ propName ] = defaultValue;\r\n\t\t_plane[ propName ] = defaultValue;\r\n\t\t_gizmo[ propName ] = defaultValue;\r\n\r\n\t}\r\n\r\n\t// updateMatrixWorld  updates key transformation variables\r\n\tthis.updateMatrixWorld = function () {\r\n\r\n\t\tif ( this.object !== undefined ) {\r\n\r\n\t\t\tthis.object.updateMatrixWorld();\r\n\t\t\tthis.object.parent.matrixWorld.decompose( parentPosition, parentQuaternion, parentScale );\r\n\t\t\tthis.object.matrixWorld.decompose( worldPosition, worldQuaternion, worldScale );\r\n\r\n\t\t}\r\n\r\n\t\tthis.camera.updateMatrixWorld();\r\n\t\tthis.camera.matrixWorld.decompose( cameraPosition, cameraQuaternion, cameraScale );\r\n\r\n\t\tif ( this.camera instanceof PerspectiveCamera ) {\r\n\r\n\t\t\teye.copy( cameraPosition ).sub( worldPosition ).normalize();\r\n\r\n\t\t} else if ( this.camera instanceof OrthographicCamera ) {\r\n\r\n\t\t\teye.copy( cameraPosition ).normalize();\r\n\r\n\t\t}\r\n\r\n\t\tObject3D.prototype.updateMatrixWorld.call( this );\r\n\r\n\t};\r\n\r\n\tthis.pointerHover = function( pointer ) {\r\n\r\n\t\tif ( this.object === undefined || this.dragging === true || ( pointer.button !== undefined && pointer.button !== 0 ) ) { return; }\r\n\r\n\t\tray.setFromCamera( pointer, this.camera );\r\n\r\n\t\tvar intersect = ray.intersectObjects( _gizmo.picker[ this.mode ].children, true )[ 0 ] || false;\r\n\r\n\t\tif ( intersect ) {\r\n\r\n\t\t\tthis.axis = intersect.object.name;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.axis = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.pointerDown = function( pointer ) {\r\n\r\n\t\tif ( this.object === undefined || this.dragging === true || ( pointer.button !== undefined && pointer.button !== 0 ) ) { return; }\r\n\r\n\t\tif ( ( pointer.button === 0 || pointer.button === undefined ) && this.axis !== null ) {\r\n\r\n\t\t\tray.setFromCamera( pointer, this.camera );\r\n\r\n\t\t\tvar planeIntersect = ray.intersectObjects( [ _plane ], true )[ 0 ] || false;\r\n\r\n\t\t\tif ( planeIntersect ) {\r\n\r\n\t\t\t\tvar space = this.space;\r\n\r\n\t\t\t\tif ( this.mode === 'scale') {\r\n\r\n\t\t\t\t\tspace = 'local';\r\n\r\n\t\t\t\t} else if ( this.axis === 'E' ||  this.axis === 'XYZE' ||  this.axis === 'XYZ' ) {\r\n\r\n\t\t\t\t\tspace = 'world';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( space === 'local' && this.mode === 'rotate' ) {\r\n\r\n\t\t\t\t\tvar snap = this.rotationSnap;\r\n\r\n\t\t\t\t\tif ( this.axis === 'X' && snap ) { this.object.rotation.x = Math.round( this.object.rotation.x / snap ) * snap; }\r\n\t\t\t\t\tif ( this.axis === 'Y' && snap ) { this.object.rotation.y = Math.round( this.object.rotation.y / snap ) * snap; }\r\n\t\t\t\t\tif ( this.axis === 'Z' && snap ) { this.object.rotation.z = Math.round( this.object.rotation.z / snap ) * snap; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.object.updateMatrixWorld();\r\n\t\t\t\tthis.object.parent.updateMatrixWorld();\r\n\r\n\t\t\t\t_positionStart.copy( this.object.position );\r\n\t\t\t\t_quaternionStart.copy( this.object.quaternion );\r\n\t\t\t\t_scaleStart.copy( this.object.scale );\r\n\r\n\t\t\t\tthis.object.matrixWorld.decompose( worldPositionStart, worldQuaternionStart, worldScaleStart );\r\n\r\n\t\t\t\tpointStart.copy( planeIntersect.point ).sub( worldPositionStart );\r\n\r\n\t\t\t\tif ( space === 'local' ) { pointStart.applyQuaternion( worldQuaternionStart.clone().inverse() ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.dragging = true;\r\n\t\t\tmouseDownEvent.mode = this.mode;\r\n\t\t\tthis.dispatchEvent( mouseDownEvent );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.pointerMove = function( pointer ) {\r\n\r\n\t\tvar axis = this.axis;\r\n\t\tvar mode = this.mode;\r\n\t\tvar object = this.object;\r\n\t\tvar space = this.space;\r\n\r\n\t\tif ( mode === 'scale') {\r\n\r\n\t\t\tspace = 'local';\r\n\r\n\t\t} else if ( axis === 'E' ||  axis === 'XYZE' ||  axis === 'XYZ' ) {\r\n\r\n\t\t\tspace = 'world';\r\n\r\n\t\t}\r\n\r\n\t\tif ( object === undefined || axis === null || this.dragging === false || ( pointer.button !== undefined && pointer.button !== 0 ) ) { return; }\r\n\r\n\t\tray.setFromCamera( pointer, this.camera );\r\n\r\n\t\tvar planeIntersect = ray.intersectObjects( [ _plane ], true )[ 0 ] || false;\r\n\r\n\t\tif ( planeIntersect === false ) { return; }\r\n\r\n\t\tpointEnd.copy( planeIntersect.point ).sub( worldPositionStart );\r\n\r\n\t\tif ( space === 'local' ) { pointEnd.applyQuaternion( worldQuaternionStart.clone().inverse() ); }\r\n\r\n\t\tif ( mode === 'translate' ) {\r\n\r\n\t\t\tif ( axis.search( 'X' ) === -1 ) {\r\n\t\t\t\tpointEnd.x = pointStart.x;\r\n\t\t\t}\r\n\t\t\tif ( axis.search( 'Y' ) === -1 ) {\r\n\t\t\t\tpointEnd.y = pointStart.y;\r\n\t\t\t}\r\n\t\t\tif ( axis.search( 'Z' ) === -1 ) {\r\n\t\t\t\tpointEnd.z = pointStart.z;\r\n\t\t\t}\r\n\r\n\t\t\t// Apply translate\r\n\r\n\t\t\tif ( space === 'local' ) {\r\n\t\t\t\tobject.position.copy( pointEnd ).sub( pointStart ).applyQuaternion( _quaternionStart );\r\n\t\t\t} else {\r\n\t\t\t\tobject.position.copy( pointEnd ).sub( pointStart );\r\n\t\t\t}\r\n\r\n\t\t\tobject.position.add( _positionStart );\r\n\r\n\t\t\t// Apply translation snap\r\n\r\n\t\t\tif ( this.translationSnap ) {\r\n\r\n\t\t\t\tif ( space === 'local' ) {\r\n\r\n\t\t\t\t\tobject.position.applyQuaternion(_tempQuaternion.copy( _quaternionStart ).inverse() );\r\n\r\n\t\t\t\t\tif ( axis.search( 'X' ) !== -1 ) {\r\n\t\t\t\t\t\tobject.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( axis.search( 'Y' ) !== -1 ) {\r\n\t\t\t\t\t\tobject.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( axis.search( 'Z' ) !== -1 ) {\r\n\t\t\t\t\t\tobject.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject.position.applyQuaternion( _quaternionStart );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( space === 'world' ) {\r\n\r\n\t\t\t\t\tif ( object.parent ) {\r\n\t\t\t\t\t\tobject.position.add( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( axis.search( 'X' ) !== -1 ) {\r\n\t\t\t\t\t\tobject.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( axis.search( 'Y' ) !== -1 ) {\r\n\t\t\t\t\t\tobject.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( axis.search( 'Z' ) !== -1 ) {\r\n\t\t\t\t\t\tobject.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( object.parent ) {\r\n\t\t\t\t\t\tobject.position.sub( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( mode === 'scale' ) {\r\n\r\n\t\t\tif ( axis.search( 'XYZ' ) !== -1 ) {\r\n\r\n\t\t\t\tvar d = pointEnd.length() / pointStart.length();\r\n\r\n\t\t\t\tif ( pointEnd.dot( pointStart ) < 0 ) { d *= -1; }\r\n\r\n\t\t\t\t_tempVector.set( d, d, d );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_tempVector.copy( pointEnd ).divide( pointStart );\r\n\r\n\t\t\t\tif ( axis.search( 'X' ) === -1 ) {\r\n\t\t\t\t\t_tempVector.x = 1;\r\n\t\t\t\t}\r\n\t\t\t\tif ( axis.search( 'Y' ) === -1 ) {\r\n\t\t\t\t\t_tempVector.y = 1;\r\n\t\t\t\t}\r\n\t\t\t\tif ( axis.search( 'Z' ) === -1 ) {\r\n\t\t\t\t\t_tempVector.z = 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Apply scale\r\n\r\n\t\t\tobject.scale.copy( _scaleStart ).multiply( _tempVector );\r\n\r\n\t\t} else if ( mode === 'rotate' ) {\r\n\r\n\t\t\tvar ROTATION_SPEED = 20 / worldPosition.distanceTo( _tempVector.setFromMatrixPosition( this.camera.matrixWorld ) );\r\n\r\n\t\t\tvar quaternion = this.space === \"local\" ? worldQuaternion : _identityQuaternion;\r\n\r\n\t\t\tvar unit = _unit[ axis ];\r\n\r\n\t\t\tif ( axis === 'E' ) {\r\n\r\n\t\t\t\t_tempVector.copy( pointEnd ).cross( pointStart );\r\n\t\t\t\trotationAxis.copy( eye );\r\n\t\t\t\trotationAngle = pointEnd.angleTo( pointStart ) * ( _tempVector.dot( eye ) < 0 ? 1 : -1 );\r\n\r\n\t\t\t} else if ( axis === 'XYZE' ) {\r\n\r\n\t\t\t\t_tempVector.copy( pointEnd ).sub( pointStart ).cross( eye ).normalize();\r\n\t\t\t\trotationAxis.copy( _tempVector );\r\n\t\t\t\trotationAngle = pointEnd.sub( pointStart ).dot( _tempVector.cross( eye ) ) * ROTATION_SPEED;\r\n\r\n\t\t\t} else if ( axis === 'X' || axis === 'Y' || axis === 'Z' ) {\r\n\r\n\t\t\t\t_alignVector.copy( unit ).applyQuaternion( quaternion );\r\n\r\n\t\t\t\trotationAxis.copy( unit );\r\n\r\n\t\t\t\t_tempVector = unit.clone();\r\n\t\t\t\t_tempVector2 = pointEnd.clone().sub( pointStart );\r\n\t\t\t\tif ( space === 'local' ) {\r\n\t\t\t\t\t_tempVector.applyQuaternion( quaternion );\r\n\t\t\t\t\t_tempVector2.applyQuaternion( worldQuaternionStart );\r\n\t\t\t\t}\r\n\t\t\t\trotationAngle = _tempVector2.dot( _tempVector.cross( eye ).normalize() ) * ROTATION_SPEED;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Apply rotation snap\r\n\r\n\t\t\tif ( this.rotationSnap ) { rotationAngle = Math.round( rotationAngle / this.rotationSnap ) * this.rotationSnap; }\r\n\r\n\t\t\tthis.rotationAngle = rotationAngle;\r\n\r\n\t\t\t// Apply rotate\r\n\r\n\t\t\tif ( space === 'local' ) {\r\n\r\n\t\t\t\tobject.quaternion.copy( _quaternionStart );\r\n\t\t\t\tobject.quaternion.multiply( _tempQuaternion.setFromAxisAngle( rotationAxis, rotationAngle ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject.quaternion.copy( _tempQuaternion.setFromAxisAngle( rotationAxis, rotationAngle ) );\r\n\t\t\t\tobject.quaternion.multiply( _quaternionStart );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.dispatchEvent( changeEvent );\r\n\t\tthis.dispatchEvent( objectChangeEvent );\r\n\r\n\t};\r\n\r\n\tthis.pointerUp = function( pointer ) {\r\n\r\n\t\tif ( pointer.button !== undefined && pointer.button !== 0 ) { return; }\r\n\r\n\t\tif ( this.dragging && ( this.axis !== null ) ) {\r\n\r\n\t\t\tmouseUpEvent.mode = this.mode;\r\n\t\t\tthis.dispatchEvent( mouseUpEvent );\r\n\r\n\t\t}\r\n\r\n\t\tthis.dragging = false;\r\n\r\n\t\tif ( pointer.button === undefined ) { this.axis = null; }\r\n\r\n\t};\r\n\r\n\t// normalize mouse / touch pointer and remap {x,y} to view space.\r\n\r\n\tfunction getPointer( event ) {\r\n\r\n\t\tvar pointer = event.changedTouches ? event.changedTouches[ 0 ] : event;\r\n\r\n\t\tvar rect = domElement.getBoundingClientRect();\r\n\r\n\t\treturn {\r\n\t\t\tx: ( pointer.clientX - rect.left ) / rect.width * 2 - 1,\r\n\t\t\ty: - ( pointer.clientY - rect.top ) / rect.height * 2 + 1,\r\n\t\t\tbutton: event.button\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// mouse / touch event handlers\r\n\r\n\tfunction onContext( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t}\r\n\r\n\tfunction onPointerHover( event ) {\r\n\r\n\t\tif ( !scope.enabled ) { return; }\r\n\r\n\t\tscope.pointerHover( getPointer( event ) );\r\n\r\n\t}\r\n\r\n\tfunction onPointerDown( event ) {\r\n\r\n\t\tif ( !scope.enabled ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tscope.pointerHover( getPointer( event ) );\r\n\t\tscope.pointerDown( getPointer( event ) );\r\n\r\n\t}\r\n\r\n\tfunction onPointerMove( event ) {\r\n\r\n\t\tif ( !scope.enabled ) { return; }\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tscope.pointerMove( getPointer( event ) );\r\n\r\n\t}\r\n\r\n\tfunction onPointerUp( event ) {\r\n\r\n\t\tif ( !scope.enabled ) { return; }\r\n\r\n\t\tevent.preventDefault(); // Prevent MouseEvent on mobile\r\n\r\n\t\tscope.pointerUp( getPointer( event ) );\r\n\r\n\t}\r\n\r\n\t// TODO: depricate\r\n\r\n\tthis.getMode = function () {\r\n\r\n\t\treturn scope.mode;\r\n\r\n\t};\r\n\r\n\tthis.setMode = function ( mode ) {\r\n\r\n\t\tscope.mode = mode;\r\n\r\n\t};\r\n\r\n\tthis.setTranslationSnap = function ( translationSnap ) {\r\n\r\n\t\tscope.translationSnap = translationSnap;\r\n\r\n\t};\r\n\r\n\tthis.setRotationSnap = function ( rotationSnap ) {\r\n\r\n\t\tscope.rotationSnap = rotationSnap;\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( size ) {\r\n\r\n\t\tscope.size = size;\r\n\r\n\t};\r\n\r\n\tthis.setSpace = function ( space ) {\r\n\r\n\t\tscope.space = space;\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n\r\n\t\tconsole.warn( 'TransformControls: update function has been depricated.' );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTransformControls.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n  constructor: TransformControls,\r\n\r\n  isTransformControls: true\r\n\r\n} );\r\n\r\nvar TransformControlsGizmo = function () {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'TransformControlsGizmo';\r\n\r\n\t// shared materials\r\n\r\n\tvar gizmoMaterial = new MeshBasicMaterial({\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false,\r\n\t\ttransparent: true,\r\n\t\tside: DoubleSide,\r\n\t\tfog: false\r\n\t});\r\n\r\n\tvar gizmoLineMaterial = new LineBasicMaterial({\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false,\r\n\t\ttransparent: true,\r\n\t\tlinewidth: 1,\r\n\t\tfog: false\r\n\t});\r\n\r\n\t// Make unique material for each axis/color\r\n\r\n\tvar matInvisible = gizmoMaterial.clone();\r\n\tmatInvisible.opacity = 0.15;\r\n\r\n\tvar matHelper = gizmoMaterial.clone();\r\n\tmatHelper.opacity = 0.33;\r\n\r\n\tvar matRed = gizmoMaterial.clone();\r\n\tmatRed.color.set( 0xff0000 );\r\n\r\n\tvar matGreen = gizmoMaterial.clone();\r\n\tmatGreen.color.set( 0x00ff00 );\r\n\r\n\tvar matBlue = gizmoMaterial.clone();\r\n\tmatBlue.color.set( 0x0000ff );\r\n\r\n\tvar matWhiteTransperent = gizmoMaterial.clone();\r\n\tmatWhiteTransperent.opacity = 0.25;\r\n\r\n\tvar matYellowTransparent = matWhiteTransperent.clone();\r\n\tmatYellowTransparent.color.set( 0xffff00 );\r\n\r\n\tvar matCyanTransparent = matWhiteTransperent.clone();\r\n\tmatCyanTransparent.color.set( 0x00ffff );\r\n\r\n\tvar matMagentaTransparent = matWhiteTransperent.clone();\r\n\tmatMagentaTransparent.color.set( 0xff00ff );\r\n\r\n\tvar matYellow = gizmoMaterial.clone();\r\n\tmatYellow.color.set( 0xffff00 );\r\n\r\n\tvar matLineRed = gizmoLineMaterial.clone();\r\n\tmatLineRed.color.set( 0xff0000 );\r\n\r\n\tvar matLineGreen = gizmoLineMaterial.clone();\r\n\tmatLineGreen.color.set( 0x00ff00 );\r\n\r\n\tvar matLineBlue = gizmoLineMaterial.clone();\r\n\tmatLineBlue.color.set( 0x0000ff );\r\n\r\n\tvar matLineCyan = gizmoLineMaterial.clone();\r\n\tmatLineCyan.color.set( 0x00ffff );\r\n\r\n\tvar matLineMagenta = gizmoLineMaterial.clone();\r\n\tmatLineMagenta.color.set( 0xff00ff );\r\n\r\n\tvar matLineYellow = gizmoLineMaterial.clone();\r\n\tmatLineYellow.color.set( 0xffff00 );\r\n\r\n\tvar matLineGray = gizmoLineMaterial.clone();\r\n\tmatLineGray.color.set( 0x787878);\r\n\r\n\tvar matLineYellowTransparent = matLineYellow.clone();\r\n\tmatLineYellowTransparent.opacity = 0.25;\r\n\r\n\t// reusable geometry\r\n\r\n\tvar arrowGeometry = new CylinderBufferGeometry( 0, 0.05, 0.2, 12, 1, false);\r\n\r\n\tvar scaleHandleGeometry = new BoxBufferGeometry( 0.125, 0.125, 0.125);\r\n\r\n\tvar lineGeometry = new BufferGeometry( );\r\n\tlineGeometry.addAttribute('position', new Float32BufferAttribute( [ 0, 0, 0,\t1, 0, 0 ], 3 ) );\r\n\r\n\tvar CircleGeometry = function( radius, arc ) {\r\n\r\n\t\tvar geometry = new BufferGeometry( );\r\n\t\tvar vertices = [];\r\n\r\n\t\tfor ( var i = 0; i <= 64 * arc; ++i ) {\r\n\r\n\t\t\tvertices.push( 0, Math.cos( i / 32 * Math.PI ) * radius, Math.sin( i / 32 * Math.PI ) * radius );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.addAttribute('position', new Float32BufferAttribute( vertices, 3 ) );\r\n\r\n\t\treturn geometry;\r\n\r\n\t};\r\n\r\n\t// Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position\r\n\r\n\tvar TranslateHelperGeometry = function( radius, arc ) {\r\n\r\n\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\tgeometry.addAttribute('position', new Float32BufferAttribute( [ 0, 0, 0, 1, 1, 1 ], 3 ) );\r\n\r\n\t\treturn geometry;\r\n\r\n\t};\r\n\r\n\t// Gizmo definitions - custom hierarchy definitions for setupGizmo() function\r\n\r\n\tvar gizmoTranslate = {\r\n\t\tX: [\r\n\t\t\t[ new Mesh( arrowGeometry, matRed ), [ 1, 0, 0 ], [ 0, 0, -Math.PI / 2 ], null, 'fwd' ],\r\n\t\t\t[ new Mesh( arrowGeometry, matRed ), [ 1, 0, 0 ], [ 0, 0, Math.PI / 2 ], null, 'bwd' ],\r\n\t\t\t[ new Line( lineGeometry, matLineRed ) ]\r\n\t\t],\r\n\t\tY: [\r\n\t\t\t[ new Mesh( arrowGeometry, matGreen ), [ 0, 1, 0 ], null, null, 'fwd' ],\r\n\t\t\t[ new Mesh( arrowGeometry, matGreen ), [ 0, 1, 0 ], [ Math.PI, 0, 0 ], null, 'bwd' ],\r\n\t\t\t[ new Line( lineGeometry, matLineGreen ), null, [ 0, 0, Math.PI / 2 ] ]\r\n\t\t],\r\n\t\tZ: [\r\n\t\t\t[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 1 ], [ Math.PI / 2, 0, 0 ], null, 'fwd' ],\r\n\t\t\t[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 1 ], [ -Math.PI / 2, 0, 0 ], null, 'bwd' ],\r\n\t\t\t[ new Line( lineGeometry, matLineBlue ), null, [ 0, -Math.PI / 2, 0 ] ]\r\n\t\t],\r\n\t\tXYZ: [\r\n\t\t\t[ new Mesh( new OctahedronBufferGeometry( 0.1, 0 ), matWhiteTransperent ), [ 0, 0, 0 ], [ 0, 0, 0 ] ]\r\n\t\t],\r\n\t\tXY: [\r\n\t\t\t[ new Mesh( new PlaneBufferGeometry( 0.295, 0.295 ), matYellowTransparent ), [ 0.15, 0.15, 0 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineYellow ), [ 0.18, 0.3, 0 ], null, [ 0.125, 1, 1 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineYellow ), [ 0.3, 0.18, 0 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ] ]\r\n\t\t],\r\n\t\tYZ: [\r\n\t\t\t[ new Mesh( new PlaneBufferGeometry( 0.295, 0.295 ), matCyanTransparent ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineCyan ), [ 0, 0.18, 0.3 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineCyan ), [ 0, 0.3, 0.18 ], [ 0, -Math.PI / 2, 0 ], [ 0.125, 1, 1 ] ]\r\n\t\t],\r\n\t\tXZ: [\r\n\t\t\t[ new Mesh( new PlaneBufferGeometry( 0.295, 0.295 ), matMagentaTransparent ), [ 0.15, 0, 0.15 ], [ -Math.PI / 2, 0, 0 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineMagenta ), [ 0.18, 0, 0.3 ], null, [ 0.125, 1, 1 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineMagenta ), [ 0.3, 0, 0.18 ], [ 0, -Math.PI / 2, 0 ], [ 0.125, 1, 1 ] ]\r\n\t\t]\r\n\t};\r\n\r\n\tvar pickerTranslate = {\r\n\t\tX: [\r\n\t\t\t[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0.6, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ]\r\n\t\t],\r\n\t\tY: [\r\n\t\t\t[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0, 0.6, 0 ] ]\r\n\t\t],\r\n\t\tZ: [\r\n\t\t\t[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0, 0, 0.6 ], [ Math.PI / 2, 0, 0 ] ]\r\n\t\t],\r\n\t\tXYZ: [\r\n\t\t\t[ new Mesh( new OctahedronBufferGeometry( 0.2, 0 ), matInvisible ) ]\r\n\t\t],\r\n\t\tXY: [\r\n\t\t\t[ new Mesh( new PlaneBufferGeometry( 0.4, 0.4 ), matInvisible ), [ 0.2, 0.2, 0 ] ]\r\n\t\t],\r\n\t\tYZ: [\r\n\t\t\t[ new Mesh( new PlaneBufferGeometry( 0.4, 0.4 ), matInvisible ), [ 0, 0.2, 0.2 ], [ 0, Math.PI / 2, 0 ] ]\r\n\t\t],\r\n\t\tXZ: [\r\n\t\t\t[ new Mesh( new PlaneBufferGeometry( 0.4, 0.4 ), matInvisible ), [ 0.2, 0, 0.2 ], [ -Math.PI / 2, 0, 0 ] ]\r\n\t\t]\r\n\t};\r\n\r\n\tvar helperTranslate = {\r\n\t\tSTART: [\r\n\t\t\t[ new Mesh( new OctahedronBufferGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]\r\n\t\t],\r\n\t\tEND: [\r\n\t\t\t[ new Mesh( new OctahedronBufferGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]\r\n\t\t],\r\n\t\tDELTA: [\r\n\t\t\t[ new Line( TranslateHelperGeometry(), matHelper ), null, null, null, 'helper' ]\r\n\t\t],\r\n\t\tX: [\r\n\t\t\t[ new Line( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\r\n\t\t],\r\n\t\tY: [\r\n\t\t\t[ new Line( lineGeometry, matHelper.clone() ), [ 0, -1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]\r\n\t\t],\r\n\t\tZ: [\r\n\t\t\t[ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, -1e3 ], [ 0, -Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]\r\n\t\t]\r\n\t};\r\n\r\n\tvar gizmoRotate = {\r\n\t\tX: [\r\n\t\t\t[ new Line( CircleGeometry( 1, 0.5 ), matLineRed ) ],\r\n\t\t\t[ new Mesh( new OctahedronBufferGeometry( 0.04, 0 ), matRed ), [ 0, 0, 0.99 ], null, [ 1, 3, 1 ] ] ],\r\n\t\tY: [\r\n\t\t\t[ new Line( CircleGeometry( 1, 0.5 ), matLineGreen ), null, [ 0, 0, -Math.PI / 2 ] ],\r\n\t\t\t[ new Mesh( new OctahedronBufferGeometry( 0.04, 0 ), matGreen ), [ 0, 0, 0.99 ], null, [ 3, 1, 1 ] ] ],\r\n\t\tZ: [\r\n\t\t\t[ new Line( CircleGeometry( 1, 0.5 ), matLineBlue ), null, [ 0, Math.PI / 2, 0 ] ],\r\n\t\t\t[ new Mesh( new OctahedronBufferGeometry( 0.04, 0 ), matBlue ), [ 0.99, 0, 0 ], null, [ 1, 3, 1 ] ] ],\r\n\t\tE: [\r\n\t\t\t[ new Line( CircleGeometry( 1.25, 1 ), matLineYellowTransparent ), null, [ 0, Math.PI / 2, 0 ] ],\r\n\t\t\t[ new Mesh( new CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 1.17, 0, 0 ], [ 0, 0, -Math.PI / 2 ], [ 1, 1, 0.001 ]],\r\n\t\t\t[ new Mesh( new CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ -1.17, 0, 0 ], [ 0, 0, Math.PI / 2 ], [ 1, 1, 0.001 ]],\r\n\t\t\t[ new Mesh( new CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 0, -1.17, 0 ], [ Math.PI, 0, 0 ], [ 1, 1, 0.001 ]],\r\n\t\t\t[ new Mesh( new CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 0, 1.17, 0 ], [ 0, 0, 0 ], [ 1, 1, 0.001 ]] ],\r\n\t\tXYZE: [\r\n\t\t\t[ new Line( CircleGeometry( 1, 1 ), matLineGray ), null, [ 0, Math.PI / 2, 0 ] ]\r\n\t\t]\r\n\t};\r\n\r\n\tvar helperRotate = {\r\n\t\tAXIS: [\r\n\t\t\t[ new Line( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\r\n\t\t]\r\n\t};\r\n\r\n\tvar pickerRotate = {\r\n\t\tX: [\r\n\t\t\t[ new Mesh( new TorusBufferGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, -Math.PI / 2, -Math.PI / 2 ] ] ],\r\n\t\tY: [\r\n\t\t\t[ new Mesh( new TorusBufferGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ] ] ],\r\n\t\tZ: [\r\n\t\t\t[ new Mesh( new TorusBufferGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ] ],\r\n\t\tE: [\r\n\t\t\t[ new Mesh( new TorusBufferGeometry( 1.25, 0.1, 2, 24 ), matInvisible ) ]\r\n\t\t],\r\n\t\tXYZE: [\r\n\t\t\t[ new Mesh( new SphereBufferGeometry( 0.7, 10, 8 ), matInvisible ) ]\r\n\t\t]\r\n\t};\r\n\r\n\tvar gizmoScale = {\r\n\t\tX: [\r\n\t\t\t[ new Mesh( scaleHandleGeometry, matRed ), [ 0.8, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineRed ), null, null, [ 0.8, 1, 1 ] ]\r\n\t\t],\r\n\t\tY: [\r\n\t\t\t[ new Mesh( scaleHandleGeometry, matGreen ), [ 0, 0.8, 0 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineGreen ), null, [ 0, 0, Math.PI / 2 ], [ 0.8, 1, 1 ] ]\r\n\t\t],\r\n\t\tZ: [\r\n\t\t\t[ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, 0.8 ], [ Math.PI / 2, 0, 0 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineBlue ), null, [ 0, -Math.PI / 2, 0 ], [ 0.8, 1, 1 ] ]\r\n\t\t],\r\n\t\tXY: [\r\n\t\t\t[ new Mesh( scaleHandleGeometry, matYellowTransparent ), [ 0.85, 0.85, 0 ], null, [ 2, 2, 0.2 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineYellow ), [ 0.855, 0.98, 0 ], null, [ 0.125, 1, 1 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineYellow ), [ 0.98, 0.855, 0 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ] ]\r\n\t\t],\r\n\t\tYZ: [\r\n\t\t\t[ new Mesh( scaleHandleGeometry, matCyanTransparent ), [ 0, 0.85, 0.85 ], null, [ 0.2, 2, 2 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineCyan ), [ 0, 0.855, 0.98 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineCyan ), [ 0, 0.98, 0.855 ], [ 0, -Math.PI / 2, 0 ], [ 0.125, 1, 1 ] ]\r\n\t\t],\r\n\t\tXZ: [\r\n\t\t\t[ new Mesh( scaleHandleGeometry, matMagentaTransparent ), [ 0.85, 0, 0.85 ], null, [ 2, 0.2, 2 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineMagenta ), [ 0.855, 0, 0.98 ], null, [ 0.125, 1, 1 ] ],\r\n\t\t\t[ new Line( lineGeometry, matLineMagenta ), [ 0.98, 0, 0.855 ], [ 0, -Math.PI / 2, 0 ], [ 0.125, 1, 1 ] ]\r\n\t\t],\r\n\t\tXYZX: [\r\n\t\t\t[ new Mesh( new BoxBufferGeometry( 0.125, 0.125, 0.125 ), matWhiteTransperent ), [ 1.1, 0, 0 ] ] ],\r\n\t\tXYZY: [\r\n\t\t\t[ new Mesh( new BoxBufferGeometry( 0.125, 0.125, 0.125 ), matWhiteTransperent ), [ 0, 1.1, 0 ] ] ],\r\n\t\tXYZZ: [\r\n\t\t\t[ new Mesh( new BoxBufferGeometry( 0.125, 0.125, 0.125 ), matWhiteTransperent ), [ 0, 0, 1.1 ] ] ]\r\n\t};\r\n\r\n\tvar pickerScale = {\r\n\t\tX: [\r\n\t\t\t[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0.5, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ]\r\n\t\t],\r\n\t\tY: [\r\n\t\t\t[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0, 0.5, 0 ] ]\r\n\t\t],\r\n\t\tZ: [\r\n\t\t\t[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ] ]\r\n\t\t],\r\n\t\tXY: [\r\n\t\t\t[ new Mesh( scaleHandleGeometry, matInvisible ), [ 0.85, 0.85, 0 ], null, [ 3, 3, 0.2 ] ] ],\r\n\t\tYZ: [\r\n\t\t\t[ new Mesh( scaleHandleGeometry, matInvisible ), [ 0, 0.85, 0.85 ], null, [ 0.2, 3, 3 ] ] ],\r\n\t\tXZ: [\r\n\t\t\t[ new Mesh( scaleHandleGeometry, matInvisible ), [ 0.85, 0, 0.85 ], null, [ 3, 0.2, 3 ] ] ],\r\n\t\tXYZX: [\r\n\t\t\t[ new Mesh( new BoxBufferGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 1.1, 0, 0 ] ] ],\r\n\t\tXYZY: [\r\n\t\t\t[ new Mesh( new BoxBufferGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 1.1, 0 ] ] ],\r\n\t\tXYZZ: [\r\n\t\t\t[ new Mesh( new BoxBufferGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 0, 1.1 ] ] ]\r\n\t};\r\n\r\n\tvar helperScale = {\r\n\t\tX: [\r\n\t\t\t[ new Line( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\r\n\t\t],\r\n\t\tY: [\r\n\t\t\t[ new Line( lineGeometry, matHelper.clone() ), [ 0, -1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]\r\n\t\t],\r\n\t\tZ: [\r\n\t\t\t[ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, -1e3 ], [ 0, -Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]\r\n\t\t]\r\n\t};\r\n\r\n\t// Creates an Object3D with gizmos described in custom hierarchy definition.\r\n\r\n\tvar setupGizmo = function( gizmoMap ) {\r\n\r\n\t\tvar gizmo = new Object3D();\r\n\r\n\t\tfor ( var name in gizmoMap ) {\r\n\r\n\t\t\tfor ( var i = gizmoMap[ name ].length; i --; ) {\r\n\r\n\t\t\t\tvar object = gizmoMap[ name ][ i ][ 0 ].clone();\r\n\t\t\t\tvar position = gizmoMap[ name ][ i ][ 1 ];\r\n\t\t\t\tvar rotation = gizmoMap[ name ][ i ][ 2 ];\r\n\t\t\t\tvar scale = gizmoMap[ name ][ i ][ 3 ];\r\n\t\t\t\tvar tag = gizmoMap[ name ][ i ][ 4 ];\r\n\r\n\t\t\t\t// name and tag properties are essential for picking and updating logic.\r\n\t\t\t\tobject.name = name;\r\n\t\t\t\tobject.tag = tag;\r\n\r\n\t\t\t\tif (position) {\r\n\t\t\t\t\tobject.position.set(position[ 0 ], position[ 1 ], position[ 2 ]);\r\n\t\t\t\t}\r\n\t\t\t\tif (rotation) {\r\n\t\t\t\t\tobject.rotation.set(rotation[ 0 ], rotation[ 1 ], rotation[ 2 ]);\r\n\t\t\t\t}\r\n\t\t\t\tif (scale) {\r\n\t\t\t\t\tobject.scale.set(scale[ 0 ], scale[ 1 ], scale[ 2 ]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.updateMatrix();\r\n\r\n\t\t\t\tvar tempGeometry = object.geometry.clone();\r\n\t\t\t\ttempGeometry.applyMatrix(object.matrix);\r\n\t\t\t\tobject.geometry = tempGeometry;\r\n\r\n\t\t\t\tobject.position.set( 0, 0, 0 );\r\n\t\t\t\tobject.rotation.set( 0, 0, 0 );\r\n\t\t\t\tobject.scale.set(1, 1, 1);\r\n\r\n\t\t\t\tgizmo.add(object);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn gizmo;\r\n\r\n\t};\r\n\r\n\t// Reusable utility variables\r\n\r\n\tvar tempVector = new Vector3( 0, 0, 0 );\r\n\tvar tempEuler = new Euler();\r\n\tvar alignVector = new Vector3( 0, 1, 0 );\r\n\tvar zeroVector = new Vector3( 0, 0, 0 );\r\n\tvar lookAtMatrix = new Matrix4();\r\n\tvar tempQuaternion = new Quaternion();\r\n\tvar tempQuaternion2 = new Quaternion();\r\n\tvar identityQuaternion = new Quaternion();\r\n\r\n\tvar unitX = new Vector3( 1, 0, 0 );\r\n\tvar unitY = new Vector3( 0, 1, 0 );\r\n\tvar unitZ = new Vector3( 0, 0, 1 );\r\n\r\n\t// Gizmo creation\r\n\r\n\tthis.gizmo = {};\r\n\tthis.picker = {};\r\n\tthis.helper = {};\r\n\r\n\tthis.add( this.gizmo[ \"translate\" ] = setupGizmo( gizmoTranslate ) );\r\n\tthis.add( this.gizmo[ \"rotate\" ] = setupGizmo( gizmoRotate ) );\r\n\tthis.add( this.gizmo[ \"scale\" ] = setupGizmo( gizmoScale ) );\r\n\tthis.add( this.picker[ \"translate\" ] = setupGizmo( pickerTranslate ) );\r\n\tthis.add( this.picker[ \"rotate\" ] = setupGizmo( pickerRotate ) );\r\n\tthis.add( this.picker[ \"scale\" ] = setupGizmo( pickerScale ) );\r\n\tthis.add( this.helper[ \"translate\" ] = setupGizmo( helperTranslate ) );\r\n\tthis.add( this.helper[ \"rotate\" ] = setupGizmo( helperRotate ) );\r\n\tthis.add( this.helper[ \"scale\" ] = setupGizmo( helperScale ) );\r\n\r\n\t// Pickers should be hidden always\r\n\r\n\tthis.picker[ \"translate\" ].visible = false;\r\n\tthis.picker[ \"rotate\" ].visible = false;\r\n\tthis.picker[ \"scale\" ].visible = false;\r\n\r\n\t// updateMatrixWorld will update transformations and appearance of individual handles\r\n\r\n\tthis.updateMatrixWorld = function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar space = this.space;\r\n\r\n\t\tif ( this.mode === 'scale' ) { space = 'local'; } // scale always oriented to local rotation\r\n\r\n\t\tvar quaternion = space === \"local\" ? this.worldQuaternion : identityQuaternion;\r\n\r\n\t\t// Show only gizmos for current transform mode\r\n\r\n\t\tthis.gizmo[ \"translate\" ].visible = this.mode === \"translate\";\r\n\t\tthis.gizmo[ \"rotate\" ].visible = this.mode === \"rotate\";\r\n\t\tthis.gizmo[ \"scale\" ].visible = this.mode === \"scale\";\r\n\r\n\t\tthis.helper[ \"translate\" ].visible = this.mode === \"translate\";\r\n\t\tthis.helper[ \"rotate\" ].visible = this.mode === \"rotate\";\r\n\t\tthis.helper[ \"scale\" ].visible = this.mode === \"scale\";\r\n\r\n\t\tvar handles = [];\r\n\t\thandles = handles.concat( this.picker[ this.mode ].children );\r\n\t\thandles = handles.concat( this.gizmo[ this.mode ].children );\r\n\t\thandles = handles.concat( this.helper[ this.mode ].children );\r\n\r\n\t\tfor ( var i = 0; i < handles.length; i++ ) {\r\n\r\n\t\t\tvar handle = handles[i];\r\n\r\n\t\t\t// hide aligned to camera\r\n\r\n\t\t\thandle.visible = true;\r\n\t\t\thandle.rotation.set( 0, 0, 0 );\r\n\t\t\thandle.position.copy( this$1.worldPosition );\r\n\r\n\t\t\tvar eyeDistance = this$1.worldPosition.distanceTo( this$1.cameraPosition);\r\n\t\t\thandle.scale.set( 1, 1, 1 ).multiplyScalar( eyeDistance * this$1.size / 7 );\r\n\r\n\t\t\t// TODO: simplify helpers and consider decoupling from gizmo\r\n\r\n\t\t\tif ( handle.tag === 'helper' ) {\r\n\r\n\t\t\t\thandle.visible = false;\r\n\r\n\t\t\t\tif ( handle.name === 'AXIS' ) {\r\n\r\n\t\t\t\t\thandle.position.copy( this$1.worldPositionStart );\r\n\t\t\t\t\thandle.visible = !!this$1.axis;\r\n\r\n\t\t\t\t\tif ( this$1.axis === 'X' ) {\r\n\r\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, 0, 0 ) );\r\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( tempQuaternion );\r\n\r\n\t\t\t\t\t\tif ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > 0.9 ) {\r\n\t\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( this$1.axis === 'Y' ) {\r\n\r\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, 0, Math.PI / 2 ) );\r\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( tempQuaternion );\r\n\r\n\t\t\t\t\t\tif ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > 0.9 ) {\r\n\t\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( this$1.axis === 'Z' ) {\r\n\r\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, Math.PI / 2, 0 ) );\r\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( tempQuaternion );\r\n\r\n\t\t\t\t\t\tif ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > 0.9 ) {\r\n\t\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( this$1.axis === 'XYZE' ) {\r\n\r\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, Math.PI / 2, 0 ) );\r\n\t\t\t\t\t\talignVector.copy( this$1.rotationAxis );\r\n\t\t\t\t\t\thandle.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( zeroVector, alignVector, unitY ) );\r\n\t\t\t\t\t\thandle.quaternion.multiply( tempQuaternion );\r\n\t\t\t\t\t\thandle.visible = this$1.dragging;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( this$1.axis === 'E' ) {\r\n\r\n\t\t\t\t\t\thandle.visible = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( handle.name === 'START' ) {\r\n\r\n\t\t\t\t\thandle.position.copy( this$1.worldPositionStart );\r\n\t\t\t\t\thandle.visible = this$1.dragging;\r\n\r\n\t\t\t\t} else if ( handle.name === 'END' ) {\r\n\r\n\t\t\t\t\thandle.position.copy( this$1.worldPosition );\r\n\t\t\t\t\thandle.visible = this$1.dragging;\r\n\r\n\t\t\t\t} else if ( handle.name === 'DELTA' ) {\r\n\r\n\t\t\t\t\thandle.position.copy( this$1.worldPositionStart );\r\n\t\t\t\t\thandle.quaternion.copy( this$1.worldQuaternionStart );\r\n\t\t\t\t\ttempVector.set( 1e-10, 1e-10, 1e-10 ).add( this$1.worldPositionStart ).sub( this$1.worldPosition ).multiplyScalar( -1 );\r\n\t\t\t\t\ttempVector.applyQuaternion( this$1.worldQuaternionStart.clone().inverse() );\r\n\t\t\t\t\thandle.scale.copy( tempVector );\r\n\t\t\t\t\thandle.visible = this$1.dragging;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\thandle.quaternion.copy( quaternion );\r\n\r\n\t\t\t\t\tif ( this$1.dragging ) {\r\n\r\n\t\t\t\t\t\thandle.position.copy( this$1.worldPositionStart );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\thandle.position.copy( this$1.worldPosition );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( this$1.axis ) {\r\n\r\n\t\t\t\t\t\thandle.visible = this$1.axis.search( handle.name ) !== -1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If updating helper, skip rest of the loop\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Align handles to current local or world rotation\r\n\r\n\t\t\thandle.quaternion.copy( quaternion );\r\n\r\n\t\t\tif ( this$1.mode === 'translate' || this$1.mode === 'scale' ) {\r\n\r\n\t\t\t\t// Hide translate and scale axis facing the camera\r\n\r\n\t\t\t\tvar AXIS_HIDE_TRESHOLD = 0.99;\r\n\t\t\t\tvar PLANE_HIDE_TRESHOLD = 0.2;\r\n\t\t\t\tvar AXIS_FLIP_TRESHOLD = -0.4;\r\n\r\n\t\t\t\tif ( handle.name === 'X' || handle.name === 'XYZX' ) {\r\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > AXIS_HIDE_TRESHOLD ) {\r\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\r\n\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( handle.name === 'Y' || handle.name === 'XYZY' ) {\r\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > AXIS_HIDE_TRESHOLD ) {\r\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\r\n\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( handle.name === 'Z' || handle.name === 'XYZZ' ) {\r\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > AXIS_HIDE_TRESHOLD ) {\r\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\r\n\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( handle.name === 'XY' ) {\r\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this$1.eye ) ) < PLANE_HIDE_TRESHOLD ) {\r\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\r\n\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( handle.name === 'YZ' ) {\r\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this$1.eye ) ) < PLANE_HIDE_TRESHOLD ) {\r\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\r\n\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( handle.name === 'XZ' ) {\r\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this$1.eye ) ) < PLANE_HIDE_TRESHOLD ) {\r\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\r\n\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Flip translate and scale axis ocluded behind another axis\r\n\r\n\t\t\t\tif ( handle.name.search( 'X' ) !== -1 ) {\r\n\t\t\t\t\tif ( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this$1.eye ) < AXIS_FLIP_TRESHOLD ) {\r\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\r\n\t\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\thandle.scale.x *= -1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\r\n\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( handle.name.search( 'Y' ) !== -1 ) {\r\n\t\t\t\t\tif ( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this$1.eye ) < AXIS_FLIP_TRESHOLD ) {\r\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\r\n\t\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\thandle.scale.y *= -1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\r\n\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( handle.name.search( 'Z' ) !== -1 ) {\r\n\t\t\t\t\tif ( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this$1.eye ) < AXIS_FLIP_TRESHOLD ) {\r\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\r\n\t\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\thandle.scale.z *= -1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\r\n\t\t\t\t\t\thandle.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( this$1.mode === 'rotate' ) {\r\n\r\n\t\t\t\t// Align handles to current local or world rotation\r\n\r\n\t\t\t\ttempQuaternion2.copy( quaternion );\r\n\t\t\t\talignVector.copy( this$1.eye ).applyQuaternion( tempQuaternion.copy( quaternion ).inverse() );\r\n\r\n\t\t\t\tif ( handle.name.search( \"E\" ) !== - 1 ) {\r\n\r\n\t\t\t\t\thandle.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( this$1.eye, zeroVector, unitY ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( handle.name === 'X' ) {\r\n\r\n\t\t\t\t\ttempQuaternion.setFromAxisAngle( unitX, Math.atan2( -alignVector.y, alignVector.z ) );\r\n\t\t\t\t\ttempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );\r\n\t\t\t\t\thandle.quaternion.copy( tempQuaternion );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( handle.name === 'Y' ) {\r\n\r\n\t\t\t\t\ttempQuaternion.setFromAxisAngle( unitY, Math.atan2( alignVector.x, alignVector.z ) );\r\n\t\t\t\t\ttempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );\r\n\t\t\t\t\thandle.quaternion.copy( tempQuaternion );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( handle.name === 'Z' ) {\r\n\r\n\t\t\t\t\ttempQuaternion.setFromAxisAngle( unitZ, Math.atan2( alignVector.y, alignVector.x ) );\r\n\t\t\t\t\ttempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );\r\n\t\t\t\t\thandle.quaternion.copy( tempQuaternion );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Hide disabled axes\r\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( \"X\" ) === -1 || this$1.showX );\r\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( \"Y\" ) === -1 || this$1.showY );\r\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( \"Z\" ) === -1 || this$1.showZ );\r\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( \"E\" ) === -1 || ( this$1.showX && this$1.showY && this$1.showZ ) );\r\n\r\n\t\t\t// highlight selected axis\r\n\r\n\t\t\thandle.material._opacity = handle.material._opacity || handle.material.opacity;\r\n\t\t\thandle.material._color = handle.material._color || handle.material.color.clone();\r\n\r\n\t\t\thandle.material.color.copy( handle.material._color );\r\n\t\t\thandle.material.opacity = handle.material._opacity;\r\n\r\n\t\t\tif ( !this$1.enabled ) {\r\n\r\n\t\t\t\thandle.material.opacity *= 0.5;\r\n\t\t\t\thandle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );\r\n\r\n\t\t\t} else if ( this$1.axis ) {\r\n\r\n\t\t\t\tif ( handle.name === this$1.axis ) {\r\n\r\n\t\t\t\t\thandle.material.opacity = 1.0;\r\n\t\t\t\t\thandle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );\r\n\r\n\t\t\t\t} else if ( this$1.axis.split('').some( function( a ) { return handle.name === a; } ) ) {\r\n\r\n\t\t\t\t\thandle.material.opacity = 1.0;\r\n\t\t\t\t\thandle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\thandle.material.opacity *= 0.25;\r\n\t\t\t\t\thandle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tObject3D.prototype.updateMatrixWorld.call( this );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTransformControlsGizmo.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: TransformControlsGizmo,\r\n\r\n\tisTransformControlsGizmo: true\r\n\r\n} );\r\n\r\nvar TransformControlsPlane = function () {\r\n\r\n\tMesh.call( this,\r\n\t\tnew PlaneBufferGeometry( 100000, 100000, 2, 2 ),\r\n\t\tnew MeshBasicMaterial( { visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1 } )\r\n\t);\r\n\r\n\tthis.type = 'TransformControlsPlane';\r\n\r\n\tvar unitX = new Vector3( 1, 0, 0 );\r\n\tvar unitY = new Vector3( 0, 1, 0 );\r\n\tvar unitZ = new Vector3( 0, 0, 1 );\r\n\r\n\tvar tempVector = new Vector3();\r\n\tvar dirVector = new Vector3();\r\n\tvar alignVector = new Vector3();\r\n\tvar tempMatrix = new Matrix4();\r\n\tvar identityQuaternion = new Quaternion();\r\n\r\n\tthis.updateMatrixWorld = function() {\r\n\r\n\t\tvar space = this.space;\r\n\r\n\t\tthis.position.copy( this.worldPosition );\r\n\r\n\t\tif ( this.mode === 'scale' ) { space = 'local'; } // scale always oriented to local rotation\r\n\r\n\t\tunitX.set( 1, 0, 0 ).applyQuaternion( space === \"local\" ? this.worldQuaternion : identityQuaternion );\r\n\t\tunitY.set( 0, 1, 0 ).applyQuaternion( space === \"local\" ? this.worldQuaternion : identityQuaternion );\r\n\t\tunitZ.set( 0, 0, 1 ).applyQuaternion( space === \"local\" ? this.worldQuaternion : identityQuaternion );\r\n\r\n\t\t// Align the plane for current transform mode, axis and space.\r\n\r\n\t\talignVector.copy( unitY );\r\n\r\n\t\tswitch ( this.mode ) {\r\n\t\t\tcase 'translate':\r\n\t\t\tcase 'scale':\r\n\t\t\t\tswitch ( this.axis ) {\r\n\t\t\t\t\tcase 'X':\r\n\t\t\t\t\t\talignVector.copy( this.eye ).cross( unitX );\r\n\t\t\t\t\t\tdirVector.copy( unitX ).cross( alignVector );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'Y':\r\n\t\t\t\t\t\talignVector.copy( this.eye ).cross( unitY );\r\n\t\t\t\t\t\tdirVector.copy( unitY ).cross( alignVector );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'Z':\r\n\t\t\t\t\t\talignVector.copy( this.eye ).cross( unitZ );\r\n\t\t\t\t\t\tdirVector.copy( unitZ ).cross( alignVector );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'XY':\r\n\t\t\t\t\t\tdirVector.copy( unitZ );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'YZ':\r\n\t\t\t\t\t\tdirVector.copy( unitX );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'XZ':\r\n\t\t\t\t\t\talignVector.copy( unitZ );\r\n\t\t\t\t\t\tdirVector.copy( unitY );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'XYZ':\r\n\t\t\t\t\tcase 'E':\r\n\t\t\t\t\t\tdirVector.set( 0, 0, 0 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'rotate':\r\n\t\t\tdefault:\r\n\t\t\t\t// special case for rotate\r\n\t\t\t\tdirVector.set( 0, 0, 0 );\r\n\t\t}\r\n\r\n\t\tif ( dirVector.length() === 0 ) {\r\n\r\n\t\t\t// If in rotate mode, make the plane parallel to camera\r\n\t\t\tthis.quaternion.copy( this.cameraQuaternion );\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttempMatrix.lookAt( tempVector.set( 0, 0, 0 ), dirVector, alignVector );\r\n\r\n\t\t\tthis.quaternion.setFromRotationMatrix( tempMatrix );\r\n\r\n\t\t}\r\n\r\n\t\tObject3D.prototype.updateMatrixWorld.call( this );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTransformControlsPlane.prototype = Object.assign( Object.create( Mesh.prototype ), {\r\n\r\n\tconstructor: TransformControlsPlane,\r\n\r\n\tisTransformControlsPlane: true\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Line3( start, end ) {\r\n\r\n\tthis.start = ( start !== undefined ) ? start : new Vector3();\r\n\tthis.end = ( end !== undefined ) ? end : new Vector3();\r\n\r\n}\r\n\r\nObject.assign( Line3.prototype, {\r\n\r\n\tset: function ( start, end ) {\r\n\r\n\t\tthis.start.copy( start );\r\n\t\tthis.end.copy( end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( line ) {\r\n\r\n\t\tthis.start.copy( line.start );\r\n\t\tthis.end.copy( line.end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetCenter: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Line3: .getCenter() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tdelta: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Line3: .delta() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.subVectors( this.end, this.start );\r\n\r\n\t},\r\n\r\n\tdistanceSq: function () {\r\n\r\n\t\treturn this.start.distanceToSquared( this.end );\r\n\r\n\t},\r\n\r\n\tdistance: function () {\r\n\r\n\t\treturn this.start.distanceTo( this.end );\r\n\r\n\t},\r\n\r\n\tat: function ( t, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Line3: .at() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tclosestPointToPointParameter: function () {\r\n\r\n\t\tvar startP = new Vector3();\r\n\t\tvar startEnd = new Vector3();\r\n\r\n\t\treturn function closestPointToPointParameter( point, clampToLine ) {\r\n\r\n\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\r\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\r\n\t\t\tvar t = startEnd_startP / startEnd2;\r\n\r\n\t\t\tif ( clampToLine ) {\r\n\r\n\t\t\t\tt = _Math.clamp( t, 0, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn t;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, clampToLine, target ) {\r\n\r\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Line3: .closestPointToPoint() target is now required' );\r\n\t\t\ttarget = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.start.applyMatrix4( matrix );\r\n\t\tthis.end.applyMatrix4( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( line ) {\r\n\r\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\tvar Visible = 0;\r\n\tvar Deleted = 1;\r\n\r\n\tfunction QuickHull() {\r\n\r\n\t\tthis.tolerance = - 1;\r\n\r\n\t\tthis.faces = []; // the generated faces of the convex hull\r\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\r\n\r\n\t\t// the vertex lists work as follows:\r\n\t\t//\r\n\t\t// let 'a' and 'b' be 'Face' instances\r\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\r\n\t\t//\r\n\t\t//     [v, v, ..., v, v, v, ...]\r\n\t\t//      ^             ^\r\n\t\t//      |             |\r\n\t\t//  a.outside     b.outside\r\n\t\t//\r\n\t\tthis.assigned = new VertexList();\r\n\t\tthis.unassigned = new VertexList();\r\n\r\n\t\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\r\n\r\n\t}\r\n\r\n\tObject.assign( QuickHull.prototype, {\r\n\r\n\t\tsetFromPoints: function ( points ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tif ( Array.isArray( points ) !== true ) {\r\n\r\n\t\t\t\tconsole.error( 'QuickHull: Points parameter is not an array.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( points.length < 4 ) {\r\n\r\n\t\t\t\tconsole.error( 'QuickHull: The algorithm needs at least four points.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis$1.vertices.push( new VertexNode( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.compute();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromObject: function ( object ) {\r\n\r\n\t\t\tvar points = [];\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tobject.traverse( function ( node ) {\r\n\r\n\t\t\t\tvar i, l, point;\r\n\r\n\t\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\t\tif ( geometry.isGeometry ) {\r\n\r\n\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint = vertices[ i ].clone();\r\n\t\t\t\t\t\t\tpoint.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tpoints.push( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\t\tvar attribute = geometry.attributes.position;\r\n\r\n\t\t\t\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tpoint = new Vector3();\r\n\r\n\t\t\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\t\tpoints.push( point );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this.setFromPoints( points );\r\n\r\n\t\t},\r\n\r\n\t\tmakeEmpty: function () {\r\n\r\n\t\t\tthis.faces = [];\r\n\t\t\tthis.vertices = [];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\r\n\r\n\t\taddVertexToFace: function ( vertex, face ) {\r\n\r\n\t\t\tvertex.face = face;\r\n\r\n\t\t\tif ( face.outside === null ) {\r\n\r\n\t\t\t\tthis.assigned.append( vertex );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.assigned.insertBefore( face.outside, vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tface.outside = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes a vertex from the 'assigned' list of vertices and from the given face\r\n\r\n\t\tremoveVertexFromFace: function ( vertex, face ) {\r\n\r\n\t\t\tif ( vertex === face.outside ) {\r\n\r\n\t\t\t\t// fix face.outside link\r\n\r\n\t\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\r\n\r\n\t\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\r\n\r\n\t\t\t\t\tface.outside = vertex.next;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// vertex was the only outside vertex that face had\r\n\r\n\t\t\t\t\tface.outside = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.assigned.remove( vertex );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\r\n\r\n\t\tremoveAllVerticesFromFace: function ( face ) {\r\n\r\n\t\t\tif ( face.outside !== null ) {\r\n\r\n\t\t\t\t// reference to the first and last vertex of this face\r\n\r\n\t\t\t\tvar start = face.outside;\r\n\t\t\t\tvar end = face.outside;\r\n\r\n\t\t\t\twhile ( end.next !== null && end.next.face === face ) {\r\n\r\n\t\t\t\t\tend = end.next;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.assigned.removeSubList( start, end );\r\n\r\n\t\t\t\t// fix references\r\n\r\n\t\t\t\tstart.prev = end.next = null;\r\n\t\t\t\tface.outside = null;\r\n\r\n\t\t\t\treturn start;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// Removes all the visible vertices that 'face' is able to see\r\n\r\n\t\tdeleteFaceVertices: function ( face, absorbingFace ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar faceVertices = this.removeAllVerticesFromFace( face );\r\n\r\n\t\t\tif ( faceVertices !== undefined ) {\r\n\r\n\t\t\t\tif ( absorbingFace === undefined ) {\r\n\r\n\t\t\t\t\t// mark the vertices to be reassigned to some other face\r\n\r\n\t\t\t\t\tthis.unassigned.appendChain( faceVertices );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\r\n\r\n\t\t\t\t\tvar vertex = faceVertices;\r\n\r\n\t\t\t\t\tdo {\r\n\r\n\t\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\r\n\t\t\t\t\t\t// will be changed by upcoming method calls\r\n\r\n\t\t\t\t\t\tvar nextVertex = vertex.next;\r\n\r\n\t\t\t\t\t\tvar distance = absorbingFace.distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\r\n\r\n\t\t\t\t\t\tif ( distance > this$1.tolerance ) {\r\n\r\n\t\t\t\t\t\t\tthis$1.addVertexToFace( vertex, absorbingFace );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tthis$1.unassigned.append( vertex );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// now assign next vertex\r\n\r\n\t\t\t\t\t\tvertex = nextVertex;\r\n\r\n\t\t\t\t\t} while ( vertex !== null );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Reassigns as many vertices as possible from the unassigned list to the new faces\r\n\r\n\t\tresolveUnassignedPoints: function ( newFaces ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tif ( this.unassigned.isEmpty() === false ) {\r\n\r\n\t\t\t\tvar vertex = this.unassigned.first();\r\n\r\n\t\t\t\tdo {\r\n\r\n\t\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\r\n\r\n\t\t\t\t\tvar nextVertex = vertex.next;\r\n\r\n\t\t\t\t\tvar maxDistance = this$1.tolerance;\r\n\r\n\t\t\t\t\tvar maxFace = null;\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < newFaces.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar face = newFaces[ i ];\r\n\r\n\t\t\t\t\t\tif ( face.mark === Visible ) {\r\n\r\n\t\t\t\t\t\t\tvar distance = face.distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\t\tmaxFace = face;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( maxDistance > 1000 * this$1.tolerance ) { break; }\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\r\n\r\n\t\t\t\t\tif ( maxFace !== null ) {\r\n\r\n\t\t\t\t\t\tthis$1.addVertexToFace( vertex, maxFace );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvertex = nextVertex;\r\n\r\n\t\t\t\t} while ( vertex !== null );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Computes the extremes of a simplex which will be the initial hull\r\n\r\n\t\tcomputeExtremes: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar min = new Vector3();\r\n\t\t\tvar max = new Vector3();\r\n\r\n\t\t\tvar minVertices = [];\r\n\t\t\tvar maxVertices = [];\r\n\r\n\t\t\tvar i, l, j;\r\n\r\n\t\t\t// initially assume that the first vertex is the min/max\r\n\r\n\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tminVertices[ i ] = maxVertices[ i ] = this$1.vertices[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.copy( this.vertices[ 0 ].point );\r\n\t\t\tmax.copy( this.vertices[ 0 ].point );\r\n\r\n\t\t\t// compute the min/max vertex on all six directions\r\n\r\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar vertex = this$1.vertices[ i ];\r\n\t\t\t\tvar point = vertex.point;\r\n\r\n\t\t\t\t// update the min coordinates\r\n\r\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\r\n\r\n\t\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\r\n\t\t\t\t\t\tminVertices[ j ] = vertex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// update the max coordinates\r\n\r\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\r\n\r\n\t\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\r\n\t\t\t\t\t\tmaxVertices[ j ] = vertex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// use min/max vectors to compute an optimal epsilon\r\n\r\n\t\t\tthis.tolerance = 3 * Number.EPSILON * (\r\n\t\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\r\n\t\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\r\n\t\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\r\n\t\t\t);\r\n\r\n\t\t\treturn { min: minVertices, max: maxVertices };\r\n\r\n\t\t},\r\n\r\n\t\t// Computes the initial simplex assigning to its faces all the points\r\n\t\t// that are candidates to form part of the hull\r\n\r\n\t\tcomputeInitialHull: function () {\r\n\r\n\t\t\tvar line3, plane, closestPoint;\r\n\r\n\t\t\treturn function computeInitialHull() {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tif ( line3 === undefined ) {\r\n\r\n\t\t\t\t\tline3 = new Line3();\r\n\t\t\t\t\tplane = new Plane();\r\n\t\t\t\t\tclosestPoint = new Vector3();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar vertex, vertices = this.vertices;\r\n\t\t\t\tvar extremes = this.computeExtremes();\r\n\t\t\t\tvar min = extremes.min;\r\n\t\t\t\tvar max = extremes.max;\r\n\r\n\t\t\t\tvar v0, v1, v2, v3;\r\n\t\t\t\tvar i, l, j;\r\n\r\n\t\t\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\r\n\t\t\t\t// (max.x - min.x)\r\n\t\t\t\t// (max.y - min.y)\r\n\t\t\t\t// (max.z - min.z)\r\n\r\n\t\t\t\tvar distance, maxDistance = 0;\r\n\t\t\t\tvar index = 0;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tdistance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\r\n\r\n\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\tindex = i;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tv0 = min[ index ];\r\n\t\t\t\tv1 = max[ index ];\r\n\r\n\t\t\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\r\n\r\n\t\t\t\tmaxDistance = 0;\r\n\t\t\t\tline3.set( v0.point, v1.point );\r\n\r\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ i ];\r\n\r\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\r\n\r\n\t\t\t\t\t\tline3.closestPointToPoint( vertex.point, true, closestPoint );\r\n\r\n\t\t\t\t\t\tdistance = closestPoint.distanceToSquared( vertex.point );\r\n\r\n\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\tv2 = vertex;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\r\n\r\n\t\t\t\tmaxDistance = - 1;\r\n\t\t\t\tplane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\r\n\r\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ i ];\r\n\r\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\r\n\r\n\t\t\t\t\t\tdistance = Math.abs( plane.distanceToPoint( vertex.point ) );\r\n\r\n\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\tv3 = vertex;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar faces = [];\r\n\r\n\t\t\t\tif ( plane.distanceToPoint( v3.point ) < 0 ) {\r\n\r\n\t\t\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\r\n\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tFace.create( v0, v1, v2 ),\r\n\t\t\t\t\t\tFace.create( v3, v1, v0 ),\r\n\t\t\t\t\t\tFace.create( v3, v2, v1 ),\r\n\t\t\t\t\t\tFace.create( v3, v0, v2 )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// set the twin edge\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\r\n\r\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\r\n\r\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\r\n\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tFace.create( v0, v2, v1 ),\r\n\t\t\t\t\t\tFace.create( v3, v0, v1 ),\r\n\t\t\t\t\t\tFace.create( v3, v1, v2 ),\r\n\t\t\t\t\t\tFace.create( v3, v2, v0 )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// set the twin edge\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\r\n\r\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\r\n\r\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ]\r\n\r\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// the initial hull is the tetrahedron\r\n\r\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\tthis$1.faces.push( faces[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// initial assignment of vertices to the faces of the tetrahedron\r\n\r\n\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ i ];\r\n\r\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\r\n\r\n\t\t\t\t\t\tmaxDistance = this$1.tolerance;\r\n\t\t\t\t\t\tvar maxFace = null;\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tdistance = this$1.faces[ j ].distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\t\t\tmaxFace = this$1.faces[ j ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( maxFace !== null ) {\r\n\r\n\t\t\t\t\t\t\tthis$1.addVertexToFace( vertex, maxFace );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t};\r\n\r\n\t\t}(),\r\n\r\n\t\t// Removes inactive faces\r\n\r\n\t\treindexFaces: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar activeFaces = [];\r\n\r\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\t\tvar face = this$1.faces[ i ];\r\n\r\n\t\t\t\tif ( face.mark === Visible ) {\r\n\r\n\t\t\t\t\tactiveFaces.push( face );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.faces = activeFaces;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Finds the next vertex to create faces with the current hull\r\n\r\n\t\tnextVertexToAdd: function () {\r\n\r\n\t\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\r\n\r\n\t\t\tif ( this.assigned.isEmpty() === false ) {\r\n\r\n\t\t\t\tvar eyeVertex, maxDistance = 0;\r\n\r\n\t\t\t\t// grap the first available face and start with the first visible vertex of that face\r\n\r\n\t\t\t\tvar eyeFace = this.assigned.first().face;\r\n\t\t\t\tvar vertex = eyeFace.outside;\r\n\r\n\t\t\t\t// now calculate the farthest vertex that face can see\r\n\r\n\t\t\t\tdo {\r\n\r\n\t\t\t\t\tvar distance = eyeFace.distanceToPoint( vertex.point );\r\n\r\n\t\t\t\t\tif ( distance > maxDistance ) {\r\n\r\n\t\t\t\t\t\tmaxDistance = distance;\r\n\t\t\t\t\t\teyeVertex = vertex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvertex = vertex.next;\r\n\r\n\t\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\r\n\r\n\t\t\t\treturn eyeVertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// Computes a chain of half edges in CCW order called the 'horizon'.\r\n\t\t// For an edge to be part of the horizon it must join a face that can see\r\n\t\t// 'eyePoint' and a face that cannot see 'eyePoint'.\r\n\r\n\t\tcomputeHorizon: function ( eyePoint, crossEdge, face, horizon ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t// moves face's vertices to the 'unassigned' vertex list\r\n\r\n\t\t\tthis.deleteFaceVertices( face );\r\n\r\n\t\t\tface.mark = Deleted;\r\n\r\n\t\t\tvar edge;\r\n\r\n\t\t\tif ( crossEdge === null ) {\r\n\r\n\t\t\t\tedge = crossEdge = face.getEdge( 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// start from the next edge since 'crossEdge' was already analyzed\r\n\t\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\r\n\r\n\t\t\t\tedge = crossEdge.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvar twinEdge = edge.twin;\r\n\t\t\t\tvar oppositeFace = twinEdge.face;\r\n\r\n\t\t\t\tif ( oppositeFace.mark === Visible ) {\r\n\r\n\t\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this$1.tolerance ) {\r\n\r\n\t\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\r\n\r\n\t\t\t\t\t\tthis$1.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\r\n\r\n\t\t\t\t\t\thorizon.push( edge );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tedge = edge.next;\r\n\r\n\t\t\t} while ( edge !== crossEdge );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\r\n\r\n\t\taddAdjoiningFace: function ( eyeVertex, horizonEdge ) {\r\n\r\n\t\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\r\n\r\n\t\t\tvar face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\r\n\r\n\t\t\tthis.faces.push( face );\r\n\r\n\t\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\r\n\r\n\t\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\r\n\r\n\t\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\r\n\r\n\t\t},\r\n\r\n\t\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\r\n\t\t//  horizon opposite face and the face on the left/right\r\n\r\n\t\taddNewFaces: function ( eyeVertex, horizon ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tthis.newFaces = [];\r\n\r\n\t\t\tvar firstSideEdge = null;\r\n\t\t\tvar previousSideEdge = null;\r\n\r\n\t\t\tfor ( var i = 0; i < horizon.length; i ++ ) {\r\n\r\n\t\t\t\tvar horizonEdge = horizon[ i ];\r\n\r\n\t\t\t\t// returns the right side edge\r\n\r\n\t\t\t\tvar sideEdge = this$1.addAdjoiningFace( eyeVertex, horizonEdge );\r\n\r\n\t\t\t\tif ( firstSideEdge === null ) {\r\n\r\n\t\t\t\t\tfirstSideEdge = sideEdge;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\r\n\r\n\t\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis$1.newFaces.push( sideEdge.face );\r\n\t\t\t\tpreviousSideEdge = sideEdge;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// perform final join of new faces\r\n\r\n\t\t\tfirstSideEdge.next.setTwin( previousSideEdge );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Adds a vertex to the hull\r\n\r\n\t\taddVertexToHull: function ( eyeVertex ) {\r\n\r\n\t\t\tvar horizon = [];\r\n\r\n\t\t\tthis.unassigned.clear();\r\n\r\n\t\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\r\n\r\n\t\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\r\n\r\n\t\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\r\n\r\n\t\t\tthis.addNewFaces( eyeVertex, horizon );\r\n\r\n\t\t\t// reassign 'unassigned' vertices to the new faces\r\n\r\n\t\t\tthis.resolveUnassignedPoints( this.newFaces );\r\n\r\n\t\t\treturn\tthis;\r\n\r\n\t\t},\r\n\r\n\t\tcleanup: function () {\r\n\r\n\t\t\tthis.assigned.clear();\r\n\t\t\tthis.unassigned.clear();\r\n\t\t\tthis.newFaces = [];\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tcompute: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar vertex;\r\n\r\n\t\t\tthis.computeInitialHull();\r\n\r\n\t\t\t// add all available vertices gradually to the hull\r\n\r\n\t\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\r\n\r\n\t\t\t\tthis$1.addVertexToHull( vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.reindexFaces();\r\n\r\n\t\t\tthis.cleanup();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t//\r\n\r\n\tfunction Face() {\r\n\r\n\t\tthis.normal = new Vector3();\r\n\t\tthis.midpoint = new Vector3();\r\n\t\tthis.area = 0;\r\n\r\n\t\tthis.constant = 0; // signed distance from face to the origin\r\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\r\n\t\tthis.mark = Visible;\r\n\t\tthis.edge = null;\r\n\r\n\t}\r\n\r\n\tObject.assign( Face, {\r\n\r\n\t\tcreate: function ( a, b, c ) {\r\n\r\n\t\t\tvar face = new Face();\r\n\r\n\t\t\tvar e0 = new HalfEdge( a, face );\r\n\t\t\tvar e1 = new HalfEdge( b, face );\r\n\t\t\tvar e2 = new HalfEdge( c, face );\r\n\r\n\t\t\t// join edges\r\n\r\n\t\t\te0.next = e2.prev = e1;\r\n\t\t\te1.next = e0.prev = e2;\r\n\t\t\te2.next = e1.prev = e0;\r\n\r\n\t\t\t// main half edge reference\r\n\r\n\t\t\tface.edge = e0;\r\n\r\n\t\t\treturn face.compute();\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tObject.assign( Face.prototype, {\r\n\r\n\t\tgetEdge: function ( i ) {\r\n\r\n\t\t\tvar edge = this.edge;\r\n\r\n\t\t\twhile ( i > 0 ) {\r\n\r\n\t\t\t\tedge = edge.next;\r\n\t\t\t\ti --;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( i < 0 ) {\r\n\r\n\t\t\t\tedge = edge.prev;\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn edge;\r\n\r\n\t\t},\r\n\r\n\t\tcompute: function () {\r\n\r\n\t\t\tvar triangle;\r\n\r\n\t\t\treturn function compute() {\r\n\r\n\t\t\t\tif ( triangle === undefined ) { triangle = new Triangle(); }\r\n\r\n\t\t\t\tvar a = this.edge.tail();\r\n\t\t\t\tvar b = this.edge.head();\r\n\t\t\t\tvar c = this.edge.next.head();\r\n\r\n\t\t\t\ttriangle.set( a.point, b.point, c.point );\r\n\r\n\t\t\t\ttriangle.getNormal( this.normal );\r\n\t\t\t\ttriangle.getMidpoint( this.midpoint );\r\n\t\t\t\tthis.area = triangle.getArea();\r\n\r\n\t\t\t\tthis.constant = this.normal.dot( this.midpoint );\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t};\r\n\r\n\t\t}(),\r\n\r\n\t\tdistanceToPoint: function ( point ) {\r\n\r\n\t\t\treturn this.normal.dot( point ) - this.constant;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t// Entity for a Doubly-Connected Edge List (DCEL).\r\n\r\n\tfunction HalfEdge( vertex, face ) {\r\n\r\n\t\tthis.vertex = vertex;\r\n\t\tthis.prev = null;\r\n\t\tthis.next = null;\r\n\t\tthis.twin = null;\r\n\t\tthis.face = face;\r\n\r\n\t}\r\n\r\n\tObject.assign( HalfEdge.prototype, {\r\n\r\n\t\thead: function () {\r\n\r\n\t\t\treturn this.vertex;\r\n\r\n\t\t},\r\n\r\n\t\ttail: function () {\r\n\r\n\t\t\treturn this.prev ? this.prev.vertex : null;\r\n\r\n\t\t},\r\n\r\n\t\tlength: function () {\r\n\r\n\t\t\tvar head = this.head();\r\n\t\t\tvar tail = this.tail();\r\n\r\n\t\t\tif ( tail !== null ) {\r\n\r\n\t\t\t\treturn tail.point.distanceTo( head.point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn - 1;\r\n\r\n\t\t},\r\n\r\n\t\tlengthSquared: function () {\r\n\r\n\t\t\tvar head = this.head();\r\n\t\t\tvar tail = this.tail();\r\n\r\n\t\t\tif ( tail !== null ) {\r\n\r\n\t\t\t\treturn tail.point.distanceToSquared( head.point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn - 1;\r\n\r\n\t\t},\r\n\r\n\t\tsetTwin: function ( edge ) {\r\n\r\n\t\t\tthis.twin = edge;\r\n\t\t\tedge.twin = this;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t// A vertex as a double linked list node.\r\n\r\n\tfunction VertexNode( point ) {\r\n\r\n\t\tthis.point = point;\r\n\t\tthis.prev = null;\r\n\t\tthis.next = null;\r\n\t\tthis.face = null; // the face that is able to see this vertex\r\n\r\n\t}\r\n\r\n\t// A double linked list that contains vertex nodes.\r\n\r\n\tfunction VertexList() {\r\n\r\n\t\tthis.head = null;\r\n\t\tthis.tail = null;\r\n\r\n\t}\r\n\r\n\tObject.assign( VertexList.prototype, {\r\n\r\n\t\tfirst: function () {\r\n\r\n\t\t\treturn this.head;\r\n\r\n\t\t},\r\n\r\n\t\tlast: function () {\r\n\r\n\t\t\treturn this.tail;\r\n\r\n\t\t},\r\n\r\n\t\tclear: function () {\r\n\r\n\t\t\tthis.head = this.tail = null;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Inserts a vertex before the target vertex\r\n\r\n\t\tinsertBefore: function ( target, vertex ) {\r\n\r\n\t\t\tvertex.prev = target.prev;\r\n\t\t\tvertex.next = target;\r\n\r\n\t\t\tif ( vertex.prev === null ) {\r\n\r\n\t\t\t\tthis.head = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.prev.next = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.prev = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Inserts a vertex after the target vertex\r\n\r\n\t\tinsertAfter: function ( target, vertex ) {\r\n\r\n\t\t\tvertex.prev = target;\r\n\t\t\tvertex.next = target.next;\r\n\r\n\t\t\tif ( vertex.next === null ) {\r\n\r\n\t\t\t\tthis.tail = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.next.prev = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttarget.next = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Appends a vertex to the end of the linked list\r\n\r\n\t\tappend: function ( vertex ) {\r\n\r\n\t\t\tif ( this.head === null ) {\r\n\r\n\t\t\t\tthis.head = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.tail.next = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertex.prev = this.tail;\r\n\t\t\tvertex.next = null; // the tail has no subsequent vertex\r\n\r\n\t\t\tthis.tail = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Appends a chain of vertices where 'vertex' is the head.\r\n\r\n\t\tappendChain: function ( vertex ) {\r\n\r\n\t\t\tif ( this.head === null ) {\r\n\r\n\t\t\t\tthis.head = vertex;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.tail.next = vertex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertex.prev = this.tail;\r\n\r\n\t\t\t// ensure that the 'tail' reference points to the last vertex of the chain\r\n\r\n\t\t\twhile ( vertex.next !== null ) {\r\n\r\n\t\t\t\tvertex = vertex.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.tail = vertex;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes a vertex from the linked list\r\n\r\n\t\tremove: function ( vertex ) {\r\n\r\n\t\t\tif ( vertex.prev === null ) {\r\n\r\n\t\t\t\tthis.head = vertex.next;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.prev.next = vertex.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( vertex.next === null ) {\r\n\r\n\t\t\t\tthis.tail = vertex.prev;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertex.next.prev = vertex.prev;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\r\n\r\n\t\tremoveSubList: function ( a, b ) {\r\n\r\n\t\t\tif ( a.prev === null ) {\r\n\r\n\t\t\t\tthis.head = b.next;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ta.prev.next = b.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( b.next === null ) {\r\n\r\n\t\t\t\tthis.tail = a.prev;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tb.next.prev = a.prev;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tisEmpty: function () {\r\n\r\n\t\t\treturn this.head === null;\r\n\r\n\t\t}\r\n\r\n\t} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t// ConvexGeometry\r\n\r\n\tfunction ConvexGeometry( points ) {\r\n\r\n\t\tGeometry.call( this );\r\n\r\n\t\tthis.fromBufferGeometry( new ConvexBufferGeometry( points ) );\r\n\t\tthis.mergeVertices();\r\n\r\n\t}\r\n\r\n\tConvexGeometry.prototype = Object.create( Geometry.prototype );\r\n\tConvexGeometry.prototype.constructor = ConvexGeometry;\r\n\r\n\t// ConvexBufferGeometry\r\n\r\n\tfunction ConvexBufferGeometry( points ) {\r\n\r\n\t\tBufferGeometry.call( this );\r\n\r\n\t\t// buffers\r\n\r\n\t\tvar vertices = [];\r\n\t\tvar normals = [];\r\n\r\n\t\t// execute QuickHull\r\n\r\n\t\tif ( QuickHull === undefined ) {\r\n\r\n\t\t\tconsole.error( 'ConvexBufferGeometry: ConvexBufferGeometry relies on QuickHull' );\r\n\r\n\t\t}\r\n\r\n\t\tvar quickHull = new QuickHull().setFromPoints( points );\r\n\r\n\t\t// generate vertices and normals\r\n\r\n\t\tvar faces = quickHull.faces;\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\t\t\tvar edge = face.edge;\r\n\r\n\t\t\t// we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvar point = edge.head().point;\r\n\r\n\t\t\t\tvertices.push( point.x, point.y, point.z );\r\n\t\t\t\tnormals.push( face.normal.x, face.normal.y, face.normal.z );\r\n\r\n\t\t\t\tedge = edge.next;\r\n\r\n\t\t\t} while ( edge !== face.edge );\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t}\r\n\r\n\tConvexBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\n\tConvexBufferGeometry.prototype.constructor = ConvexBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ConvexObjectBreaker = function ( minSizeForBreak, smallDelta ) {\n\tvar this$1 = this;\n\r\n\r\n\tthis.minSizeForBreak = minSizeForBreak || 1.4;\r\n\tthis.smallDelta = smallDelta || 0.0001;\r\n\r\n\tthis.tempLine1 = new Line3();\r\n\tthis.tempPlane1 = new Plane();\r\n\tthis.tempPlane2 = new Plane();\r\n\tthis.tempPlane_Cut = new Plane();\r\n\tthis.tempCM1 = new Vector3();\r\n\tthis.tempCM2 = new Vector3();\r\n\tthis.tempVector3 = new Vector3();\r\n\tthis.tempVector3_2 = new Vector3();\r\n\tthis.tempVector3_3 = new Vector3();\r\n\tthis.tempVector3_P0 = new Vector3();\r\n\tthis.tempVector3_P1 = new Vector3();\r\n\tthis.tempVector3_P2 = new Vector3();\r\n\tthis.tempVector3_N0 = new Vector3();\r\n\tthis.tempVector3_N1 = new Vector3();\r\n\tthis.tempVector3_AB = new Vector3();\r\n\tthis.tempVector3_CB = new Vector3();\r\n\tthis.tempResultObjects = { object1: null, object2: null };\r\n\r\n\tthis.segments = [];\r\n\tvar n = 30 * 30;\r\n\tfor ( var i = 0; i < n; i ++ ) { this$1.segments[ i ] = false; }\r\n\r\n};\r\n\r\nConvexObjectBreaker.prototype = {\r\n\r\n\tconstructor: ConvexObjectBreaker,\r\n\r\n\tprepareBreakableObject: function ( object, mass, velocity, angularVelocity, breakable ) {\r\n\r\n\t\t// object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\r\n\t\t// Its material property is propagated to its children (sub-pieces)\r\n\t\t// mass must be > 0\r\n\r\n\t\tif ( ! object.geometry.isBufferGeometry ) {\r\n\r\n\t\t\tconsole.error( 'ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar userData = object.userData;\r\n\t\tuserData.mass = mass;\r\n\t\tuserData.velocity = velocity.clone();\r\n\t\tuserData.angularVelocity = angularVelocity.clone();\r\n\t\tuserData.breakable = breakable;\r\n\r\n\t},\r\n\t\r\n\tsubdivideByImpact: function ( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {\r\n\r\n\t\tvar debris = [];\r\n\r\n\t\tvar tempPlane1 = this.tempPlane1;\r\n\t\tvar tempPlane2 = this.tempPlane2;\r\n\r\n\t\tthis.tempVector3.addVectors( pointOfImpact, normal );\r\n\t\ttempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );\r\n\r\n\t\tvar maxTotalIterations = maxRandomIterations + maxRadialIterations;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tfunction subdivideRadial( subObject, startAngle, endAngle, numIterations ) {\r\n\r\n\t\t\tif ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {\r\n\r\n\t\t\t\tdebris.push( subObject );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar angle = Math.PI;\r\n\r\n\t\t\tif ( numIterations === 0 ) {\r\n\r\n\t\t\t\ttempPlane2.normal.copy( tempPlane1.normal );\r\n\t\t\t\ttempPlane2.constant = tempPlane1.constant;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( numIterations <= maxRadialIterations ) {\r\n\r\n\t\t\t\t\tangle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;\r\n\r\n\t\t\t\t\t// Rotate tempPlane2 at impact point around normal axis and the angle\r\n\t\t\t\t\tscope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );\r\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tangle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;\r\n\r\n\t\t\t\t\t// Rotate tempPlane2 at object position around normal axis and the angle\r\n\t\t\t\t\tscope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );\r\n\t\t\t\t\tscope.tempVector3_3.copy( normal ).add( subObject.position );\r\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Perform the cut\r\n\t\t\tscope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );\r\n\r\n\t\t\tvar obj1 = scope.tempResultObjects.object1;\r\n\t\t\tvar obj2 = scope.tempResultObjects.object2;\r\n\r\n\t\t\tif ( obj1 ) {\r\n\r\n\t\t\t\tsubdivideRadial( obj1, startAngle, angle, numIterations + 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( obj2 ) {\r\n\r\n\t\t\t\tsubdivideRadial( obj2, angle, endAngle, numIterations + 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsubdivideRadial( object, 0, 2 * Math.PI, 0 );\r\n\r\n\t\treturn debris;\r\n\r\n\t},\r\n\r\n\tcutByPlane: function ( object, plane, output ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\t// Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\r\n\t\t// object2 can be null if the plane doesn't cut the object.\r\n\t\t// object1 can be null only in case of internal error\r\n\t\t// Returned value is number of pieces, 0 for error.\r\n\r\n\t\tvar geometry = object.geometry;\r\n\t\tvar coords = geometry.attributes.position.array;\r\n\t\tvar normals = geometry.attributes.normal.array;\r\n\r\n\t\tvar numPoints = coords.length / 3;\r\n\t\tvar numFaces = numPoints / 3;\r\n\r\n\t\tvar indices = geometry.getIndex();\r\n\r\n\t\tif ( indices ) {\r\n\r\n\t\t\tindices = indices.array;\r\n\t\t\tnumFaces = indices.length / 3;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getVertexIndex( faceIdx, vert ) {\r\n\r\n\t\t\t// vert = 0, 1 or 2.\r\n\r\n\t\t\tvar idx = faceIdx * 3 + vert;\r\n\r\n\t\t\treturn indices ? indices[ idx ] : idx;\r\n\r\n\t\t}\r\n\r\n\t\tvar points1 = [];\r\n\t\tvar points2 = [];\r\n\r\n\t\tvar delta = this.smallDelta;\r\n\r\n\t\t// Reset segments mark\r\n\t\tvar numPointPairs = numPoints * numPoints;\r\n\t\tfor ( var i = 0; i < numPointPairs; i ++ ) { this$1.segments[ i ] = false; }\r\n\r\n\t\tvar p0 = this.tempVector3_P0;\r\n\t\tvar p1 = this.tempVector3_P1;\r\n\t\tvar n0 = this.tempVector3_N0;\r\n\t\tvar n1 = this.tempVector3_N1;\r\n\r\n\t\t// Iterate through the faces to mark edges shared by coplanar faces\r\n\t\tfor ( var i = 0; i < numFaces - 1; i ++ ) {\r\n\r\n\t\t\tvar a1 = getVertexIndex( i, 0 );\r\n\t\t\tvar b1 = getVertexIndex( i, 1 );\r\n\t\t\tvar c1 = getVertexIndex( i, 2 );\r\n\r\n\t\t\t// Assuming all 3 vertices have the same normal\r\n\t\t\tn0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );\r\n\r\n\t\t\tfor ( var j = i + 1; j < numFaces; j ++ ) {\r\n\r\n\t\t\t\tvar a2 = getVertexIndex( j, 0 );\r\n\t\t\t\tvar b2 = getVertexIndex( j, 1 );\r\n\t\t\t\tvar c2 = getVertexIndex( j, 2 );\r\n\r\n\t\t\t\t// Assuming all 3 vertices have the same normal\r\n\t\t\t\tn1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );\r\n\r\n\t\t\t\tvar coplanar = 1 - n0.dot( n1 ) < delta;\r\n\r\n\t\t\t\tif ( coplanar ) {\r\n\r\n\t\t\t\t\tif ( a1 === a2 || a1 === b2 || a1 === c2 ) {\r\n\r\n\t\t\t\t\t\tif ( b1 === a2 || b1 === b2 || b1 === c2 ) {\r\n\r\n\t\t\t\t\t\t\tthis$1.segments[ a1 * numPoints + b1 ] = true;\r\n\t\t\t\t\t\t\tthis$1.segments[ b1 * numPoints + a1 ] = true;\r\n\r\n\t\t\t\t\t\t}\telse {\r\n\r\n\t\t\t\t\t\t\tthis$1.segments[ c1 * numPoints + a1 ] = true;\r\n\t\t\t\t\t\t\tthis$1.segments[ a1 * numPoints + c1 ] = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\telse if ( b1 === a2 || b1 === b2 || b1 === c2 ) {\r\n\r\n\t\t\t\t\t\tthis$1.segments[ c1 * numPoints + b1 ] = true;\r\n\t\t\t\t\t\tthis$1.segments[ b1 * numPoints + c1 ] = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Transform the plane to object local space\r\n\t\tvar localPlane = this.tempPlane_Cut;\r\n\t\tobject.updateMatrix();\r\n\t\tConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );\r\n\r\n\t\t// Iterate through the faces adding points to both pieces\r\n\t\tfor ( var i = 0; i < numFaces; i ++ ) {\r\n\r\n\t\t\tvar va = getVertexIndex( i, 0 );\r\n\t\t\tvar vb = getVertexIndex( i, 1 );\r\n\t\t\tvar vc = getVertexIndex( i, 2 );\r\n\r\n\t\t\tfor ( var segment = 0; segment < 3; segment ++ ) {\r\n\r\n\t\t\t\tvar i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );\r\n\t\t\t\tvar i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );\r\n\r\n\t\t\t\tvar segmentState = this$1.segments[ i0 * numPoints + i1 ];\r\n\r\n\t\t\t\tif ( segmentState ) { continue; } // The segment already has been processed in another face\r\n\r\n\t\t\t\t// Mark segment as processed (also inverted segment)\r\n\t\t\t\tthis$1.segments[ i0 * numPoints + i1 ] = true;\r\n\t\t\t\tthis$1.segments[ i1 * numPoints + i0 ] = true;\r\n\r\n\t\t\t\tp0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );\r\n\t\t\t\tp1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );\r\n\r\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\r\n\t\t\t\tvar mark0 = 0;\r\n\r\n\t\t\t\tvar d = localPlane.distanceToPoint( p0 );\r\n\r\n\t\t\t\tif ( d > delta ) {\r\n\r\n\t\t\t\t\tmark0 = 2;\r\n\t\t\t\t\tpoints2.push( p0.clone() );\r\n\r\n\t\t\t\t} else if ( d < - delta ) {\r\n\r\n\t\t\t\t\tmark0 = 1;\r\n\t\t\t\t\tpoints1.push( p0.clone() );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmark0 = 3;\r\n\t\t\t\t\tpoints1.push( p0.clone() );\r\n\t\t\t\t\tpoints2.push( p0.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\r\n\t\t\t\tvar mark1 = 0;\r\n\r\n\t\t\t\tvar d = localPlane.distanceToPoint( p1 );\r\n\r\n\t\t\t\tif ( d > delta ) {\r\n\r\n\t\t\t\t\tmark1 = 2;\r\n\t\t\t\t\tpoints2.push( p1.clone() );\r\n\r\n\t\t\t\t} else if ( d < - delta ) {\r\n\r\n\t\t\t\t\tmark1 = 1;\r\n\t\t\t\t\tpoints1.push( p1.clone() );\r\n\r\n\t\t\t\t}\telse {\r\n\r\n\t\t\t\t\tmark1 = 3;\r\n\t\t\t\t\tpoints1.push( p1.clone() );\r\n\t\t\t\t\tpoints2.push( p1.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {\r\n\r\n\t\t\t\t\t// Intersection of segment with the plane\r\n\r\n\t\t\t\t\tthis$1.tempLine1.start.copy( p0 );\r\n\t\t\t\t\tthis$1.tempLine1.end.copy( p1 );\r\n\r\n\t\t\t\t\tvar intersection = new Vector3();\r\n\t\t\t\t\tintersection = localPlane.intersectLine( this$1.tempLine1, intersection );\r\n\r\n\t\t\t\t\tif ( intersection === undefined ) {\r\n\r\n\t\t\t\t\t\t// Shouldn't happen\r\n\t\t\t\t\t\tconsole.error( \"Internal error: segment does not intersect plane.\" );\r\n\t\t\t\t\t\toutput.segmentedObject1 = null;\r\n\t\t\t\t\t\toutput.segmentedObject2 = null;\r\n\t\t\t\t\t\treturn 0;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpoints1.push( intersection );\r\n\t\t\t\t\tpoints2.push( intersection.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Calculate debris mass (very fast and imprecise):\r\n\t\tvar newMass = object.userData.mass * 0.5;\r\n\r\n\t\t// Calculate debris Center of Mass (again fast and imprecise)\r\n\t\tthis.tempCM1.set( 0, 0, 0 );\r\n\t\tvar radius1 = 0;\r\n\t\tvar numPoints1 = points1.length;\r\n\r\n\t\tif ( numPoints1 > 0 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < numPoints1; i ++ ) { this$1.tempCM1.add( points1[ i ] ); }\r\n\r\n\t\t\tthis.tempCM1.divideScalar( numPoints1 );\r\n\t\t\tfor ( var i = 0; i < numPoints1; i ++ ) {\r\n\r\n\t\t\t\tvar p = points1[ i ];\r\n\t\t\t\tp.sub( this$1.tempCM1 );\r\n\t\t\t\tradius1 = Math.max( radius1, p.x, p.y, p.z );\r\n\r\n\t\t\t}\r\n\t\t\tthis.tempCM1.add( object.position );\r\n\r\n\t\t}\r\n\r\n\t\tthis.tempCM2.set( 0, 0, 0 );\r\n\t\tvar radius2 = 0;\r\n\t\tvar numPoints2 = points2.length;\r\n\t\tif ( numPoints2 > 0 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < numPoints2; i ++ ) { this$1.tempCM2.add( points2[ i ] ); }\r\n\r\n\t\t\tthis.tempCM2.divideScalar( numPoints2 );\r\n\t\t\tfor ( var i = 0; i < numPoints2; i ++ ) {\r\n\r\n\t\t\t\tvar p = points2[ i ];\r\n\t\t\t\tp.sub( this$1.tempCM2 );\r\n\t\t\t\tradius2 = Math.max( radius2, p.x, p.y, p.z );\r\n\r\n\t\t\t}\r\n\t\t\tthis.tempCM2.add( object.position );\r\n\r\n\t\t}\r\n\r\n\t\tvar object1 = null;\r\n\t\tvar object2 = null;\r\n\r\n\t\tvar numObjects = 0;\r\n\r\n\t\tif ( numPoints1 > 4 ) {\r\n\r\n\t\t\tobject1 = new Mesh( new ConvexBufferGeometry( points1 ), object.material );\r\n\t\t\tobject1.position.copy( this.tempCM1 );\r\n\t\t\tobject1.quaternion.copy( object.quaternion );\r\n\r\n\t\t\tthis.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );\r\n\r\n\t\t\tnumObjects ++;\r\n\r\n\t\t}\r\n\r\n\t\tif ( numPoints2 > 4 ) {\r\n\r\n\t\t\tobject2 = new Mesh( new ConvexBufferGeometry( points2 ), object.material );\r\n\t\t\tobject2.position.copy( this.tempCM2 );\r\n\t\t\tobject2.quaternion.copy( object.quaternion );\r\n\r\n\t\t\tthis.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );\r\n\r\n\t\t\tnumObjects ++;\r\n\r\n\t\t}\r\n\r\n\t\toutput.object1 = object1;\r\n\t\toutput.object2 = object2;\r\n\r\n\t\treturn numObjects;\r\n\r\n\t}\r\n\r\n};\r\n\r\nConvexObjectBreaker.transformFreeVector = function ( v, m ) {\r\n\r\n\t// input:\r\n\t// vector interpreted as a free vector\r\n\t// Matrix4 orthogonal matrix (matrix without scale)\r\n\r\n\tvar x = v.x, y = v.y, z = v.z;\r\n\tvar e = m.elements;\r\n\r\n\tv.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\r\n\tv.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\r\n\tv.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\treturn v;\r\n\r\n};\r\n\r\nConvexObjectBreaker.transformFreeVectorInverse = function ( v, m ) {\r\n\r\n\t// input:\r\n\t// vector interpreted as a free vector\r\n\t// Matrix4 orthogonal matrix (matrix without scale)\r\n\r\n\tvar x = v.x, y = v.y, z = v.z;\r\n\tvar e = m.elements;\r\n\r\n\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;\r\n\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;\r\n\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;\r\n\r\n\treturn v;\r\n\r\n};\r\n\r\nConvexObjectBreaker.transformTiedVectorInverse = function ( v, m ) {\r\n\r\n\t// input:\r\n\t// vector interpreted as a tied (ordinary) vector\r\n\t// Matrix4 orthogonal matrix (matrix without scale)\r\n\r\n\tvar x = v.x, y = v.y, z = v.z;\r\n\tvar e = m.elements;\r\n\r\n\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];\r\n\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];\r\n\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];\r\n\r\n\treturn v;\r\n\r\n};\r\n\r\nConvexObjectBreaker.transformPlaneToLocalSpace = function () {\r\n\r\n\tvar v1 = new Vector3();\r\n\r\n\treturn function transformPlaneToLocalSpace( plane, m, resultPlane ) {\r\n\r\n\t\tresultPlane.normal.copy( plane.normal );\r\n\t\tresultPlane.constant = plane.constant;\r\n\r\n\t\tvar referencePoint = ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( v1 ), m );\r\n\r\n\t\tConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );\r\n\r\n\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\r\n\t\tresultPlane.constant = - referencePoint.dot( resultPlane.normal );\r\n\r\n\t};\r\n\r\n}();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Curve() {\r\n\r\n\tthis.type = 'Curve';\r\n\r\n\tthis.arcLengthDivisions = 200;\r\n\r\n}\r\n\r\nObject.assign( Curve.prototype, {\r\n\r\n\t// Virtual base class method to overwrite and implement in subclasses\r\n\t//\t- t [0 .. 1]\r\n\r\n\tgetPoint: function (  ) {\r\n\r\n\t\tconsole.warn( 'Curve: .getPoint() not implemented.' );\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\t// Get point at relative position in curve according to arc length\r\n\t// - u [0 .. 1]\r\n\r\n\tgetPointAt: function ( u, optionalTarget ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getPoint( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPoint( t )\r\n\r\n\tgetPoints: function ( divisions ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( divisions === undefined ) { divisions = 5; }\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpoints.push( this$1.getPoint( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPointAt( u )\r\n\r\n\tgetSpacedPoints: function ( divisions ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( divisions === undefined ) { divisions = 5; }\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpoints.push( this$1.getPointAt( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\t// Get total curve arc length\r\n\r\n\tgetLength: function () {\r\n\r\n\t\tvar lengths = this.getLengths();\r\n\t\treturn lengths[ lengths.length - 1 ];\r\n\r\n\t},\r\n\r\n\t// Get list of cumulative segment lengths\r\n\r\n\tgetLengths: function ( divisions ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( divisions === undefined ) { divisions = this.arcLengthDivisions; }\r\n\r\n\t\tif ( this.cacheArcLengths &&\r\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\r\n\t\t\t! this.needsUpdate ) {\r\n\r\n\t\t\treturn this.cacheArcLengths;\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t\tvar cache = [];\r\n\t\tvar current, last = this.getPoint( 0 );\r\n\t\tvar p, sum = 0;\r\n\r\n\t\tcache.push( 0 );\r\n\r\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\t\tcurrent = this$1.getPoint( p / divisions );\r\n\t\t\tsum += current.distanceTo( last );\r\n\t\t\tcache.push( sum );\r\n\t\t\tlast = current;\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheArcLengths = cache;\r\n\r\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\r\n\r\n\t},\r\n\r\n\tupdateArcLengths: function () {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.getLengths();\r\n\r\n\t},\r\n\r\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n\tgetUtoTmapping: function ( u, distance ) {\r\n\r\n\t\tvar arcLengths = this.getLengths();\r\n\r\n\t\tvar i = 0, il = arcLengths.length;\r\n\r\n\t\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\t\tif ( distance ) {\r\n\r\n\t\t\ttargetArcLength = distance;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t\t}\r\n\r\n\t\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\t\tvar low = 0, high = il - 1, comparison;\r\n\r\n\t\twhile ( low <= high ) {\r\n\r\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\t\tlow = i + 1;\r\n\r\n\t\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\t\thigh = i - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thigh = i;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// DONE\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ti = high;\r\n\r\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\r\n\r\n\t\t\treturn i / ( il - 1 );\r\n\r\n\t\t}\r\n\r\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\r\n\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\r\n\t\t// determine where we are between the 'before' and 'after' points\r\n\r\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n\t\t// add that fractional amount to t\r\n\r\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n\t\treturn t;\r\n\r\n\t},\r\n\r\n\t// Returns a unit vector tangent at t\r\n\t// In case any sub curve does not implement its tangent derivation,\r\n\t// 2 points a small delta apart will be used to find its gradient\r\n\t// which seems to give a reasonable approximation\r\n\r\n\tgetTangent: function ( t ) {\r\n\r\n\t\tvar delta = 0.0001;\r\n\t\tvar t1 = t - delta;\r\n\t\tvar t2 = t + delta;\r\n\r\n\t\t// Capping in case of danger\r\n\r\n\t\tif ( t1 < 0 ) { t1 = 0; }\r\n\t\tif ( t2 > 1 ) { t2 = 1; }\r\n\r\n\t\tvar pt1 = this.getPoint( t1 );\r\n\t\tvar pt2 = this.getPoint( t2 );\r\n\r\n\t\tvar vec = pt2.clone().sub( pt1 );\r\n\t\treturn vec.normalize();\r\n\r\n\t},\r\n\r\n\tgetTangentAt: function ( u ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getTangent( t );\r\n\r\n\t},\r\n\r\n\tcomputeFrenetFrames: function ( segments, closed ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n\r\n\t\tvar normal = new Vector3();\r\n\r\n\t\tvar tangents = [];\r\n\t\tvar normals = [];\r\n\t\tvar binormals = [];\r\n\r\n\t\tvar vec = new Vector3();\r\n\t\tvar mat = new Matrix4();\r\n\r\n\t\tvar i, u, theta;\r\n\r\n\t\t// compute the tangent vectors for each segment on the curve\r\n\r\n\t\tfor ( i = 0; i <= segments; i ++ ) {\r\n\r\n\t\t\tu = i / segments;\r\n\r\n\t\t\ttangents[ i ] = this$1.getTangentAt( u );\r\n\t\t\ttangents[ i ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\r\n\t\t// and in the direction of the minimum tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new Vector3();\r\n\t\tbinormals[ 0 ] = new Vector3();\r\n\t\tvar min = Number.MAX_VALUE;\r\n\t\tvar tx = Math.abs( tangents[ 0 ].x );\r\n\t\tvar ty = Math.abs( tangents[ 0 ].y );\r\n\t\tvar tz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= min ) {\r\n\r\n\t\t\tmin = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ty <= min ) {\r\n\r\n\t\t\tmin = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tz <= min ) {\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\r\n\r\n\t\tfor ( i = 1; i <= segments; i ++ ) {\r\n\r\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\r\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n\t\t\tif ( vec.length() > Number.EPSILON ) {\r\n\r\n\t\t\t\tvec.normalize();\r\n\r\n\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\t\tif ( closed === true ) {\r\n\r\n\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\r\n\t\t\ttheta /= segments;\r\n\r\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\r\n\r\n\t\t\t\ttheta = - theta;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\r\n\r\n\t\t\t\t// twist a little...\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttangents: tangents,\r\n\t\t\tnormals: normals,\r\n\t\t\tbinormals: binormals\r\n\t\t};\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Curve',\r\n\t\t\t\tgenerator: 'Curve.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\r\n\t\tdata.type = this.type;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\r\n\r\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t// GrannyKnot\r\n\r\n\tfunction GrannyKnot() {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t}\r\n\r\n\tGrannyKnot.prototype = Object.create( Curve.prototype );\r\n\tGrannyKnot.prototype.constructor = GrannyKnot;\r\n\r\n\tGrannyKnot.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tt = 2 * Math.PI * t;\r\n\r\n\t\tvar x = - 0.22 * Math.cos( t ) - 1.28 * Math.sin( t ) - 0.44 * Math.cos( 3 * t ) - 0.78 * Math.sin( 3 * t );\r\n\t\tvar y = - 0.1 * Math.cos( 2 * t ) - 0.27 * Math.sin( 2 * t ) + 0.38 * Math.cos( 4 * t ) + 0.46 * Math.sin( 4 * t );\r\n\t\tvar z = 0.7 * Math.cos( 3 * t ) - 0.4 * Math.sin( 3 * t );\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( 20 );\r\n\r\n\t};\r\n\r\n\t// HeartCurve\r\n\r\n\tfunction HeartCurve( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 5 : scale;\r\n\r\n\t}\r\n\r\n\tHeartCurve.prototype = Object.create( Curve.prototype );\r\n\tHeartCurve.prototype.constructor = HeartCurve;\r\n\r\n\tHeartCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tt *= 2 * Math.PI;\r\n\r\n\t\tvar x = 16 * Math.pow( Math.sin( t ), 3 );\r\n\t\tvar y = 13 * Math.cos( t ) - 5 * Math.cos( 2 * t ) - 2 * Math.cos( 3 * t ) - Math.cos( 4 * t );\r\n\t\tvar z = 0;\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( this.scale );\r\n\r\n\t};\r\n\r\n\t// Viviani's Curve\r\n\r\n\tfunction VivianiCurve( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 70 : scale;\r\n\r\n\t}\r\n\r\n\tVivianiCurve.prototype = Object.create( Curve.prototype );\r\n\tVivianiCurve.prototype.constructor = VivianiCurve;\r\n\r\n\tVivianiCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tt = t * 4 * Math.PI; // normalized to 0..1\r\n\t\tvar a = this.scale / 2;\r\n\r\n\t\tvar x = a * ( 1 + Math.cos( t ) );\r\n\t\tvar y = a * Math.sin( t );\r\n\t\tvar z = 2 * a * Math.sin( t / 2 );\r\n\r\n\t\treturn point.set( x, y, z );\r\n\r\n\t};\r\n\r\n\t// KnotCurve\r\n\r\n\tfunction KnotCurve() {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t}\r\n\r\n\tKnotCurve.prototype = Object.create( Curve.prototype );\r\n\tKnotCurve.prototype.constructor = KnotCurve;\r\n\r\n\tKnotCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tt *= 2 * Math.PI;\r\n\r\n\t\tvar R = 10;\r\n\t\tvar s = 50;\r\n\r\n\t\tvar x = s * Math.sin( t );\r\n\t\tvar y = Math.cos( t ) * ( R + s * Math.cos( t ) );\r\n\t\tvar z = Math.sin( t ) * ( R + s * Math.cos( t ) );\r\n\r\n\t\treturn point.set( x, y, z );\r\n\r\n\t};\r\n\r\n\t// HelixCurve\r\n\r\n\tfunction HelixCurve() {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t}\r\n\r\n\tHelixCurve.prototype = Object.create( Curve.prototype );\r\n\tHelixCurve.prototype.constructor = HelixCurve;\r\n\r\n\tHelixCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tvar a = 30; // radius\r\n\t\tvar b = 150; // height\r\n\r\n\t\tvar t2 = 2 * Math.PI * t * b / 30;\r\n\r\n\t\tvar x = Math.cos( t2 ) * a;\r\n\t\tvar y = Math.sin( t2 ) * a;\r\n\t\tvar z = b * t;\r\n\r\n\t\treturn point.set( x, y, z );\r\n\r\n\t};\r\n\r\n\t// TrefoilKnot\r\n\r\n\tfunction TrefoilKnot( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 10 : scale;\r\n\r\n\t}\r\n\r\n\tTrefoilKnot.prototype = Object.create( Curve.prototype );\r\n\tTrefoilKnot.prototype.constructor = TrefoilKnot;\r\n\r\n\tTrefoilKnot.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tt *= Math.PI * 2;\r\n\r\n\t\tvar x = ( 2 + Math.cos( 3 * t ) ) * Math.cos( 2 * t );\r\n\t\tvar y = ( 2 + Math.cos( 3 * t ) ) * Math.sin( 2 * t );\r\n\t\tvar z = Math.sin( 3 * t );\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( this.scale );\r\n\r\n\t};\r\n\r\n\t// TorusKnot\r\n\r\n\tfunction TorusKnot( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 10 : scale;\r\n\r\n\t}\r\n\r\n\tTorusKnot.prototype = Object.create( Curve.prototype );\r\n\tTorusKnot.prototype.constructor = TorusKnot;\r\n\r\n\tTorusKnot.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tvar p = 3;\r\n\t\tvar q = 4;\r\n\r\n\t\tt *= Math.PI * 2;\r\n\r\n\t\tvar x = ( 2 + Math.cos( q * t ) ) * Math.cos( p * t );\r\n\t\tvar y = ( 2 + Math.cos( q * t ) ) * Math.sin( p * t );\r\n\t\tvar z = Math.sin( q * t );\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( this.scale );\r\n\r\n\t};\r\n\r\n\t// CinquefoilKnot\r\n\r\n\tfunction CinquefoilKnot( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 10 : scale;\r\n\r\n\t}\r\n\r\n\tCinquefoilKnot.prototype = Object.create( Curve.prototype );\r\n\tCinquefoilKnot.prototype.constructor = CinquefoilKnot;\r\n\r\n\tCinquefoilKnot.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tvar p = 2;\r\n\t\tvar q = 5;\r\n\r\n\t\tt *= Math.PI * 2;\r\n\r\n\t\tvar x = ( 2 + Math.cos( q * t ) ) * Math.cos( p * t );\r\n\t\tvar y = ( 2 + Math.cos( q * t ) ) * Math.sin( p * t );\r\n\t\tvar z = Math.sin( q * t );\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( this.scale );\r\n\r\n\t};\r\n\r\n\t// TrefoilPolynomialKnot\r\n\r\n\tfunction TrefoilPolynomialKnot( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 10 : scale;\r\n\r\n\t}\r\n\r\n\tTrefoilPolynomialKnot.prototype = Object.create( Curve.prototype );\r\n\tTrefoilPolynomialKnot.prototype.constructor = TrefoilPolynomialKnot;\r\n\r\n\tTrefoilPolynomialKnot.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tt = t * 4 - 2;\r\n\r\n\t\tvar x = Math.pow( t, 3 ) - 3 * t;\r\n\t\tvar y = Math.pow( t, 4 ) - 4 * t * t;\r\n\t\tvar z = 1 / 5 * Math.pow( t, 5 ) - 2 * t;\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( this.scale );\r\n\r\n\t};\r\n\r\n\tvar scaleTo = function ( x, y, t ) {\r\n\r\n\t\tvar r = y - x;\r\n\t\treturn t * r + x;\r\n\r\n\t};\r\n\r\n\t// FigureEightPolynomialKnot\r\n\r\n\tfunction FigureEightPolynomialKnot( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 1 : scale;\r\n\r\n\t}\r\n\r\n\tFigureEightPolynomialKnot.prototype = Object.create( Curve.prototype );\r\n\tFigureEightPolynomialKnot.prototype.constructor = FigureEightPolynomialKnot;\r\n\r\n\tFigureEightPolynomialKnot.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tt = scaleTo( - 4, 4, t );\r\n\r\n\t\tvar x = 2 / 5 * t * ( t * t - 7 ) * ( t * t - 10 );\r\n\t\tvar y = Math.pow( t, 4 ) - 13 * t * t;\r\n\t\tvar z = 1 / 10 * t * ( t * t - 4 ) * ( t * t - 9 ) * ( t * t - 12 );\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( this.scale );\r\n\r\n\t};\r\n\r\n\t// DecoratedTorusKnot4a\r\n\r\n\tfunction DecoratedTorusKnot4a( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 40 : scale;\r\n\r\n\t}\r\n\r\n\tDecoratedTorusKnot4a.prototype = Object.create( Curve.prototype );\r\n\tDecoratedTorusKnot4a.prototype.constructor = DecoratedTorusKnot4a;\r\n\r\n\tDecoratedTorusKnot4a.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tt *= Math.PI * 2;\r\n\r\n\t\tvar x = Math.cos( 2 * t ) * ( 1 + 0.6 * ( Math.cos( 5 * t ) + 0.75 * Math.cos( 10 * t ) ) );\r\n\t\tvar y = Math.sin( 2 * t ) * ( 1 + 0.6 * ( Math.cos( 5 * t ) + 0.75 * Math.cos( 10 * t ) ) );\r\n\t\tvar z = 0.35 * Math.sin( 5 * t );\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( this.scale );\r\n\r\n\t};\r\n\r\n\t// DecoratedTorusKnot4b\r\n\r\n\tfunction DecoratedTorusKnot4b( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 40 : scale;\r\n\r\n\t}\r\n\r\n\tDecoratedTorusKnot4b.prototype = Object.create( Curve.prototype );\r\n\tDecoratedTorusKnot4b.prototype.constructor = DecoratedTorusKnot4b;\r\n\r\n\tDecoratedTorusKnot4b.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tvar fi = t * Math.PI * 2;\r\n\r\n\t\tvar x = Math.cos( 2 * fi ) * ( 1 + 0.45 * Math.cos( 3 * fi ) + 0.4 * Math.cos( 9 * fi ) );\r\n\t\tvar y = Math.sin( 2 * fi ) * ( 1 + 0.45 * Math.cos( 3 * fi ) + 0.4 * Math.cos( 9 * fi ) );\r\n\t\tvar z = 0.2 * Math.sin( 9 * fi );\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( this.scale );\r\n\r\n\t};\r\n\r\n\t// DecoratedTorusKnot5a\r\n\r\n\tfunction DecoratedTorusKnot5a( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 40 : scale;\r\n\r\n\t}\r\n\r\n\tDecoratedTorusKnot5a.prototype = Object.create( Curve.prototype );\r\n\tDecoratedTorusKnot5a.prototype.constructor = DecoratedTorusKnot5a;\r\n\r\n\tDecoratedTorusKnot5a.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tvar fi = t * Math.PI * 2;\r\n\r\n\t\tvar x = Math.cos( 3 * fi ) * ( 1 + 0.3 * Math.cos( 5 * fi ) + 0.5 * Math.cos( 10 * fi ) );\r\n\t\tvar y = Math.sin( 3 * fi ) * ( 1 + 0.3 * Math.cos( 5 * fi ) + 0.5 * Math.cos( 10 * fi ) );\r\n\t\tvar z = 0.2 * Math.sin( 20 * fi );\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( this.scale );\r\n\r\n\t};\r\n\r\n\t// DecoratedTorusKnot5c\r\n\r\n\tfunction DecoratedTorusKnot5c( scale ) {\r\n\r\n\t\tCurve.call( this );\r\n\r\n\t\tthis.scale = ( scale === undefined ) ? 40 : scale;\r\n\r\n\t}\r\n\r\n\tDecoratedTorusKnot5c.prototype = Object.create( Curve.prototype );\r\n\tDecoratedTorusKnot5c.prototype.constructor = DecoratedTorusKnot5c;\r\n\r\n\tDecoratedTorusKnot5c.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\t\tvar point = optionalTarget || new Vector3();\r\n\r\n\t\tvar fi = t * Math.PI * 2;\r\n\r\n\t\tvar x = Math.cos( 4 * fi ) * ( 1 + 0.5 * ( Math.cos( 5 * fi ) + 0.4 * Math.cos( 20 * fi ) ) );\r\n\t\tvar y = Math.sin( 4 * fi ) * ( 1 + 0.5 * ( Math.cos( 5 * fi ) + 0.4 * Math.cos( 20 * fi ) ) );\r\n\t\tvar z = 0.35 * Math.sin( 15 * fi );\r\n\r\n\t\treturn point.set( x, y, z ).multiplyScalar( this.scale );\r\n\r\n\t};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar NURBSUtils = {\r\n\t\r\n\tfindSpan: function( p,  u,  U ) {\r\n\r\n\t\tvar n = U.length - p - 1;\r\n\r\n\t\tif ( u >= U[ n ] ) {\r\n\r\n\t\t\treturn n - 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( u <= U[ p ] ) {\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t}\r\n\r\n\t\tvar low = p;\r\n\t\tvar high = n;\r\n\t\tvar mid = Math.floor( ( low + high ) / 2 );\r\n\r\n\t\twhile ( u < U[ mid ] || u >= U[ mid + 1 ] ) {\r\n\r\n\t\t\tif ( u < U[ mid ] ) {\r\n\r\n\t\t\t\thigh = mid;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlow = mid;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmid = Math.floor( ( low + high ) / 2 );\r\n\r\n\t\t}\r\n\r\n\t\treturn mid;\r\n\r\n\t},\r\n\t\r\n\tcalcBasisFunctions: function( span, u, p, U ) {\r\n\r\n\t\tvar N = [];\r\n\t\tvar left = [];\r\n\t\tvar right = [];\r\n\t\tN[ 0 ] = 1.0;\r\n\r\n\t\tfor ( var j = 1; j <= p; ++ j ) {\r\n\r\n\t\t\tleft[ j ] = u - U[ span + 1 - j ];\r\n\t\t\tright[ j ] = U[ span + j ] - u;\r\n\r\n\t\t\tvar saved = 0.0;\r\n\r\n\t\t\tfor ( var r = 0; r < j; ++ r ) {\r\n\r\n\t\t\t\tvar rv = right[ r + 1 ];\r\n\t\t\t\tvar lv = left[ j - r ];\r\n\t\t\t\tvar temp = N[ r ] / ( rv + lv );\r\n\t\t\t\tN[ r ] = saved + rv * temp;\r\n\t\t\t\tsaved = lv * temp;\r\n\r\n\t\t\t }\r\n\r\n\t\t\t N[ j ] = saved;\r\n\r\n\t\t }\r\n\r\n\t\t return N;\r\n\r\n\t},\r\n\t\r\n\tcalcBSplinePoint: function( p, U, P, u ) {\r\n\r\n\t\tvar span = this.findSpan( p, u, U );\r\n\t\tvar N = this.calcBasisFunctions( span, u, p, U );\r\n\t\tvar C = new Vector4( 0, 0, 0, 0 );\r\n\r\n\t\tfor ( var j = 0; j <= p; ++ j ) {\r\n\r\n\t\t\tvar point = P[ span - p + j ];\r\n\t\t\tvar Nj = N[ j ];\r\n\t\t\tvar wNj = point.w * Nj;\r\n\t\t\tC.x += point.x * wNj;\r\n\t\t\tC.y += point.y * wNj;\r\n\t\t\tC.z += point.z * wNj;\r\n\t\t\tC.w += point.w * Nj;\r\n\r\n\t\t}\r\n\r\n\t\treturn C;\r\n\r\n\t},\r\n\t\r\n\tcalcBasisFunctionDerivatives: function( span,  u,  p,  n,  U ) {\r\n\r\n\t\tvar zeroArr = [];\r\n\t\tfor ( var i = 0; i <= p; ++ i )\r\n\t\t\t{ zeroArr[ i ] = 0.0; }\r\n\r\n\t\tvar ders = [];\r\n\t\tfor ( var i = 0; i <= n; ++ i )\r\n\t\t\t{ ders[ i ] = zeroArr.slice( 0 ); }\r\n\r\n\t\tvar ndu = [];\r\n\t\tfor ( var i = 0; i <= p; ++ i )\r\n\t\t\t{ ndu[ i ] = zeroArr.slice( 0 ); }\r\n\r\n\t\tndu[ 0 ][ 0 ] = 1.0;\r\n\r\n\t\tvar left = zeroArr.slice( 0 );\r\n\t\tvar right = zeroArr.slice( 0 );\r\n\r\n\t\tfor ( var j = 1; j <= p; ++ j ) {\r\n\r\n\t\t\tleft[ j ] = u - U[ span + 1 - j ];\r\n\t\t\tright[ j ] = U[ span + j ] - u;\r\n\r\n\t\t\tvar saved = 0.0;\r\n\r\n\t\t\tfor ( var r = 0; r < j; ++ r ) {\r\n\r\n\t\t\t\tvar rv = right[ r + 1 ];\r\n\t\t\t\tvar lv = left[ j - r ];\r\n\t\t\t\tndu[ j ][ r ] = rv + lv;\r\n\r\n\t\t\t\tvar temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];\r\n\t\t\t\tndu[ r ][ j ] = saved + rv * temp;\r\n\t\t\t\tsaved = lv * temp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tndu[ j ][ j ] = saved;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var j = 0; j <= p; ++ j ) {\r\n\r\n\t\t\tders[ 0 ][ j ] = ndu[ j ][ p ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var r = 0; r <= p; ++ r ) {\r\n\r\n\t\t\tvar s1 = 0;\r\n\t\t\tvar s2 = 1;\r\n\r\n\t\t\tvar a = [];\r\n\t\t\tfor ( var i = 0; i <= p; ++ i ) {\r\n\r\n\t\t\t\ta[ i ] = zeroArr.slice( 0 );\r\n\r\n\t\t\t}\r\n\t\t\ta[ 0 ][ 0 ] = 1.0;\r\n\r\n\t\t\tfor ( var k = 1; k <= n; ++ k ) {\r\n\r\n\t\t\t\tvar d = 0.0;\r\n\t\t\t\tvar rk = r - k;\r\n\t\t\t\tvar pk = p - k;\r\n\r\n\t\t\t\tif ( r >= k ) {\r\n\r\n\t\t\t\t\ta[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];\r\n\t\t\t\t\td = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar j1 = ( rk >= - 1 ) ? 1 : - rk;\r\n\t\t\t\tvar j2 = ( r - 1 <= pk ) ? k - 1 :  p - r;\r\n\r\n\t\t\t\tfor ( var j = j1; j <= j2; ++ j ) {\r\n\r\n\t\t\t\t\ta[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];\r\n\t\t\t\t\td += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( r <= pk ) {\r\n\r\n\t\t\t\t\ta[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];\r\n\t\t\t\t\td += a[ s2 ][ k ] * ndu[ r ][ pk ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tders[ k ][ r ] = d;\r\n\r\n\t\t\t\tvar j = s1;\r\n\t\t\t\ts1 = s2;\r\n\t\t\t\ts2 = j;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar r = p;\r\n\r\n\t\tfor ( var k = 1; k <= n; ++ k ) {\r\n\r\n\t\t\tfor ( var j = 0; j <= p; ++ j ) {\r\n\r\n\t\t\t\tders[ k ][ j ] *= r;\r\n\r\n\t\t\t}\r\n\t\t\tr *= p - k;\r\n\r\n\t\t}\r\n\r\n\t\treturn ders;\r\n\r\n\t},\r\n\t\r\n\tcalcBSplineDerivatives: function( p,  U,  P,  u,  nd ) {\r\n\r\n\t\tvar du = nd < p ? nd : p;\r\n\t\tvar CK = [];\r\n\t\tvar span = this.findSpan( p, u, U );\r\n\t\tvar nders = this.calcBasisFunctionDerivatives( span, u, p, du, U );\r\n\t\tvar Pw = [];\r\n\r\n\t\tfor ( var i = 0; i < P.length; ++ i ) {\r\n\r\n\t\t\tvar point = P[ i ].clone();\r\n\t\t\tvar w = point.w;\r\n\r\n\t\t\tpoint.x *= w;\r\n\t\t\tpoint.y *= w;\r\n\t\t\tpoint.z *= w;\r\n\r\n\t\t\tPw[ i ] = point;\r\n\r\n\t\t}\r\n\t\tfor ( var k = 0; k <= du; ++ k ) {\r\n\r\n\t\t\tvar point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );\r\n\r\n\t\t\tfor ( var j = 1; j <= p; ++ j ) {\r\n\r\n\t\t\t\tpoint.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tCK[ k ] = point;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var k = du + 1; k <= nd + 1; ++ k ) {\r\n\r\n\t\t\tCK[ k ] = new Vector4( 0, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\treturn CK;\r\n\r\n\t},\r\n\t\r\n\tcalcKoverI: function( k, i ) {\r\n\r\n\t\tvar nom = 1;\r\n\r\n\t\tfor ( var j = 2; j <= k; ++ j ) {\r\n\r\n\t\t\tnom *= j;\r\n\r\n\t\t}\r\n\r\n\t\tvar denom = 1;\r\n\r\n\t\tfor ( var j = 2; j <= i; ++ j ) {\r\n\r\n\t\t\tdenom *= j;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var j = 2; j <= k - i; ++ j ) {\r\n\r\n\t\t\tdenom *= j;\r\n\r\n\t\t}\r\n\r\n\t\treturn nom / denom;\r\n\r\n\t},\r\n\t\r\n\tcalcRationalCurveDerivatives: function ( Pders ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar nd = Pders.length;\r\n\t\tvar Aders = [];\r\n\t\tvar wders = [];\r\n\r\n\t\tfor ( var i = 0; i < nd; ++ i ) {\r\n\r\n\t\t\tvar point = Pders[ i ];\r\n\t\t\tAders[ i ] = new Vector3( point.x, point.y, point.z );\r\n\t\t\twders[ i ] = point.w;\r\n\r\n\t\t}\r\n\r\n\t\tvar CK = [];\r\n\r\n\t\tfor ( var k = 0; k < nd; ++ k ) {\r\n\r\n\t\t\tvar v = Aders[ k ].clone();\r\n\r\n\t\t\tfor ( var i = 1; i <= k; ++ i ) {\r\n\r\n\t\t\t\tv.sub( CK[ k - i ].clone().multiplyScalar( this$1.calcKoverI( k, i ) * wders[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tCK[ k ] = v.divideScalar( wders[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn CK;\r\n\r\n\t},\r\n\t\r\n\tcalcNURBSDerivatives: function( p,  U,  P,  u,  nd ) {\r\n\r\n\t\tvar Pders = this.calcBSplineDerivatives( p, U, P, u, nd );\r\n\t\treturn this.calcRationalCurveDerivatives( Pders );\r\n\r\n\t},\r\n\t\r\n\tcalcSurfacePoint: function ( p, q, U, V, P, u, v, target ) {\r\n\r\n\t\tvar uspan = this.findSpan( p, u, U );\r\n\t\tvar vspan = this.findSpan( q, v, V );\r\n\t\tvar Nu = this.calcBasisFunctions( uspan, u, p, U );\r\n\t\tvar Nv = this.calcBasisFunctions( vspan, v, q, V );\r\n\t\tvar temp = [];\r\n\r\n\t\tfor ( var l = 0; l <= q; ++ l ) {\r\n\r\n\t\t\ttemp[ l ] = new Vector4( 0, 0, 0, 0 );\r\n\t\t\tfor ( var k = 0; k <= p; ++ k ) {\r\n\r\n\t\t\t\tvar point = P[ uspan - p + k ][ vspan - q + l ].clone();\r\n\t\t\t\tvar w = point.w;\r\n\t\t\t\tpoint.x *= w;\r\n\t\t\t\tpoint.y *= w;\r\n\t\t\t\tpoint.z *= w;\r\n\t\t\t\ttemp[ l ].add( point.multiplyScalar( Nu[ k ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar Sw = new Vector4( 0, 0, 0, 0 );\r\n\t\tfor ( var l = 0; l <= q; ++ l ) {\r\n\r\n\t\t\tSw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tSw.divideScalar( Sw.w );\r\n\t\ttarget.set( Sw.x, Sw.y, Sw.z );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar NURBSCurve = function ( degree, knots , controlPoints , startKnot , endKnot  ) {\n\tvar this$1 = this;\n\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.degree = degree;\r\n\tthis.knots = knots;\r\n\tthis.controlPoints = [];\r\n\t// Used by periodic NURBS to remove hidden spans\r\n\tthis.startKnot = startKnot || 0;\r\n\tthis.endKnot = endKnot || ( this.knots.length - 1 );\r\n\tfor ( var i = 0; i < controlPoints.length; ++ i ) {\r\n\r\n\t\t// ensure Vector4 for control points\r\n\t\tvar point = controlPoints[ i ];\r\n\t\tthis$1.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );\r\n\r\n\t}\r\n\r\n};\r\n\r\nNURBSCurve.prototype = Object.create( Curve.prototype );\r\nNURBSCurve.prototype.constructor = NURBSCurve;\r\n\r\nNURBSCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\r\n\r\n\t// following results in (wx, wy, wz, w) homogeneous point\r\n\tvar hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\r\n\r\n\tif ( hpoint.w != 1.0 ) {\r\n\r\n\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\r\n\t\thpoint.divideScalar( hpoint.w );\r\n\r\n\t}\r\n\r\n\treturn new Vector3( hpoint.x, hpoint.y, hpoint.z );\r\n\r\n};\r\n\r\nNURBSCurve.prototype.getTangent = function ( t ) {\r\n\r\n\tvar u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\r\n\tvar ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\r\n\tvar tangent = ders[ 1 ].clone();\r\n\ttangent.normalize();\r\n\r\n\treturn tangent;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar NURBSSurface = function ( degree1, degree2, knots1, knots2 , controlPoints  ) {\n\tvar this$1 = this;\n\r\n\r\n\tthis.degree1 = degree1;\r\n\tthis.degree2 = degree2;\r\n\tthis.knots1 = knots1;\r\n\tthis.knots2 = knots2;\r\n\tthis.controlPoints = [];\r\n\r\n\tvar len1 = knots1.length - degree1 - 1;\r\n\tvar len2 = knots2.length - degree2 - 1;\r\n\r\n\t// ensure Vector4 for control points\r\n\tfor ( var i = 0; i < len1; ++ i ) {\r\n\r\n\t\tthis$1.controlPoints[ i ] = [];\r\n\t\tfor ( var j = 0; j < len2; ++ j ) {\r\n\r\n\t\t\tvar point = controlPoints[ i ][ j ];\r\n\t\t\tthis$1.controlPoints[ i ][ j ] = new Vector4( point.x, point.y, point.z, point.w );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nNURBSSurface.prototype = {\r\n\r\n\tconstructor: NURBSSurface,\r\n\r\n\tgetPoint: function ( t1, t2, target ) {\r\n\r\n\t\tvar u = this.knots1[ 0 ] + t1 * ( this.knots1[ this.knots1.length - 1 ] - this.knots1[ 0 ] ); // linear mapping t1->u\r\n\t\tvar v = this.knots2[ 0 ] + t2 * ( this.knots2[ this.knots2.length - 1 ] - this.knots2[ 0 ] ); // linear mapping t2->u\r\n\r\n\t\tNURBSUtils.calcSurfacePoint( this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target );\r\n\r\n\t}\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Detector = {\r\n\r\n\tcanvas: !! window.CanvasRenderingContext2D,\r\n\twebgl: ( function () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' ); return !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );\r\n\r\n\t\t} catch ( e ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t} )(),\r\n\twebgl2: ( function () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' ); return !! ( window.WebGL2RenderingContext && ( canvas.getContext( 'webgl2' ) ) );\r\n\r\n\t\t} catch ( e ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t} )(),\r\n\tworkers: !! window.Worker,\r\n\tfileapi: window.File && window.FileReader && window.FileList && window.Blob,\r\n\r\n\tgetWebGLErrorMessage: function () {\r\n\r\n\t\tvar element = document.createElement( 'div' );\r\n\t\telement.id = 'webgl-error-message';\r\n\t\telement.style.fontFamily = 'monospace';\r\n\t\telement.style.fontSize = '13px';\r\n\t\telement.style.fontWeight = 'normal';\r\n\t\telement.style.textAlign = 'center';\r\n\t\telement.style.background = '#fff';\r\n\t\telement.style.color = '#000';\r\n\t\telement.style.padding = '1.5em';\r\n\t\telement.style.width = '400px';\r\n\t\telement.style.margin = '5em auto 0';\r\n\r\n\t\tif ( ! this.webgl ) {\r\n\r\n\t\t\telement.innerHTML = window.WebGLRenderingContext ? [\r\n\t\t\t\t'Your graphics card does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">WebGL</a>.<br />',\r\n\t\t\t\t'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000\">here</a>.'\r\n\t\t\t].join( '\\n' ) : [\r\n\t\t\t\t'Your browser does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">WebGL</a>.<br/>',\r\n\t\t\t\t'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000\">here</a>.'\r\n\t\t\t].join( '\\n' );\r\n\r\n\t\t}\r\n\r\n\t\treturn element;\r\n\r\n\t},\r\n\r\n\taddGetWebGLMessage: function ( parameters ) {\r\n\r\n\t\tvar parent, id, element;\r\n\r\n\t\tparameters = parameters || {};\r\n\r\n\t\tparent = parameters.parent !== undefined ? parameters.parent : document.body;\r\n\t\tid = parameters.id !== undefined ? parameters.id : 'oldie';\r\n\r\n\t\telement = Detector.getWebGLErrorMessage();\r\n\t\telement.id = id;\r\n\r\n\t\tparent.appendChild( element );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction StereoCamera() {\r\n\r\n\tthis.type = 'StereoCamera';\r\n\r\n\tthis.aspect = 1;\r\n\r\n\tthis.eyeSep = 0.064;\r\n\r\n\tthis.cameraL = new PerspectiveCamera();\r\n\tthis.cameraL.layers.enable( 1 );\r\n\tthis.cameraL.matrixAutoUpdate = false;\r\n\r\n\tthis.cameraR = new PerspectiveCamera();\r\n\tthis.cameraR.layers.enable( 2 );\r\n\tthis.cameraR.matrixAutoUpdate = false;\r\n\r\n}\r\n\r\nObject.assign( StereoCamera.prototype, {\r\n\r\n\tupdate: ( function () {\r\n\r\n\t\tvar instance, focus, fov, aspect, near, far, zoom, eyeSep;\r\n\r\n\t\tvar eyeRight = new Matrix4();\r\n\t\tvar eyeLeft = new Matrix4();\r\n\r\n\t\treturn function update( camera ) {\r\n\r\n\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\r\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\r\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;\r\n\r\n\t\t\tif ( needsUpdate ) {\r\n\r\n\t\t\t\tinstance = this;\r\n\t\t\t\tfocus = camera.focus;\r\n\t\t\t\tfov = camera.fov;\r\n\t\t\t\taspect = camera.aspect * this.aspect;\r\n\t\t\t\tnear = camera.near;\r\n\t\t\t\tfar = camera.far;\r\n\t\t\t\tzoom = camera.zoom;\r\n\r\n\t\t\t\t// Off-axis stereoscopic effect based on\r\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\r\n\r\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\r\n\t\t\t\teyeSep = this.eyeSep / 2;\r\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\r\n\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\r\n\t\t\t\tvar xmin, xmax;\r\n\r\n\t\t\t\t// translate xOffset\r\n\r\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\r\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\r\n\r\n\t\t\t\t// for left eye\r\n\r\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\r\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\r\n\r\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\r\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\r\n\r\n\t\t\t\t// for right eye\r\n\r\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\r\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\r\n\r\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\r\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\r\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar AnaglyphEffect = function ( renderer, width, height ) {\r\n\r\n\t// Matrices generated with angler.js https://github.com/tschw/angler.js/\r\n\t// (in column-major element order, as accepted by WebGL)\r\n\r\n\tthis.colorMatrixLeft = new Matrix3().fromArray( [\r\n\r\n\t\t\t1.0671679973602295, \t-0.0016435992438346148,\t\t 0.0001777536963345483, // r out\r\n\t\t\t-0.028107794001698494,\t-0.00019593400065787137,\t-0.0002875397040043026, // g out\r\n\t\t\t-0.04279090091586113,\t 0.000015809757314855233,\t-0.00024287120322696865 // b out\r\n\r\n\t] );\r\n\r\n\t//\t\tred\t\t\t\t\t\tgreen \t\t\t\t\t\tblue  \t\t\t\t\t\tin\r\n\r\n\tthis.colorMatrixRight = new Matrix3().fromArray( [\r\n\r\n\t\t\t-0.0355340838432312,\t-0.06440307199954987,\t\t 0.018319187685847282,\t// r out\r\n\t\t\t-0.10269022732973099,\t 0.8079727292060852,\t\t-0.04835830628871918,\t// g out\r\n\t\t\t0.0001224992738571018,\t-0.009558862075209618,\t\t 0.567823588848114\t\t// b out\r\n\r\n\t] );\r\n\r\n\tvar _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\r\n\tvar _scene = new Scene();\r\n\r\n\tvar _stereo = new StereoCamera();\r\n\r\n\tvar _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };\r\n\r\n\tif ( width === undefined ) { width = 512; }\r\n\tif ( height === undefined ) { height = 512; }\r\n\r\n\tvar _renderTargetL = new WebGLRenderTarget( width, height, _params );\r\n\tvar _renderTargetR = new WebGLRenderTarget( width, height, _params );\r\n\r\n\tvar _material = new ShaderMaterial( {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"mapLeft\": { value: _renderTargetL.texture },\r\n\t\t\t\"mapRight\": { value: _renderTargetR.texture },\r\n\r\n\t\t\t\"colorMatrixLeft\": { value: this.colorMatrixLeft },\r\n\t\t\t\"colorMatrixRight\": { value: this.colorMatrixRight }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvUv = vec2( uv.x, uv.y );\",\r\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D mapLeft;\",\r\n\t\t\t\"uniform sampler2D mapRight;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"uniform mat3 colorMatrixLeft;\",\r\n\t\t\t\"uniform mat3 colorMatrixRight;\",\r\n\r\n\t\t\t// These functions implement sRGB linearization and gamma correction\r\n\r\n\t\t\t\"float lin( float c ) {\",\r\n\t\t\t\"\treturn c <= 0.04045 ? c * 0.0773993808 :\",\r\n\t\t\t\"\t\t\tpow( c * 0.9478672986 + 0.0521327014, 2.4 );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"vec4 lin( vec4 c ) {\",\r\n\t\t\t\"\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"float dev( float c ) {\",\r\n\t\t\t\"\treturn c <= 0.0031308 ? c * 12.92\",\r\n\t\t\t\"\t\t\t: pow( c, 0.41666 ) * 1.055 - 0.055;\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec2 uv = vUv;\",\r\n\r\n\t\t\t\"\tvec4 colorL = lin( texture2D( mapLeft, uv ) );\",\r\n\t\t\t\"\tvec4 colorR = lin( texture2D( mapRight, uv ) );\",\r\n\r\n\t\t\t\"\tvec3 color = clamp(\",\r\n\t\t\t\"\t\t\tcolorMatrixLeft * colorL.rgb +\",\r\n\t\t\t\"\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );\",\r\n\r\n\t\t\t\"\tgl_FragColor = vec4(\",\r\n\t\t\t\"\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),\",\r\n\t\t\t\"\t\t\tmax( colorL.a, colorR.a ) );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t} );\r\n\r\n\tvar _mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), _material );\r\n\t_scene.add( _mesh );\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\trenderer.setSize( width, height );\r\n\r\n\t\tvar pixelRatio = renderer.getPixelRatio();\r\n\r\n\t\t_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );\r\n\t\t_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\tif ( camera.parent === null ) { camera.updateMatrixWorld(); }\r\n\r\n\t\t_stereo.update( camera );\r\n\r\n\t\trenderer.render( scene, _stereo.cameraL, _renderTargetL, true );\r\n\t\trenderer.render( scene, _stereo.cameraR, _renderTargetR, true );\r\n\t\trenderer.render( _scene, _camera );\r\n\r\n\t};\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tif ( _renderTargetL ) { _renderTargetL.dispose(); }\r\n\t\tif ( _renderTargetR ) { _renderTargetR.dispose(); }\r\n\t\tif ( _mesh ) { _mesh.geometry.dispose(); }\r\n\t\tif ( _material ) { _material.dispose(); }\r\n\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar AsciiEffect = function ( renderer, charSet, options ) {\r\n\r\n\t// its fun to create one your own!\r\n\r\n\tcharSet = ( charSet === undefined ) ? ' .:-=+*#%@' : charSet;\r\n\r\n\t// ' .,:;=|iI+hHOE#`$';\r\n\t// darker bolder character set from https://github.com/saw/Canvas-ASCII-Art/\r\n\t// ' .\\'`^\",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$'.split('');\r\n\r\n\tif ( ! options ) { options = {}; }\r\n\r\n\t// Some ASCII settings\r\n\r\n\tvar bResolution = ! options[ 'resolution' ] ? 0.15 : options[ 'resolution' ]; // Higher for more details\r\n\tvar iScale = ! options[ 'scale' ] ? 1 : options[ 'scale' ];\r\n\tvar bColor = ! options[ 'color' ] ? false : options[ 'color' ]; // nice but slows down rendering!\r\n\tvar bAlpha = ! options[ 'alpha' ] ? false : options[ 'alpha' ]; // Transparency\r\n\tvar bBlock = ! options[ 'block' ] ? false : options[ 'block' ]; // blocked characters. like good O dos\r\n\tvar bInvert = ! options[ 'invert' ] ? false : options[ 'invert' ]; // black is white, white is black\r\n\r\n\tvar strResolution = 'low';\r\n\r\n\tvar width, height;\r\n\r\n\tvar domElement = document.createElement( 'div' );\r\n\tdomElement.style.cursor = 'default';\r\n\r\n\tvar oAscii = document.createElement( \"table\" );\r\n\tdomElement.appendChild( oAscii );\r\n\r\n\tvar iWidth, iHeight;\r\n\tvar oImg;\r\n\r\n\tthis.setSize = function ( w, h ) {\r\n\r\n\t\twidth = w;\r\n\t\theight = h;\r\n\r\n\t\trenderer.setSize( w, h );\r\n\r\n\t\tinitAsciiSize();\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\trenderer.render( scene, camera );\r\n\t\tasciifyImage( renderer, oAscii );\r\n\r\n\t};\r\n\r\n\tthis.domElement = domElement;\r\n\r\n\t// Throw in ascii library from http://www.nihilogic.dk/labs/jsascii/jsascii.js\r\n\r\n\tfunction initAsciiSize() {\r\n\r\n\t\tiWidth = Math.round( width * fResolution );\r\n\t\tiHeight = Math.round( height * fResolution );\r\n\r\n\t\toCanvas.width = iWidth;\r\n\t\toCanvas.height = iHeight;\r\n\t\t// oCanvas.style.display = \"none\";\r\n\t\t// oCanvas.style.width = iWidth;\r\n\t\t// oCanvas.style.height = iHeight;\r\n\r\n\t\toImg = renderer.domElement;\r\n\r\n\t\tif ( oImg.style.backgroundColor ) {\r\n\r\n\t\t\toAscii.rows[ 0 ].cells[ 0 ].style.backgroundColor = oImg.style.backgroundColor;\r\n\t\t\toAscii.rows[ 0 ].cells[ 0 ].style.color = oImg.style.color;\r\n\r\n\t\t}\r\n\r\n\t\toAscii.cellSpacing = 0;\r\n\t\toAscii.cellPadding = 0;\r\n\r\n\t\tvar oStyle = oAscii.style;\r\n\t\toStyle.display = \"inline\";\r\n\t\toStyle.width = Math.round( iWidth / fResolution * iScale ) + \"px\";\r\n\t\toStyle.height = Math.round( iHeight / fResolution * iScale ) + \"px\";\r\n\t\toStyle.whiteSpace = \"pre\";\r\n\t\toStyle.margin = \"0px\";\r\n\t\toStyle.padding = \"0px\";\r\n\t\toStyle.letterSpacing = fLetterSpacing + \"px\";\r\n\t\toStyle.fontFamily = strFont;\r\n\t\toStyle.fontSize = fFontSize + \"px\";\r\n\t\toStyle.lineHeight = fLineHeight + \"px\";\r\n\t\toStyle.textAlign = \"left\";\r\n\t\toStyle.textDecoration = \"none\";\r\n\r\n\t}\r\n\r\n\tvar aDefaultCharList = ( \" .,:;i1tfLCG08@\" ).split( \"\" );\r\n\tvar aDefaultColorCharList = ( \" CGO08@\" ).split( \"\" );\r\n\tvar strFont = \"courier new, monospace\";\r\n\r\n\tvar oCanvasImg = renderer.domElement;\r\n\r\n\tvar oCanvas = document.createElement( \"canvas\" );\r\n\tif ( ! oCanvas.getContext ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvar oCtx = oCanvas.getContext( \"2d\" );\r\n\tif ( ! oCtx.getImageData ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvar aCharList = ( bColor ? aDefaultColorCharList : aDefaultCharList );\r\n\r\n\tif ( charSet ) { aCharList = charSet; }\r\n\r\n\tvar fResolution = 0.5;\r\n\r\n\tswitch ( strResolution ) {\r\n\r\n\t\tcase \"low\" : \tfResolution = 0.25; break;\r\n\t\tcase \"medium\" : fResolution = 0.5; break;\r\n\t\tcase \"high\" : \tfResolution = 1; break;\r\n\r\n\t}\r\n\r\n\tif ( bResolution ) { fResolution = bResolution; }\r\n\r\n\t// Setup dom\r\n\r\n\tvar fFontSize = ( 2 / fResolution ) * iScale;\r\n\tvar fLineHeight = ( 2 / fResolution ) * iScale;\r\n\r\n\t// adjust letter-spacing for all combinations of scale and resolution to get it to fit the image width.\r\n\r\n\tvar fLetterSpacing = 0;\r\n\r\n\t{\r\n\r\n\t\tswitch ( iScale ) {\r\n\t\t\tcase 1 : fLetterSpacing = - 1; break;\r\n\t\t\tcase 2 :\r\n\t\t\tcase 3 : fLetterSpacing = - 2.1; break;\r\n\t\t\tcase 4 : fLetterSpacing = - 3.1; break;\r\n\t\t\tcase 5 : fLetterSpacing = - 4.15; break;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// can't get a span or div to flow like an img element, but a table works?\r\n\r\n\t// convert img element to ascii\r\n\r\n\tfunction asciifyImage( canvasRenderer, oAscii ) {\r\n\r\n\t\toCtx.clearRect( 0, 0, iWidth, iHeight );\r\n\t\toCtx.drawImage( oCanvasImg, 0, 0, iWidth, iHeight );\r\n\t\tvar oImgData = oCtx.getImageData( 0, 0, iWidth, iHeight ).data;\r\n\r\n\t\t// Coloring loop starts now\r\n\t\tvar strChars = \"\";\r\n\r\n\t\t// console.time('rendering');\r\n\r\n\t\tfor ( var y = 0; y < iHeight; y += 2 ) {\r\n\r\n\t\t\tfor ( var x = 0; x < iWidth; x ++ ) {\r\n\r\n\t\t\t\tvar iOffset = ( y * iWidth + x ) * 4;\r\n\r\n\t\t\t\tvar iRed = oImgData[ iOffset ];\r\n\t\t\t\tvar iGreen = oImgData[ iOffset + 1 ];\r\n\t\t\t\tvar iBlue = oImgData[ iOffset + 2 ];\r\n\t\t\t\tvar iAlpha = oImgData[ iOffset + 3 ];\r\n\t\t\t\tvar iCharIdx;\r\n\r\n\t\t\t\tvar fBrightness;\r\n\r\n\t\t\t\tfBrightness = ( 0.3 * iRed + 0.59 * iGreen + 0.11 * iBlue ) / 255;\r\n\t\t\t\t// fBrightness = (0.3*iRed + 0.5*iGreen + 0.3*iBlue) / 255;\r\n\r\n\t\t\t\tif ( iAlpha == 0 ) {\r\n\r\n\t\t\t\t\t// should calculate alpha instead, but quick hack :)\r\n\t\t\t\t\t//fBrightness *= (iAlpha / 255);\r\n\t\t\t\t\tfBrightness = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tiCharIdx = Math.floor( ( 1 - fBrightness ) * ( aCharList.length - 1 ) );\r\n\r\n\t\t\t\tif ( bInvert ) {\r\n\r\n\t\t\t\t\tiCharIdx = aCharList.length - iCharIdx - 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// good for debugging\r\n\t\t\t\t//fBrightness = Math.floor(fBrightness * 10);\r\n\t\t\t\t//strThisChar = fBrightness;\r\n\r\n\t\t\t\tvar strThisChar = aCharList[ iCharIdx ];\r\n\r\n\t\t\t\tif ( strThisChar === undefined || strThisChar == \" \" )\r\n\t\t\t\t\t{ strThisChar = \"&nbsp;\"; }\r\n\r\n\t\t\t\tif ( bColor ) {\r\n\r\n\t\t\t\t\tstrChars += \"<span style='\"\r\n\t\t\t\t\t\t+ \"color:rgb(\" + iRed + \",\" + iGreen + \",\" + iBlue + \");\"\r\n\t\t\t\t\t\t+ ( bBlock ? \"background-color:rgb(\" + iRed + \",\" + iGreen + \",\" + iBlue + \");\" : \"\" )\r\n\t\t\t\t\t\t+ ( bAlpha ? \"opacity:\" + ( iAlpha / 255 ) + \";\" : \"\" )\r\n\t\t\t\t\t\t+ \"'>\" + strThisChar + \"</span>\";\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstrChars += strThisChar;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tstrChars += \"<br/>\";\r\n\r\n\t\t}\r\n\r\n\t\toAscii.innerHTML = \"<tr><td>\" + strChars + \"</td></tr>\";\r\n\r\n\t\t// console.timeEnd('rendering');\r\n\r\n\t\t// return oAscii;\r\n\r\n\t}\r\n\r\n\t// end modified asciifyImage block\r\n\r\n};\n\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\nvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\nvar begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\nvar beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\nvar bsdfs = \"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t}\\n\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit(  ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit(  );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\\n\";\n\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\nvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\nvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\nvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\nvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\n\";\n\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\nvar defaultnormal_vertex = \"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n\";\n\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\nvar encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\nvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\\n\";\n\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\nvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = -mvPosition.z;\\n#endif\\n\";\n\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\\n\";\n\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\\n\";\n\nvar gradientmap_pars_fragment = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\nvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\nvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\nvar lights_pars_begin = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n\";\n\nvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance(  const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance(  const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\nvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n#endif\\n\";\n\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance(  geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance(  geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#ifndef STANDARD\\n\\t\\tclearCoatRadiance += getLightProbeIndirectRadiance(  geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#endif\\n#endif\\n\";\n\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n#endif\\n\";\n\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\\n\";\n\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\nvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\nvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\nvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\\n\";\n\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\nvar normal_fragment_begin = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n#endif\\n\";\n\nvar normal_fragment_maps = \"#ifdef USE_NORMALMAP\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tnormal = - normal;\\n\\t\\t#endif\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t#endif\\n\\t\\tnormal = normalize( normalMatrix * normal );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tuniform mat3 normalMatrix;\\n\\t#else\\n\\t\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\t\\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\\n\\t\\t\\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\\n\\t\\t\\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\\n\\t\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t\\tmapN.xy *= normalScale;\\n\\t\\t\\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t\\treturn normalize( tsn * mapN );\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\nvar project_vertex = \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\nvar dithering_fragment = \"#if defined( DITHERING )\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\\n\";\n\nvar dithering_pars_fragment = \"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\\n\";\n\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\\n\";\n\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\nvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\t\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\nvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\t\\n#endif\\n\";\n\nvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t\\n#endif\\n\";\n\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\\n\";\n\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\nvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\nvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\\n\";\n\nvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\n\nvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\nvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\nvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\\n\";\n\nvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\nvar cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\\n\";\n\nvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\nvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\nvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\\n\";\n\nvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\\n\";\n\nvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\nvar equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\nvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\";\n\nvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\";\n\nvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n\";\n\nvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\\n\";\n\nvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\\n\";\n\nvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar shadow_vert = \"#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar ShaderChunk = {\n\talphamap_fragment: alphamap_fragment,\n\talphamap_pars_fragment: alphamap_pars_fragment,\n\talphatest_fragment: alphatest_fragment,\n\taomap_fragment: aomap_fragment,\n\taomap_pars_fragment: aomap_pars_fragment,\n\tbegin_vertex: begin_vertex,\n\tbeginnormal_vertex: beginnormal_vertex,\n\tbsdfs: bsdfs,\n\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\tclipping_planes_fragment: clipping_planes_fragment,\n\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\tclipping_planes_vertex: clipping_planes_vertex,\n\tcolor_fragment: color_fragment,\n\tcolor_pars_fragment: color_pars_fragment,\n\tcolor_pars_vertex: color_pars_vertex,\n\tcolor_vertex: color_vertex,\n\tcommon: common,\n\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\tdefaultnormal_vertex: defaultnormal_vertex,\n\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\tdisplacementmap_vertex: displacementmap_vertex,\n\temissivemap_fragment: emissivemap_fragment,\n\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\tencodings_fragment: encodings_fragment,\n\tencodings_pars_fragment: encodings_pars_fragment,\n\tenvmap_fragment: envmap_fragment,\n\tenvmap_pars_fragment: envmap_pars_fragment,\n\tenvmap_pars_vertex: envmap_pars_vertex,\n\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\tenvmap_vertex: envmap_vertex,\n\tfog_vertex: fog_vertex,\n\tfog_pars_vertex: fog_pars_vertex,\n\tfog_fragment: fog_fragment,\n\tfog_pars_fragment: fog_pars_fragment,\n\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\tlightmap_fragment: lightmap_fragment,\n\tlightmap_pars_fragment: lightmap_pars_fragment,\n\tlights_lambert_vertex: lights_lambert_vertex,\n\tlights_pars_begin: lights_pars_begin,\n\tlights_phong_fragment: lights_phong_fragment,\n\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\tlights_physical_fragment: lights_physical_fragment,\n\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\tlights_fragment_begin: lights_fragment_begin,\n\tlights_fragment_maps: lights_fragment_maps,\n\tlights_fragment_end: lights_fragment_end,\n\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\tmap_fragment: map_fragment,\n\tmap_pars_fragment: map_pars_fragment,\n\tmap_particle_fragment: map_particle_fragment,\n\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\tmetalnessmap_fragment: metalnessmap_fragment,\n\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\tmorphnormal_vertex: morphnormal_vertex,\n\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\tmorphtarget_vertex: morphtarget_vertex,\n\tnormal_fragment_begin: normal_fragment_begin,\n\tnormal_fragment_maps: normal_fragment_maps,\n\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\tpacking: packing,\n\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\tproject_vertex: project_vertex,\n\tdithering_fragment: dithering_fragment,\n\tdithering_pars_fragment: dithering_pars_fragment,\n\troughnessmap_fragment: roughnessmap_fragment,\n\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\tshadowmap_vertex: shadowmap_vertex,\n\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\tskinbase_vertex: skinbase_vertex,\n\tskinning_pars_vertex: skinning_pars_vertex,\n\tskinning_vertex: skinning_vertex,\n\tskinnormal_vertex: skinnormal_vertex,\n\tspecularmap_fragment: specularmap_fragment,\n\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\ttonemapping_fragment: tonemapping_fragment,\n\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\tuv_pars_fragment: uv_pars_fragment,\n\tuv_pars_vertex: uv_pars_vertex,\n\tuv_vertex: uv_vertex,\n\tuv2_pars_fragment: uv2_pars_fragment,\n\tuv2_pars_vertex: uv2_pars_vertex,\n\tuv2_vertex: uv2_vertex,\n\tworldpos_vertex: worldpos_vertex,\n\n\tcube_frag: cube_frag,\n\tcube_vert: cube_vert,\n\tdepth_frag: depth_frag,\n\tdepth_vert: depth_vert,\n\tdistanceRGBA_frag: distanceRGBA_frag,\n\tdistanceRGBA_vert: distanceRGBA_vert,\n\tequirect_frag: equirect_frag,\n\tequirect_vert: equirect_vert,\n\tlinedashed_frag: linedashed_frag,\n\tlinedashed_vert: linedashed_vert,\n\tmeshbasic_frag: meshbasic_frag,\n\tmeshbasic_vert: meshbasic_vert,\n\tmeshlambert_frag: meshlambert_frag,\n\tmeshlambert_vert: meshlambert_vert,\n\tmeshphong_frag: meshphong_frag,\n\tmeshphong_vert: meshphong_vert,\n\tmeshphysical_frag: meshphysical_frag,\n\tmeshphysical_vert: meshphysical_vert,\n\tnormal_frag: normal_frag,\n\tnormal_vert: normal_vert,\n\tpoints_frag: points_frag,\n\tpoints_vert: points_vert,\n\tshadow_frag: shadow_frag,\n\tshadow_vert: shadow_vert,\n\tsprite_frag: sprite_frag,\n\tsprite_vert: sprite_vert\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar UniformsLib = {\r\n\r\n\tcommon: {\r\n\r\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\r\n\t\topacity: { value: 1.0 },\r\n\r\n\t\tmap: { value: null },\r\n\t\tuvTransform: { value: new Matrix3() },\r\n\r\n\t\talphaMap: { value: null },\r\n\r\n\t},\r\n\r\n\tspecularmap: {\r\n\r\n\t\tspecularMap: { value: null },\r\n\r\n\t},\r\n\r\n\tenvmap: {\r\n\r\n\t\tenvMap: { value: null },\r\n\t\tflipEnvMap: { value: - 1 },\r\n\t\treflectivity: { value: 1.0 },\r\n\t\trefractionRatio: { value: 0.98 },\r\n\t\tmaxMipLevel: { value: 0 }\r\n\r\n\t},\r\n\r\n\taomap: {\r\n\r\n\t\taoMap: { value: null },\r\n\t\taoMapIntensity: { value: 1 }\r\n\r\n\t},\r\n\r\n\tlightmap: {\r\n\r\n\t\tlightMap: { value: null },\r\n\t\tlightMapIntensity: { value: 1 }\r\n\r\n\t},\r\n\r\n\temissivemap: {\r\n\r\n\t\temissiveMap: { value: null }\r\n\r\n\t},\r\n\r\n\tbumpmap: {\r\n\r\n\t\tbumpMap: { value: null },\r\n\t\tbumpScale: { value: 1 }\r\n\r\n\t},\r\n\r\n\tnormalmap: {\r\n\r\n\t\tnormalMap: { value: null },\r\n\t\tnormalScale: { value: new Vector2( 1, 1 ) }\r\n\r\n\t},\r\n\r\n\tdisplacementmap: {\r\n\r\n\t\tdisplacementMap: { value: null },\r\n\t\tdisplacementScale: { value: 1 },\r\n\t\tdisplacementBias: { value: 0 }\r\n\r\n\t},\r\n\r\n\troughnessmap: {\r\n\r\n\t\troughnessMap: { value: null }\r\n\r\n\t},\r\n\r\n\tmetalnessmap: {\r\n\r\n\t\tmetalnessMap: { value: null }\r\n\r\n\t},\r\n\r\n\tgradientmap: {\r\n\r\n\t\tgradientMap: { value: null }\r\n\r\n\t},\r\n\r\n\tfog: {\r\n\r\n\t\tfogDensity: { value: 0.00025 },\r\n\t\tfogNear: { value: 1 },\r\n\t\tfogFar: { value: 2000 },\r\n\t\tfogColor: { value: new Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tlights: {\r\n\r\n\t\tambientLightColor: { value: [] },\r\n\r\n\t\tdirectionalLights: { value: [], properties: {\r\n\t\t\tdirection: {},\r\n\t\t\tcolor: {},\r\n\r\n\t\t\tshadow: {},\r\n\t\t\tshadowBias: {},\r\n\t\t\tshadowRadius: {},\r\n\t\t\tshadowMapSize: {}\r\n\t\t} },\r\n\r\n\t\tdirectionalShadowMap: { value: [] },\r\n\t\tdirectionalShadowMatrix: { value: [] },\r\n\r\n\t\tspotLights: { value: [], properties: {\r\n\t\t\tcolor: {},\r\n\t\t\tposition: {},\r\n\t\t\tdirection: {},\r\n\t\t\tdistance: {},\r\n\t\t\tconeCos: {},\r\n\t\t\tpenumbraCos: {},\r\n\t\t\tdecay: {},\r\n\r\n\t\t\tshadow: {},\r\n\t\t\tshadowBias: {},\r\n\t\t\tshadowRadius: {},\r\n\t\t\tshadowMapSize: {}\r\n\t\t} },\r\n\r\n\t\tspotShadowMap: { value: [] },\r\n\t\tspotShadowMatrix: { value: [] },\r\n\r\n\t\tpointLights: { value: [], properties: {\r\n\t\t\tcolor: {},\r\n\t\t\tposition: {},\r\n\t\t\tdecay: {},\r\n\t\t\tdistance: {},\r\n\r\n\t\t\tshadow: {},\r\n\t\t\tshadowBias: {},\r\n\t\t\tshadowRadius: {},\r\n\t\t\tshadowMapSize: {},\r\n\t\t\tshadowCameraNear: {},\r\n\t\t\tshadowCameraFar: {}\r\n\t\t} },\r\n\r\n\t\tpointShadowMap: { value: [] },\r\n\t\tpointShadowMatrix: { value: [] },\r\n\r\n\t\themisphereLights: { value: [], properties: {\r\n\t\t\tdirection: {},\r\n\t\t\tskyColor: {},\r\n\t\t\tgroundColor: {}\r\n\t\t} },\r\n\r\n\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\r\n\t\trectAreaLights: { value: [], properties: {\r\n\t\t\tcolor: {},\r\n\t\t\tposition: {},\r\n\t\t\twidth: {},\r\n\t\t\theight: {}\r\n\t\t} }\r\n\r\n\t},\r\n\r\n\tpoints: {\r\n\r\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\r\n\t\topacity: { value: 1.0 },\r\n\t\tsize: { value: 1.0 },\r\n\t\tscale: { value: 1.0 },\r\n\t\tmap: { value: null },\r\n\t\tuvTransform: { value: new Matrix3() }\r\n\r\n\t},\r\n\r\n\tsprite: {\r\n\r\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\r\n\t\topacity: { value: 1.0 },\r\n\t\tcenter: { value: new Vector2( 0.5, 0.5 ) },\r\n\t\trotation: { value: 0.0 },\r\n\t\tmap: { value: null },\r\n\t\tuvTransform: { value: new Matrix3() }\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ShaderLib = {\r\n\r\n\tbasic: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.common,\r\n\t\t\tUniformsLib.specularmap,\r\n\t\t\tUniformsLib.envmap,\r\n\t\t\tUniformsLib.aomap,\r\n\t\t\tUniformsLib.lightmap,\r\n\t\t\tUniformsLib.fog\r\n\t\t] ),\r\n\r\n\t\tvertexShader: ShaderChunk.meshbasic_vert,\r\n\t\tfragmentShader: ShaderChunk.meshbasic_frag\r\n\r\n\t},\r\n\r\n\tlambert: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.common,\r\n\t\t\tUniformsLib.specularmap,\r\n\t\t\tUniformsLib.envmap,\r\n\t\t\tUniformsLib.aomap,\r\n\t\t\tUniformsLib.lightmap,\r\n\t\t\tUniformsLib.emissivemap,\r\n\t\t\tUniformsLib.fog,\r\n\t\t\tUniformsLib.lights,\r\n\t\t\t{\r\n\t\t\t\temissive: { value: new Color( 0x000000 ) }\r\n\t\t\t}\r\n\t\t] ),\r\n\r\n\t\tvertexShader: ShaderChunk.meshlambert_vert,\r\n\t\tfragmentShader: ShaderChunk.meshlambert_frag\r\n\r\n\t},\r\n\r\n\tphong: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.common,\r\n\t\t\tUniformsLib.specularmap,\r\n\t\t\tUniformsLib.envmap,\r\n\t\t\tUniformsLib.aomap,\r\n\t\t\tUniformsLib.lightmap,\r\n\t\t\tUniformsLib.emissivemap,\r\n\t\t\tUniformsLib.bumpmap,\r\n\t\t\tUniformsLib.normalmap,\r\n\t\t\tUniformsLib.displacementmap,\r\n\t\t\tUniformsLib.gradientmap,\r\n\t\t\tUniformsLib.fog,\r\n\t\t\tUniformsLib.lights,\r\n\t\t\t{\r\n\t\t\t\temissive: { value: new Color( 0x000000 ) },\r\n\t\t\t\tspecular: { value: new Color( 0x111111 ) },\r\n\t\t\t\tshininess: { value: 30 }\r\n\t\t\t}\r\n\t\t] ),\r\n\r\n\t\tvertexShader: ShaderChunk.meshphong_vert,\r\n\t\tfragmentShader: ShaderChunk.meshphong_frag\r\n\r\n\t},\r\n\r\n\tstandard: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.common,\r\n\t\t\tUniformsLib.envmap,\r\n\t\t\tUniformsLib.aomap,\r\n\t\t\tUniformsLib.lightmap,\r\n\t\t\tUniformsLib.emissivemap,\r\n\t\t\tUniformsLib.bumpmap,\r\n\t\t\tUniformsLib.normalmap,\r\n\t\t\tUniformsLib.displacementmap,\r\n\t\t\tUniformsLib.roughnessmap,\r\n\t\t\tUniformsLib.metalnessmap,\r\n\t\t\tUniformsLib.fog,\r\n\t\t\tUniformsLib.lights,\r\n\t\t\t{\r\n\t\t\t\temissive: { value: new Color( 0x000000 ) },\r\n\t\t\t\troughness: { value: 0.5 },\r\n\t\t\t\tmetalness: { value: 0.5 },\r\n\t\t\t\tenvMapIntensity: { value: 1 } // temporary\r\n\t\t\t}\r\n\t\t] ),\r\n\r\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\r\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\r\n\r\n\t},\r\n\r\n\tpoints: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.points,\r\n\t\t\tUniformsLib.fog\r\n\t\t] ),\r\n\r\n\t\tvertexShader: ShaderChunk.points_vert,\r\n\t\tfragmentShader: ShaderChunk.points_frag\r\n\r\n\t},\r\n\r\n\tdashed: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.common,\r\n\t\t\tUniformsLib.fog,\r\n\t\t\t{\r\n\t\t\t\tscale: { value: 1 },\r\n\t\t\t\tdashSize: { value: 1 },\r\n\t\t\t\ttotalSize: { value: 2 }\r\n\t\t\t}\r\n\t\t] ),\r\n\r\n\t\tvertexShader: ShaderChunk.linedashed_vert,\r\n\t\tfragmentShader: ShaderChunk.linedashed_frag\r\n\r\n\t},\r\n\r\n\tdepth: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.common,\r\n\t\t\tUniformsLib.displacementmap\r\n\t\t] ),\r\n\r\n\t\tvertexShader: ShaderChunk.depth_vert,\r\n\t\tfragmentShader: ShaderChunk.depth_frag\r\n\r\n\t},\r\n\r\n\tnormal: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.common,\r\n\t\t\tUniformsLib.bumpmap,\r\n\t\t\tUniformsLib.normalmap,\r\n\t\t\tUniformsLib.displacementmap,\r\n\t\t\t{\r\n\t\t\t\topacity: { value: 1.0 }\r\n\t\t\t}\r\n\t\t] ),\r\n\r\n\t\tvertexShader: ShaderChunk.normal_vert,\r\n\t\tfragmentShader: ShaderChunk.normal_frag\r\n\r\n\t},\r\n\r\n\tsprite: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.sprite,\r\n\t\t\tUniformsLib.fog\r\n\t\t] ),\r\n\r\n\t\tvertexShader: ShaderChunk.sprite_vert,\r\n\t\tfragmentShader: ShaderChunk.sprite_frag\r\n\r\n\t},\r\n\r\n\tcube: {\r\n\r\n\t\tuniforms: {\r\n\t\t\ttCube: { value: null },\r\n\t\t\ttFlip: { value: - 1 },\r\n\t\t\topacity: { value: 1.0 }\r\n\t\t},\r\n\r\n\t\tvertexShader: ShaderChunk.cube_vert,\r\n\t\tfragmentShader: ShaderChunk.cube_frag\r\n\r\n\t},\r\n\r\n\tequirect: {\r\n\r\n\t\tuniforms: {\r\n\t\t\ttEquirect: { value: null },\r\n\t\t},\r\n\r\n\t\tvertexShader: ShaderChunk.equirect_vert,\r\n\t\tfragmentShader: ShaderChunk.equirect_frag\r\n\r\n\t},\r\n\r\n\tdistanceRGBA: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.common,\r\n\t\t\tUniformsLib.displacementmap,\r\n\t\t\t{\r\n\t\t\t\treferencePosition: { value: new Vector3() },\r\n\t\t\t\tnearDistance: { value: 1 },\r\n\t\t\t\tfarDistance: { value: 1000 }\r\n\t\t\t}\r\n\t\t] ),\r\n\r\n\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\r\n\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\r\n\r\n\t},\r\n\r\n\tshadow: {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib.lights,\r\n\t\t\tUniformsLib.fog,\r\n\t\t\t{\r\n\t\t\t\tcolor: { value: new Color( 0x00000 ) },\r\n\t\t\t\topacity: { value: 1.0 }\r\n\t\t\t} ] ),\r\n\r\n\t\tvertexShader: ShaderChunk.shadow_vert,\r\n\t\tfragmentShader: ShaderChunk.shadow_frag\r\n\r\n\t}\r\n\r\n};\r\n\r\nShaderLib.physical = {\r\n\r\n\tuniforms: UniformsUtils.merge( [\r\n\t\tShaderLib.standard.uniforms,\r\n\t\t{\r\n\t\t\tclearCoat: { value: 0 },\r\n\t\t\tclearCoatRoughness: { value: 0 }\r\n\t\t}\r\n\t] ),\r\n\r\n\tvertexShader: ShaderChunk.meshphysical_vert,\r\n\tfragmentShader: ShaderChunk.meshphysical_frag\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar OutlineEffect = function ( renderer, parameters ) {\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tthis.enabled = true;\r\n\r\n\tvar defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\r\n\tvar defaultColor = new Color().fromArray( parameters.defaultColor !== undefined ? parameters.defaultColor : [ 0, 0, 0 ] );\r\n\tvar defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\r\n\tvar defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\r\n\r\n\t// object.material.uuid -> outlineMaterial or\r\n\t// object.material[ n ].uuid -> outlineMaterial\r\n\t// save at the outline material creation and release\r\n\t// if it's unused removeThresholdCount frames\r\n\t// unless keepAlive is true.\r\n\tvar cache = {};\r\n\r\n\tvar removeThresholdCount = 60;\r\n\r\n\t// outlineMaterial.uuid -> object.material or\r\n\t// outlineMaterial.uuid -> object.material[ n ]\r\n\t// save before render and release after render.\r\n\tvar originalMaterials = {};\r\n\r\n\t// object.uuid -> originalOnBeforeRender\r\n\t// save before render and release after render.\r\n\tvar originalOnBeforeRenders = {};\r\n\r\n\t//this.cache = cache;  // for debug\r\n\r\n\t// copied from WebGLPrograms and removed some materials\r\n\tvar shaderIDs = {\r\n\t\tMeshBasicMaterial: 'basic',\r\n\t\tMeshLambertMaterial: 'lambert',\r\n\t\tMeshPhongMaterial: 'phong',\r\n\t\tMeshToonMaterial: 'phong',\r\n\t\tMeshStandardMaterial: 'physical',\r\n\t\tMeshPhysicalMaterial: 'physical'\r\n\t};\r\n\r\n\tvar uniformsChunk = {\r\n\t\toutlineThickness: { type: \"f\", value: defaultThickness },\r\n\t\toutlineColor: { type: \"c\", value: defaultColor },\r\n\t\toutlineAlpha: { type: \"f\", value: defaultAlpha }\r\n\t};\r\n\r\n\tvar vertexShaderChunk = [\r\n\r\n\t\t\"#include <fog_pars_vertex>\",\r\n\r\n\t\t\"uniform float outlineThickness;\",\r\n\r\n\t\t\"vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {\",\r\n\r\n\t\t\"\tfloat thickness = outlineThickness;\",\r\n\t\t\"\tconst float ratio = 1.0;\", // TODO: support outline thickness ratio for each vertex\r\n\t\t\"\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );\",\r\n\t\t// NOTE: subtract pos2 from pos because BackSide objectNormal is negative\r\n\t\t\"\tvec4 norm = normalize( pos - pos2 );\",\r\n\t\t\"\treturn pos + norm * thickness * pos.w * ratio;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" );\r\n\r\n\tvar vertexShaderChunk2 = [\r\n\r\n\t\t\"#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( PHYSICAL )\",\r\n\t\t\"\t#ifndef USE_ENVMAP\",\r\n\t\t\"\t\tvec3 objectNormal = normalize( normal );\",\r\n\t\t\"\t#endif\",\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef FLIP_SIDED\",\r\n\t\t\"\tobjectNormal = -objectNormal;\",\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef DECLARE_TRANSFORMED\",\r\n\t\t\"\tvec3 transformed = vec3( position );\",\r\n\t\t\"#endif\",\r\n\r\n\t\t\"gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );\",\r\n\r\n\t\t\"#include <fog_vertex>\"\r\n\r\n\t].join( \"\\n\" );\r\n\r\n\tvar fragmentShader = [\r\n\r\n\t\t\"#include <common>\",\r\n\t\t\"#include <fog_pars_fragment>\",\r\n\r\n\t\t\"uniform vec3 outlineColor;\",\r\n\t\t\"uniform float outlineAlpha;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\"\tgl_FragColor = vec4( outlineColor, outlineAlpha );\",\r\n\r\n\t\t\"\t#include <fog_fragment>\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" );\r\n\r\n\tfunction createInvisibleMaterial() {\r\n\r\n\t\treturn new ShaderMaterial( { name: 'invisible', visible: false } );\r\n\r\n\t}\r\n\r\n\tfunction createMaterial( originalMaterial ) {\r\n\r\n\t\tvar shaderID = shaderIDs[ originalMaterial.type ];\r\n\t\tvar originalUniforms, originalVertexShader;\r\n\t\tvar outlineParameters = originalMaterial.userData.outlineParameters;\r\n\r\n\t\tif ( shaderID !== undefined ) {\r\n\r\n\t\t\tvar shader = ShaderLib[ shaderID ];\r\n\t\t\toriginalUniforms = shader.uniforms;\r\n\t\t\toriginalVertexShader = shader.vertexShader;\r\n\r\n\t\t} else if ( originalMaterial.isRawShaderMaterial === true ) {\r\n\r\n\t\t\toriginalUniforms = originalMaterial.uniforms;\r\n\t\t\toriginalVertexShader = originalMaterial.vertexShader;\r\n\r\n\t\t\tif ( ! /attribute\\s+vec3\\s+position\\s*;/.test( originalVertexShader ) ||\r\n\t\t\t     ! /attribute\\s+vec3\\s+normal\\s*;/.test( originalVertexShader ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'OutlineEffect requires both vec3 position and normal attributes in vertex shader, ' +\r\n\t\t\t\t              'does not draw outline for ' + originalMaterial.name + '(uuid:' + originalMaterial.uuid + ') material.' );\r\n\r\n\t\t\t\treturn createInvisibleMaterial();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( originalMaterial.isShaderMaterial === true ) {\r\n\r\n\t\t\toriginalUniforms = originalMaterial.uniforms;\r\n\t\t\toriginalVertexShader = originalMaterial.vertexShader;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn createInvisibleMaterial();\r\n\r\n\t\t}\r\n\r\n\t\tvar uniforms = Object.assign( {}, originalUniforms, uniformsChunk );\r\n\r\n\t\tvar vertexShader = originalVertexShader\r\n\t\t\t\t\t// put vertexShaderChunk right before \"void main() {...}\"\r\n\t\t\t\t\t.replace( /void\\s+main\\s*\\(\\s*\\)/, vertexShaderChunk + '\\nvoid main()' )\r\n\t\t\t\t\t// put vertexShaderChunk2 the end of \"void main() {...}\"\r\n\t\t\t\t\t// Note: here assums originalVertexShader ends with \"}\" of \"void main() {...}\"\r\n\t\t\t\t\t.replace( /\\}\\s*$/, vertexShaderChunk2 + '\\n}' )\r\n\t\t\t\t\t// remove any light related lines\r\n\t\t\t\t\t// Note: here is very sensitive to originalVertexShader\r\n\t\t\t\t\t// TODO: consider safer way\r\n\t\t\t\t\t.replace( /#include\\s+<[\\w_]*light[\\w_]*>/g, '' );\r\n\r\n\t\tvar defines = {};\r\n\r\n\t\tif ( ! /vec3\\s+transformed\\s*=/.test( originalVertexShader ) &&\r\n\t\t     ! /#include\\s+<begin_vertex>/.test( originalVertexShader ) ) { defines.DECLARE_TRANSFORMED = true; }\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\t\t\tdefines: defines,\r\n\t\t\tuniforms: uniforms,\r\n\t\t\tvertexShader: vertexShader,\r\n\t\t\tfragmentShader: fragmentShader,\r\n\t\t\tside: BackSide,\r\n\t\t\t//wireframe: true,\r\n\t\t\tskinning: false,\r\n\t\t\tmorphTargets: false,\r\n\t\t\tmorphNormals: false,\r\n\t\t\tfog: false\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tfunction getOutlineMaterialFromCache( originalMaterial ) {\r\n\r\n\t\tvar data = cache[ originalMaterial.uuid ];\r\n\r\n\t\tif ( data === undefined ) {\r\n\r\n\t\t\tdata = {\r\n\t\t\t\tmaterial: createMaterial( originalMaterial ),\r\n\t\t\t\tused: true,\r\n\t\t\t\tkeepAlive: defaultKeepAlive,\r\n\t\t\t\tcount: 0\r\n\t\t\t};\r\n\r\n\t\t\tcache[ originalMaterial.uuid ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tdata.used = true;\r\n\r\n\t\treturn data.material;\r\n\r\n\t}\r\n\r\n\tfunction getOutlineMaterial( originalMaterial ) {\r\n\r\n\t\tvar outlineMaterial = getOutlineMaterialFromCache( originalMaterial );\r\n\r\n\t\toriginalMaterials[ outlineMaterial.uuid ] = originalMaterial;\r\n\r\n\t\tupdateOutlineMaterial( outlineMaterial, originalMaterial );\r\n\r\n\t\treturn outlineMaterial;\r\n\r\n\t}\r\n\r\n\tfunction setOutlineMaterial( object ) {\r\n\r\n\t\tif ( object.material === undefined ) { return; }\r\n\r\n\t\tif ( Array.isArray( object.material ) ) {\r\n\r\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tobject.material[ i ] = getOutlineMaterial( object.material[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject.material = getOutlineMaterial( object.material );\r\n\r\n\t\t}\r\n\r\n\t\toriginalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;\r\n\t\tobject.onBeforeRender = onBeforeRender;\r\n\r\n\t}\r\n\r\n\tfunction restoreOriginalMaterial( object ) {\r\n\r\n\t\tif ( object.material === undefined ) { return; }\r\n\r\n\t\tif ( Array.isArray( object.material ) ) {\r\n\r\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tobject.material[ i ] = originalMaterials[ object.material[ i ].uuid ];\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject.material = originalMaterials[ object.material.uuid ];\r\n\r\n\t\t}\r\n\r\n\t\tobject.onBeforeRender = originalOnBeforeRenders[ object.uuid ];\r\n\r\n\t}\r\n\r\n\tfunction onBeforeRender( renderer, scene, camera, geometry, material, group ) {\r\n\r\n\t\tvar originalMaterial = originalMaterials[ material.uuid ];\r\n\r\n\t\t// just in case\r\n\t\tif ( originalMaterial === undefined ) { return; }\r\n\r\n\t\tupdateUniforms( material, originalMaterial );\r\n\r\n\t}\r\n\r\n\tfunction updateUniforms( material, originalMaterial ) {\r\n\r\n\t\tvar outlineParameters = originalMaterial.userData.outlineParameters;\r\n\r\n\t\tmaterial.uniforms.outlineAlpha.value = originalMaterial.opacity;\r\n\r\n\t\tif ( outlineParameters !== undefined ) {\r\n\r\n\t\t\tif ( outlineParameters.thickness !== undefined ) { material.uniforms.outlineThickness.value = outlineParameters.thickness; }\r\n\t\t\tif ( outlineParameters.color !== undefined ) { material.uniforms.outlineColor.value.fromArray( outlineParameters.color ); }\r\n\t\t\tif ( outlineParameters.alpha !== undefined ) { material.uniforms.outlineAlpha.value = outlineParameters.alpha; }\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction updateOutlineMaterial( material, originalMaterial ) {\r\n\r\n\t\tif ( material.name === 'invisible' ) { return; }\r\n\r\n\t\tvar outlineParameters = originalMaterial.userData.outlineParameters;\r\n\r\n\t\tmaterial.skinning = originalMaterial.skinning;\r\n\t\tmaterial.morphTargets = originalMaterial.morphTargets;\r\n\t\tmaterial.morphNormals = originalMaterial.morphNormals;\r\n\t\tmaterial.fog = originalMaterial.fog;\r\n\r\n\t\tif ( outlineParameters !== undefined ) {\r\n\r\n\t\t\tif ( originalMaterial.visible === false ) {\r\n\r\n\t\t\t\tmaterial.visible = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;\r\n\r\n\t\t\tif ( outlineParameters.keepAlive !== undefined ) { cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive; }\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.transparent = originalMaterial.transparent;\r\n\t\t\tmaterial.visible = originalMaterial.visible;\r\n\r\n\t\t}\r\n\r\n\t\tif ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) { material.visible = false; }\r\n\r\n\t}\r\n\r\n\tfunction cleanupCache() {\r\n\r\n\t\tvar keys;\r\n\r\n\t\t// clear originialMaterials\r\n\t\tkeys = Object.keys( originalMaterials );\r\n\r\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\toriginalMaterials[ keys[ i ] ] = undefined;\r\n\r\n\t\t}\r\n\r\n\t\t// clear originalOnBeforeRenders\r\n\t\tkeys = Object.keys( originalOnBeforeRenders );\r\n\r\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\toriginalOnBeforeRenders[ keys[ i ] ] = undefined;\r\n\r\n\t\t}\r\n\r\n\t\t// remove unused outlineMaterial from cache\r\n\t\tkeys = Object.keys( cache );\r\n\r\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar key = keys[ i ];\r\n\r\n\t\t\tif ( cache[ key ].used === false ) {\r\n\r\n\t\t\t\tcache[ key ].count++;\r\n\r\n\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {\r\n\r\n\t\t\t\t\tdelete cache[ key ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcache[ key ].used = false;\r\n\t\t\t\tcache[ key ].count = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( this.enabled === false ) {\r\n\r\n\t\t\trenderer.render( scene, camera, renderTarget, forceClear );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar currentAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = this.autoClear;\r\n\r\n\t\t// 1. render normally\r\n\t\trenderer.render( scene, camera, renderTarget, forceClear );\r\n\r\n\t\t// 2. render outline\r\n\t\tvar currentSceneAutoUpdate = scene.autoUpdate;\r\n\t\tvar currentSceneBackground = scene.background;\r\n\t\tvar currentShadowMapEnabled = renderer.shadowMap.enabled;\r\n\r\n\t\tscene.autoUpdate = false;\r\n\t\tscene.background = null;\r\n\t\trenderer.autoClear = false;\r\n\t\trenderer.shadowMap.enabled = false;\r\n\r\n\t\tscene.traverse( setOutlineMaterial );\r\n\r\n\t\trenderer.render( scene, camera, renderTarget );\r\n\r\n\t\tscene.traverse( restoreOriginalMaterial );\r\n\r\n\t\tcleanupCache();\r\n\r\n\t\tscene.autoUpdate = currentSceneAutoUpdate;\r\n\t\tscene.background = currentSceneBackground;\r\n\t\trenderer.autoClear = currentAutoClear;\r\n\t\trenderer.shadowMap.enabled = currentShadowMapEnabled;\r\n\r\n\t};\r\n\t\r\n\tthis.autoClear = renderer.autoClear;\r\n\tthis.domElement = renderer.domElement;\r\n\tthis.shadowMap = renderer.shadowMap;\r\n\r\n\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\trenderer.clear( color, depth, stencil );\r\n\r\n\t};\r\n\r\n\tthis.getPixelRatio = function () {\r\n\r\n\t\treturn renderer.getPixelRatio();\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function ( value ) {\r\n\r\n\t\trenderer.setPixelRatio( value );\r\n\r\n\t};\r\n\r\n\tthis.getSize = function () {\r\n\r\n\t\treturn renderer.getSize();\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\trenderer.setSize( width, height, updateStyle );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\trenderer.setViewport( x, y, width, height );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\trenderer.setScissor( x, y, width, height );\r\n\r\n\t};\r\n\r\n\tthis.setScissorTest = function ( boolean ) {\r\n\r\n\t\trenderer.setScissorTest( boolean );\r\n\r\n\t};\r\n\r\n\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\trenderer.setRenderTarget( renderTarget );\r\n\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ParallaxBarrierEffect = function ( renderer ) {\r\n\r\n\tvar _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\r\n\tvar _scene = new Scene();\r\n\r\n\tvar _stereo = new StereoCamera();\r\n\r\n\tvar _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };\r\n\r\n\tvar _renderTargetL = new WebGLRenderTarget( 512, 512, _params );\r\n\tvar _renderTargetR = new WebGLRenderTarget( 512, 512, _params );\r\n\r\n\tvar _material = new ShaderMaterial( {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"mapLeft\": { value: _renderTargetL.texture },\r\n\t\t\t\"mapRight\": { value: _renderTargetR.texture }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvUv = vec2( uv.x, uv.y );\",\r\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D mapLeft;\",\r\n\t\t\t\"uniform sampler2D mapRight;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec2 uv = vUv;\",\r\n\r\n\t\t\t\"\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {\",\r\n\r\n\t\t\t\"\t\tgl_FragColor = texture2D( mapLeft, uv );\",\r\n\r\n\t\t\t\"\t} else {\",\r\n\r\n\t\t\t\"\t\tgl_FragColor = texture2D( mapRight, uv );\",\r\n\r\n\t\t\t\"\t}\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t} );\r\n\r\n\tvar mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), _material );\r\n\t_scene.add( mesh );\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\trenderer.setSize( width, height );\r\n\r\n\t\tvar pixelRatio = renderer.getPixelRatio();\r\n\r\n\t\t_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );\r\n\t\t_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\tif ( camera.parent === null ) { camera.updateMatrixWorld(); }\r\n\r\n\t\t_stereo.update( camera );\r\n\r\n\t\trenderer.render( scene, _stereo.cameraL, _renderTargetL, true );\r\n\t\trenderer.render( scene, _stereo.cameraR, _renderTargetR, true );\r\n\t\trenderer.render( _scene, _camera );\r\n\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PeppersGhostEffect = function ( renderer ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tscope.cameraDistance = 15;\r\n\tscope.reflectFromAbove = false;\r\n\r\n\t// Internals\r\n\tvar _halfWidth, _width, _height;\r\n\r\n\tvar _cameraF = new PerspectiveCamera(); //front\r\n\tvar _cameraB = new PerspectiveCamera(); //back\r\n\tvar _cameraL = new PerspectiveCamera(); //left\r\n\tvar _cameraR = new PerspectiveCamera(); //right\r\n\r\n\tvar _position = new Vector3();\r\n\tvar _quaternion = new Quaternion();\r\n\tvar _scale = new Vector3();\r\n\r\n\t// Initialization\r\n\trenderer.autoClear = false;\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\t_halfWidth = width / 2;\r\n\t\tif ( width < height ) {\r\n\r\n\t\t\t_width = width / 3;\r\n\t\t\t_height = width / 3;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_width = height / 3;\r\n\t\t\t_height = height / 3;\r\n\r\n\t\t}\r\n\t\trenderer.setSize( width, height );\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\tif ( camera.parent === null ) { camera.updateMatrixWorld(); }\r\n\r\n\t\tcamera.matrixWorld.decompose( _position, _quaternion, _scale );\r\n\r\n\t\t// front\r\n\t\t_cameraF.position.copy( _position );\r\n\t\t_cameraF.quaternion.copy( _quaternion );\r\n\t\t_cameraF.translateZ( scope.cameraDistance );\r\n\t\t_cameraF.lookAt( scene.position );\r\n\r\n\t\t// back\r\n\t\t_cameraB.position.copy( _position );\r\n\t\t_cameraB.quaternion.copy( _quaternion );\r\n\t\t_cameraB.translateZ( - ( scope.cameraDistance ) );\r\n\t\t_cameraB.lookAt( scene.position );\r\n\t\t_cameraB.rotation.z += 180 * ( Math.PI / 180 );\r\n\r\n\t\t// left\r\n\t\t_cameraL.position.copy( _position );\r\n\t\t_cameraL.quaternion.copy( _quaternion );\r\n\t\t_cameraL.translateX( - ( scope.cameraDistance ) );\r\n\t\t_cameraL.lookAt( scene.position );\r\n\t\t_cameraL.rotation.x += 90 * ( Math.PI / 180 );\r\n\r\n\t\t// right\r\n\t\t_cameraR.position.copy( _position );\r\n\t\t_cameraR.quaternion.copy( _quaternion );\r\n\t\t_cameraR.translateX( scope.cameraDistance );\r\n\t\t_cameraR.lookAt( scene.position );\r\n\t\t_cameraR.rotation.x += 90 * ( Math.PI / 180 );\r\n\r\n\t\trenderer.clear();\r\n\t\trenderer.setScissorTest( true );\r\n\r\n\t\trenderer.setScissor( _halfWidth - ( _width / 2 ), ( _height * 2 ), _width, _height );\r\n\t\trenderer.setViewport( _halfWidth - ( _width / 2 ), ( _height * 2 ), _width, _height );\r\n\r\n\t\tif ( scope.reflectFromAbove ) {\r\n\r\n\t\t\trenderer.render( scene, _cameraB );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( scene, _cameraF );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setScissor( _halfWidth - ( _width / 2 ), 0, _width, _height );\r\n\t\trenderer.setViewport( _halfWidth - ( _width / 2 ), 0, _width, _height );\r\n\r\n\t\tif ( scope.reflectFromAbove ) {\r\n\r\n\t\t\trenderer.render( scene, _cameraF );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( scene, _cameraB );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setScissor( _halfWidth - ( _width / 2 ) - _width, _height, _width, _height );\r\n\t\trenderer.setViewport( _halfWidth - ( _width / 2 ) - _width, _height, _width, _height );\r\n\r\n\t\tif ( scope.reflectFromAbove ) {\r\n\r\n\t\t\trenderer.render( scene, _cameraR );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( scene, _cameraL );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setScissor( _halfWidth + ( _width / 2 ), _height, _width, _height );\r\n\t\trenderer.setViewport( _halfWidth + ( _width / 2 ), _height, _width, _height );\r\n\r\n\t\tif ( scope.reflectFromAbove ) {\r\n\r\n\t\t\trenderer.render( scene, _cameraL );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( scene, _cameraR );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setScissorTest( false );\r\n\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar StereoEffect = function ( renderer ) {\r\n\r\n\tvar _stereo = new StereoCamera();\r\n\t_stereo.aspect = 0.5;\r\n\r\n\tthis.setEyeSeparation = function ( eyeSep ) {\r\n\r\n\t\t_stereo.eyeSep = eyeSep;\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\trenderer.setSize( width, height );\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\tif ( camera.parent === null ) { camera.updateMatrixWorld(); }\r\n\r\n\t\t_stereo.update( camera );\r\n\r\n\t\tvar size = renderer.getSize();\r\n\r\n\t\tif ( renderer.autoClear ) { renderer.clear(); }\r\n\t\trenderer.setScissorTest( true );\r\n\r\n\t\trenderer.setScissor( 0, 0, size.width / 2, size.height );\r\n\t\trenderer.setViewport( 0, 0, size.width / 2, size.height );\r\n\t\trenderer.render( scene, _stereo.cameraL );\r\n\r\n\t\trenderer.setScissor( size.width / 2, 0, size.width / 2, size.height );\r\n\t\trenderer.setViewport( size.width / 2, 0, size.width / 2, size.height );\r\n\t\trenderer.render( scene, _stereo.cameraR );\r\n\r\n\t\trenderer.setScissorTest( false );\r\n\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ColladaExporter = function () {};\r\n\r\nColladaExporter.prototype = {\r\n\r\n\tconstructor: ColladaExporter,\r\n\r\n\tparse: function ( object, onDone, options ) {\n\t\tif ( options === void 0 ) options = {};\n\r\n\r\n\t\toptions = Object.assign( {\r\n\t\t\tversion: '1.4.1',\r\n\t\t\tauthor: null,\r\n\t\t\ttextureDirectory: '',\r\n\t\t}, options );\r\n\r\n\t\tif ( options.textureDirectory !== '' ) {\r\n\r\n\t\t\toptions.textureDirectory = ((options.textureDirectory) + \"/\")\r\n\t\t\t\t.replace( /\\\\/g, '/' )\r\n\t\t\t\t.replace( /\\/+/g, '/' );\r\n\r\n\t\t}\r\n\r\n\t\tvar version = options.version;\r\n\t\tif ( version !== '1.4.1' && version !== '1.5.0' ) {\r\n\r\n\t\t\tconsole.warn( (\"ColladaExporter : Version \" + version + \" not supported for export. Only 1.4.1 and 1.5.0.\") );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// Convert the urdf xml into a well-formatted, indented format\r\n\t\tfunction format( urdf ) {\r\n\r\n\t\t\tvar IS_END_TAG = /^<\\//;\r\n\t\t\tvar IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\r\n\t\t\tvar HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\r\n\r\n\t\t\tvar pad = function ( ch, num ) { return ( num > 0 ? ch + pad( ch, num - 1 ) : '' ); };\r\n\r\n\t\t\tvar tagnum = 0;\r\n\t\t\treturn urdf\r\n\t\t\t\t.match( /(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g )\r\n\t\t\t\t.map( function (tag) {\r\n\r\n\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && IS_END_TAG.test( tag ) ) {\r\n\r\n\t\t\t\t\t\ttagnum --;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar res = \"\" + (pad( '  ', tagnum )) + tag;\r\n\r\n\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && ! IS_END_TAG.test( tag ) ) {\r\n\r\n\t\t\t\t\t\ttagnum ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn res;\r\n\r\n\t\t\t\t} )\r\n\t\t\t\t.join( '\\n' );\r\n\r\n\t\t}\r\n\r\n\t\t// Convert an image into a png format for saving\r\n\t\tfunction base64ToBuffer( str ) {\r\n\r\n\t\t\tvar b = atob( str );\r\n\t\t\tvar buf = new Uint8Array( b.length );\r\n\r\n\t\t\tfor ( var i = 0, l = buf.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tbuf[ i ] = b.charCodeAt( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buf;\r\n\r\n\t\t}\r\n\r\n\t\tvar canvas, ctx;\r\n\t\tfunction imageToData( image, ext ) {\r\n\r\n\t\t\tcanvas = canvas || document.createElement( 'canvas' );\r\n\t\t\tctx = ctx || canvas.getContext( '2d' );\r\n\r\n\t\t\tcanvas.width = image.naturalWidth;\r\n\t\t\tcanvas.height = image.naturalHeight;\r\n\r\n\t\t\tctx.drawImage( image, 0, 0 );\r\n\r\n\t\t\t// Get the base64 encoded data\r\n\t\t\tvar base64data = canvas\r\n\t\t\t\t.toDataURL( (\"image/\" + ext), 1 )\r\n\t\t\t\t.replace( /^data:image\\/(png|jpg);base64,/, '' );\r\n\r\n\t\t\t// Convert to a uint8 array\r\n\t\t\treturn base64ToBuffer( base64data );\r\n\r\n\t\t}\r\n\r\n\t\t// gets the attribute array. Generate a new array if the attribute is interleaved\r\n\t\tvar getFuncs = [ 'getX', 'getY', 'getZ', 'getW' ];\r\n\t\tfunction attrBufferToArray( attr ) {\r\n\r\n\t\t\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\t\t// use the typed array constructor to save on memory\r\n\t\t\t\tvar arr = new attr.array.constructor( attr.count * attr.itemSize );\r\n\t\t\t\tvar size = attr.itemSize;\r\n\t\t\t\tfor ( var i = 0, l = attr.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < size; j ++ ) {\r\n\r\n\t\t\t\t\t\tarr[ i * size + j ] = attr[ getFuncs[ j ] ]( i );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn arr;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn attr.array;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Returns an array of the same type starting at the `st` index,\r\n\t\t// and `ct` length\r\n\t\tfunction subArray( arr, st, ct ) {\r\n\r\n\t\t\tif ( Array.isArray( arr ) ) { return arr.slice( st, st + ct ); }\r\n\t\t\telse { return new arr.constructor( arr.buffer, st * arr.BYTES_PER_ELEMENT, ct ); }\r\n\r\n\t\t}\r\n\r\n\t\t// Returns the string for a geometry's attribute\r\n\t\tfunction getAttribute( attr, name, params, type ) {\r\n\r\n\t\t\tvar array = attrBufferToArray( attr );\r\n\t\t\tvar res =\r\n\t\t\t\t\t\"<source id=\\\"\" + name + \"\\\">\" +\r\n\r\n\t\t\t\t\t\"<float_array id=\\\"\" + name + \"-array\\\" count=\\\"\" + (array.length) + \"\\\">\" +\r\n\t\t\t\t\tarray.join( ' ' ) +\r\n\t\t\t\t\t'</float_array>' +\r\n\r\n\t\t\t\t\t'<technique_common>' +\r\n\t\t\t\t\t\"<accessor source=\\\"#\" + name + \"-array\\\" count=\\\"\" + (Math.floor( array.length / attr.itemSize )) + \"\\\" stride=\\\"\" + (attr.itemSize) + \"\\\">\" +\r\n\r\n\t\t\t\t\tparams.map( function (n) { return (\"<param name=\\\"\" + n + \"\\\" type=\\\"\" + type + \"\\\" />\"); } ).join( '' ) +\r\n\r\n\t\t\t\t\t'</accessor>' +\r\n\t\t\t\t\t'</technique_common>' +\r\n\t\t\t\t\t'</source>';\r\n\r\n\t\t\treturn res;\r\n\r\n\t\t}\r\n\r\n\t\t// Returns the string for a node's transform information\r\n\t\tvar transMat;\r\n\t\tfunction getTransform( o ) {\r\n\r\n\t\t\t// ensure the object's matrix is up to date\r\n\t\t\t// before saving the transform\r\n\t\t\to.updateMatrix();\r\n\r\n\t\t\ttransMat = transMat || new Matrix4();\r\n\t\t\ttransMat.copy( o.matrix );\r\n\t\t\ttransMat.transpose();\r\n\t\t\treturn (\"<matrix>\" + (transMat.toArray().join( ' ' )) + \"</matrix>\");\r\n\r\n\t\t}\r\n\r\n\t\t// Process the given piece of geometry into the geometry library\r\n\t\t// Returns the mesh id\r\n\t\tfunction processGeometry( g ) {\r\n\r\n\t\t\tvar info = geometryInfo.get( g );\r\n\r\n\t\t\tif ( ! info ) {\r\n\r\n\t\t\t\t// convert the geometry to bufferGeometry if it isn't already\r\n\t\t\t\tvar bufferGeometry = g;\r\n\t\t\t\tif ( bufferGeometry instanceof Geometry ) {\r\n\r\n\t\t\t\t\tbufferGeometry = ( new BufferGeometry() ).fromGeometry( bufferGeometry );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar meshid = \"Mesh\" + (libraryGeometries.length + 1);\r\n\r\n\t\t\t\tvar indexCount =\r\n\t\t\t\t\tbufferGeometry.index ?\r\n\t\t\t\t\t\tbufferGeometry.index.count * bufferGeometry.index.itemSize :\r\n\t\t\t\t\t\tbufferGeometry.attributes.position.count;\r\n\r\n\t\t\t\tvar groups =\r\n\t\t\t\t\tbufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ?\r\n\t\t\t\t\t\tbufferGeometry.groups :\r\n\t\t\t\t\t\t[ { start: 0, count: indexCount, materialIndex: 0 } ];\r\n\r\n\t\t\t\tvar gnode = \"<geometry id=\\\"\" + meshid + \"\\\" name=\\\"\" + (g.name) + \"\\\"><mesh>\";\r\n\r\n\t\t\t\t// define the geometry node and the vertices for the geometry\r\n\t\t\t\tvar posName = meshid + \"-position\";\r\n\t\t\t\tvar vertName = meshid + \"-vertices\";\r\n\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.position, posName, [ 'X', 'Y', 'Z' ], 'float' );\r\n\t\t\t\tgnode += \"<vertices id=\\\"\" + vertName + \"\\\"><input semantic=\\\"POSITION\\\" source=\\\"#\" + posName + \"\\\" /></vertices>\";\r\n\r\n\t\t\t\t// NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\r\n\t\t\t\t// can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\r\n\t\t\t\t// models with attributes that share an offset.\r\n\t\t\t\t// MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\r\n\r\n\t\t\t\t// serialize normals\r\n\t\t\t\tvar triangleInputs = \"<input semantic=\\\"VERTEX\\\" source=\\\"#\" + vertName + \"\\\" offset=\\\"0\\\" />\";\r\n\t\t\t\tif ( 'normal' in bufferGeometry.attributes ) {\r\n\r\n\t\t\t\t\tvar normName = meshid + \"-normal\";\r\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.normal, normName, [ 'X', 'Y', 'Z' ], 'float' );\r\n\t\t\t\t\ttriangleInputs += \"<input semantic=\\\"NORMAL\\\" source=\\\"#\" + normName + \"\\\" offset=\\\"0\\\" />\";\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// serialize uvs\r\n\t\t\t\tif ( 'uv' in bufferGeometry.attributes ) {\r\n\r\n\t\t\t\t\tvar uvName = meshid + \"-texcoord\";\r\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.uv, uvName, [ 'S', 'T' ], 'float' );\r\n\t\t\t\t\ttriangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\" + uvName + \"\\\" offset=\\\"0\\\" set=\\\"0\\\" />\";\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// serialize colors\r\n\t\t\t\tif ( 'color' in bufferGeometry.attributes ) {\r\n\r\n\t\t\t\t\tvar colName = meshid + \"-color\";\r\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.color, colName, [ 'X', 'Y', 'Z' ], 'uint8' );\r\n\t\t\t\t\ttriangleInputs += \"<input semantic=\\\"COLOR\\\" source=\\\"#\" + colName + \"\\\" offset=\\\"0\\\" />\";\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar indexArray = null;\r\n\t\t\t\tif ( bufferGeometry.index ) {\r\n\r\n\t\t\t\t\tindexArray = attrBufferToArray( bufferGeometry.index );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tindexArray = new Array( indexCount );\r\n\t\t\t\t\tfor ( var i = 0, l = indexArray.length; i < l; i ++ ) { indexArray[ i ] = i; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\t\tvar subarr = subArray( indexArray, group.start, group.count );\r\n\t\t\t\t\tvar polycount = subarr.length / 3;\r\n\t\t\t\t\tgnode += \"<triangles material=\\\"MESH_MATERIAL_\" + (group.materialIndex) + \"\\\" count=\\\"\" + polycount + \"\\\">\";\r\n\t\t\t\t\tgnode += triangleInputs;\r\n\r\n\t\t\t\t\tgnode += \"<p>\" + (subarr.join( ' ' )) + \"</p>\";\r\n\t\t\t\t\tgnode += '</triangles>';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgnode += \"</mesh></geometry>\";\r\n\r\n\t\t\t\tlibraryGeometries.push( gnode );\r\n\r\n\t\t\t\tinfo = { meshid: meshid, bufferGeometry: bufferGeometry };\r\n\t\t\t\tgeometryInfo.set( g, info );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn info;\r\n\r\n\t\t}\r\n\r\n\t\t// Process the given texture into the image library\r\n\t\t// Returns the image library\r\n\t\tfunction processTexture( tex ) {\r\n\r\n\t\t\tvar texid = imageMap.get( tex );\r\n\t\t\tif ( texid == null ) {\r\n\r\n\t\t\t\ttexid = \"image-\" + (libraryImages.length + 1);\r\n\r\n\t\t\t\tvar ext = 'png';\r\n\t\t\t\tvar name = tex.name || texid;\r\n\t\t\t\tvar imageNode = \"<image id=\\\"\" + texid + \"\\\" name=\\\"\" + name + \"\\\">\";\r\n\r\n\t\t\t\tif ( version === '1.5.0' ) {\r\n\r\n\t\t\t\t\timageNode += \"<init_from><ref>\" + (options.textureDirectory) + name + \".\" + ext + \"</ref></init_from>\";\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// version image node 1.4.1\r\n\t\t\t\t\timageNode += \"<init_from>\" + (options.textureDirectory) + name + \".\" + ext + \"</init_from>\";\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\timageNode += '</image>';\r\n\r\n\t\t\t\tlibraryImages.push( imageNode );\r\n\t\t\t\timageMap.set( tex, texid );\r\n\t\t\t\ttextures.push( {\r\n\t\t\t\t\tdirectory: options.textureDirectory,\r\n\t\t\t\t\tname: name,\r\n\t\t\t\t\text: ext,\r\n\t\t\t\t\tdata: imageToData( tex.image, ext ),\r\n\t\t\t\t\toriginal: tex\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn texid;\r\n\r\n\t\t}\r\n\r\n\t\t// Process the given material into the material and effect libraries\r\n\t\t// Returns the material id\r\n\t\tfunction processMaterial( m ) {\r\n\r\n\t\t\tvar matid = materialMap.get( m );\r\n\r\n\t\t\tif ( matid == null ) {\r\n\r\n\t\t\t\tmatid = \"Mat\" + (libraryEffects.length + 1);\r\n\r\n\t\t\t\tvar type = 'phong';\r\n\r\n\t\t\t\tif ( m instanceof MeshLambertMaterial ) {\r\n\r\n\t\t\t\t\ttype = 'lambert';\r\n\r\n\t\t\t\t} else if ( m instanceof MeshBasicMaterial ) {\r\n\r\n\t\t\t\t\ttype = 'constant';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar emissive = m.emissive ? m.emissive : new Color( 0, 0, 0 );\r\n\t\t\t\tvar diffuse = m.color ? m.color : new Color( 0, 0, 0 );\r\n\t\t\t\tvar specular = m.specular ? m.specular : new Color( 1, 1, 1 );\r\n\t\t\t\tvar shininess = m.shininess || 0;\r\n\t\t\t\tvar reflectivity = m.reflectivity || 0;\r\n\r\n\t\t\t\t// Do not export and alpha map for the reasons mentioned in issue (#13792)\r\n\t\t\t\t// in js alpha maps are black and white, but collada expects the alpha\r\n\t\t\t\t// channel to specify the transparency\r\n\t\t\t\tvar transparencyNode = '';\r\n\t\t\t\tif ( m.transparent === true ) {\r\n\r\n\t\t\t\t\ttransparencyNode +=\r\n\t\t\t\t\t\t\"<transparent>\" +\r\n\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\tm.map ?\r\n\t\t\t\t\t\t\t\t\"<texture texture=\\\"diffuse-sampler\\\"></texture>\" :\r\n\t\t\t\t\t\t\t\t'<float>1</float>'\r\n\t\t\t\t\t\t) +\r\n\t\t\t\t\t\t'</transparent>';\r\n\r\n\t\t\t\t\tif ( m.opacity < 1 ) {\r\n\r\n\t\t\t\t\t\ttransparencyNode += \"<transparency><float>\" + (m.opacity) + \"</float></transparency>\";\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar techniqueNode = \"<technique sid=\\\"common\\\"><\" + type + \">\" +\r\n\r\n\t\t\t\t\t'<emission>' +\r\n\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\tm.emissiveMap ?\r\n\t\t\t\t\t\t\t'<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' :\r\n\t\t\t\t\t\t\t(\"<color sid=\\\"emission\\\">\" + (emissive.r) + \" \" + (emissive.g) + \" \" + (emissive.b) + \" 1</color>\")\r\n\t\t\t\t\t) +\r\n\r\n\t\t\t\t\t'</emission>' +\r\n\r\n\t\t\t\t\t'<diffuse>' +\r\n\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\tm.map ?\r\n\t\t\t\t\t\t\t'<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' :\r\n\t\t\t\t\t\t\t(\"<color sid=\\\"diffuse\\\">\" + (diffuse.r) + \" \" + (diffuse.g) + \" \" + (diffuse.b) + \" 1</color>\")\r\n\t\t\t\t\t) +\r\n\r\n\t\t\t\t\t'</diffuse>' +\r\n\r\n\t\t\t\t\t\"<specular><color sid=\\\"specular\\\">\" + (specular.r) + \" \" + (specular.g) + \" \" + (specular.b) + \" 1</color></specular>\" +\r\n\r\n\t\t\t\t\t'<shininess>' +\r\n\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\tm.specularMap ?\r\n\t\t\t\t\t\t\t'<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' :\r\n\t\t\t\t\t\t\t(\"<float sid=\\\"shininess\\\">\" + shininess + \"</float>\")\r\n\t\t\t\t\t) +\r\n\r\n\t\t\t\t\t'</shininess>' +\r\n\r\n\t\t\t\t\t\"<reflective><color>\" + (diffuse.r) + \" \" + (diffuse.g) + \" \" + (diffuse.b) + \" 1</color></reflective>\" +\r\n\r\n\t\t\t\t\t\"<reflectivity><float>\" + reflectivity + \"</float></reflectivity>\" +\r\n\r\n\t\t\t\t\ttransparencyNode +\r\n\r\n\t\t\t\t\t\"</\" + type + \"></technique>\";\r\n\r\n\t\t\t\tvar effectnode =\r\n\t\t\t\t\t\"<effect id=\\\"\" + matid + \"-effect\\\">\" +\r\n\t\t\t\t\t'<profile_COMMON>' +\r\n\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\tm.map ?\r\n\t\t\t\t\t\t\t'<newparam sid=\"diffuse-surface\"><surface type=\"2D\">' +\r\n\t\t\t\t\t\t\t\"<init_from>\" + (processTexture( m.map )) + \"</init_from>\" +\r\n\t\t\t\t\t\t\t'</surface></newparam>' +\r\n\t\t\t\t\t\t\t'<newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>' :\r\n\t\t\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\tm.specularMap ?\r\n\t\t\t\t\t\t\t'<newparam sid=\"specular-surface\"><surface type=\"2D\">' +\r\n\t\t\t\t\t\t\t\"<init_from>\" + (processTexture( m.specularMap )) + \"</init_from>\" +\r\n\t\t\t\t\t\t\t'</surface></newparam>' +\r\n\t\t\t\t\t\t\t'<newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>' :\r\n\t\t\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\tm.emissiveMap ?\r\n\t\t\t\t\t\t\t'<newparam sid=\"emissive-surface\"><surface type=\"2D\">' +\r\n\t\t\t\t\t\t\t\"<init_from>\" + (processTexture( m.emissiveMap )) + \"</init_from>\" +\r\n\t\t\t\t\t\t\t'</surface></newparam>' +\r\n\t\t\t\t\t\t\t'<newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>' :\r\n\t\t\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\r\n\t\t\t\t\ttechniqueNode +\r\n\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\tm.side === DoubleSide ?\r\n\t\t\t\t\t\t\t\"<extra><technique><double_sided sid=\\\"double_sided\\\" type=\\\"int\\\">1</double_sided></technique></extra>\" :\r\n\t\t\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\r\n\t\t\t\t\t'</profile_COMMON>' +\r\n\r\n\t\t\t\t\t'</effect>';\r\n\r\n\t\t\t\tlibraryMaterials.push( (\"<material id=\\\"\" + matid + \"\\\" name=\\\"\" + (m.name) + \"\\\"><instance_effect url=\\\"#\" + matid + \"-effect\\\" /></material>\") );\r\n\t\t\t\tlibraryEffects.push( effectnode );\r\n\t\t\t\tmaterialMap.set( m, matid );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn matid;\r\n\r\n\t\t}\r\n\r\n\t\t// Recursively process the object into a scene\r\n\t\tfunction processObject( o ) {\r\n\r\n\t\t\tvar node = \"<node name=\\\"\" + (o.name) + \"\\\">\";\r\n\r\n\t\t\tnode += getTransform( o );\r\n\r\n\t\t\tif ( o instanceof Mesh && o.geometry != null ) {\r\n\r\n\t\t\t\t// function returns the id associated with the mesh and a \"BufferGeometry\" version\r\n\t\t\t\t// of the geometry in case it's not a geometry.\r\n\t\t\t\tvar geomInfo = processGeometry( o.geometry );\r\n\t\t\t\tvar meshid = geomInfo.meshid;\r\n\t\t\t\tvar geometry = geomInfo.bufferGeometry;\r\n\r\n\t\t\t\t// ids of the materials to bind to the geometry\r\n\t\t\t\tvar matids = null;\r\n\r\n\t\t\t\t// get a list of materials to bind to the sub groups of the geometry.\r\n\t\t\t\t// If the amount of subgroups is greater than the materials, than reuse\r\n\t\t\t\t// the materials.\r\n\t\t\t\tvar mat = o.material || new MeshBasicMaterial();\r\n\t\t\t\tvar materials = Array.isArray( mat ) ? mat : [ mat ];\r\n\t\t\t\tmatids = new Array( geometry.groups.length )\r\n\t\t\t\t\t.fill()\r\n\t\t\t\t\t.map( function ( v, i ) { return processMaterial( materials[ i % materials.length ] ); } );\r\n\r\n\t\t\t\tnode +=\r\n\t\t\t\t\t\"<instance_geometry url=\\\"#\" + meshid + \"\\\">\" +\r\n\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\tmatids != null ?\r\n\t\t\t\t\t\t\t'<bind_material><technique_common>' +\r\n\t\t\t\t\t\t\tmatids.map( function ( id, i ) { return \"<instance_material symbol=\\\"MESH_MATERIAL_\" + i + \"\\\" target=\\\"#\" + id + \"\\\" >\" +\r\n\r\n\t\t\t\t\t\t\t\t'<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" />' +\r\n\r\n\t\t\t\t\t\t\t\t'</instance_material>'; }\r\n\t\t\t\t\t\t\t).join( '' ) +\r\n\t\t\t\t\t\t\t'</technique_common></bind_material>' :\r\n\t\t\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\r\n\t\t\t\t\t'</instance_geometry>';\r\n\r\n\t\t\t}\r\n\r\n\t\t\to.children.forEach( function (c) { return node += processObject( c ); } );\r\n\r\n\t\t\tnode += '</node>';\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\tvar geometryInfo = new WeakMap();\r\n\t\tvar materialMap = new WeakMap();\r\n\t\tvar imageMap = new WeakMap();\r\n\t\tvar textures = [];\r\n\r\n\t\tvar libraryImages = [];\r\n\t\tvar libraryGeometries = [];\r\n\t\tvar libraryEffects = [];\r\n\t\tvar libraryMaterials = [];\r\n\t\tvar libraryVisualScenes = processObject( object );\r\n\r\n\t\tvar specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\r\n\t\tvar dae =\r\n\t\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>' +\r\n\t\t\t\"<COLLADA xmlns=\\\"\" + specLink + \"\\\" version=\\\"\" + version + \"\\\">\" +\r\n\t\t\t'<asset>' +\r\n\t\t\t(\r\n\t\t\t\t'<contributor>' +\r\n\t\t\t\t'<authoring_tool>js Collada Exporter</authoring_tool>' +\r\n\t\t\t\t( options.author !== null ? (\"<author>\" + (options.author) + \"</author>\") : '' ) +\r\n\t\t\t\t'</contributor>' +\r\n\t\t\t\t\"<created>\" + (( new Date() ).toISOString()) + \"</created>\" +\r\n\t\t\t\t\"<modified>\" + (( new Date() ).toISOString()) + \"</modified>\" +\r\n\t\t\t\t'<up_axis>Y_UP</up_axis>'\r\n\t\t\t) +\r\n\t\t\t'</asset>';\r\n\r\n\t\tdae += \"<library_images>\" + (libraryImages.join( '' )) + \"</library_images>\";\r\n\r\n\t\tdae += \"<library_effects>\" + (libraryEffects.join( '' )) + \"</library_effects>\";\r\n\r\n\t\tdae += \"<library_materials>\" + (libraryMaterials.join( '' )) + \"</library_materials>\";\r\n\r\n\t\tdae += \"<library_geometries>\" + (libraryGeometries.join( '' )) + \"</library_geometries>\";\r\n\r\n\t\tdae += \"<library_visual_scenes><visual_scene id=\\\"Scene\\\" name=\\\"scene\\\">\" + libraryVisualScenes + \"</visual_scene></library_visual_scenes>\";\r\n\r\n\t\tdae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\r\n\r\n\t\tdae += '</COLLADA>';\r\n\r\n\t\tvar res = {\r\n\t\t\tdata: format( dae ),\r\n\t\t\ttextures: textures\r\n\t\t};\r\n\r\n\t\tif ( typeof onDone === 'function' ) {\r\n\r\n\t\t\trequestAnimationFrame( function () { return onDone( res ); } );\r\n\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//------------------------------------------------------------------------------\r\n// Constants\r\n//------------------------------------------------------------------------------\r\nvar WEBGL_CONSTANTS = {\r\n\tPOINTS: 0x0000,\r\n\tLINES: 0x0001,\r\n\tLINE_LOOP: 0x0002,\r\n\tLINE_STRIP: 0x0003,\r\n\tTRIANGLES: 0x0004,\r\n\tTRIANGLE_STRIP: 0x0005,\r\n\tTRIANGLE_FAN: 0x0006,\r\n\r\n\tUNSIGNED_BYTE: 0x1401,\r\n\tUNSIGNED_SHORT: 0x1403,\r\n\tFLOAT: 0x1406,\r\n\tUNSIGNED_INT: 0x1405,\r\n\tARRAY_BUFFER: 0x8892,\r\n\tELEMENT_ARRAY_BUFFER: 0x8893,\r\n\r\n\tNEAREST: 0x2600,\r\n\tLINEAR: 0x2601,\r\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\r\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\r\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\r\n\tLINEAR_MIPMAP_LINEAR: 0x2703\r\n};\r\n\r\nvar THREE_TO_WEBGL = {\r\n\t// @TODO Replace with computed property name [*] when available on es6\r\n\t1003: WEBGL_CONSTANTS.NEAREST,\r\n\t1004: WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST,\r\n\t1005: WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR,\r\n\t1006: WEBGL_CONSTANTS.LINEAR,\r\n\t1007: WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST,\r\n\t1008: WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR\r\n};\r\n\r\nvar PATH_PROPERTIES = {\r\n\tscale: 'scale',\r\n\tposition: 'translation',\r\n\tquaternion: 'rotation',\r\n\tmorphTargetInfluences: 'weights'\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// GLTF Exporter\r\n//------------------------------------------------------------------------------\r\nvar GLTFExporter = function () {};\r\n\r\nGLTFExporter.prototype = {\r\n\r\n\tconstructor: GLTFExporter,\r\n\t\r\n\tparse: function ( input, onDone, options ) {\r\n\r\n\t\tvar DEFAULT_OPTIONS = {\r\n\t\t\tbinary: false,\r\n\t\t\ttrs: false,\r\n\t\t\tonlyVisible: true,\r\n\t\t\ttruncateDrawRange: true,\r\n\t\t\tembedImages: true,\r\n\t\t\tanimations: [],\r\n\t\t\tforceIndices: false,\r\n\t\t\tforcePowerOfTwoTextures: false\r\n\t\t};\r\n\r\n\t\toptions = Object.assign( {}, DEFAULT_OPTIONS, options );\r\n\r\n\t\tif ( options.animations.length > 0 ) {\r\n\r\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\r\n\t\t\toptions.trs = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar outputJSON = {\r\n\r\n\t\t\tasset: {\r\n\r\n\t\t\t\tversion: \"2.0\",\r\n\t\t\t\tgenerator: \"GLTFExporter\"\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tvar byteOffset = 0;\r\n\t\tvar buffers = [];\r\n\t\tvar pending = [];\r\n\t\tvar nodeMap = new Map();\r\n\t\tvar skins = [];\r\n\t\tvar extensionsUsed = {};\r\n\t\tvar cachedData = {\r\n\r\n\t\t\tattributes: new Map(),\r\n\t\t\tmaterials: new Map(),\r\n\t\t\ttextures: new Map(),\r\n\t\t\timages: new Map()\r\n\r\n\t\t};\r\n\r\n\t\tvar cachedCanvas;\r\n\t\t\r\n\t\tfunction equalArray( array1, array2 ) {\r\n\r\n\t\t\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\r\n\r\n\t\t\t\treturn element === array2[ index ];\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction stringToArrayBuffer( text ) {\r\n\r\n\t\t\tif ( window.TextEncoder !== undefined ) {\r\n\r\n\t\t\t\treturn new TextEncoder().encode( text ).buffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar array = new Uint8Array( new ArrayBuffer( text.length ) );\r\n\r\n\t\t\tfor ( var i = 0, il = text.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar value = text.charCodeAt( i );\r\n\r\n\t\t\t\t// Replacing multi-byte character with space(0x20).\r\n\t\t\t\tarray[ i ] = value > 0xFF ? 0x20 : value;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array.buffer;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction getMinMax( attribute, start, count ) {\r\n\r\n\t\t\tvar output = {\r\n\r\n\t\t\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\r\n\t\t\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\r\n\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = start; i < start + count; i ++ ) {\r\n\r\n\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\r\n\r\n\t\t\t\t\tvar value = attribute.array[ i * attribute.itemSize + a ];\r\n\t\t\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\r\n\t\t\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn output;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction isPowerOfTwo( image ) {\r\n\r\n\t\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction isNormalizedNormalAttribute( normal ) {\r\n\r\n\t\t\tif ( cachedData.attributes.has( normal ) ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar v = new Vector3();\r\n\r\n\t\t\tfor ( var i = 0, il = normal.count; i < il; i ++ ) {\r\n\r\n\t\t\t\t// 0.0005 is from glTF-validator\r\n\t\t\t\tif ( Math.abs( v.fromArray( normal.array, i * 3 ).length() - 1.0 ) > 0.0005 ) { return false; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction createNormalizedNormalAttribute( normal ) {\r\n\r\n\t\t\tif ( cachedData.attributes.has( normal ) ) {\r\n\r\n\t\t\t\treturn cachedData.attributes.get( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar attribute = normal.clone();\r\n\r\n\t\t\tvar v = new Vector3();\r\n\r\n\t\t\tfor ( var i = 0, il = attribute.count; i < il; i ++ ) {\r\n\r\n\t\t\t\tv.fromArray( attribute.array, i * 3 );\r\n\r\n\t\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\r\n\r\n\t\t\t\t\t// if values can't be normalized set (1, 0, 0)\r\n\t\t\t\t\tv.setX( 1.0 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv.normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tv.toArray( attribute.array, i * 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcachedData.attributes.set( normal, attribute );\r\n\r\n\t\t\treturn attribute;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction getPaddedBufferSize( bufferSize ) {\r\n\r\n\t\t\treturn Math.ceil( bufferSize / 4 ) * 4;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction getPaddedArrayBuffer( arrayBuffer, paddingByte ) {\r\n\r\n\t\t\tpaddingByte = paddingByte || 0;\r\n\r\n\t\t\tvar paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\r\n\r\n\t\t\tif ( paddedLength !== arrayBuffer.byteLength ) {\r\n\r\n\t\t\t\tvar array = new Uint8Array( paddedLength );\r\n\t\t\t\tarray.set( new Uint8Array( arrayBuffer ) );\r\n\r\n\t\t\t\tif ( paddingByte !== 0 ) {\r\n\r\n\t\t\t\t\tfor ( var i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\r\n\r\n\t\t\t\t\t\tarray[ i ] = paddingByte;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn array.buffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn arrayBuffer;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction serializeUserData( object ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\treturn JSON.parse( JSON.stringify( object.userData ) );\r\n\r\n\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\tconsole.warn( 'GLTFExporter: userData of \\'' + object.name + '\\' ' +\r\n\t\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\r\n\r\n\t\t\t\treturn {};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processBuffer( buffer ) {\r\n\r\n\t\t\tif ( ! outputJSON.buffers ) {\r\n\r\n\t\t\t\toutputJSON.buffers = [ { byteLength: 0 } ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// All buffers are merged before export.\r\n\t\t\tbuffers.push( buffer );\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processBufferView( attribute, componentType, start, count, target ) {\r\n\r\n\t\t\tif ( ! outputJSON.bufferViews ) {\r\n\r\n\t\t\t\toutputJSON.bufferViews = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Create a new dataview and dump the attribute's array into it\r\n\r\n\t\t\tvar componentSize;\r\n\r\n\t\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\r\n\r\n\t\t\t\tcomponentSize = 1;\r\n\r\n\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\r\n\r\n\t\t\t\tcomponentSize = 2;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcomponentSize = 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\r\n\t\t\tvar dataView = new DataView( new ArrayBuffer( byteLength ) );\r\n\t\t\tvar offset = 0;\r\n\r\n\t\t\tfor ( var i = start; i < start + count; i ++ ) {\r\n\r\n\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\r\n\r\n\t\t\t\t\t// @TODO Fails on InterleavedBufferAttribute, and could probably be\r\n\t\t\t\t\t// optimized for normal BufferAttribute.\r\n\t\t\t\t\tvar value = attribute.array[ i * attribute.itemSize + a ];\r\n\r\n\t\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\r\n\r\n\t\t\t\t\t\tdataView.setFloat32( offset, value, true );\r\n\r\n\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\r\n\r\n\t\t\t\t\t\tdataView.setUint32( offset, value, true );\r\n\r\n\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\r\n\r\n\t\t\t\t\t\tdataView.setUint16( offset, value, true );\r\n\r\n\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\r\n\r\n\t\t\t\t\t\tdataView.setUint8( offset, value );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toffset += componentSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar gltfBufferView = {\r\n\r\n\t\t\t\tbuffer: processBuffer( dataView.buffer ),\r\n\t\t\t\tbyteOffset: byteOffset,\r\n\t\t\t\tbyteLength: byteLength\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( target !== undefined ) { gltfBufferView.target = target; }\r\n\r\n\t\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\r\n\r\n\t\t\t\t// Only define byteStride for vertex attributes.\r\n\t\t\t\tgltfBufferView.byteStride = attribute.itemSize * componentSize;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += byteLength;\r\n\r\n\t\t\toutputJSON.bufferViews.push( gltfBufferView );\r\n\r\n\t\t\t// @TODO Merge bufferViews where possible.\r\n\t\t\tvar output = {\r\n\r\n\t\t\t\tid: outputJSON.bufferViews.length - 1,\r\n\t\t\t\tbyteLength: 0\r\n\r\n\t\t\t};\r\n\r\n\t\t\treturn output;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processBufferViewImage( blob ) {\r\n\r\n\t\t\tif ( ! outputJSON.bufferViews ) {\r\n\r\n\t\t\t\toutputJSON.bufferViews = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new Promise( function ( resolve ) {\r\n\r\n\t\t\t\tvar reader = new window.FileReader();\r\n\t\t\t\treader.readAsArrayBuffer( blob );\r\n\t\t\t\treader.onloadend = function () {\r\n\r\n\t\t\t\t\tvar buffer = getPaddedArrayBuffer( reader.result );\r\n\r\n\t\t\t\t\tvar bufferView = {\r\n\t\t\t\t\t\tbuffer: processBuffer( buffer ),\r\n\t\t\t\t\t\tbyteOffset: byteOffset,\r\n\t\t\t\t\t\tbyteLength: buffer.byteLength\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t\t\t\t\toutputJSON.bufferViews.push( bufferView );\r\n\r\n\t\t\t\t\tresolve( outputJSON.bufferViews.length - 1 );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processAccessor( attribute, geometry, start, count ) {\r\n\r\n\t\t\tvar types = {\r\n\r\n\t\t\t\t1: 'SCALAR',\r\n\t\t\t\t2: 'VEC2',\r\n\t\t\t\t3: 'VEC3',\r\n\t\t\t\t4: 'VEC4',\r\n\t\t\t\t16: 'MAT4'\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar componentType;\r\n\r\n\t\t\t// Detect the component type of the attribute array (float, uint or ushort)\r\n\t\t\tif ( attribute.array.constructor === Float32Array ) {\r\n\r\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\r\n\r\n\t\t\t} else if ( attribute.array.constructor === Uint32Array ) {\r\n\r\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\r\n\r\n\t\t\t} else if ( attribute.array.constructor === Uint16Array ) {\r\n\r\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\r\n\r\n\t\t\t} else if ( attribute.array.constructor === Uint8Array ) {\r\n\r\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'GLTFExporter: Unsupported bufferAttribute component type.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( start === undefined ) { start = 0; }\r\n\t\t\tif ( count === undefined ) { count = attribute.count; }\r\n\r\n\t\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\r\n\t\t\tif ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {\r\n\r\n\t\t\t\tvar end = start + count;\r\n\t\t\t\tvar end2 = geometry.drawRange.count === Infinity\r\n\t\t\t\t\t? attribute.count\r\n\t\t\t\t\t: geometry.drawRange.start + geometry.drawRange.count;\r\n\r\n\t\t\t\tstart = Math.max( start, geometry.drawRange.start );\r\n\t\t\t\tcount = Math.min( end, end2 ) - start;\r\n\r\n\t\t\t\tif ( count < 0 ) { count = 0; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Skip creating an accessor if the attribute doesn't have data to export\r\n\t\t\tif ( count === 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar minMax = getMinMax( attribute, start, count );\r\n\r\n\t\t\tvar bufferViewTarget;\r\n\r\n\t\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\r\n\t\t\t// animation samplers, target must not be set.\r\n\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar bufferView = processBufferView( attribute, componentType, start, count, bufferViewTarget );\r\n\r\n\t\t\tvar gltfAccessor = {\r\n\r\n\t\t\t\tbufferView: bufferView.id,\r\n\t\t\t\tbyteOffset: bufferView.byteOffset,\r\n\t\t\t\tcomponentType: componentType,\r\n\t\t\t\tcount: count,\r\n\t\t\t\tmax: minMax.max,\r\n\t\t\t\tmin: minMax.min,\r\n\t\t\t\ttype: types[ attribute.itemSize ]\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( ! outputJSON.accessors ) {\r\n\r\n\t\t\t\toutputJSON.accessors = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutputJSON.accessors.push( gltfAccessor );\r\n\r\n\t\t\treturn outputJSON.accessors.length - 1;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processImage( image, format, flipY ) {\r\n\r\n\t\t\tif ( ! cachedData.images.has( image ) ) {\r\n\r\n\t\t\t\tcachedData.images.set( image, {} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar cachedImages = cachedData.images.get( image );\r\n\t\t\tvar mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\r\n\t\t\tvar key = mimeType + \":flipY/\" + flipY.toString();\r\n\r\n\t\t\tif ( cachedImages[ key ] !== undefined ) {\r\n\r\n\t\t\t\treturn cachedImages[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! outputJSON.images ) {\r\n\r\n\t\t\t\toutputJSON.images = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar gltfImage = { mimeType: mimeType };\r\n\r\n\t\t\tif ( options.embedImages ) {\r\n\r\n\t\t\t\tvar canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );\r\n\r\n\t\t\t\tcanvas.width = image.width;\r\n\t\t\t\tcanvas.height = image.height;\r\n\r\n\t\t\t\tif ( options.forcePowerOfTwoTextures && ! isPowerOfTwo( image ) ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Resized non-power-of-two image.', image );\r\n\r\n\t\t\t\t\tcanvas.width = _Math.floorPowerOfTwo( canvas.width );\r\n\t\t\t\t\tcanvas.height = _Math.floorPowerOfTwo( canvas.height );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar ctx = canvas.getContext( '2d' );\r\n\r\n\t\t\t\tif ( flipY === true ) {\r\n\r\n\t\t\t\t\tctx.translate( 0, canvas.height );\r\n\t\t\t\t\tctx.scale( 1, - 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\t\tif ( options.binary === true ) {\r\n\r\n\t\t\t\t\tpending.push( new Promise( function ( resolve ) {\r\n\r\n\t\t\t\t\t\tcanvas.toBlob( function ( blob ) {\r\n\r\n\t\t\t\t\t\t\tprocessBufferViewImage( blob ).then( function ( bufferViewIndex ) {\r\n\r\n\t\t\t\t\t\t\t\tgltfImage.bufferView = bufferViewIndex;\r\n\r\n\t\t\t\t\t\t\t\tresolve();\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t}, mimeType );\r\n\r\n\t\t\t\t\t} ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgltfImage.uri = canvas.toDataURL( mimeType );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgltfImage.uri = image.src;\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutputJSON.images.push( gltfImage );\r\n\r\n\t\t\tvar index = outputJSON.images.length - 1;\r\n\t\t\tcachedImages[ key ] = index;\r\n\r\n\t\t\treturn index;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processSampler( map ) {\r\n\r\n\t\t\tif ( ! outputJSON.samplers ) {\r\n\r\n\t\t\t\toutputJSON.samplers = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar gltfSampler = {\r\n\r\n\t\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\r\n\t\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\r\n\t\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\r\n\t\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\r\n\r\n\t\t\t};\r\n\r\n\t\t\toutputJSON.samplers.push( gltfSampler );\r\n\r\n\t\t\treturn outputJSON.samplers.length - 1;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processTexture( map ) {\r\n\r\n\t\t\tif ( cachedData.textures.has( map ) ) {\r\n\r\n\t\t\t\treturn cachedData.textures.get( map );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! outputJSON.textures ) {\r\n\r\n\t\t\t\toutputJSON.textures = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar gltfTexture = {\r\n\r\n\t\t\t\tsampler: processSampler( map ),\r\n\t\t\t\tsource: processImage( map.image, map.format, map.flipY )\r\n\r\n\t\t\t};\r\n\r\n\t\t\toutputJSON.textures.push( gltfTexture );\r\n\r\n\t\t\tvar index = outputJSON.textures.length - 1;\r\n\t\t\tcachedData.textures.set( map, index );\r\n\r\n\t\t\treturn index;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processMaterial( material ) {\r\n\r\n\t\t\tif ( cachedData.materials.has( material ) ) {\r\n\r\n\t\t\t\treturn cachedData.materials.get( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! outputJSON.materials ) {\r\n\r\n\t\t\t\toutputJSON.materials = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.isShaderMaterial ) {\r\n\r\n\t\t\t\tconsole.warn( 'GLTFExporter: ShaderMaterial not supported.' );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// @QUESTION Should we avoid including any attribute that has the default value?\r\n\t\t\tvar gltfMaterial = {\r\n\r\n\t\t\t\tpbrMetallicRoughness: {}\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( material.isMeshBasicMaterial ) {\r\n\r\n\t\t\t\tgltfMaterial.extensions = { KHR_materials_unlit: {} };\r\n\r\n\t\t\t\textensionsUsed[ 'KHR_materials_unlit' ] = true;\r\n\r\n\t\t\t} else if ( ! material.isMeshStandardMaterial ) {\r\n\r\n\t\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// pbrMetallicRoughness.baseColorFactor\r\n\t\t\tvar color = material.color.toArray().concat( [ material.opacity ] );\r\n\r\n\t\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\r\n\r\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorFactor = color;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.isMeshStandardMaterial ) {\r\n\r\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\r\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\r\n\r\n\t\t\t} else if ( material.isMeshBasicMaterial ) {\r\n\r\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;\r\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;\r\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// pbrMetallicRoughness.metallicRoughnessTexture\r\n\t\t\tif ( material.metalnessMap || material.roughnessMap ) {\r\n\r\n\t\t\t\tif ( material.metalnessMap === material.roughnessMap ) {\r\n\r\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = {\r\n\r\n\t\t\t\t\t\tindex: processTexture( material.metalnessMap )\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// pbrMetallicRoughness.baseColorTexture\r\n\t\t\tif ( material.map ) {\r\n\r\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorTexture = {\r\n\r\n\t\t\t\t\tindex: processTexture( material.map )\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.isMeshBasicMaterial ||\r\n\t\t\t\tmaterial.isLineBasicMaterial ||\r\n\t\t\t\tmaterial.isPointsMaterial ) ; else {\r\n\r\n\t\t\t\t// emissiveFactor\r\n\t\t\t\tvar emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity ).toArray();\r\n\r\n\t\t\t\tif ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {\r\n\r\n\t\t\t\t\tgltfMaterial.emissiveFactor = emissive;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// emissiveTexture\r\n\t\t\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\t\t\tgltfMaterial.emissiveTexture = {\r\n\r\n\t\t\t\t\t\tindex: processTexture( material.emissiveMap )\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// normalTexture\r\n\t\t\tif ( material.normalMap ) {\r\n\r\n\t\t\t\tgltfMaterial.normalTexture = {\r\n\r\n\t\t\t\t\tindex: processTexture( material.normalMap )\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( material.normalScale.x !== - 1 ) {\r\n\r\n\t\t\t\t\tif ( material.normalScale.x !== material.normalScale.y ) {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgltfMaterial.normalTexture.scale = material.normalScale.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// occlusionTexture\r\n\t\t\tif ( material.aoMap ) {\r\n\r\n\t\t\t\tgltfMaterial.occlusionTexture = {\r\n\r\n\t\t\t\t\tindex: processTexture( material.aoMap )\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\r\n\r\n\t\t\t\t\tgltfMaterial.occlusionTexture.strength = material.aoMapIntensity;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// alphaMode\r\n\t\t\tif ( material.transparent || material.alphaTest > 0.0 ) {\r\n\r\n\t\t\t\tgltfMaterial.alphaMode = material.opacity < 1.0 ? 'BLEND' : 'MASK';\r\n\r\n\t\t\t\t// Write alphaCutoff if it's non-zero and different from the default (0.5).\r\n\t\t\t\tif ( material.alphaTest > 0.0 && material.alphaTest !== 0.5 ) {\r\n\r\n\t\t\t\t\tgltfMaterial.alphaCutoff = material.alphaTest;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// doubleSided\r\n\t\t\tif ( material.side === DoubleSide ) {\r\n\r\n\t\t\t\tgltfMaterial.doubleSided = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.name !== '' ) {\r\n\r\n\t\t\t\tgltfMaterial.name = material.name;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( Object.keys( material.userData ).length > 0 ) {\r\n\r\n\t\t\t\tgltfMaterial.extras = serializeUserData( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutputJSON.materials.push( gltfMaterial );\r\n\r\n\t\t\tvar index = outputJSON.materials.length - 1;\r\n\t\t\tcachedData.materials.set( material, index );\r\n\r\n\t\t\treturn index;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processMesh( mesh ) {\r\n\r\n\t\t\tvar geometry = mesh.geometry;\r\n\r\n\t\t\tvar mode;\r\n\r\n\t\t\t// Use the correct mode\r\n\t\t\tif ( mesh.isLineSegments ) {\r\n\r\n\t\t\t\tmode = WEBGL_CONSTANTS.LINES;\r\n\r\n\t\t\t} else if ( mesh.isLineLoop ) {\r\n\r\n\t\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\r\n\r\n\t\t\t} else if ( mesh.isLine ) {\r\n\r\n\t\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\r\n\r\n\t\t\t} else if ( mesh.isPoints ) {\r\n\r\n\t\t\t\tmode = WEBGL_CONSTANTS.POINTS;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\tvar geometryTemp = new BufferGeometry();\r\n\t\t\t\t\tgeometryTemp.fromGeometry( geometry );\r\n\t\t\t\t\tgeometry = geometryTemp;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( mesh.drawMode === TriangleFanDrawMode ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'GLTFExporter: TriangleFanDrawMode and wireframe incompatible.' );\r\n\t\t\t\t\tmode = WEBGL_CONSTANTS.TRIANGLE_FAN;\r\n\r\n\t\t\t\t} else if ( mesh.drawMode === TriangleStripDrawMode ) {\r\n\r\n\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINE_STRIP : WEBGL_CONSTANTS.TRIANGLE_STRIP;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar gltfMesh = {};\r\n\r\n\t\t\tvar attributes = {};\r\n\t\t\tvar primitives = [];\r\n\t\t\tvar targets = [];\r\n\r\n\t\t\t// Conversion between attributes names in threejs and gltf spec\r\n\t\t\tvar nameConversion = {\r\n\r\n\t\t\t\tuv: 'TEXCOORD_0',\r\n\t\t\t\tuv2: 'TEXCOORD_1',\r\n\t\t\t\tcolor: 'COLOR_0',\r\n\t\t\t\tskinWeight: 'WEIGHTS_0',\r\n\t\t\t\tskinIndex: 'JOINTS_0'\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar originalNormal = geometry.getAttribute( 'normal' );\r\n\r\n\t\t\tif ( originalNormal !== undefined && ! isNormalizedNormalAttribute( originalNormal ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\r\n\r\n\t\t\t\tgeometry.addAttribute( 'normal', createNormalizedNormalAttribute( originalNormal ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// @QUESTION Detect if .vertexColors = VertexColors?\r\n\t\t\t// For every attribute create an accessor\r\n\t\t\tfor ( var attributeName in geometry.attributes ) {\r\n\r\n\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\r\n\t\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\r\n\r\n\t\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\r\n\t\t\t\tvar array = attribute.array;\r\n\t\t\t\tif ( attributeName === 'JOINTS_0' &&\r\n\t\t\t\t\t! ( array instanceof Uint16Array ) &&\r\n\t\t\t\t\t! ( array instanceof Uint8Array ) ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\r\n\t\t\t\t\tattribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( attributeName.substr( 0, 5 ) !== 'MORPH' ) {\r\n\r\n\t\t\t\t\tvar accessor = processAccessor( attribute, geometry );\r\n\t\t\t\t\tif ( accessor !== null ) {\r\n\r\n\t\t\t\t\t\tattributes[ attributeName ] = accessor;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( originalNormal !== undefined ) { geometry.addAttribute( 'normal', originalNormal ); }\r\n\r\n\t\t\t// Skip if no exportable attributes found\r\n\t\t\tif ( Object.keys( attributes ).length === 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Morph targets\r\n\t\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\r\n\r\n\t\t\t\tvar weights = [];\r\n\t\t\t\tvar targetNames = [];\r\n\t\t\t\tvar reverseDictionary = {};\r\n\r\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\r\n\r\n\t\t\t\t\tfor ( var key in mesh.morphTargetDictionary ) {\r\n\r\n\t\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\r\n\r\n\t\t\t\t\tvar target = {};\r\n\r\n\t\t\t\t\tvar warned = false;\r\n\r\n\t\t\t\t\tfor ( var attributeName in geometry.morphAttributes ) {\r\n\r\n\t\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\r\n\t\t\t\t\t\t// Three.js doesn't support TANGENT yet.\r\n\r\n\t\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\r\n\r\n\t\t\t\t\t\t\tif ( ! warned ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\r\n\t\t\t\t\t\t\t\twarned = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar attribute = geometry.morphAttributes[ attributeName ][ i ];\r\n\r\n\t\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// glTF 2.0 Specification:\r\n\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\r\n\r\n\t\t\t\t\t\tvar baseAttribute = geometry.attributes[ attributeName ];\r\n\t\t\t\t\t\t// Clones attribute not to override\r\n\t\t\t\t\t\tvar relativeAttribute = attribute.clone();\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = attribute.count; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\trelativeAttribute.setXYZ(\r\n\t\t\t\t\t\t\t\tj,\r\n\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\r\n\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\r\n\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttarget[ attributeName.toUpperCase() ] = processAccessor( relativeAttribute, geometry );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargets.push( target );\r\n\r\n\t\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\r\n\t\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) { targetNames.push( reverseDictionary[ i ] ); }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgltfMesh.weights = weights;\r\n\r\n\t\t\t\tif ( targetNames.length > 0 ) {\r\n\r\n\t\t\t\t\tgltfMesh.extras = {};\r\n\t\t\t\t\tgltfMesh.extras.targetNames = targetNames;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar extras = ( Object.keys( geometry.userData ).length > 0 ) ? serializeUserData( geometry ) : undefined;\r\n\r\n\t\t\tvar forceIndices = options.forceIndices;\r\n\t\t\tvar isMultiMaterial = Array.isArray( mesh.material );\r\n\r\n\t\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) { return null; }\r\n\r\n\t\t\tif ( ! forceIndices && geometry.index === null && isMultiMaterial ) {\r\n\r\n\t\t\t\t// temporal workaround.\r\n\t\t\t\tconsole.warn( 'GLTFExporter: Creating index for non-indexed multi-material mesh.' );\r\n\t\t\t\tforceIndices = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar didForceIndices = false;\r\n\r\n\t\t\tif ( geometry.index === null && forceIndices ) {\r\n\r\n\t\t\t\tvar indices = [];\r\n\r\n\t\t\t\tfor ( var i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tindices[ i ] = i;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.setIndex( indices );\r\n\r\n\t\t\t\tdidForceIndices = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar materials = isMultiMaterial ? mesh.material : [ mesh.material ];\r\n\t\t\tvar groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\r\n\r\n\t\t\tfor ( var i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar primitive = {\r\n\t\t\t\t\tmode: mode,\r\n\t\t\t\t\tattributes: attributes,\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( extras ) { primitive.extras = extras; }\r\n\r\n\t\t\t\tif ( targets.length > 0 ) { primitive.targets = targets; }\r\n\r\n\t\t\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t\t\tprimitive.indices = processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar material = processMaterial( materials[ groups[ i ].materialIndex ] );\r\n\r\n\t\t\t\tif ( material !== null ) {\r\n\r\n\t\t\t\t\tprimitive.material = material;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprimitives.push( primitive );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( didForceIndices ) {\r\n\r\n\t\t\t\tgeometry.setIndex( null );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgltfMesh.primitives = primitives;\r\n\r\n\t\t\tif ( ! outputJSON.meshes ) {\r\n\r\n\t\t\t\toutputJSON.meshes = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutputJSON.meshes.push( gltfMesh );\r\n\r\n\t\t\treturn outputJSON.meshes.length - 1;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processCamera( camera ) {\r\n\r\n\t\t\tif ( ! outputJSON.cameras ) {\r\n\r\n\t\t\t\toutputJSON.cameras = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar isOrtho = camera.isOrthographicCamera;\r\n\r\n\t\t\tvar gltfCamera = {\r\n\r\n\t\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( isOrtho ) {\r\n\r\n\t\t\t\tgltfCamera.orthographic = {\r\n\r\n\t\t\t\t\txmag: camera.right * 2,\r\n\t\t\t\t\tymag: camera.top * 2,\r\n\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\r\n\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgltfCamera.perspective = {\r\n\r\n\t\t\t\t\taspectRatio: camera.aspect,\r\n\t\t\t\t\tyfov: _Math.degToRad( camera.fov ) / camera.aspect,\r\n\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\r\n\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( camera.name !== '' ) {\r\n\r\n\t\t\t\tgltfCamera.name = camera.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutputJSON.cameras.push( gltfCamera );\r\n\r\n\t\t\treturn outputJSON.cameras.length - 1;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processAnimation( clip, root ) {\r\n\r\n\t\t\tif ( ! outputJSON.animations ) {\r\n\r\n\t\t\t\toutputJSON.animations = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar channels = [];\r\n\t\t\tvar samplers = [];\r\n\r\n\t\t\tfor ( var i = 0; i < clip.tracks.length; ++ i ) {\r\n\r\n\t\t\t\tvar track = clip.tracks[ i ];\r\n\t\t\t\tvar trackBinding = PropertyBinding.parseTrackName( track.name );\r\n\t\t\t\tvar trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\r\n\t\t\t\tvar trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\r\n\r\n\t\t\t\tif ( trackBinding.objectName === 'bones' ) {\r\n\r\n\t\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\r\n\r\n\t\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttrackNode = undefined;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! trackNode || ! trackProperty ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Could not export animation track \"%s\".', track.name );\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar inputItemSize = 1;\r\n\t\t\t\tvar outputItemSize = track.values.length / track.times.length;\r\n\r\n\t\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\r\n\r\n\t\t\t\t\tif ( trackNode.morphTargetInfluences.length !== 1 &&\r\n\t\t\t\t\t\ttrackBinding.propertyIndex !== undefined ) {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Skipping animation track \"%s\". ' +\r\n\t\t\t\t\t\t\t'Morph target keyframe tracks must target all available morph targets ' +\r\n\t\t\t\t\t\t\t'for the given mesh.', track.name );\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar interpolation;\r\n\r\n\t\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\r\n\r\n\t\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\r\n\t\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\r\n\t\t\t\t// valid value from .getInterpolation().\r\n\t\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\r\n\r\n\t\t\t\t\tinterpolation = 'CUBICSPLINE';\r\n\r\n\t\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\r\n\t\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\r\n\t\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\r\n\t\t\t\t\toutputItemSize /= 3;\r\n\r\n\t\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\r\n\r\n\t\t\t\t\tinterpolation = 'STEP';\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tinterpolation = 'LINEAR';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsamplers.push( {\r\n\r\n\t\t\t\t\tinput: processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\r\n\t\t\t\t\toutput: processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\r\n\t\t\t\t\tinterpolation: interpolation\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tchannels.push( {\r\n\r\n\t\t\t\t\tsampler: samplers.length - 1,\r\n\t\t\t\t\ttarget: {\r\n\t\t\t\t\t\tnode: nodeMap.get( trackNode ),\r\n\t\t\t\t\t\tpath: trackProperty\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutputJSON.animations.push( {\r\n\r\n\t\t\t\tname: clip.name || 'clip_' + outputJSON.animations.length,\r\n\t\t\t\tsamplers: samplers,\r\n\t\t\t\tchannels: channels\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn outputJSON.animations.length - 1;\r\n\r\n\t\t}\r\n\r\n\t\tfunction processSkin( object ) {\r\n\r\n\t\t\tvar node = outputJSON.nodes[ nodeMap.get( object ) ];\r\n\r\n\t\t\tvar skeleton = object.skeleton;\r\n\t\t\tvar rootJoint = object.skeleton.bones[ 0 ];\r\n\r\n\t\t\tif ( rootJoint === undefined ) { return null; }\r\n\r\n\t\t\tvar joints = [];\r\n\t\t\tvar inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\r\n\r\n\t\t\tfor ( var i = 0; i < skeleton.bones.length; ++ i ) {\r\n\r\n\t\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\r\n\r\n\t\t\t\tskeleton.boneInverses[ i ].toArray( inverseBindMatrices, i * 16 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( outputJSON.skins === undefined ) {\r\n\r\n\t\t\t\toutputJSON.skins = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutputJSON.skins.push( {\r\n\r\n\t\t\t\tinverseBindMatrices: processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\r\n\t\t\t\tjoints: joints,\r\n\t\t\t\tskeleton: nodeMap.get( rootJoint )\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tvar skinIndex = node.skin = outputJSON.skins.length - 1;\r\n\r\n\t\t\treturn skinIndex;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processNode( object ) {\r\n\r\n\t\t\tif ( object.isLight ) {\r\n\r\n\t\t\t\tconsole.warn( 'GLTFExporter: Unsupported node type:', object.constructor.name );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! outputJSON.nodes ) {\r\n\r\n\t\t\t\toutputJSON.nodes = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar gltfNode = {};\r\n\r\n\t\t\tif ( options.trs ) {\r\n\r\n\t\t\t\tvar rotation = object.quaternion.toArray();\r\n\t\t\t\tvar position = object.position.toArray();\r\n\t\t\t\tvar scale = object.scale.toArray();\r\n\r\n\t\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\r\n\r\n\t\t\t\t\tgltfNode.rotation = rotation;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\r\n\r\n\t\t\t\t\tgltfNode.translation = position;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\r\n\r\n\t\t\t\t\tgltfNode.scale = scale;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject.updateMatrix();\r\n\t\t\t\tif ( ! equalArray( object.matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] ) ) {\r\n\r\n\t\t\t\t\tgltfNode.matrix = object.matrix.elements;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// We don't export empty strings name because it represents no-name in Three.js.\r\n\t\t\tif ( object.name !== '' ) {\r\n\r\n\t\t\t\tgltfNode.name = String( object.name );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.userData && Object.keys( object.userData ).length > 0 ) {\r\n\r\n\t\t\t\tgltfNode.extras = serializeUserData( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\r\n\r\n\t\t\t\tvar mesh = processMesh( object );\r\n\r\n\t\t\t\tif ( mesh !== null ) {\r\n\r\n\t\t\t\t\tgltfNode.mesh = mesh;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object.isCamera ) {\r\n\r\n\t\t\t\tgltfNode.camera = processCamera( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.isSkinnedMesh ) {\r\n\r\n\t\t\t\tskins.push( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.children.length > 0 ) {\r\n\r\n\t\t\t\tvar children = [];\r\n\r\n\t\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar child = object.children[ i ];\r\n\r\n\t\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\r\n\r\n\t\t\t\t\t\tvar node = processNode( child );\r\n\r\n\t\t\t\t\t\tif ( node !== null ) {\r\n\r\n\t\t\t\t\t\t\tchildren.push( node );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( children.length > 0 ) {\r\n\r\n\t\t\t\t\tgltfNode.children = children;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutputJSON.nodes.push( gltfNode );\r\n\r\n\t\t\tvar nodeIndex = outputJSON.nodes.length - 1;\r\n\t\t\tnodeMap.set( object, nodeIndex );\r\n\r\n\t\t\treturn nodeIndex;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processScene( scene ) {\r\n\r\n\t\t\tif ( ! outputJSON.scenes ) {\r\n\r\n\t\t\t\toutputJSON.scenes = [];\r\n\t\t\t\toutputJSON.scene = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar gltfScene = {\r\n\r\n\t\t\t\tnodes: []\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( scene.name !== '' ) {\r\n\r\n\t\t\t\tgltfScene.name = scene.name;\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutputJSON.scenes.push( gltfScene );\r\n\r\n\t\t\tvar nodes = [];\r\n\r\n\t\t\tfor ( var i = 0, l = scene.children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = scene.children[ i ];\r\n\r\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\r\n\r\n\t\t\t\t\tvar node = processNode( child );\r\n\r\n\t\t\t\t\tif ( node !== null ) {\r\n\r\n\t\t\t\t\t\tnodes.push( node );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodes.length > 0 ) {\r\n\r\n\t\t\t\tgltfScene.nodes = nodes;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction processObjects( objects ) {\r\n\r\n\t\t\tvar scene = new Scene();\r\n\t\t\tscene.name = 'AuxScene';\r\n\r\n\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\r\n\r\n\t\t\t\t// We push directly to children instead of calling `add` to prevent\r\n\t\t\t\t// modify the .parent and break its original scene and hierarchy\r\n\t\t\t\tscene.children.push( objects[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprocessScene( scene );\r\n\r\n\t\t}\r\n\r\n\t\tfunction processInput( input ) {\r\n\r\n\t\t\tinput = input instanceof Array ? input : [ input ];\r\n\r\n\t\t\tvar objectsWithoutScene = [];\r\n\r\n\t\t\tfor ( var i = 0; i < input.length; i ++ ) {\r\n\r\n\t\t\t\tif ( input[ i ] instanceof Scene ) {\r\n\r\n\t\t\t\t\tprocessScene( input[ i ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tobjectsWithoutScene.push( input[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( objectsWithoutScene.length > 0 ) {\r\n\r\n\t\t\t\tprocessObjects( objectsWithoutScene );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < skins.length; ++ i ) {\r\n\r\n\t\t\t\tprocessSkin( skins[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < options.animations.length; ++ i ) {\r\n\r\n\t\t\t\tprocessAnimation( options.animations[ i ], input[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tprocessInput( input );\r\n\r\n\t\tPromise.all( pending ).then( function () {\r\n\r\n\t\t\t// Merge buffers.\r\n\t\t\tvar blob = new Blob( buffers, { type: 'application/octet-stream' } );\r\n\r\n\t\t\t// Declare extensions.\r\n\t\t\tvar extensionsUsedList = Object.keys( extensionsUsed );\r\n\t\t\tif ( extensionsUsedList.length > 0 ) { outputJSON.extensionsUsed = extensionsUsedList; }\r\n\r\n\t\t\tif ( outputJSON.buffers && outputJSON.buffers.length > 0 ) {\r\n\r\n\t\t\t\t// Update bytelength of the single buffer.\r\n\t\t\t\toutputJSON.buffers[ 0 ].byteLength = blob.size;\r\n\r\n\t\t\t\tvar reader = new window.FileReader();\r\n\r\n\t\t\t\tif ( options.binary === true ) {\r\n\r\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n\r\n\t\t\t\t\tvar GLB_HEADER_BYTES = 12;\r\n\t\t\t\t\tvar GLB_HEADER_MAGIC = 0x46546C67;\r\n\t\t\t\t\tvar GLB_VERSION = 2;\r\n\r\n\t\t\t\t\tvar GLB_CHUNK_PREFIX_BYTES = 8;\r\n\t\t\t\t\tvar GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\r\n\t\t\t\t\tvar GLB_CHUNK_TYPE_BIN = 0x004E4942;\r\n\r\n\t\t\t\t\treader.readAsArrayBuffer( blob );\r\n\t\t\t\t\treader.onloadend = function () {\r\n\r\n\t\t\t\t\t\t// Binary chunk.\r\n\t\t\t\t\t\tvar binaryChunk = getPaddedArrayBuffer( reader.result );\r\n\t\t\t\t\t\tvar binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\r\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\r\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\r\n\r\n\t\t\t\t\t\t// JSON chunk.\r\n\t\t\t\t\t\tvar jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( outputJSON ) ), 0x20 );\r\n\t\t\t\t\t\tvar jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\r\n\t\t\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\r\n\t\t\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\r\n\r\n\t\t\t\t\t\t// GLB header.\r\n\t\t\t\t\t\tvar header = new ArrayBuffer( GLB_HEADER_BYTES );\r\n\t\t\t\t\t\tvar headerView = new DataView( header );\r\n\t\t\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\r\n\t\t\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\r\n\t\t\t\t\t\tvar totalByteLength = GLB_HEADER_BYTES\r\n\t\t\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\r\n\t\t\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\r\n\t\t\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\r\n\r\n\t\t\t\t\t\tvar glbBlob = new Blob( [\r\n\t\t\t\t\t\t\theader,\r\n\t\t\t\t\t\t\tjsonChunkPrefix,\r\n\t\t\t\t\t\t\tjsonChunk,\r\n\t\t\t\t\t\t\tbinaryChunkPrefix,\r\n\t\t\t\t\t\t\tbinaryChunk\r\n\t\t\t\t\t\t], { type: 'application/octet-stream' } );\r\n\r\n\t\t\t\t\t\tvar glbReader = new window.FileReader();\r\n\t\t\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\r\n\t\t\t\t\t\tglbReader.onloadend = function () {\r\n\r\n\t\t\t\t\t\t\tonDone( glbReader.result );\r\n\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treader.readAsDataURL( blob );\r\n\t\t\t\t\treader.onloadend = function () {\r\n\r\n\t\t\t\t\t\tvar base64data = reader.result;\r\n\t\t\t\t\t\toutputJSON.buffers[ 0 ].uri = base64data;\r\n\t\t\t\t\t\tonDone( outputJSON );\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tonDone( outputJSON );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MMDExporter = function () {\r\n\r\n\t// Unicode to Shift_JIS table\r\n\tvar u2sTable;\r\n\r\n\tfunction unicodeToShiftjis( str ) {\r\n\r\n\t\tif ( u2sTable === undefined ) {\r\n\r\n\t\t\tvar encoder = new MMDParser.CharsetEncoder();\r\n\t\t\tvar table = encoder.s2uTable;\r\n\t\t\tu2sTable = {};\r\n\r\n\t\t\tvar keys = Object.keys( table );\r\n\r\n\t\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar key = keys[ i ];\r\n\r\n\t\t\t\tvar value = table[ key ];\r\n\t\t\t\tkey = parseInt( key );\r\n\r\n\t\t\t\tu2sTable[ value ] = key;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0, il = str.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar code = str.charCodeAt( i );\r\n\r\n\t\t\tvar value = u2sTable[ code ];\r\n\r\n\t\t\tif ( value === undefined ) {\r\n\r\n\t\t\t\tthrow 'cannot convert charcode 0x' + code.toString( 16 );\r\n\r\n\t\t\t} else if ( value > 0xff ) {\r\n\r\n\t\t\t\tarray.push( ( value >> 8 ) & 0xff );\r\n\t\t\t\tarray.push( value & 0xff );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tarray.push( value & 0xff );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn new Uint8Array( array );\r\n\r\n\t}\r\n\r\n\tfunction getBindBones( skin ) {\r\n\r\n\t\t// any more efficient ways?\r\n\t\tvar poseSkin = skin.clone();\r\n\t\tposeSkin.pose();\r\n\t\treturn poseSkin.skeleton.bones;\r\n\r\n\t}\r\n\t\r\n\tthis.parseVpd = function ( skin, outputShiftJis, useOriginalBones ) {\r\n\r\n\t\tif ( skin.isSkinnedMesh !== true ) {\r\n\r\n\t\t\tconsole.warn( 'MMDExporter: parseVpd() requires SkinnedMesh instance.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tfunction toStringsFromNumber( num ) {\r\n\r\n\t\t\tif ( Math.abs( num ) < 1e-6 ) { num = 0; }\r\n\r\n\t\t\tvar a = num.toString();\r\n\r\n\t\t\tif ( a.indexOf( '.' ) === - 1 ) {\r\n\r\n\t\t\t\ta += '.';\r\n\r\n\t\t\t}\r\n\r\n\t\t\ta += '000000';\r\n\r\n\t\t\tvar index = a.indexOf( '.' );\r\n\r\n\t\t\tvar d = a.slice( 0, index );\r\n\t\t\tvar p = a.slice( index + 1, index + 7 );\r\n\r\n\t\t\treturn d + '.' + p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction toStringsFromArray( array ) {\r\n\r\n\t\t\tvar a = [];\r\n\r\n\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\ta.push( toStringsFromNumber( array[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a.join( ',' );\r\n\r\n\t\t}\r\n\r\n\t\tskin.updateMatrixWorld( true );\r\n\r\n\t\tvar bones = skin.skeleton.bones;\r\n\t\tvar bones2 = getBindBones( skin );\r\n\r\n\t\tvar position = new Vector3();\r\n\t\tvar quaternion = new Quaternion();\r\n\t\tvar quaternion2 = new Quaternion();\r\n\t\tvar matrix = new Matrix4();\r\n\r\n\t\tvar array = [];\r\n\t\tarray.push( 'Vocaloid Pose Data file' );\r\n\t\tarray.push( '' );\r\n\t\tarray.push( ( skin.name !== '' ? skin.name.replace( /\\s/g, '_' ) : 'skin' ) + '.osm;' );\r\n\t\tarray.push( bones.length + ';' );\r\n\t\tarray.push( '' );\r\n\r\n\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar bone = bones[ i ];\r\n\t\t\tvar bone2 = bones2[ i ];\r\n\t\t\t\r\n\t\t\tif ( useOriginalBones === true &&\r\n\t\t\t\tbone.userData.ik !== undefined &&\r\n\t\t\t\tbone.userData.ik.originalMatrix !== undefined ) {\r\n\r\n\t\t\t\tmatrix.fromArray( bone.userData.ik.originalMatrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmatrix.copy( bone.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tposition.setFromMatrixPosition( matrix );\r\n\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\r\n\t\t\tvar pArray = position.sub( bone2.position ).toArray();\r\n\t\t\tvar qArray = quaternion2.copy( bone2.quaternion ).conjugate().multiply( quaternion ).toArray();\r\n\r\n\t\t\t// right to left\r\n\t\t\tpArray[ 2 ] = - pArray[ 2 ];\r\n\t\t\tqArray[ 0 ] = - qArray[ 0 ];\r\n\t\t\tqArray[ 1 ] = - qArray[ 1 ];\r\n\r\n\t\t\tarray.push( 'Bone' + i + '{' + bone.name );\r\n\t\t\tarray.push( '  ' + toStringsFromArray( pArray ) + ';' );\r\n\t\t\tarray.push( '  ' + toStringsFromArray( qArray ) + ';' );\r\n\t\t\tarray.push( '}' );\r\n\t\t\tarray.push( '' );\r\n\r\n\t\t}\r\n\r\n\t\tarray.push( '' );\r\n\r\n\t\tvar lines = array.join( '\\n' );\r\n\r\n\t\treturn ( outputShiftJis === true ) ? unicodeToShiftjis( lines ) : lines;\r\n\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar OBJExporter = function () {};\r\n\r\nOBJExporter.prototype = {\r\n\r\n\tconstructor: OBJExporter,\r\n\r\n\tparse: function ( object ) {\r\n\r\n\t\tvar output = '';\r\n\r\n\t\tvar indexVertex = 0;\r\n\t\tvar indexVertexUvs = 0;\r\n\t\tvar indexNormals = 0;\r\n\r\n\t\tvar vertex = new Vector3();\r\n\t\tvar normal = new Vector3();\r\n\t\tvar uv = new Vector2();\r\n\r\n\t\tvar i, j, k, l, m, face = [];\r\n\r\n\t\tvar parseMesh = function ( mesh ) {\r\n\r\n\t\t\tvar nbVertex = 0;\r\n\t\t\tvar nbNormals = 0;\r\n\t\t\tvar nbVertexUvs = 0;\r\n\r\n\t\t\tvar geometry = mesh.geometry;\r\n\r\n\t\t\tvar normalMatrixWorld = new Matrix3();\r\n\r\n\t\t\tif ( geometry instanceof Geometry ) {\r\n\r\n\t\t\t\tgeometry = new BufferGeometry().setFromObject( mesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry instanceof BufferGeometry ) {\r\n\r\n\t\t\t\t// shortcuts\r\n\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\r\n\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\r\n\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\r\n\t\t\t\tvar indices = geometry.getIndex();\r\n\r\n\t\t\t\t// name of the mesh object\r\n\t\t\t\toutput += 'o ' + mesh.name + '\\n';\r\n\r\n\t\t\t\t// name of the mesh material\r\n\t\t\t\tif ( mesh.material && mesh.material.name ) {\r\n\r\n\t\t\t\t\toutput += 'usemtl ' + mesh.material.name + '\\n';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// vertices\r\n\r\n\t\t\t\tif ( vertices !== undefined ) {\r\n\r\n\t\t\t\t\tfor ( i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\r\n\r\n\t\t\t\t\t\tvertex.x = vertices.getX( i );\r\n\t\t\t\t\t\tvertex.y = vertices.getY( i );\r\n\t\t\t\t\t\tvertex.z = vertices.getZ( i );\r\n\r\n\t\t\t\t\t\t// transfrom the vertex to world space\r\n\t\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\r\n\r\n\t\t\t\t\t\t// transform the vertex to export format\r\n\t\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// uvs\r\n\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\t\tfor ( i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {\r\n\r\n\t\t\t\t\t\tuv.x = uvs.getX( i );\r\n\t\t\t\t\t\tuv.y = uvs.getY( i );\r\n\r\n\t\t\t\t\t\t// transform the uv to export format\r\n\t\t\t\t\t\toutput += 'vt ' + uv.x + ' ' + uv.y + '\\n';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// normals\r\n\r\n\t\t\t\tif ( normals !== undefined ) {\r\n\r\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\r\n\r\n\t\t\t\t\tfor ( i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {\r\n\r\n\t\t\t\t\t\tnormal.x = normals.getX( i );\r\n\t\t\t\t\t\tnormal.y = normals.getY( i );\r\n\t\t\t\t\t\tnormal.z = normals.getZ( i );\r\n\r\n\t\t\t\t\t\t// transfrom the normal to world space\r\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrixWorld );\r\n\r\n\t\t\t\t\t\t// transform the normal to export format\r\n\t\t\t\t\t\toutput += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// faces\r\n\r\n\t\t\t\tif ( indices !== null ) {\r\n\r\n\t\t\t\t\tfor ( i = 0, l = indices.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\tfor ( m = 0; m < 3; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tj = indices.getX( i + m ) + 1;\r\n\r\n\t\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// transform the face to export format\r\n\t\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + \"\\n\";\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( i = 0, l = vertices.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\tfor ( m = 0; m < 3; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tj = i + m + 1;\r\n\r\n\t\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// transform the face to export format\r\n\t\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + \"\\n\";\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'OBJExporter.parseMesh(): geometry type unsupported', geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update index\r\n\t\t\tindexVertex += nbVertex;\r\n\t\t\tindexVertexUvs += nbVertexUvs;\r\n\t\t\tindexNormals += nbNormals;\r\n\r\n\t\t};\r\n\r\n\t\tvar parseLine = function ( line ) {\r\n\r\n\t\t\tvar nbVertex = 0;\r\n\r\n\t\t\tvar geometry = line.geometry;\r\n\t\t\tvar type = line.type;\r\n\r\n\t\t\tif ( geometry instanceof Geometry ) {\r\n\r\n\t\t\t\tgeometry = new BufferGeometry().setFromObject( line );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry instanceof BufferGeometry ) {\r\n\r\n\t\t\t\t// shortcuts\r\n\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\r\n\r\n\t\t\t\t// name of the line object\r\n\t\t\t\toutput += 'o ' + line.name + '\\n';\r\n\r\n\t\t\t\tif ( vertices !== undefined ) {\r\n\r\n\t\t\t\t\tfor ( i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\r\n\r\n\t\t\t\t\t\tvertex.x = vertices.getX( i );\r\n\t\t\t\t\t\tvertex.y = vertices.getY( i );\r\n\t\t\t\t\t\tvertex.z = vertices.getZ( i );\r\n\r\n\t\t\t\t\t\t// transfrom the vertex to world space\r\n\t\t\t\t\t\tvertex.applyMatrix4( line.matrixWorld );\r\n\r\n\t\t\t\t\t\t// transform the vertex to export format\r\n\t\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( type === 'Line' ) {\r\n\r\n\t\t\t\t\toutput += 'l ';\r\n\r\n\t\t\t\t\tfor ( j = 1, l = vertices.count; j <= l; j ++ ) {\r\n\r\n\t\t\t\t\t\toutput += ( indexVertex + j ) + ' ';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutput += '\\n';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( type === 'LineSegments' ) {\r\n\r\n\t\t\t\t\tfor ( j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {\r\n\r\n\t\t\t\t\t\toutput += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '\\n';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'OBJExporter.parseLine(): geometry type unsupported', geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update index\r\n\t\t\tindexVertex += nbVertex;\r\n\r\n\t\t};\r\n\r\n\t\tobject.traverse( function ( child ) {\r\n\r\n\t\t\tif ( child instanceof Mesh ) {\r\n\r\n\t\t\t\tparseMesh( child );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( child instanceof Line ) {\r\n\r\n\t\t\t\tparseLine( child );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn output;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PLYExporter = function () {};\r\n\r\nPLYExporter.prototype = {\r\n\r\n\tconstructor: PLYExporter,\r\n\r\n\tparse: function ( object, onDone, options ) {\r\n\r\n\t\tif ( onDone && typeof onDone === 'object' ) {\r\n\r\n\t\t\tconsole.warn( 'PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.' );\r\n\t\t\toptions = onDone;\r\n\t\t\tonDone = undefined;\r\n\r\n\t\t}\r\n\r\n\t\t// Iterate over the valid meshes in the object\r\n\t\tfunction traverseMeshes( cb ) {\r\n\r\n\t\t\tobject.traverse( function ( child ) {\r\n\r\n\t\t\t\tif ( child.isMesh === true ) {\r\n\r\n\t\t\t\t\tvar mesh = child;\r\n\t\t\t\t\tvar geometry = mesh.geometry;\r\n\r\n\t\t\t\t\tif ( geometry.isGeometry === true ) {\r\n\r\n\t\t\t\t\t\tgeometry = geomToBufferGeom.get( geometry );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( geometry.isBufferGeometry === true ) {\r\n\r\n\t\t\t\t\t\tif ( geometry.getAttribute( 'position' ) !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tcb( mesh, geometry );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\t// Default options\r\n\t\tvar defaultOptions = {\r\n\t\t\tbinary: false,\r\n\t\t\texcludeAttributes: [] // normal, uv, color, index\r\n\t\t};\r\n\r\n\t\toptions = Object.assign( defaultOptions, options );\r\n\r\n\t\tvar excludeAttributes = options.excludeAttributes;\r\n\t\tvar geomToBufferGeom = new WeakMap();\r\n\t\tvar includeNormals = false;\r\n\t\tvar includeColors = false;\r\n\t\tvar includeUVs = false;\r\n\r\n\t\t// count the vertices, check which properties are used,\r\n\t\t// and cache the BufferGeometry\r\n\t\tvar vertexCount = 0;\r\n\t\tvar faceCount = 0;\r\n\t\tobject.traverse( function ( child ) {\r\n\r\n\t\t\tif ( child.isMesh === true ) {\r\n\r\n\t\t\t\tvar mesh = child;\r\n\t\t\t\tvar geometry = mesh.geometry;\r\n\r\n\t\t\t\tif ( geometry.isGeometry === true ) {\r\n\r\n\t\t\t\t\tvar bufferGeometry = geomToBufferGeom.get( geometry ) || new BufferGeometry().setFromObject( mesh );\r\n\t\t\t\t\tgeomToBufferGeom.set( geometry, bufferGeometry );\r\n\t\t\t\t\tgeometry = bufferGeometry;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geometry.isBufferGeometry === true ) {\r\n\r\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\r\n\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\r\n\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\r\n\t\t\t\t\tvar colors = geometry.getAttribute( 'color' );\r\n\t\t\t\t\tvar indices = geometry.getIndex();\r\n\r\n\t\t\t\t\tif ( vertices === undefined ) {\r\n\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvertexCount += vertices.count;\r\n\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\r\n\r\n\t\t\t\t\tif ( normals !== undefined ) { includeNormals = true; }\r\n\r\n\t\t\t\t\tif ( uvs !== undefined ) { includeUVs = true; }\r\n\r\n\t\t\t\t\tif ( colors !== undefined ) { includeColors = true; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tvar includeIndices = excludeAttributes.indexOf( 'index' ) === - 1;\r\n\t\tincludeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === - 1;\r\n\t\tincludeColors = includeColors && excludeAttributes.indexOf( 'color' ) === - 1;\r\n\t\tincludeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === - 1;\r\n\r\n\t\tif ( includeIndices && faceCount !== Math.floor( faceCount ) ) {\r\n\r\n\t\t\t// point cloud meshes will not have an index array and may not have a\r\n\t\t\t// number of vertices that is divisble by 3 (and therefore representable\r\n\t\t\t// as triangles)\r\n\t\t\tconsole.error(\r\n\r\n\t\t\t\t'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\r\n\t\t\t\t'number of indices is not divisible by 3.'\r\n\r\n\t\t\t);\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// get how many bytes will be needed to save out the faces\r\n\t\t// so we can use a minimal amount of memory / data\r\n\t\tvar indexByteCount = 1;\r\n\r\n\t\tif ( vertexCount > 256 ) { // 2^8 bits\r\n\r\n\t\t\tindexByteCount = 2;\r\n\r\n\t\t}\r\n\r\n\t\tif ( vertexCount > 65536 ) { // 2^16 bits\r\n\r\n\t\t\tindexByteCount = 4;\r\n\r\n\t\t}\r\n\r\n\t\tvar header =\r\n\t\t\t'ply\\n' +\r\n\t\t\t\"format \" + (options.binary ? 'binary_big_endian' : 'ascii') + \" 1.0\\n\" +\r\n\t\t\t\"element vertex \" + vertexCount + \"\\n\" +\r\n\r\n\t\t\t// position\r\n\t\t\t'property float x\\n' +\r\n\t\t\t'property float y\\n' +\r\n\t\t\t'property float z\\n';\r\n\r\n\t\tif ( includeNormals === true ) {\r\n\r\n\t\t\t// normal\r\n\t\t\theader +=\r\n\t\t\t\t'property float nx\\n' +\r\n\t\t\t\t'property float ny\\n' +\r\n\t\t\t\t'property float nz\\n';\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeUVs === true ) {\r\n\r\n\t\t\t// uvs\r\n\t\t\theader +=\r\n\t\t\t\t'property float s\\n' +\r\n\t\t\t\t'property float t\\n';\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeColors === true ) {\r\n\r\n\t\t\t// colors\r\n\t\t\theader +=\r\n\t\t\t\t'property uchar red\\n' +\r\n\t\t\t\t'property uchar green\\n' +\r\n\t\t\t\t'property uchar blue\\n';\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeIndices === true ) {\r\n\r\n\t\t\t// faces\r\n\t\t\theader +=\r\n\t\t\t\t\"element face \" + faceCount + \"\\n\" +\r\n\t\t\t\t\"property list uchar uint\" + (indexByteCount * 8) + \" vertex_index\\n\";\r\n\r\n\t\t}\r\n\r\n\t\theader += 'end_header\\n';\r\n\r\n\t\t// Generate attribute data\r\n\t\tvar vertex = new Vector3();\r\n\t\tvar normalMatrixWorld = new Matrix3();\r\n\t\tvar result = null;\r\n\r\n\t\tif ( options.binary === true ) {\r\n\r\n\t\t\t// Binary File Generation\r\n\t\t\tvar headerBin = new TextEncoder().encode( header );\r\n\r\n\t\t\t// 3 position values at 4 bytes\r\n\t\t\t// 3 normal values at 4 bytes\r\n\t\t\t// 3 color channels with 1 byte\r\n\t\t\t// 2 uv values at 4 bytes\r\n\t\t\tvar vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );\r\n\r\n\t\t\t// 1 byte shape desciptor\r\n\t\t\t// 3 vertex indices at ${indexByteCount} bytes\r\n\t\t\tvar faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;\r\n\t\t\tvar output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );\r\n\t\t\tnew Uint8Array( output.buffer ).set( headerBin, 0 );\r\n\r\n\t\t\tvar vOffset = headerBin.length;\r\n\t\t\tvar fOffset = headerBin.length + vertexListLength;\r\n\t\t\tvar writtenVertices = 0;\r\n\t\t\ttraverseMeshes( function ( mesh, geometry ) {\r\n\r\n\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\r\n\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\r\n\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\r\n\t\t\t\tvar colors = geometry.getAttribute( 'color' );\r\n\t\t\t\tvar indices = geometry.getIndex();\r\n\r\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\r\n\r\n\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex.x = vertices.getX( i );\r\n\t\t\t\t\tvertex.y = vertices.getY( i );\r\n\t\t\t\t\tvertex.z = vertices.getZ( i );\r\n\r\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\r\n\r\n\t\t\t\t\t// Position information\r\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.x );\r\n\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.y );\r\n\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.z );\r\n\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t// Normal information\r\n\t\t\t\t\tif ( includeNormals === true ) {\r\n\r\n\t\t\t\t\t\tif ( normals != null ) {\r\n\r\n\t\t\t\t\t\t\tvertex.x = normals.getX( i );\r\n\t\t\t\t\t\t\tvertex.y = normals.getY( i );\r\n\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\r\n\r\n\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld );\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x );\r\n\t\t\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y );\r\n\t\t\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z );\r\n\t\t\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0 );\r\n\t\t\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0 );\r\n\t\t\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0 );\r\n\t\t\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// UV information\r\n\t\t\t\t\tif ( includeUVs === true ) {\r\n\r\n\t\t\t\t\t\tif ( uvs != null ) {\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getX( i ) );\r\n\t\t\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getY( i ) );\r\n\t\t\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t\t} else if ( includeUVs !== false ) {\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0 );\r\n\t\t\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0 );\r\n\t\t\t\t\t\t\tvOffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Color information\r\n\t\t\t\t\tif ( includeColors === true ) {\r\n\r\n\t\t\t\t\t\tif ( colors != null ) {\r\n\r\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getX( i ) * 255 ) );\r\n\t\t\t\t\t\t\tvOffset += 1;\r\n\r\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getY( i ) * 255 ) );\r\n\t\t\t\t\t\t\tvOffset += 1;\r\n\r\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getZ( i ) * 255 ) );\r\n\t\t\t\t\t\t\tvOffset += 1;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\r\n\t\t\t\t\t\t\tvOffset += 1;\r\n\r\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\r\n\t\t\t\t\t\t\tvOffset += 1;\r\n\r\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\r\n\t\t\t\t\t\t\tvOffset += 1;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( includeIndices === true ) {\r\n\r\n\t\t\t\t\t// Create the face list\r\n\t\t\t\t\tvar faceIndexFunc = \"setUint\" + (indexByteCount * 8);\r\n\t\t\t\t\tif ( indices !== null ) {\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = indices.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\r\n\t\t\t\t\t\t\tfOffset += 1;\r\n\r\n\t\t\t\t\t\t\toutput[ faceIndexFunc ]( fOffset, indices.getX( i + 0 ) + writtenVertices );\r\n\t\t\t\t\t\t\tfOffset += indexByteCount;\r\n\r\n\t\t\t\t\t\t\toutput[ faceIndexFunc ]( fOffset, indices.getX( i + 1 ) + writtenVertices );\r\n\t\t\t\t\t\t\tfOffset += indexByteCount;\r\n\r\n\t\t\t\t\t\t\toutput[ faceIndexFunc ]( fOffset, indices.getX( i + 2 ) + writtenVertices );\r\n\t\t\t\t\t\t\tfOffset += indexByteCount;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\r\n\t\t\t\t\t\t\tfOffset += 1;\r\n\r\n\t\t\t\t\t\t\toutput[ faceIndexFunc ]( fOffset, writtenVertices + i );\r\n\t\t\t\t\t\t\tfOffset += indexByteCount;\r\n\r\n\t\t\t\t\t\t\toutput[ faceIndexFunc ]( fOffset, writtenVertices + i + 1 );\r\n\t\t\t\t\t\t\tfOffset += indexByteCount;\r\n\r\n\t\t\t\t\t\t\toutput[ faceIndexFunc ]( fOffset, writtenVertices + i + 2 );\r\n\t\t\t\t\t\t\tfOffset += indexByteCount;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Save the amount of verts we've already written so we can offset\r\n\t\t\t\t// the face index on the next mesh\r\n\t\t\t\twrittenVertices += vertices.count;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tresult = output.buffer;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Ascii File Generation\r\n\t\t\t// count the number of vertices\r\n\t\t\tvar writtenVertices = 0;\r\n\t\t\tvar vertexList = '';\r\n\t\t\tvar faceList = '';\r\n\r\n\t\t\ttraverseMeshes( function ( mesh, geometry ) {\r\n\r\n\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\r\n\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\r\n\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\r\n\t\t\t\tvar colors = geometry.getAttribute( 'color' );\r\n\t\t\t\tvar indices = geometry.getIndex();\r\n\r\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\r\n\r\n\t\t\t\t// form each line\r\n\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvertex.x = vertices.getX( i );\r\n\t\t\t\t\tvertex.y = vertices.getY( i );\r\n\t\t\t\t\tvertex.z = vertices.getZ( i );\r\n\r\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\r\n\r\n\t\t\t\t\t// Position information\r\n\t\t\t\t\tvar line =\r\n\t\t\t\t\t\tvertex.x + ' ' +\r\n\t\t\t\t\t\tvertex.y + ' ' +\r\n\t\t\t\t\t\tvertex.z;\r\n\r\n\t\t\t\t\t// Normal information\r\n\t\t\t\t\tif ( includeNormals === true ) {\r\n\r\n\t\t\t\t\t\tif ( normals != null ) {\r\n\r\n\t\t\t\t\t\t\tvertex.x = normals.getX( i );\r\n\t\t\t\t\t\t\tvertex.y = normals.getY( i );\r\n\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\r\n\r\n\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld );\r\n\r\n\t\t\t\t\t\t\tline += ' ' +\r\n\t\t\t\t\t\t\t\tvertex.x + ' ' +\r\n\t\t\t\t\t\t\t\tvertex.y + ' ' +\r\n\t\t\t\t\t\t\t\tvertex.z;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tline += ' 0 0 0';\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// UV information\r\n\t\t\t\t\tif ( includeUVs === true ) {\r\n\r\n\t\t\t\t\t\tif ( uvs != null ) {\r\n\r\n\t\t\t\t\t\t\tline += ' ' +\r\n\t\t\t\t\t\t\t\tuvs.getX( i ) + ' ' +\r\n\t\t\t\t\t\t\t\tuvs.getY( i );\r\n\r\n\t\t\t\t\t\t} else if ( includeUVs !== false ) {\r\n\r\n\t\t\t\t\t\t\tline += ' 0 0';\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Color information\r\n\t\t\t\t\tif ( includeColors === true ) {\r\n\r\n\t\t\t\t\t\tif ( colors != null ) {\r\n\r\n\t\t\t\t\t\t\tline += ' ' +\r\n\t\t\t\t\t\t\t\tMath.floor( colors.getX( i ) * 255 ) + ' ' +\r\n\t\t\t\t\t\t\t\tMath.floor( colors.getY( i ) * 255 ) + ' ' +\r\n\t\t\t\t\t\t\t\tMath.floor( colors.getZ( i ) * 255 );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tline += ' 255 255 255';\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvertexList += line + '\\n';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Create the face list\r\n\t\t\t\tif ( includeIndices === true ) {\r\n\r\n\t\t\t\t\tif ( indices !== null ) {\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = indices.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\tfaceList += \"3 \" + (indices.getX( i + 0 ) + writtenVertices);\r\n\t\t\t\t\t\t\tfaceList += \" \" + (indices.getX( i + 1 ) + writtenVertices);\r\n\t\t\t\t\t\t\tfaceList += \" \" + (indices.getX( i + 2 ) + writtenVertices) + \"\\n\";\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\tfaceList += \"3 \" + (writtenVertices + i) + \" \" + (writtenVertices + i + 1) + \" \" + (writtenVertices + i + 2) + \"\\n\";\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\twrittenVertices += vertices.count;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tresult = \"\" + header + vertexList + \"\\n\" + (includeIndices ? (faceList + \"\\n\") : '');\r\n\r\n\t\t}\r\n\r\n\t\tif ( typeof onDone === 'function' ) { requestAnimationFrame( function () { return onDone( result ); } ); }\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar STLExporter = function () {};\r\n\r\nSTLExporter.prototype = {\r\n\r\n\tconstructor: STLExporter,\r\n\r\n\tparse: ( function () {\r\n\r\n\t\tvar vector = new Vector3();\r\n\t\tvar normalMatrixWorld = new Matrix3();\r\n\r\n\t\treturn function parse( scene, options ) {\r\n\r\n\t\t\tif ( options === undefined ) { options = {}; }\r\n\r\n\t\t\tvar binary = options.binary !== undefined ? options.binary : false;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tvar objects = [];\r\n\t\t\tvar triangles = 0;\r\n\r\n\t\t\tscene.traverse( function ( object ) {\r\n\r\n\t\t\t\tif ( object.isMesh ) {\r\n\r\n\t\t\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\t\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\t\tgeometry = new Geometry().fromBufferGeometry( geometry );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( geometry.isGeometry ) {\r\n\r\n\t\t\t\t\t\ttriangles += geometry.faces.length;\r\n\r\n\t\t\t\t\t\tobjects.push( {\r\n\r\n\t\t\t\t\t\t\tgeometry: geometry,\r\n\t\t\t\t\t\t\tmatrixWorld: object.matrixWorld\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tif ( binary ) {\r\n\r\n\t\t\t\tvar offset = 80; // skip header\r\n\t\t\t\tvar bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\r\n\t\t\t\tvar arrayBuffer = new ArrayBuffer( bufferLength );\r\n\t\t\t\tvar output = new DataView( arrayBuffer );\r\n\t\t\t\toutput.setUint32( offset, triangles, true ); offset += 4;\r\n\r\n\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar object = objects[ i ];\r\n\r\n\t\t\t\t\tvar vertices = object.geometry.vertices;\r\n\t\t\t\t\tvar faces = object.geometry.faces;\r\n\t\t\t\t\tvar matrixWorld = object.matrixWorld;\r\n\r\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( matrixWorld );\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = faces.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar face = faces[ j ];\r\n\r\n\t\t\t\t\t\tvector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();\r\n\r\n\t\t\t\t\t\toutput.setFloat32( offset, vector.x, true ); offset += 4; // normal\r\n\t\t\t\t\t\toutput.setFloat32( offset, vector.y, true ); offset += 4;\r\n\t\t\t\t\t\toutput.setFloat32( offset, vector.z, true ); offset += 4;\r\n\r\n\t\t\t\t\t\tvar indices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\t\t\t\tfor ( var k = 0; k < 3; k ++ ) {\r\n\r\n\t\t\t\t\t\t\tvector.copy( vertices[ indices[ k ] ] ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.x, true ); offset += 4; // vertices\r\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.y, true ); offset += 4;\r\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.z, true ); offset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\toutput.setUint16( offset, 0, true ); offset += 2; // attribute byte count\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn output;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar output = '';\r\n\r\n\t\t\t\toutput += 'solid exported\\n';\r\n\r\n\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar object = objects[ i ];\r\n\r\n\t\t\t\t\tvar vertices = object.geometry.vertices;\r\n\t\t\t\t\tvar faces = object.geometry.faces;\r\n\t\t\t\t\tvar matrixWorld = object.matrixWorld;\r\n\r\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( matrixWorld );\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = faces.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar face = faces[ j ];\r\n\r\n\t\t\t\t\t\tvector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();\r\n\r\n\t\t\t\t\t\toutput += '\\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\r\n\t\t\t\t\t\toutput += '\\t\\touter loop\\n';\r\n\r\n\t\t\t\t\t\tvar indices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\t\t\t\tfor ( var k = 0; k < 3; k ++ ) {\r\n\r\n\t\t\t\t\t\t\tvector.copy( vertices[ indices[ k ] ] ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\t\t\t\toutput += '\\t\\t\\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\toutput += '\\t\\tendloop\\n';\r\n\t\t\t\t\t\toutput += '\\tendfacet\\n';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\toutput += 'endsolid exported\\n';\r\n\r\n\t\t\t\treturn output;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TypedGeometryExporter = function () {};\r\n\r\nTypedGeometryExporter.prototype = {\r\n\r\n\tconstructor: TypedGeometryExporter,\r\n\r\n\tparse: function ( geometry ) {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.0,\r\n\t\t\t\ttype: 'TypedGeometry',\r\n\t\t\t\tgenerator: 'TypedGeometryExporter'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar attributes = [ 'vertices', 'normals', 'uvs' ];\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tvar typedArray = geometry[ attribute ];\r\n\t\t\tvar array = [];\r\n\r\n\t\t\tfor ( var i = 0, l = typedArray.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = typedArray[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutput[ attribute ] = array;\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = geometry.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\toutput.boundingSphere = {\r\n\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\tfunction DecalGeometry( mesh, position, orientation, size ) {\r\n\r\n\t\tBufferGeometry.call( this );\r\n\r\n\t\t// buffers\r\n\r\n\t\tvar vertices = [];\r\n\t\tvar normals = [];\r\n\t\tvar uvs = [];\r\n\r\n\t\t// helpers\r\n\r\n\t\tvar plane = new Vector3();\r\n\r\n\t\t// this matrix represents the transformation of the decal projector\r\n\r\n\t\tvar projectorMatrix = new Matrix4();\r\n\t\tprojectorMatrix.makeRotationFromEuler( orientation );\r\n\t\tprojectorMatrix.setPosition( position );\r\n\r\n\t\tvar projectorMatrixInverse = new Matrix4().getInverse( projectorMatrix );\r\n\r\n\t\t// generate buffers\r\n\r\n\t\tgenerate();\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\tfunction generate() {\r\n\r\n\t\t\tvar i;\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\t\t\tvar decalVertices = [];\r\n\r\n\t\t\tvar vertex = new Vector3();\r\n\t\t\tvar normal = new Vector3();\r\n\r\n\t\t\t// handle different geometry types\r\n\r\n\t\t\tif ( mesh.geometry.isGeometry ) {\r\n\r\n\t\t\t\tgeometry.fromGeometry( mesh.geometry );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgeometry.copy( mesh.geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positionAttribute = geometry.attributes.position;\r\n\t\t\tvar normalAttribute = geometry.attributes.normal;\r\n\r\n\t\t\t// first, create an array of 'DecalVertex' objects\r\n\t\t\t// three consecutive 'DecalVertex' objects represent a single face\r\n\t\t\t//\r\n\t\t\t// this data structure will be later used to perform the clipping\r\n\r\n\t\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t\t// indexed BufferGeometry\r\n\r\n\t\t\t\tvar index = geometry.index;\r\n\r\n\t\t\t\tfor ( i = 0; i < index.count; i ++ ) {\r\n\r\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, index.getX( i ) );\r\n\t\t\t\t\tnormal.fromBufferAttribute( normalAttribute, index.getX( i ) );\r\n\r\n\t\t\t\t\tpushDecalVertex( decalVertices, vertex, normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed BufferGeometry\r\n\r\n\t\t\t\tfor ( i = 0; i < positionAttribute.count; i ++ ) {\r\n\r\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, i );\r\n\t\t\t\t\tnormal.fromBufferAttribute( normalAttribute, i );\r\n\r\n\t\t\t\t\tpushDecalVertex( decalVertices, vertex, normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// second, clip the geometry so that it doesn't extend out from the projector\r\n\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 1, 0, 0 ) );\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( - 1, 0, 0 ) );\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 1, 0 ) );\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, - 1, 0 ) );\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 0, 1 ) );\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 0, - 1 ) );\r\n\r\n\t\t\t// third, generate final vertices, normals and uvs\r\n\r\n\t\t\tfor ( i = 0; i < decalVertices.length; i ++ ) {\r\n\r\n\t\t\t\tvar decalVertex = decalVertices[ i ];\r\n\r\n\t\t\t\t// create texture coordinates (we are still in projector space)\r\n\r\n\t\t\t\tuvs.push(\r\n\t\t\t\t\t0.5 + ( decalVertex.position.x / size.x ),\r\n\t\t\t\t\t0.5 + ( decalVertex.position.y / size.y )\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// transform the vertex back to world space\r\n\r\n\t\t\t\tdecalVertex.position.applyMatrix4( projectorMatrix );\r\n\r\n\t\t\t\t// now create vertex and normal buffer data\r\n\r\n\t\t\t\tvertices.push( decalVertex.position.x, decalVertex.position.y, decalVertex.position.z );\r\n\t\t\t\tnormals.push( decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushDecalVertex( decalVertices, vertex, normal ) {\r\n\r\n\t\t\t// transform the vertex to world space, then to projector space\r\n\r\n\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\r\n\t\t\tvertex.applyMatrix4( projectorMatrixInverse );\r\n\r\n\t\t\tdecalVertices.push( new DecalVertex( vertex.clone(), normal.clone() ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction clipGeometry( inVertices, plane ) {\r\n\r\n\t\t\tvar outVertices = [];\r\n\r\n\t\t\tvar s = 0.5 * Math.abs( size.dot( plane ) );\r\n\r\n\t\t\t// a single iteration clips one face,\r\n\t\t\t// which consists of three consecutive 'DecalVertex' objects\r\n\r\n\t\t\tfor ( var i = 0; i < inVertices.length; i += 3 ) {\r\n\r\n\t\t\t\tvar v1Out, v2Out, v3Out, total = 0;\r\n\t\t\t\tvar nV1, nV2, nV3, nV4;\r\n\r\n\t\t\t\tvar d1 = inVertices[ i + 0 ].position.dot( plane ) - s;\r\n\t\t\t\tvar d2 = inVertices[ i + 1 ].position.dot( plane ) - s;\r\n\t\t\t\tvar d3 = inVertices[ i + 2 ].position.dot( plane ) - s;\r\n\r\n\t\t\t\tv1Out = d1 > 0;\r\n\t\t\t\tv2Out = d2 > 0;\r\n\t\t\t\tv3Out = d3 > 0;\r\n\r\n\t\t\t\t// calculate, how many vertices of the face lie outside of the clipping plane\r\n\r\n\t\t\t\ttotal = ( v1Out ? 1 : 0 ) + ( v2Out ? 1 : 0 ) + ( v3Out ? 1 : 0 );\r\n\r\n\t\t\t\tswitch ( total ) {\r\n\r\n\t\t\t\t\tcase 0: {\r\n\r\n\t\t\t\t\t\t// the entire face lies inside of the plane, no clipping needed\r\n\r\n\t\t\t\t\t\toutVertices.push( inVertices[ i ] );\r\n\t\t\t\t\t\toutVertices.push( inVertices[ i + 1 ] );\r\n\t\t\t\t\t\toutVertices.push( inVertices[ i + 2 ] );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase 1: {\r\n\r\n\t\t\t\t\t\t// one vertex lies outside of the plane, perform clipping\r\n\r\n\t\t\t\t\t\tif ( v1Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 1 ];\r\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 2 ];\r\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i ], nV1, plane, s );\r\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i ], nV2, plane, s );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( v2Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i ];\r\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 2 ];\r\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i + 1 ], nV1, plane, s );\r\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i + 1 ], nV2, plane, s );\r\n\r\n\t\t\t\t\t\t\toutVertices.push( nV3 );\r\n\t\t\t\t\t\t\toutVertices.push( nV2.clone() );\r\n\t\t\t\t\t\t\toutVertices.push( nV1.clone() );\r\n\r\n\t\t\t\t\t\t\toutVertices.push( nV2.clone() );\r\n\t\t\t\t\t\t\toutVertices.push( nV3.clone() );\r\n\t\t\t\t\t\t\toutVertices.push( nV4 );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( v3Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i ];\r\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 1 ];\r\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i + 2 ], nV1, plane, s );\r\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i + 2 ], nV2, plane, s );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\toutVertices.push( nV1.clone() );\r\n\t\t\t\t\t\toutVertices.push( nV2.clone() );\r\n\t\t\t\t\t\toutVertices.push( nV3 );\r\n\r\n\t\t\t\t\t\toutVertices.push( nV4 );\r\n\t\t\t\t\t\toutVertices.push( nV3.clone() );\r\n\t\t\t\t\t\toutVertices.push( nV2.clone() );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase 2: {\r\n\r\n\t\t\t\t\t\t// two vertices lies outside of the plane, perform clipping\r\n\r\n\t\t\t\t\t\tif ( ! v1Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i ].clone();\r\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i + 1 ], plane, s );\r\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i + 2 ], plane, s );\r\n\t\t\t\t\t\t\toutVertices.push( nV1 );\r\n\t\t\t\t\t\t\toutVertices.push( nV2 );\r\n\t\t\t\t\t\t\toutVertices.push( nV3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( ! v2Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 1 ].clone();\r\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i + 2 ], plane, s );\r\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i ], plane, s );\r\n\t\t\t\t\t\t\toutVertices.push( nV1 );\r\n\t\t\t\t\t\t\toutVertices.push( nV2 );\r\n\t\t\t\t\t\t\toutVertices.push( nV3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( ! v3Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 2 ].clone();\r\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i ], plane, s );\r\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i + 1 ], plane, s );\r\n\t\t\t\t\t\t\toutVertices.push( nV1 );\r\n\t\t\t\t\t\t\toutVertices.push( nV2 );\r\n\t\t\t\t\t\t\toutVertices.push( nV3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase 3: {\r\n\r\n\t\t\t\t\t\t// the entire face lies outside of the plane, so let's discard the corresponding vertices\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn outVertices;\r\n\r\n\t\t}\r\n\r\n\t\tfunction clip( v0, v1, p, s ) {\r\n\r\n\t\t\tvar d0 = v0.position.dot( p ) - s;\r\n\t\t\tvar d1 = v1.position.dot( p ) - s;\r\n\r\n\t\t\tvar s0 = d0 / ( d0 - d1 );\r\n\r\n\t\t\tvar v = new DecalVertex(\r\n\t\t\t\tnew Vector3(\r\n\t\t\t\t\tv0.position.x + s0 * ( v1.position.x - v0.position.x ),\r\n\t\t\t\t\tv0.position.y + s0 * ( v1.position.y - v0.position.y ),\r\n\t\t\t\t\tv0.position.z + s0 * ( v1.position.z - v0.position.z )\r\n\t\t\t\t),\r\n\t\t\t\tnew Vector3(\r\n\t\t\t\t\tv0.normal.x + s0 * ( v1.normal.x - v0.normal.x ),\r\n\t\t\t\t\tv0.normal.y + s0 * ( v1.normal.y - v0.normal.y ),\r\n\t\t\t\t\tv0.normal.z + s0 * ( v1.normal.z - v0.normal.z )\r\n\t\t\t\t)\r\n\t\t\t);\r\n\r\n\t\t\t// need to clip more values (texture coordinates)? do it this way:\r\n\t\t\t// intersectpoint.value = a.value + s * ( b.value - a.value );\r\n\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tDecalGeometry.prototype = Object.create( BufferGeometry.prototype );\r\n\tDecalGeometry.prototype.constructor = DecalGeometry;\r\n\r\n\t// helper\r\n\r\n\tfunction DecalVertex( position, normal ) {\r\n\r\n\t\tthis.position = position;\r\n\t\tthis.normal = normal;\r\n\r\n\t}\r\n\r\n\tDecalVertex.prototype.clone = function () {\r\n\r\n\t\treturn new DecalVertex( this.position.clone(), this.normal.clone() );\r\n\r\n\t};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction hilbert2D( center, size, iterations, v0, v1, v2, v3 ) {\r\n\r\n\t// Default Vars\r\n\tvar center = undefined !== center ? center : new Vector3( 0, 0, 0 ),\r\n\t\tsize = undefined !== size ? size : 10,\r\n\t\thalf = size / 2,\r\n\t\titerations = undefined !== iterations ? iterations : 1,\r\n\t\tv0 = undefined !== v0 ? v0 : 0,\r\n\t\tv1 = undefined !== v1 ? v1 : 1,\r\n\t\tv2 = undefined !== v2 ? v2 : 2,\r\n\t\tv3 = undefined !== v3 ? v3 : 3\r\n\t;\r\n\r\n\tvar vec_s = [\r\n\t\tnew Vector3( center.x - half, center.y, center.z - half ),\r\n\t\tnew Vector3( center.x - half, center.y, center.z + half ),\r\n\t\tnew Vector3( center.x + half, center.y, center.z + half ),\r\n\t\tnew Vector3( center.x + half, center.y, center.z - half )\r\n\t];\r\n\r\n\tvar vec = [\r\n\t\tvec_s[ v0 ],\r\n\t\tvec_s[ v1 ],\r\n\t\tvec_s[ v2 ],\r\n\t\tvec_s[ v3 ]\r\n\t];\r\n\r\n\t// Recurse iterations\r\n\tif ( 0 <= -- iterations ) {\r\n\r\n\t\tvar tmp = [];\r\n\r\n\t\tArray.prototype.push.apply( tmp, hilbert2D( vec[ 0 ], half, iterations, v0, v3, v2, v1 ) );\r\n\t\tArray.prototype.push.apply( tmp, hilbert2D( vec[ 1 ], half, iterations, v0, v1, v2, v3 ) );\r\n\t\tArray.prototype.push.apply( tmp, hilbert2D( vec[ 2 ], half, iterations, v0, v1, v2, v3 ) );\r\n\t\tArray.prototype.push.apply( tmp, hilbert2D( vec[ 3 ], half, iterations, v2, v1, v0, v3 ) );\r\n\r\n\t\t// Return recursive call\r\n\t\treturn tmp;\r\n\r\n\t}\r\n\r\n\t// Return complete Hilbert Curve.\r\n\treturn vec;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction hilbert3D( center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7 ) {\r\n\r\n\t// Default Vars\r\n\tvar center = undefined !== center ? center : new Vector3( 0, 0, 0 ),\r\n\t\tsize = undefined !== size ? size : 10,\r\n\t\thalf = size / 2,\r\n\t\titerations = undefined !== iterations ? iterations : 1,\r\n\t\tv0 = undefined !== v0 ? v0 : 0,\r\n\t\tv1 = undefined !== v1 ? v1 : 1,\r\n\t\tv2 = undefined !== v2 ? v2 : 2,\r\n\t\tv3 = undefined !== v3 ? v3 : 3,\r\n\t\tv4 = undefined !== v4 ? v4 : 4,\r\n\t\tv5 = undefined !== v5 ? v5 : 5,\r\n\t\tv6 = undefined !== v6 ? v6 : 6,\r\n\t\tv7 = undefined !== v7 ? v7 : 7\r\n\t;\r\n\r\n\tvar vec_s = [\r\n\t\tnew Vector3( center.x - half, center.y + half, center.z - half ),\r\n\t\tnew Vector3( center.x - half, center.y + half, center.z + half ),\r\n\t\tnew Vector3( center.x - half, center.y - half, center.z + half ),\r\n\t\tnew Vector3( center.x - half, center.y - half, center.z - half ),\r\n\t\tnew Vector3( center.x + half, center.y - half, center.z - half ),\r\n\t\tnew Vector3( center.x + half, center.y - half, center.z + half ),\r\n\t\tnew Vector3( center.x + half, center.y + half, center.z + half ),\r\n\t\tnew Vector3( center.x + half, center.y + half, center.z - half )\r\n\t];\r\n\r\n\tvar vec = [\r\n\t\tvec_s[ v0 ],\r\n\t\tvec_s[ v1 ],\r\n\t\tvec_s[ v2 ],\r\n\t\tvec_s[ v3 ],\r\n\t\tvec_s[ v4 ],\r\n\t\tvec_s[ v5 ],\r\n\t\tvec_s[ v6 ],\r\n\t\tvec_s[ v7 ]\r\n\t];\r\n\r\n\t// Recurse iterations\r\n\tif ( -- iterations >= 0 ) {\r\n\r\n\t\tvar tmp = [];\r\n\r\n\t\tArray.prototype.push.apply( tmp, hilbert3D( vec[ 0 ], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1 ) );\r\n\t\tArray.prototype.push.apply( tmp, hilbert3D( vec[ 1 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ) );\r\n\t\tArray.prototype.push.apply( tmp, hilbert3D( vec[ 2 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ) );\r\n\t\tArray.prototype.push.apply( tmp, hilbert3D( vec[ 3 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ) );\r\n\t\tArray.prototype.push.apply( tmp, hilbert3D( vec[ 4 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ) );\r\n\t\tArray.prototype.push.apply( tmp, hilbert3D( vec[ 5 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ) );\r\n\t\tArray.prototype.push.apply( tmp, hilbert3D( vec[ 6 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ) );\r\n\t\tArray.prototype.push.apply( tmp, hilbert3D( vec[ 7 ], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7 ) );\r\n\r\n\t\t// Return recursive call\r\n\t\treturn tmp;\r\n\r\n\t}\r\n\r\n\t// Return complete Hilbert Curve.\r\n\treturn vec;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TeapotBufferGeometry = function ( size, segments, bottom, lid, body, fitLid, blinn ) {\r\n\r\n\t// 32 * 4 * 4 Bezier spline patches\r\n\tvar teapotPatches = [\r\n\t\t\r\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\r\n\t\t3, 16, 17, 18, 7, 19, 20, 21, 11, 22, 23, 24, 15, 25, 26, 27,\r\n\t\t18, 28, 29, 30, 21, 31, 32, 33, 24, 34, 35, 36, 27, 37, 38, 39,\r\n\t\t30, 40, 41, 0, 33, 42, 43, 4, 36, 44, 45, 8, 39, 46, 47, 12,\r\n\t\t\r\n\t\t12, 13, 14, 15, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\r\n\t\t15, 25, 26, 27, 51, 60, 61, 62, 55, 63, 64, 65, 59, 66, 67, 68,\r\n\t\t27, 37, 38, 39, 62, 69, 70, 71, 65, 72, 73, 74, 68, 75, 76, 77,\r\n\t\t39, 46, 47, 12, 71, 78, 79, 48, 74, 80, 81, 52, 77, 82, 83, 56,\r\n\t\t56, 57, 58, 59, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\r\n\t\t59, 66, 67, 68, 87, 96, 97, 98, 91, 99, 100, 101, 95, 102, 103, 104,\r\n\t\t68, 75, 76, 77, 98, 105, 106, 107, 101, 108, 109, 110, 104, 111, 112, 113,\r\n\t\t77, 82, 83, 56, 107, 114, 115, 84, 110, 116, 117, 88, 113, 118, 119, 92,\r\n\t\t\r\n\t\t120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135,\r\n\t\t123, 136, 137, 120, 127, 138, 139, 124, 131, 140, 141, 128, 135, 142, 143, 132,\r\n\t\t132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151, 68, 152, 153, 154,\r\n\t\t135, 142, 143, 132, 147, 155, 156, 144, 151, 157, 158, 148, 154, 159, 160, 68,\r\n\t\t\r\n\t\t161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176,\r\n\t\t164, 177, 178, 161, 168, 179, 180, 165, 172, 181, 182, 169, 176, 183, 184, 173,\r\n\t\t173, 174, 175, 176, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196,\r\n\t\t176, 183, 184, 173, 188, 197, 198, 185, 192, 199, 200, 189, 196, 201, 202, 193,\r\n\t\t\r\n\t\t203, 203, 203, 203, 204, 205, 206, 207, 208, 208, 208, 208, 209, 210, 211, 212,\r\n\t\t203, 203, 203, 203, 207, 213, 214, 215, 208, 208, 208, 208, 212, 216, 217, 218,\r\n\t\t203, 203, 203, 203, 215, 219, 220, 221, 208, 208, 208, 208, 218, 222, 223, 224,\r\n\t\t203, 203, 203, 203, 221, 225, 226, 204, 208, 208, 208, 208, 224, 227, 228, 209,\r\n\t\t209, 210, 211, 212, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240,\r\n\t\t212, 216, 217, 218, 232, 241, 242, 243, 236, 244, 245, 246, 240, 247, 248, 249,\r\n\t\t218, 222, 223, 224, 243, 250, 251, 252, 246, 253, 254, 255, 249, 256, 257, 258,\r\n\t\t224, 227, 228, 209, 252, 259, 260, 229, 255, 261, 262, 233, 258, 263, 264, 237,\r\n\t\t\r\n\t\t265, 265, 265, 265, 266, 267, 268, 269, 270, 271, 272, 273, 92, 119, 118, 113,\r\n\t\t265, 265, 265, 265, 269, 274, 275, 276, 273, 277, 278, 279, 113, 112, 111, 104,\r\n\t\t265, 265, 265, 265, 276, 280, 281, 282, 279, 283, 284, 285, 104, 103, 102, 95,\r\n\t\t265, 265, 265, 265, 282, 286, 287, 266, 285, 288, 289, 270, 95, 94, 93, 92\r\n\t];\r\n\r\n\tvar teapotVertices = [\r\n\t\t1.4, 0, 2.4,\r\n\t\t1.4, - 0.784, 2.4,\r\n\t\t0.784, - 1.4, 2.4,\r\n\t\t0, - 1.4, 2.4,\r\n\t\t1.3375, 0, 2.53125,\r\n\t\t1.3375, - 0.749, 2.53125,\r\n\t\t0.749, - 1.3375, 2.53125,\r\n\t\t0, - 1.3375, 2.53125,\r\n\t\t1.4375, 0, 2.53125,\r\n\t\t1.4375, - 0.805, 2.53125,\r\n\t\t0.805, - 1.4375, 2.53125,\r\n\t\t0, - 1.4375, 2.53125,\r\n\t\t1.5, 0, 2.4,\r\n\t\t1.5, - 0.84, 2.4,\r\n\t\t0.84, - 1.5, 2.4,\r\n\t\t0, - 1.5, 2.4,\r\n\t\t- 0.784, - 1.4, 2.4,\r\n\t\t- 1.4, - 0.784, 2.4,\r\n\t\t- 1.4, 0, 2.4,\r\n\t\t- 0.749, - 1.3375, 2.53125,\r\n\t\t- 1.3375, - 0.749, 2.53125,\r\n\t\t- 1.3375, 0, 2.53125,\r\n\t\t- 0.805, - 1.4375, 2.53125,\r\n\t\t- 1.4375, - 0.805, 2.53125,\r\n\t\t- 1.4375, 0, 2.53125,\r\n\t\t- 0.84, - 1.5, 2.4,\r\n\t\t- 1.5, - 0.84, 2.4,\r\n\t\t- 1.5, 0, 2.4,\r\n\t\t- 1.4, 0.784, 2.4,\r\n\t\t- 0.784, 1.4, 2.4,\r\n\t\t0, 1.4, 2.4,\r\n\t\t- 1.3375, 0.749, 2.53125,\r\n\t\t- 0.749, 1.3375, 2.53125,\r\n\t\t0, 1.3375, 2.53125,\r\n\t\t- 1.4375, 0.805, 2.53125,\r\n\t\t- 0.805, 1.4375, 2.53125,\r\n\t\t0, 1.4375, 2.53125,\r\n\t\t- 1.5, 0.84, 2.4,\r\n\t\t- 0.84, 1.5, 2.4,\r\n\t\t0, 1.5, 2.4,\r\n\t\t0.784, 1.4, 2.4,\r\n\t\t1.4, 0.784, 2.4,\r\n\t\t0.749, 1.3375, 2.53125,\r\n\t\t1.3375, 0.749, 2.53125,\r\n\t\t0.805, 1.4375, 2.53125,\r\n\t\t1.4375, 0.805, 2.53125,\r\n\t\t0.84, 1.5, 2.4,\r\n\t\t1.5, 0.84, 2.4,\r\n\t\t1.75, 0, 1.875,\r\n\t\t1.75, - 0.98, 1.875,\r\n\t\t0.98, - 1.75, 1.875,\r\n\t\t0, - 1.75, 1.875,\r\n\t\t2, 0, 1.35,\r\n\t\t2, - 1.12, 1.35,\r\n\t\t1.12, - 2, 1.35,\r\n\t\t0, - 2, 1.35,\r\n\t\t2, 0, 0.9,\r\n\t\t2, - 1.12, 0.9,\r\n\t\t1.12, - 2, 0.9,\r\n\t\t0, - 2, 0.9,\r\n\t\t- 0.98, - 1.75, 1.875,\r\n\t\t- 1.75, - 0.98, 1.875,\r\n\t\t- 1.75, 0, 1.875,\r\n\t\t- 1.12, - 2, 1.35,\r\n\t\t- 2, - 1.12, 1.35,\r\n\t\t- 2, 0, 1.35,\r\n\t\t- 1.12, - 2, 0.9,\r\n\t\t- 2, - 1.12, 0.9,\r\n\t\t- 2, 0, 0.9,\r\n\t\t- 1.75, 0.98, 1.875,\r\n\t\t- 0.98, 1.75, 1.875,\r\n\t\t0, 1.75, 1.875,\r\n\t\t- 2, 1.12, 1.35,\r\n\t\t- 1.12, 2, 1.35,\r\n\t\t0, 2, 1.35,\r\n\t\t- 2, 1.12, 0.9,\r\n\t\t- 1.12, 2, 0.9,\r\n\t\t0, 2, 0.9,\r\n\t\t0.98, 1.75, 1.875,\r\n\t\t1.75, 0.98, 1.875,\r\n\t\t1.12, 2, 1.35,\r\n\t\t2, 1.12, 1.35,\r\n\t\t1.12, 2, 0.9,\r\n\t\t2, 1.12, 0.9,\r\n\t\t2, 0, 0.45,\r\n\t\t2, - 1.12, 0.45,\r\n\t\t1.12, - 2, 0.45,\r\n\t\t0, - 2, 0.45,\r\n\t\t1.5, 0, 0.225,\r\n\t\t1.5, - 0.84, 0.225,\r\n\t\t0.84, - 1.5, 0.225,\r\n\t\t0, - 1.5, 0.225,\r\n\t\t1.5, 0, 0.15,\r\n\t\t1.5, - 0.84, 0.15,\r\n\t\t0.84, - 1.5, 0.15,\r\n\t\t0, - 1.5, 0.15,\r\n\t\t- 1.12, - 2, 0.45,\r\n\t\t- 2, - 1.12, 0.45,\r\n\t\t- 2, 0, 0.45,\r\n\t\t- 0.84, - 1.5, 0.225,\r\n\t\t- 1.5, - 0.84, 0.225,\r\n\t\t- 1.5, 0, 0.225,\r\n\t\t- 0.84, - 1.5, 0.15,\r\n\t\t- 1.5, - 0.84, 0.15,\r\n\t\t- 1.5, 0, 0.15,\r\n\t\t- 2, 1.12, 0.45,\r\n\t\t- 1.12, 2, 0.45,\r\n\t\t0, 2, 0.45,\r\n\t\t- 1.5, 0.84, 0.225,\r\n\t\t- 0.84, 1.5, 0.225,\r\n\t\t0, 1.5, 0.225,\r\n\t\t- 1.5, 0.84, 0.15,\r\n\t\t- 0.84, 1.5, 0.15,\r\n\t\t0, 1.5, 0.15,\r\n\t\t1.12, 2, 0.45,\r\n\t\t2, 1.12, 0.45,\r\n\t\t0.84, 1.5, 0.225,\r\n\t\t1.5, 0.84, 0.225,\r\n\t\t0.84, 1.5, 0.15,\r\n\t\t1.5, 0.84, 0.15,\r\n\t\t- 1.6, 0, 2.025,\r\n\t\t- 1.6, - 0.3, 2.025,\r\n\t\t- 1.5, - 0.3, 2.25,\r\n\t\t- 1.5, 0, 2.25,\r\n\t\t- 2.3, 0, 2.025,\r\n\t\t- 2.3, - 0.3, 2.025,\r\n\t\t- 2.5, - 0.3, 2.25,\r\n\t\t- 2.5, 0, 2.25,\r\n\t\t- 2.7, 0, 2.025,\r\n\t\t- 2.7, - 0.3, 2.025,\r\n\t\t- 3, - 0.3, 2.25,\r\n\t\t- 3, 0, 2.25,\r\n\t\t- 2.7, 0, 1.8,\r\n\t\t- 2.7, - 0.3, 1.8,\r\n\t\t- 3, - 0.3, 1.8,\r\n\t\t- 3, 0, 1.8,\r\n\t\t- 1.5, 0.3, 2.25,\r\n\t\t- 1.6, 0.3, 2.025,\r\n\t\t- 2.5, 0.3, 2.25,\r\n\t\t- 2.3, 0.3, 2.025,\r\n\t\t- 3, 0.3, 2.25,\r\n\t\t- 2.7, 0.3, 2.025,\r\n\t\t- 3, 0.3, 1.8,\r\n\t\t- 2.7, 0.3, 1.8,\r\n\t\t- 2.7, 0, 1.575,\r\n\t\t- 2.7, - 0.3, 1.575,\r\n\t\t- 3, - 0.3, 1.35,\r\n\t\t- 3, 0, 1.35,\r\n\t\t- 2.5, 0, 1.125,\r\n\t\t- 2.5, - 0.3, 1.125,\r\n\t\t- 2.65, - 0.3, 0.9375,\r\n\t\t- 2.65, 0, 0.9375,\r\n\t\t- 2, - 0.3, 0.9,\r\n\t\t- 1.9, - 0.3, 0.6,\r\n\t\t- 1.9, 0, 0.6,\r\n\t\t- 3, 0.3, 1.35,\r\n\t\t- 2.7, 0.3, 1.575,\r\n\t\t- 2.65, 0.3, 0.9375,\r\n\t\t- 2.5, 0.3, 1.125,\r\n\t\t- 1.9, 0.3, 0.6,\r\n\t\t- 2, 0.3, 0.9,\r\n\t\t1.7, 0, 1.425,\r\n\t\t1.7, - 0.66, 1.425,\r\n\t\t1.7, - 0.66, 0.6,\r\n\t\t1.7, 0, 0.6,\r\n\t\t2.6, 0, 1.425,\r\n\t\t2.6, - 0.66, 1.425,\r\n\t\t3.1, - 0.66, 0.825,\r\n\t\t3.1, 0, 0.825,\r\n\t\t2.3, 0, 2.1,\r\n\t\t2.3, - 0.25, 2.1,\r\n\t\t2.4, - 0.25, 2.025,\r\n\t\t2.4, 0, 2.025,\r\n\t\t2.7, 0, 2.4,\r\n\t\t2.7, - 0.25, 2.4,\r\n\t\t3.3, - 0.25, 2.4,\r\n\t\t3.3, 0, 2.4,\r\n\t\t1.7, 0.66, 0.6,\r\n\t\t1.7, 0.66, 1.425,\r\n\t\t3.1, 0.66, 0.825,\r\n\t\t2.6, 0.66, 1.425,\r\n\t\t2.4, 0.25, 2.025,\r\n\t\t2.3, 0.25, 2.1,\r\n\t\t3.3, 0.25, 2.4,\r\n\t\t2.7, 0.25, 2.4,\r\n\t\t2.8, 0, 2.475,\r\n\t\t2.8, - 0.25, 2.475,\r\n\t\t3.525, - 0.25, 2.49375,\r\n\t\t3.525, 0, 2.49375,\r\n\t\t2.9, 0, 2.475,\r\n\t\t2.9, - 0.15, 2.475,\r\n\t\t3.45, - 0.15, 2.5125,\r\n\t\t3.45, 0, 2.5125,\r\n\t\t2.8, 0, 2.4,\r\n\t\t2.8, - 0.15, 2.4,\r\n\t\t3.2, - 0.15, 2.4,\r\n\t\t3.2, 0, 2.4,\r\n\t\t3.525, 0.25, 2.49375,\r\n\t\t2.8, 0.25, 2.475,\r\n\t\t3.45, 0.15, 2.5125,\r\n\t\t2.9, 0.15, 2.475,\r\n\t\t3.2, 0.15, 2.4,\r\n\t\t2.8, 0.15, 2.4,\r\n\t\t0, 0, 3.15,\r\n\t\t0.8, 0, 3.15,\r\n\t\t0.8, - 0.45, 3.15,\r\n\t\t0.45, - 0.8, 3.15,\r\n\t\t0, - 0.8, 3.15,\r\n\t\t0, 0, 2.85,\r\n\t\t0.2, 0, 2.7,\r\n\t\t0.2, - 0.112, 2.7,\r\n\t\t0.112, - 0.2, 2.7,\r\n\t\t0, - 0.2, 2.7,\r\n\t\t- 0.45, - 0.8, 3.15,\r\n\t\t- 0.8, - 0.45, 3.15,\r\n\t\t- 0.8, 0, 3.15,\r\n\t\t- 0.112, - 0.2, 2.7,\r\n\t\t- 0.2, - 0.112, 2.7,\r\n\t\t- 0.2, 0, 2.7,\r\n\t\t- 0.8, 0.45, 3.15,\r\n\t\t- 0.45, 0.8, 3.15,\r\n\t\t0, 0.8, 3.15,\r\n\t\t- 0.2, 0.112, 2.7,\r\n\t\t- 0.112, 0.2, 2.7,\r\n\t\t0, 0.2, 2.7,\r\n\t\t0.45, 0.8, 3.15,\r\n\t\t0.8, 0.45, 3.15,\r\n\t\t0.112, 0.2, 2.7,\r\n\t\t0.2, 0.112, 2.7,\r\n\t\t0.4, 0, 2.55,\r\n\t\t0.4, - 0.224, 2.55,\r\n\t\t0.224, - 0.4, 2.55,\r\n\t\t0, - 0.4, 2.55,\r\n\t\t1.3, 0, 2.55,\r\n\t\t1.3, - 0.728, 2.55,\r\n\t\t0.728, - 1.3, 2.55,\r\n\t\t0, - 1.3, 2.55,\r\n\t\t1.3, 0, 2.4,\r\n\t\t1.3, - 0.728, 2.4,\r\n\t\t0.728, - 1.3, 2.4,\r\n\t\t0, - 1.3, 2.4,\r\n\t\t- 0.224, - 0.4, 2.55,\r\n\t\t- 0.4, - 0.224, 2.55,\r\n\t\t- 0.4, 0, 2.55,\r\n\t\t- 0.728, - 1.3, 2.55,\r\n\t\t- 1.3, - 0.728, 2.55,\r\n\t\t- 1.3, 0, 2.55,\r\n\t\t- 0.728, - 1.3, 2.4,\r\n\t\t- 1.3, - 0.728, 2.4,\r\n\t\t- 1.3, 0, 2.4,\r\n\t\t- 0.4, 0.224, 2.55,\r\n\t\t- 0.224, 0.4, 2.55,\r\n\t\t0, 0.4, 2.55,\r\n\t\t- 1.3, 0.728, 2.55,\r\n\t\t- 0.728, 1.3, 2.55,\r\n\t\t0, 1.3, 2.55,\r\n\t\t- 1.3, 0.728, 2.4,\r\n\t\t- 0.728, 1.3, 2.4,\r\n\t\t0, 1.3, 2.4,\r\n\t\t0.224, 0.4, 2.55,\r\n\t\t0.4, 0.224, 2.55,\r\n\t\t0.728, 1.3, 2.55,\r\n\t\t1.3, 0.728, 2.55,\r\n\t\t0.728, 1.3, 2.4,\r\n\t\t1.3, 0.728, 2.4,\r\n\t\t0, 0, 0,\r\n\t\t1.425, 0, 0,\r\n\t\t1.425, 0.798, 0,\r\n\t\t0.798, 1.425, 0,\r\n\t\t0, 1.425, 0,\r\n\t\t1.5, 0, 0.075,\r\n\t\t1.5, 0.84, 0.075,\r\n\t\t0.84, 1.5, 0.075,\r\n\t\t0, 1.5, 0.075,\r\n\t\t- 0.798, 1.425, 0,\r\n\t\t- 1.425, 0.798, 0,\r\n\t\t- 1.425, 0, 0,\r\n\t\t- 0.84, 1.5, 0.075,\r\n\t\t- 1.5, 0.84, 0.075,\r\n\t\t- 1.5, 0, 0.075,\r\n\t\t- 1.425, - 0.798, 0,\r\n\t\t- 0.798, - 1.425, 0,\r\n\t\t0, - 1.425, 0,\r\n\t\t- 1.5, - 0.84, 0.075,\r\n\t\t- 0.84, - 1.5, 0.075,\r\n\t\t0, - 1.5, 0.075,\r\n\t\t0.798, - 1.425, 0,\r\n\t\t1.425, - 0.798, 0,\r\n\t\t0.84, - 1.5, 0.075,\r\n\t\t1.5, - 0.84, 0.075\r\n\t];\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tsize = size || 50;\r\n\r\n\t// number of segments per patch\r\n\tsegments = segments !== undefined ? Math.max( 2, Math.floor( segments ) || 10 ) : 10;\r\n\r\n\t// which parts should be visible\r\n\tbottom = bottom === undefined ? true : bottom;\r\n\tlid = lid === undefined ? true : lid;\r\n\tbody = body === undefined ? true : body;\r\n\r\n\t// Should the lid be snug? It's not traditional, but we make it snug by default\r\n\tfitLid = fitLid === undefined ? true : fitLid;\r\n\r\n\t// Jim Blinn scaled the teapot down in size by about 1.3 for\r\n\t// some rendering tests. He liked the new proportions that he kept\r\n\t// the data in this form. The model was distributed with these new\r\n\t// proportions and became the norm. Trivia: comparing images of the\r\n\t// real teapot and the computer model, the ratio for the bowl of the\r\n\t// real teapot is more like 1.25, but since 1.3 is the traditional\r\n\t// value given, we use it here.\r\n\tvar blinnScale = 1.3;\r\n\tblinn = blinn === undefined ? true : blinn;\r\n\r\n\t// scale the size to be the real scaling factor\r\n\tvar maxHeight = 3.15 * ( blinn ? 1 : blinnScale );\r\n\r\n\tvar maxHeight2 = maxHeight / 2;\r\n\tvar trueSize = size / maxHeight2;\r\n\r\n\t// Number of elements depends on what is needed. Subtract degenerate\r\n\t// triangles at tip of bottom and lid out in advance.\r\n\tvar numTriangles = bottom ? ( 8 * segments - 4 ) * segments : 0;\r\n\tnumTriangles += lid ? ( 16 * segments - 4 ) * segments : 0;\r\n\tnumTriangles += body ? 40 * segments * segments : 0;\r\n\r\n\tvar indices = new Uint32Array( numTriangles * 3 );\r\n\r\n\tvar numVertices = bottom ? 4 : 0;\r\n\tnumVertices += lid ? 8 : 0;\r\n\tnumVertices += body ? 20 : 0;\r\n\tnumVertices *= ( segments + 1 ) * ( segments + 1 );\r\n\r\n\tvar vertices = new Float32Array( numVertices * 3 );\r\n\tvar normals = new Float32Array( numVertices * 3 );\r\n\tvar uvs = new Float32Array( numVertices * 2 );\r\n\r\n\t// Bezier form\r\n\tvar ms = new Matrix4();\r\n\tms.set(\r\n\t\t- 1.0, 3.0, - 3.0, 1.0,\r\n\t\t3.0, - 6.0, 3.0, 0.0,\r\n\t\t- 3.0, 3.0, 0.0, 0.0,\r\n\t\t1.0, 0.0, 0.0, 0.0 );\r\n\r\n\tvar g = [];\r\n\tvar i, r, c;\r\n\r\n\tvar sp = [];\r\n\tvar tp = [];\r\n\tvar dsp = [];\r\n\tvar dtp = [];\r\n\r\n\t// M * G * M matrix, sort of see\r\n\t// http://www.cs.helsinki.fi/group/goa/mallinnus/curves/surfaces.html\r\n\tvar mgm = [];\r\n\r\n\tvar vert = [];\r\n\tvar sdir = [];\r\n\tvar tdir = [];\r\n\r\n\tvar norm = new Vector3();\r\n\r\n\tvar tcoord;\r\n\r\n\tvar sstep, tstep;\r\n\tvar vertPerRow;\r\n\r\n\tvar s, t, sval, tval, p;\r\n\tvar dsval = 0;\r\n\tvar dtval = 0;\r\n\r\n\tvar normOut = new Vector3();\r\n\tvar v1, v2, v3, v4;\r\n\r\n\tvar gmx = new Matrix4();\r\n\tvar tmtx = new Matrix4();\r\n\r\n\tvar vsp = new Vector4();\r\n\tvar vtp = new Vector4();\r\n\tvar vdsp = new Vector4();\r\n\tvar vdtp = new Vector4();\r\n\r\n\tvar vsdir = new Vector3();\r\n\tvar vtdir = new Vector3();\r\n\r\n\tvar mst = ms.clone();\r\n\tmst.transpose();\r\n\r\n\t// internal function: test if triangle has any matching vertices;\r\n\t// if so, don't save triangle, since it won't display anything.\r\n\tvar notDegenerate = function ( vtx1, vtx2, vtx3 ) {\r\n\r\n\t\t// if any vertex matches, return false\r\n\t\treturn ! ( ( ( vertices[ vtx1 * 3 ] === vertices[ vtx2 * 3 ] ) &&\r\n\t\t\t\t\t ( vertices[ vtx1 * 3 + 1 ] === vertices[ vtx2 * 3 + 1 ] ) &&\r\n\t\t\t\t\t ( vertices[ vtx1 * 3 + 2 ] === vertices[ vtx2 * 3 + 2 ] ) ) ||\r\n\t\t\t\t   ( ( vertices[ vtx1 * 3 ] === vertices[ vtx3 * 3 ] ) &&\r\n\t\t\t\t\t ( vertices[ vtx1 * 3 + 1 ] === vertices[ vtx3 * 3 + 1 ] ) &&\r\n\t\t\t\t\t ( vertices[ vtx1 * 3 + 2 ] === vertices[ vtx3 * 3 + 2 ] ) ) ||\r\n\t\t\t\t   ( ( vertices[ vtx2 * 3 ] === vertices[ vtx3 * 3 ] ) &&\r\n\t\t\t\t\t ( vertices[ vtx2 * 3 + 1 ] === vertices[ vtx3 * 3 + 1 ] ) &&\r\n\t\t\t\t\t ( vertices[ vtx2 * 3 + 2 ] === vertices[ vtx3 * 3 + 2 ] ) ) );\r\n\r\n\t};\r\n\r\n\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\tmgm[ i ] = new Matrix4();\r\n\r\n\t}\r\n\r\n\tvar minPatches = body ? 0 : 20;\r\n\tvar maxPatches = bottom ? 32 : 28;\r\n\r\n\tvertPerRow = segments + 1;\r\n\r\n\tvar surfCount = 0;\r\n\r\n\tvar vertCount = 0;\r\n\tvar normCount = 0;\r\n\tvar uvCount = 0;\r\n\r\n\tvar indexCount = 0;\r\n\r\n\tfor ( var surf = minPatches; surf < maxPatches; surf ++ ) {\r\n\r\n\t\t// lid is in the middle of the data, patches 20-27,\r\n\t\t// so ignore it for this part of the loop if the lid is not desired\r\n\t\tif ( lid || ( surf < 20 || surf >= 28 ) ) {\r\n\r\n\t\t\t// get M * G * M matrix for x,y,z\r\n\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t// get control patches\r\n\t\t\t\tfor ( r = 0; r < 4; r ++ ) {\r\n\r\n\t\t\t\t\tfor ( c = 0; c < 4; c ++ ) {\r\n\r\n\t\t\t\t\t\t// transposed\r\n\t\t\t\t\t\tg[ c * 4 + r ] = teapotVertices[ teapotPatches[ surf * 16 + r * 4 + c ] * 3 + i ];\r\n\r\n\t\t\t\t\t\t// is the lid to be made larger, and is this a point on the lid\r\n\t\t\t\t\t\t// that is X or Y?\r\n\t\t\t\t\t\tif ( fitLid && ( surf >= 20 && surf < 28 ) && ( i !== 2 ) ) {\r\n\r\n\t\t\t\t\t\t\t// increase XY size by 7.7%, found empirically. I don't\r\n\t\t\t\t\t\t\t// increase Z so that the teapot will continue to fit in the\r\n\t\t\t\t\t\t\t// space -1 to 1 for Y (Y is up for the final model).\r\n\t\t\t\t\t\t\tg[ c * 4 + r ] *= 1.077;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Blinn \"fixed\" the teapot by dividing Z by blinnScale, and that's the\r\n\t\t\t\t\t\t// data we now use. The original teapot is taller. Fix it:\r\n\t\t\t\t\t\tif ( ! blinn && ( i === 2 ) ) {\r\n\r\n\t\t\t\t\t\t\tg[ c * 4 + r ] *= blinnScale;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgmx.set( g[ 0 ], g[ 1 ], g[ 2 ], g[ 3 ], g[ 4 ], g[ 5 ], g[ 6 ], g[ 7 ], g[ 8 ], g[ 9 ], g[ 10 ], g[ 11 ], g[ 12 ], g[ 13 ], g[ 14 ], g[ 15 ] );\r\n\r\n\t\t\t\ttmtx.multiplyMatrices( gmx, ms );\r\n\t\t\t\tmgm[ i ].multiplyMatrices( mst, tmtx );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// step along, get points, and output\r\n\t\t\tfor ( sstep = 0; sstep <= segments; sstep ++ ) {\r\n\r\n\t\t\t\ts = sstep / segments;\r\n\r\n\t\t\t\tfor ( tstep = 0; tstep <= segments; tstep ++ ) {\r\n\r\n\t\t\t\t\tt = tstep / segments;\r\n\r\n\t\t\t\t\t// point from basis\r\n\t\t\t\t\t// get power vectors and their derivatives\r\n\t\t\t\t\tfor ( p = 4, sval = tval = 1.0; p --; ) {\r\n\r\n\t\t\t\t\t\tsp[ p ] = sval;\r\n\t\t\t\t\t\ttp[ p ] = tval;\r\n\t\t\t\t\t\tsval *= s;\r\n\t\t\t\t\t\ttval *= t;\r\n\r\n\t\t\t\t\t\tif ( p === 3 ) {\r\n\r\n\t\t\t\t\t\t\tdsp[ p ] = dtp[ p ] = 0.0;\r\n\t\t\t\t\t\t\tdsval = dtval = 1.0;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tdsp[ p ] = dsval * ( 3 - p );\r\n\t\t\t\t\t\t\tdtp[ p ] = dtval * ( 3 - p );\r\n\t\t\t\t\t\t\tdsval *= s;\r\n\t\t\t\t\t\t\tdtval *= t;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvsp.fromArray( sp );\r\n\t\t\t\t\tvtp.fromArray( tp );\r\n\t\t\t\t\tvdsp.fromArray( dsp );\r\n\t\t\t\t\tvdtp.fromArray( dtp );\r\n\r\n\t\t\t\t\t// do for x,y,z\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\t// multiply power vectors times matrix to get value\r\n\t\t\t\t\t\ttcoord = vsp.clone();\r\n\t\t\t\t\t\ttcoord.applyMatrix4( mgm[ i ] );\r\n\t\t\t\t\t\tvert[ i ] = tcoord.dot( vtp );\r\n\r\n\t\t\t\t\t\t// get s and t tangent vectors\r\n\t\t\t\t\t\ttcoord = vdsp.clone();\r\n\t\t\t\t\t\ttcoord.applyMatrix4( mgm[ i ] );\r\n\t\t\t\t\t\tsdir[ i ] = tcoord.dot( vtp );\r\n\r\n\t\t\t\t\t\ttcoord = vsp.clone();\r\n\t\t\t\t\t\ttcoord.applyMatrix4( mgm[ i ] );\r\n\t\t\t\t\t\ttdir[ i ] = tcoord.dot( vdtp );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// find normal\r\n\t\t\t\t\tvsdir.fromArray( sdir );\r\n\t\t\t\t\tvtdir.fromArray( tdir );\r\n\t\t\t\t\tnorm.crossVectors( vtdir, vsdir );\r\n\t\t\t\t\tnorm.normalize();\r\n\r\n\t\t\t\t\t// if X and Z length is 0, at the cusp, so point the normal up or down, depending on patch number\r\n\t\t\t\t\tif ( vert[ 0 ] === 0 && vert[ 1 ] === 0 ) {\r\n\r\n\t\t\t\t\t\t// if above the middle of the teapot, normal points up, else down\r\n\t\t\t\t\t\tnormOut.set( 0, vert[ 2 ] > maxHeight2 ? 1 : - 1, 0 );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// standard output: rotate on X axis\r\n\t\t\t\t\t\tnormOut.set( norm.x, norm.z, - norm.y );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// store it all\r\n\t\t\t\t\tvertices[ vertCount ++ ] = trueSize * vert[ 0 ];\r\n\t\t\t\t\tvertices[ vertCount ++ ] = trueSize * ( vert[ 2 ] - maxHeight2 );\r\n\t\t\t\t\tvertices[ vertCount ++ ] = - trueSize * vert[ 1 ];\r\n\r\n\t\t\t\t\tnormals[ normCount ++ ] = normOut.x;\r\n\t\t\t\t\tnormals[ normCount ++ ] = normOut.y;\r\n\t\t\t\t\tnormals[ normCount ++ ] = normOut.z;\r\n\r\n\t\t\t\t\tuvs[ uvCount ++ ] = 1 - t;\r\n\t\t\t\t\tuvs[ uvCount ++ ] = 1 - s;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// save the faces\r\n\t\t\tfor ( sstep = 0; sstep < segments; sstep ++ ) {\r\n\r\n\t\t\t\tfor ( tstep = 0; tstep < segments; tstep ++ ) {\r\n\r\n\t\t\t\t\tv1 = surfCount * vertPerRow * vertPerRow + sstep * vertPerRow + tstep;\r\n\t\t\t\t\tv2 = v1 + 1;\r\n\t\t\t\t\tv3 = v2 + vertPerRow;\r\n\t\t\t\t\tv4 = v1 + vertPerRow;\r\n\r\n\t\t\t\t\t// Normals and UVs cannot be shared. Without clone(), you can see the consequences\r\n\t\t\t\t\t// of sharing if you call geometry.applyMatrix( matrix ).\r\n\t\t\t\t\tif ( notDegenerate( v1, v2, v3 ) ) {\r\n\r\n\t\t\t\t\t\tindices[ indexCount ++ ] = v1;\r\n\t\t\t\t\t\tindices[ indexCount ++ ] = v2;\r\n\t\t\t\t\t\tindices[ indexCount ++ ] = v3;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( notDegenerate( v1, v3, v4 ) ) {\r\n\r\n\t\t\t\t\t\tindices[ indexCount ++ ] = v1;\r\n\t\t\t\t\t\tindices[ indexCount ++ ] = v3;\r\n\t\t\t\t\t\tindices[ indexCount ++ ] = v4;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// increment only if a surface was used\r\n\t\t\tsurfCount ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.setIndex( new BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );\r\n\r\n\tthis.computeBoundingSphere();\r\n\r\n};\r\n\r\nTeapotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nTeapotBufferGeometry.prototype.constructor = TeapotBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\r\n\r\n\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\r\n\tthis.image = { data: data, width: width, height: height };\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\r\n\r\n\tthis.generateMipmaps = false;\r\n\tthis.flipY = false;\r\n\tthis.unpackAlignment = 1;\r\n\r\n}\r\n\r\nDataTexture.prototype = Object.create( Texture.prototype );\r\nDataTexture.prototype.constructor = DataTexture;\r\n\r\nDataTexture.prototype.isDataTexture = true;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction GPUComputationRenderer( sizeX, sizeY, renderer ) {\r\n\r\n\tthis.variables = [];\r\n\r\n\tthis.currentTextureIndex = 0;\r\n\r\n\tvar scene = new Scene();\r\n\r\n\tvar camera = new Camera();\r\n\tcamera.position.z = 1;\r\n\r\n\tvar passThruUniforms = {\r\n\t\ttexture: { value: null }\r\n\t};\r\n\r\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\r\n\r\n\tvar mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), passThruShader );\r\n\tscene.add( mesh );\r\n\r\n\tthis.addVariable = function( variableName, computeFragmentShader, initialValueTexture ) {\r\n\r\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\r\n\r\n\t\tvar variable = {\r\n\t\t\tname: variableName,\r\n\t\t\tinitialValueTexture: initialValueTexture,\r\n\t\t\tmaterial: material,\r\n\t\t\tdependencies: null,\r\n\t\t\trenderTargets: [],\r\n\t\t\twrapS: null,\r\n\t\t\twrapT: null,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter\r\n\t\t};\r\n\r\n\t\tthis.variables.push( variable );\r\n\r\n\t\treturn variable;\r\n\t\t\r\n\t};\r\n\r\n\tthis.setVariableDependencies = function( variable, dependencies ) {\r\n\r\n\t\tvariable.dependencies = dependencies;\r\n\r\n\t};\r\n\r\n\tthis.init = function() {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( ! renderer.extensions.get( \"OES_texture_float\" ) ) {\r\n\r\n\t\t\treturn \"No OES_texture_float support for float textures.\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\r\n\r\n\t\t\treturn \"No support for vertex shader textures.\";\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < this.variables.length; i++ ) {\r\n\r\n\t\t\tvar variable = this$1.variables[ i ];\r\n\r\n\t\t\t// Creates rendertargets and initialize them with input texture\r\n\t\t\tvariable.renderTargets[ 0 ] = this$1.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\tvariable.renderTargets[ 1 ] = this$1.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\r\n\t\t\tthis$1.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\r\n\t\t\tthis$1.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\r\n\r\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\r\n\t\t\tvar material = variable.material;\r\n\t\t\tvar uniforms = material.uniforms;\r\n\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d++ ) {\r\n\r\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\r\n\r\n\t\t\t\t\t\t// Checks if variable exists\r\n\t\t\t\t\t\tvar found = false;\r\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( depVar.name === this$1.variables[ j ].name ) {\r\n\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( ! found ) {\r\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\r\n\r\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.currentTextureIndex = 0;\r\n\r\n\t\treturn null;\r\n\r\n\t};\r\n\r\n\tthis.compute = function() {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar currentTextureIndex = this.currentTextureIndex;\r\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\r\n\r\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i++ ) {\r\n\r\n\t\t\tvar variable = this$1.variables[ i ];\r\n\r\n\t\t\t// Sets texture dependencies uniforms\r\n\t\t\tif ( variable.dependencies !== null ) {\r\n\r\n\t\t\t\tvar uniforms = variable.material.uniforms;\r\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d++ ) {\r\n\r\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\r\n\r\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Performs the computation for this variable\r\n\t\t\tthis$1.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTextureIndex = nextTextureIndex;\r\n\t};\r\n\r\n\tthis.getCurrentRenderTarget = function( variable ) {\r\n\r\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\r\n\r\n\t};\r\n\r\n\tthis.getAlternateRenderTarget = function( variable ) {\r\n\r\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\r\n\r\n\t};\r\n\r\n\tfunction addResolutionDefine( materialShader ) {\r\n\r\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\r\n\r\n\t}\r\n\tthis.addResolutionDefine = addResolutionDefine;\r\n\r\n\t// The following functions can be used to compute things manually\r\n\r\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\r\n\r\n\t\tuniforms = uniforms || {};\r\n\r\n\t\tvar material = new ShaderMaterial( {\r\n\t\t\tuniforms: uniforms,\r\n\t\t\tvertexShader: getPassThroughVertexShader(),\r\n\t\t\tfragmentShader: computeFragmentShader\r\n\t\t} );\r\n\r\n\t\taddResolutionDefine( material );\r\n\r\n\t\treturn material;\r\n\t}\r\n\tthis.createShaderMaterial = createShaderMaterial;\r\n\r\n\tthis.createRenderTarget = function( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\r\n\r\n\t\tsizeXTexture = sizeXTexture || sizeX;\r\n\t\tsizeYTexture = sizeYTexture || sizeY;\r\n\r\n\t\twrapS = wrapS || ClampToEdgeWrapping;\r\n\t\twrapT = wrapT || ClampToEdgeWrapping;\r\n\r\n\t\tminFilter = minFilter || NearestFilter;\r\n\t\tmagFilter = magFilter || NearestFilter;\r\n\r\n\t\tvar renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\r\n\t\t\twrapS: wrapS,\r\n\t\t\twrapT: wrapT,\r\n\t\t\tminFilter: minFilter,\r\n\t\t\tmagFilter: magFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) ? HalfFloatType : FloatType,\r\n\t\t\tstencilBuffer: false,\r\n\t\t\tdepthBuffer: false\r\n\t\t} );\r\n\r\n\t\treturn renderTarget;\r\n\r\n\t};\r\n\r\n\tthis.createTexture = function() {\r\n\r\n\t\tvar a = new Float32Array( sizeX * sizeY * 4 );\r\n\t\tvar texture = new DataTexture( a, sizeX, sizeY, RGBAFormat, FloatType );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t\treturn texture;\r\n\r\n\t};\r\n\r\n\tthis.renderTexture = function( input, output ) {\r\n\r\n\t\t// Takes a texture, and render out in rendertarget\r\n\t\t// input = Texture\r\n\t\t// output = RenderTarget\r\n\r\n\t\tpassThruUniforms.texture.value = input;\r\n\r\n\t\tthis.doRenderTarget( passThruShader, output);\r\n\r\n\t\tpassThruUniforms.texture.value = null;\r\n\r\n\t};\r\n\r\n\tthis.doRenderTarget = function( material, output ) {\r\n\r\n\t\tmesh.material = material;\r\n\t\trenderer.render( scene, camera, output );\r\n\t\tmesh.material = passThruShader;\r\n\r\n\t};\r\n\r\n\t// Shaders\r\n\r\n\tfunction getPassThroughVertexShader() {\r\n\r\n\t\treturn\t\"void main()\t{\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"}\\n\";\r\n\r\n\t}\r\n\r\n\tfunction getPassThroughFragmentShader() {\r\n\r\n\t\treturn\t\"uniform sampler2D texture;\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"void main() {\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"\tgl_FragColor = texture2D( texture, uv );\\n\" +\r\n\t\t\t\t\"\\n\" +\r\n\t\t\t\t\"}\\n\";\r\n\r\n\t}\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Points( geometry, material ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'Points';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\r\n\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n}\r\n\r\nPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: Points,\r\n\r\n\tisPoints: true,\r\n\r\n\traycast: ( function () {\r\n\r\n\t\tvar inverseMatrix = new Matrix4();\r\n\t\tvar ray = new Ray();\r\n\t\tvar sphere = new Sphere();\r\n\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\t\tvar object = this;\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\t\tvar threshold = raycaster.params.Points.threshold;\r\n\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\t\tsphere.radius += threshold;\r\n\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }\r\n\r\n\t\t\t//\r\n\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\r\n\t\t\tvar position = new Vector3();\r\n\t\t\tvar intersectPoint = new Vector3();\r\n\r\n\t\t\tfunction testPoint( point, index ) {\r\n\r\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\r\n\r\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\r\n\r\n\t\t\t\t\tray.closestPointToPoint( point, intersectPoint );\r\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) { return; }\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\r\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\t\tindex: index,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar a = indices[ i ];\r\n\r\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\r\n\t\t\t\t\t\ttestPoint( position, a );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\r\n\r\n\t\t\t\t\t\ttestPoint( position, i );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\ttestPoint( vertices[ i ], i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar GPUParticleSystem = function ( options ) {\n\tvar this$1 = this;\n\r\n\r\n\tObject3D.apply( this, arguments );\r\n\r\n\toptions = options || {};\r\n\r\n\t// parse options and use defaults\r\n\r\n\tthis.PARTICLE_COUNT = options.maxParticles || 1000000;\r\n\tthis.PARTICLE_CONTAINERS = options.containerCount || 1;\r\n\r\n\tthis.PARTICLE_NOISE_TEXTURE = options.particleNoiseTex || null;\r\n\tthis.PARTICLE_SPRITE_TEXTURE = options.particleSpriteTex || null;\r\n\r\n\tthis.PARTICLES_PER_CONTAINER = Math.ceil( this.PARTICLE_COUNT / this.PARTICLE_CONTAINERS );\r\n\tthis.PARTICLE_CURSOR = 0;\r\n\tthis.time = 0;\r\n\tthis.particleContainers = [];\r\n\tthis.rand = [];\r\n\r\n\t// custom vertex and fragement shader\r\n\r\n\tvar GPUParticleShader = {\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t'uniform float uTime;',\r\n\t\t\t'uniform float uScale;',\r\n\t\t\t'uniform sampler2D tNoise;',\r\n\r\n\t\t\t'attribute vec3 positionStart;',\r\n\t\t\t'attribute float startTime;',\r\n\t\t\t'attribute vec3 velocity;',\r\n\t\t\t'attribute float turbulence;',\r\n\t\t\t'attribute vec3 color;',\r\n\t\t\t'attribute float size;',\r\n\t\t\t'attribute float lifeTime;',\r\n\r\n\t\t\t'varying vec4 vColor;',\r\n\t\t\t'varying float lifeLeft;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t// unpack things from our attributes'\r\n\r\n\t\t\t'\tvColor = vec4( color, 1.0 );',\r\n\r\n\t\t\t// convert our velocity back into a value we can use'\r\n\r\n\t\t\t'\tvec3 newPosition;',\r\n\t\t\t'\tvec3 v;',\r\n\r\n\t\t\t'\tfloat timeElapsed = uTime - startTime;',\r\n\r\n\t\t\t'\tlifeLeft = 1.0 - ( timeElapsed / lifeTime );',\r\n\r\n\t\t\t'\tgl_PointSize = ( uScale * size ) * lifeLeft;',\r\n\r\n\t\t\t'\tv.x = ( velocity.x - 0.5 ) * 3.0;',\r\n\t\t\t'\tv.y = ( velocity.y - 0.5 ) * 3.0;',\r\n\t\t\t'\tv.z = ( velocity.z - 0.5 ) * 3.0;',\r\n\r\n\t\t\t'\tnewPosition = positionStart + ( v * 10.0 ) * timeElapsed;',\r\n\r\n\t\t\t'\tvec3 noise = texture2D( tNoise, vec2( newPosition.x * 0.015 + ( uTime * 0.05 ), newPosition.y * 0.02 + ( uTime * 0.015 ) ) ).rgb;',\r\n\t\t\t'\tvec3 noiseVel = ( noise.rgb - 0.5 ) * 30.0;',\r\n\r\n\t\t\t'\tnewPosition = mix( newPosition, newPosition + vec3( noiseVel * ( turbulence * 5.0 ) ), ( timeElapsed / lifeTime ) );',\r\n\r\n\t\t\t'\tif( v.y > 0. && v.y < .05 ) {',\r\n\r\n\t\t\t'\t\tlifeLeft = 0.0;',\r\n\r\n\t\t\t'\t}',\r\n\r\n\t\t\t'\tif( v.x < - 1.45 ) {',\r\n\r\n\t\t\t'\t\tlifeLeft = 0.0;',\r\n\r\n\t\t\t'\t}',\r\n\r\n\t\t\t'\tif( timeElapsed > 0.0 ) {',\r\n\r\n\t\t\t'\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );',\r\n\r\n\t\t\t'\t} else {',\r\n\r\n\t\t\t'\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n\t\t\t'\t\tlifeLeft = 0.0;',\r\n\t\t\t'\t\tgl_PointSize = 0.;',\r\n\r\n\t\t\t'\t}',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t'float scaleLinear( float value, vec2 valueDomain ) {',\r\n\r\n\t\t\t'\treturn ( value - valueDomain.x ) / ( valueDomain.y - valueDomain.x );',\r\n\r\n\t\t\t'}',\r\n\r\n\t\t\t'float scaleLinear( float value, vec2 valueDomain, vec2 valueRange ) {',\r\n\r\n\t\t\t'\treturn mix( valueRange.x, valueRange.y, scaleLinear( value, valueDomain ) );',\r\n\r\n\t\t\t'}',\r\n\r\n\t\t\t'varying vec4 vColor;',\r\n\t\t\t'varying float lifeLeft;',\r\n\r\n\t\t\t'uniform sampler2D tSprite;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\tfloat alpha = 0.;',\r\n\r\n\t\t\t'\tif( lifeLeft > 0.995 ) {',\r\n\r\n\t\t\t'\t\talpha = scaleLinear( lifeLeft, vec2( 1.0, 0.995 ), vec2( 0.0, 1.0 ) );',\r\n\r\n\t\t\t'\t} else {',\r\n\r\n\t\t\t'\t\talpha = lifeLeft * 0.75;',\r\n\r\n\t\t\t'\t}',\r\n\r\n\t\t\t'\tvec4 tex = texture2D( tSprite, gl_PointCoord );',\r\n\t\t\t'\tgl_FragColor = vec4( vColor.rgb * tex.a, alpha * tex.a );',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' )\r\n\r\n\t};\r\n\r\n\t// preload a million random numbers\r\n\r\n\tvar i;\r\n\r\n\tfor ( i = 1e5; i > 0; i -- ) {\r\n\r\n\t\tthis$1.rand.push( Math.random() - 0.5 );\r\n\r\n\t}\r\n\r\n\tthis.random = function () {\r\n\r\n\t\treturn ++ i >= this.rand.length ? this.rand[ i = 1 ] : this.rand[ i ];\r\n\r\n\t};\r\n\r\n\tvar textureLoader = new TextureLoader();\r\n\r\n\tthis.particleNoiseTex = this.PARTICLE_NOISE_TEXTURE || textureLoader.load( 'textures/perlin-512.png' );\r\n\tthis.particleNoiseTex.wrapS = this.particleNoiseTex.wrapT = RepeatWrapping;\r\n\r\n\tthis.particleSpriteTex = this.PARTICLE_SPRITE_TEXTURE || textureLoader.load( 'textures/particle2.png' );\r\n\tthis.particleSpriteTex.wrapS = this.particleSpriteTex.wrapT = RepeatWrapping;\r\n\r\n\tthis.particleShaderMat = new ShaderMaterial( {\r\n\t\ttransparent: true,\r\n\t\tdepthWrite: false,\r\n\t\tuniforms: {\r\n\t\t\t'uTime': {\r\n\t\t\t\tvalue: 0.0\r\n\t\t\t},\r\n\t\t\t'uScale': {\r\n\t\t\t\tvalue: 1.0\r\n\t\t\t},\r\n\t\t\t'tNoise': {\r\n\t\t\t\tvalue: this.particleNoiseTex\r\n\t\t\t},\r\n\t\t\t'tSprite': {\r\n\t\t\t\tvalue: this.particleSpriteTex\r\n\t\t\t}\r\n\t\t},\r\n\t\tblending: AdditiveBlending,\r\n\t\tvertexShader: GPUParticleShader.vertexShader,\r\n\t\tfragmentShader: GPUParticleShader.fragmentShader\r\n\t} );\r\n\r\n\t// define defaults for all values\r\n\r\n\tthis.particleShaderMat.defaultAttributeValues.particlePositionsStartTime = [ 0, 0, 0, 0 ];\r\n\tthis.particleShaderMat.defaultAttributeValues.particleVelColSizeLife = [ 0, 0, 0, 0 ];\r\n\r\n\tthis.init = function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.PARTICLE_CONTAINERS; i ++ ) {\r\n\r\n\t\t\tvar c = new GPUParticleContainer( this$1.PARTICLES_PER_CONTAINER, this$1 );\r\n\t\t\tthis$1.particleContainers.push( c );\r\n\t\t\tthis$1.add( c );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.spawnParticle = function ( options ) {\r\n\r\n\t\tthis.PARTICLE_CURSOR ++;\r\n\r\n\t\tif ( this.PARTICLE_CURSOR >= this.PARTICLE_COUNT ) {\r\n\r\n\t\t\tthis.PARTICLE_CURSOR = 1;\r\n\r\n\t\t}\r\n\r\n\t\tvar currentContainer = this.particleContainers[ Math.floor( this.PARTICLE_CURSOR / this.PARTICLES_PER_CONTAINER ) ];\r\n\r\n\t\tcurrentContainer.spawnParticle( options );\r\n\r\n\t};\r\n\r\n\tthis.update = function ( time ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.PARTICLE_CONTAINERS; i ++ ) {\r\n\r\n\t\t\tthis$1.particleContainers[ i ].update( time );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dispose = function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.particleShaderMat.dispose();\r\n\t\tthis.particleNoiseTex.dispose();\r\n\t\tthis.particleSpriteTex.dispose();\r\n\r\n\t\tfor ( var i = 0; i < this.PARTICLE_CONTAINERS; i ++ ) {\r\n\r\n\t\t\tthis$1.particleContainers[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.init();\r\n\r\n};\r\n\r\nGPUParticleSystem.prototype = Object.create( Object3D.prototype );\r\nGPUParticleSystem.prototype.constructor = GPUParticleSystem;\r\n\r\n// Subclass for particle containers, allows for very large arrays to be spread out\r\n\r\nvar GPUParticleContainer = function ( maxParticles, particleSystem ) {\r\n\r\n\tObject3D.apply( this, arguments );\r\n\r\n\tthis.PARTICLE_COUNT = maxParticles || 100000;\r\n\tthis.PARTICLE_CURSOR = 0;\r\n\tthis.time = 0;\r\n\tthis.offset = 0;\r\n\tthis.count = 0;\r\n\tthis.DPR = window.devicePixelRatio;\r\n\tthis.GPUParticleSystem = particleSystem;\r\n\tthis.particleUpdate = false;\r\n\r\n\t// geometry\r\n\r\n\tthis.particleShaderGeo = new BufferGeometry();\r\n\r\n\tthis.particleShaderGeo.addAttribute( 'position', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );\r\n\tthis.particleShaderGeo.addAttribute( 'positionStart', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );\r\n\tthis.particleShaderGeo.addAttribute( 'startTime', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );\r\n\tthis.particleShaderGeo.addAttribute( 'velocity', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );\r\n\tthis.particleShaderGeo.addAttribute( 'turbulence', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );\r\n\tthis.particleShaderGeo.addAttribute( 'color', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );\r\n\tthis.particleShaderGeo.addAttribute( 'size', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );\r\n\tthis.particleShaderGeo.addAttribute( 'lifeTime', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );\r\n\r\n\t// material\r\n\r\n\tthis.particleShaderMat = this.GPUParticleSystem.particleShaderMat;\r\n\r\n\tvar position = new Vector3();\r\n\tvar velocity = new Vector3();\r\n\tvar color = new Color();\r\n\r\n\tthis.spawnParticle = function ( options ) {\r\n\r\n\t\tvar positionStartAttribute = this.particleShaderGeo.getAttribute( 'positionStart' );\r\n\t\tvar startTimeAttribute = this.particleShaderGeo.getAttribute( 'startTime' );\r\n\t\tvar velocityAttribute = this.particleShaderGeo.getAttribute( 'velocity' );\r\n\t\tvar turbulenceAttribute = this.particleShaderGeo.getAttribute( 'turbulence' );\r\n\t\tvar colorAttribute = this.particleShaderGeo.getAttribute( 'color' );\r\n\t\tvar sizeAttribute = this.particleShaderGeo.getAttribute( 'size' );\r\n\t\tvar lifeTimeAttribute = this.particleShaderGeo.getAttribute( 'lifeTime' );\r\n\r\n\t\toptions = options || {};\r\n\r\n\t\t// setup reasonable default values for all arguments\r\n\r\n\t\tposition = options.position !== undefined ? position.copy( options.position ) : position.set( 0, 0, 0 );\r\n\t\tvelocity = options.velocity !== undefined ? velocity.copy( options.velocity ) : velocity.set( 0, 0, 0 );\r\n\t\tcolor = options.color !== undefined ? color.set( options.color ) : color.set( 0xffffff );\r\n\r\n\t\tvar positionRandomness = options.positionRandomness !== undefined ? options.positionRandomness : 0;\r\n\t\tvar velocityRandomness = options.velocityRandomness !== undefined ? options.velocityRandomness : 0;\r\n\t\tvar colorRandomness = options.colorRandomness !== undefined ? options.colorRandomness : 1;\r\n\t\tvar turbulence = options.turbulence !== undefined ? options.turbulence : 1;\r\n\t\tvar lifetime = options.lifetime !== undefined ? options.lifetime : 5;\r\n\t\tvar size = options.size !== undefined ? options.size : 10;\r\n\t\tvar sizeRandomness = options.sizeRandomness !== undefined ? options.sizeRandomness : 0;\r\n\t\tvar smoothPosition = options.smoothPosition !== undefined ? options.smoothPosition : false;\r\n\r\n\t\tif ( this.DPR !== undefined ) { size *= this.DPR; }\r\n\r\n\t\tvar i = this.PARTICLE_CURSOR;\r\n\r\n\t\t// position\r\n\r\n\t\tpositionStartAttribute.array[ i * 3 + 0 ] = position.x + ( particleSystem.random() * positionRandomness );\r\n\t\tpositionStartAttribute.array[ i * 3 + 1 ] = position.y + ( particleSystem.random() * positionRandomness );\r\n\t\tpositionStartAttribute.array[ i * 3 + 2 ] = position.z + ( particleSystem.random() * positionRandomness );\r\n\r\n\t\tif ( smoothPosition === true ) {\r\n\r\n\t\t\tpositionStartAttribute.array[ i * 3 + 0 ] += - ( velocity.x * particleSystem.random() );\r\n\t\t\tpositionStartAttribute.array[ i * 3 + 1 ] += - ( velocity.y * particleSystem.random() );\r\n\t\t\tpositionStartAttribute.array[ i * 3 + 2 ] += - ( velocity.z * particleSystem.random() );\r\n\r\n\t\t}\r\n\r\n\t\t// velocity\r\n\r\n\t\tvar maxVel = 2;\r\n\r\n\t\tvar velX = velocity.x + particleSystem.random() * velocityRandomness;\r\n\t\tvar velY = velocity.y + particleSystem.random() * velocityRandomness;\r\n\t\tvar velZ = velocity.z + particleSystem.random() * velocityRandomness;\r\n\r\n\t\tvelX = _Math.clamp( ( velX - ( - maxVel ) ) / ( maxVel - ( - maxVel ) ), 0, 1 );\r\n\t\tvelY = _Math.clamp( ( velY - ( - maxVel ) ) / ( maxVel - ( - maxVel ) ), 0, 1 );\r\n\t\tvelZ = _Math.clamp( ( velZ - ( - maxVel ) ) / ( maxVel - ( - maxVel ) ), 0, 1 );\r\n\r\n\t\tvelocityAttribute.array[ i * 3 + 0 ] = velX;\r\n\t\tvelocityAttribute.array[ i * 3 + 1 ] = velY;\r\n\t\tvelocityAttribute.array[ i * 3 + 2 ] = velZ;\r\n\r\n\t\t// color\r\n\r\n\t\tcolor.r = _Math.clamp( color.r + particleSystem.random() * colorRandomness, 0, 1 );\r\n\t\tcolor.g = _Math.clamp( color.g + particleSystem.random() * colorRandomness, 0, 1 );\r\n\t\tcolor.b = _Math.clamp( color.b + particleSystem.random() * colorRandomness, 0, 1 );\r\n\r\n\t\tcolorAttribute.array[ i * 3 + 0 ] = color.r;\r\n\t\tcolorAttribute.array[ i * 3 + 1 ] = color.g;\r\n\t\tcolorAttribute.array[ i * 3 + 2 ] = color.b;\r\n\r\n\t\t// turbulence, size, lifetime and starttime\r\n\r\n\t\tturbulenceAttribute.array[ i ] = turbulence;\r\n\t\tsizeAttribute.array[ i ] = size + particleSystem.random() * sizeRandomness;\r\n\t\tlifeTimeAttribute.array[ i ] = lifetime;\r\n\t\tstartTimeAttribute.array[ i ] = this.time + particleSystem.random() * 2e-2;\r\n\r\n\t\t// offset\r\n\r\n\t\tif ( this.offset === 0 ) {\r\n\r\n\t\t\tthis.offset = this.PARTICLE_CURSOR;\r\n\r\n\t\t}\r\n\r\n\t\t// counter and cursor\r\n\r\n\t\tthis.count ++;\r\n\t\tthis.PARTICLE_CURSOR ++;\r\n\r\n\t\tif ( this.PARTICLE_CURSOR >= this.PARTICLE_COUNT ) {\r\n\r\n\t\t\tthis.PARTICLE_CURSOR = 0;\r\n\r\n\t\t}\r\n\r\n\t\tthis.particleUpdate = true;\r\n\r\n\t};\r\n\r\n\tthis.init = function () {\r\n\r\n\t\tthis.particleSystem = new Points( this.particleShaderGeo, this.particleShaderMat );\r\n\t\tthis.particleSystem.frustumCulled = false;\r\n\t\tthis.add( this.particleSystem );\r\n\r\n\t};\r\n\r\n\tthis.update = function ( time ) {\r\n\r\n\t\tthis.time = time;\r\n\t\tthis.particleShaderMat.uniforms.uTime.value = time;\r\n\r\n\t\tthis.geometryUpdate();\r\n\r\n\t};\r\n\r\n\tthis.geometryUpdate = function () {\r\n\r\n\t\tif ( this.particleUpdate === true ) {\r\n\r\n\t\t\tthis.particleUpdate = false;\r\n\r\n\t\t\tvar positionStartAttribute = this.particleShaderGeo.getAttribute( 'positionStart' );\r\n\t\t\tvar startTimeAttribute = this.particleShaderGeo.getAttribute( 'startTime' );\r\n\t\t\tvar velocityAttribute = this.particleShaderGeo.getAttribute( 'velocity' );\r\n\t\t\tvar turbulenceAttribute = this.particleShaderGeo.getAttribute( 'turbulence' );\r\n\t\t\tvar colorAttribute = this.particleShaderGeo.getAttribute( 'color' );\r\n\t\t\tvar sizeAttribute = this.particleShaderGeo.getAttribute( 'size' );\r\n\t\t\tvar lifeTimeAttribute = this.particleShaderGeo.getAttribute( 'lifeTime' );\r\n\r\n\t\t\tif ( this.offset + this.count < this.PARTICLE_COUNT ) {\r\n\r\n\t\t\t\tpositionStartAttribute.updateRange.offset = this.offset * positionStartAttribute.itemSize;\r\n\t\t\t\tstartTimeAttribute.updateRange.offset = this.offset * startTimeAttribute.itemSize;\r\n\t\t\t\tvelocityAttribute.updateRange.offset = this.offset * velocityAttribute.itemSize;\r\n\t\t\t\tturbulenceAttribute.updateRange.offset = this.offset * turbulenceAttribute.itemSize;\r\n\t\t\t\tcolorAttribute.updateRange.offset = this.offset * colorAttribute.itemSize;\r\n\t\t\t\tsizeAttribute.updateRange.offset = this.offset * sizeAttribute.itemSize;\r\n\t\t\t\tlifeTimeAttribute.updateRange.offset = this.offset * lifeTimeAttribute.itemSize;\r\n\r\n\t\t\t\tpositionStartAttribute.updateRange.count = this.count * positionStartAttribute.itemSize;\r\n\t\t\t\tstartTimeAttribute.updateRange.count = this.count * startTimeAttribute.itemSize;\r\n\t\t\t\tvelocityAttribute.updateRange.count = this.count * velocityAttribute.itemSize;\r\n\t\t\t\tturbulenceAttribute.updateRange.count = this.count * turbulenceAttribute.itemSize;\r\n\t\t\t\tcolorAttribute.updateRange.count = this.count * colorAttribute.itemSize;\r\n\t\t\t\tsizeAttribute.updateRange.count = this.count * sizeAttribute.itemSize;\r\n\t\t\t\tlifeTimeAttribute.updateRange.count = this.count * lifeTimeAttribute.itemSize;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tpositionStartAttribute.updateRange.offset = 0;\r\n\t\t\t\tstartTimeAttribute.updateRange.offset = 0;\r\n\t\t\t\tvelocityAttribute.updateRange.offset = 0;\r\n\t\t\t\tturbulenceAttribute.updateRange.offset = 0;\r\n\t\t\t\tcolorAttribute.updateRange.offset = 0;\r\n\t\t\t\tsizeAttribute.updateRange.offset = 0;\r\n\t\t\t\tlifeTimeAttribute.updateRange.offset = 0;\r\n\r\n\t\t\t\t// Use -1 to update the entire buffer, see #11476\r\n\t\t\t\tpositionStartAttribute.updateRange.count = - 1;\r\n\t\t\t\tstartTimeAttribute.updateRange.count = - 1;\r\n\t\t\t\tvelocityAttribute.updateRange.count = - 1;\r\n\t\t\t\tturbulenceAttribute.updateRange.count = - 1;\r\n\t\t\t\tcolorAttribute.updateRange.count = - 1;\r\n\t\t\t\tsizeAttribute.updateRange.count = - 1;\r\n\t\t\t\tlifeTimeAttribute.updateRange.count = - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tpositionStartAttribute.needsUpdate = true;\r\n\t\t\tstartTimeAttribute.needsUpdate = true;\r\n\t\t\tvelocityAttribute.needsUpdate = true;\r\n\t\t\tturbulenceAttribute.needsUpdate = true;\r\n\t\t\tcolorAttribute.needsUpdate = true;\r\n\t\t\tsizeAttribute.needsUpdate = true;\r\n\t\t\tlifeTimeAttribute.needsUpdate = true;\r\n\r\n\t\t\tthis.offset = 0;\r\n\t\t\tthis.count = 0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tthis.particleShaderGeo.dispose();\r\n\r\n\t};\r\n\r\n\tthis.init();\r\n\r\n};\r\n\r\nGPUParticleContainer.prototype = Object.create( Object3D.prototype );\r\nGPUParticleContainer.prototype.constructor = GPUParticleContainer;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Gyroscope = function () {\r\n\r\n\tObject3D.call( this );\r\n\r\n};\r\n\r\nGyroscope.prototype = Object.create( Object3D.prototype );\r\nGyroscope.prototype.constructor = Gyroscope;\r\n\r\nGyroscope.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar translationObject = new Vector3();\r\n\tvar quaternionObject = new Quaternion();\r\n\tvar scaleObject = new Vector3();\r\n\r\n\tvar translationWorld = new Vector3();\r\n\tvar quaternionWorld = new Quaternion();\r\n\tvar scaleWorld = new Vector3();\r\n\r\n\treturn function updateMatrixWorld( force ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t\t// update matrixWorld\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\t\tif ( this.parent !== null ) {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t\tthis.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );\r\n\t\t\t\tthis.matrix.decompose( translationObject, quaternionObject, scaleObject );\r\n\r\n\t\t\t\tthis.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis$1.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// http://mrl.nyu.edu/~perlin/noise/\r\n\r\nvar ImprovedNoise = function () {\r\n\r\n\tvar p = [ 151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,\r\n\t\t 23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,\r\n\t\t 174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,\r\n\t\t 133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,\r\n\t\t 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,\r\n\t\t 202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,\r\n\t\t 248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,\r\n\t\t 178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,\r\n\t\t 14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,\r\n\t\t 93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 ];\r\n\r\n\tfor (var i = 0; i < 256 ; i ++) {\r\n\r\n\t\tp[256 + i] = p[i];\r\n\r\n\t}\r\n\r\n\tfunction fade(t) {\r\n\r\n\t\treturn t * t * t * (t * (t * 6 - 15) + 10);\r\n\r\n\t}\r\n\r\n\tfunction lerp(t, a, b) {\r\n\r\n\t\treturn a + t * (b - a);\r\n\r\n\t}\r\n\r\n\tfunction grad(hash, x, y, z) {\r\n\r\n\t\tvar h = hash & 15;\r\n\t\tvar u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;\r\n\t\treturn ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tnoise: function (x, y, z) {\r\n\r\n\t\t\tvar floorX = Math.floor(x), floorY = Math.floor(y), floorZ = Math.floor(z);\r\n\r\n\t\t\tvar X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;\r\n\r\n\t\t\tx -= floorX;\r\n\t\t\ty -= floorY;\r\n\t\t\tz -= floorZ;\r\n\r\n\t\t\tvar xMinus1 = x - 1, yMinus1 = y - 1, zMinus1 = z - 1;\r\n\r\n\t\t\tvar u = fade(x), v = fade(y), w = fade(z);\r\n\r\n\t\t\tvar A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;\r\n\r\n\t\t\treturn lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),\r\n\t\t\t\t\t\t\tgrad(p[BA], xMinus1, y, z)),\r\n\t\t\t\t\t\tlerp(u, grad(p[AB], x, yMinus1, z),\r\n\t\t\t\t\t\t\tgrad(p[BB], xMinus1, yMinus1, z))),\r\n\t\t\t\t\tlerp(v, lerp(u, grad(p[AA + 1], x, y, zMinus1),\r\n\t\t\t\t\t\t\tgrad(p[BA + 1], xMinus1, y, z - 1)),\r\n\t\t\t\t\t\tlerp(u, grad(p[AB + 1], x, yMinus1, zMinus1),\r\n\t\t\t\t\t\t\tgrad(p[BB + 1], xMinus1, yMinus1, zMinus1))));\r\n\r\n\t\t}\r\n\t}\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction InstancedBufferGeometry() {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'InstancedBufferGeometry';\r\n\tthis.maxInstancedCount = undefined;\r\n\r\n}\r\n\r\nInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\r\n\r\n\tconstructor: InstancedBufferGeometry,\r\n\r\n\tisInstancedBufferGeometry: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tBufferGeometry.prototype.copy.call( this, source );\r\n\r\n\t\tthis.maxInstancedCount = source.maxInstancedCount;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction InterleavedBuffer( array, stride ) {\r\n\r\n\tthis.array = array;\r\n\tthis.stride = stride;\r\n\tthis.count = array !== undefined ? array.length / stride : 0;\r\n\r\n\tthis.dynamic = false;\r\n\tthis.updateRange = { offset: 0, count: - 1 };\r\n\r\n\tthis.version = 0;\r\n\r\n}\r\n\r\nObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value === true ) { this.version ++; }\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( InterleavedBuffer.prototype, {\r\n\r\n\tisInterleavedBuffer: true,\r\n\r\n\tonUploadCallback: function () {},\r\n\r\n\tsetArray: function ( array ) {\r\n\r\n\t\tif ( Array.isArray( array ) ) {\r\n\r\n\t\t\tthrow new TypeError( 'BufferAttribute: array should be a Typed Array.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\r\n\t\tthis.array = array;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetDynamic: function ( value ) {\r\n\r\n\t\tthis.dynamic = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.array = new source.array.constructor( source.array );\r\n\t\tthis.count = source.count;\r\n\t\tthis.stride = source.stride;\r\n\t\tthis.dynamic = source.dynamic;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tindex1 *= this.stride;\r\n\t\tindex2 *= attribute.stride;\r\n\r\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\r\n\r\n\t\t\tthis$1.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) { offset = 0; }\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tonUpload: function ( callback ) {\r\n\r\n\t\tthis.onUploadCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\r\n\r\n\tInterleavedBuffer.call( this, array, stride );\r\n\r\n\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n}\r\n\r\nInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\r\n\r\n\tconstructor: InstancedInterleavedBuffer,\r\n\r\n\tisInstancedInterleavedBuffer: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tInterleavedBuffer.prototype.copy.call( this, source );\r\n\r\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\r\n\r\n\tthis.data = interleavedBuffer;\r\n\tthis.itemSize = itemSize;\r\n\tthis.offset = offset;\r\n\r\n\tthis.normalized = normalized === true;\r\n\r\n}\r\n\r\nObject.defineProperties( InterleavedBufferAttribute.prototype, {\r\n\r\n\tcount: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.data.count;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tarray: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.data.array;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nObject.assign( InterleavedBufferAttribute.prototype, {\r\n\r\n\tisInterleavedBufferAttribute: true,\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( index, w ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetX: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\r\n\r\n\t},\r\n\r\n\tgetY: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\r\n\r\n\t},\r\n\r\n\tgetZ: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\r\n\r\n\t},\r\n\r\n\tgetW: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\t\tthis.data.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\t\tthis.data.array[ index + 2 ] = z;\r\n\t\tthis.data.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WireframeGeometry( geometry ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'WireframeGeometry';\r\n\r\n\t// buffer\r\n\r\n\tvar vertices = [];\r\n\r\n\t// helper variables\r\n\r\n\tvar i, j, l, o, ol;\r\n\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\r\n\tvar key, keys = [ 'a', 'b', 'c' ];\r\n\tvar vertex;\r\n\r\n\t// different logic for Geometry and BufferGeometry\r\n\r\n\tif ( geometry && geometry.isGeometry ) {\r\n\r\n\t\t// create a data structure that contains all edges without duplicates\r\n\r\n\t\tvar faces = geometry.faces;\r\n\r\n\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\tedge1 = face[ keys[ j ] ];\r\n\t\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\r\n\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\r\n\r\n\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\r\n\r\n\t\t\t\tif ( edges[ key ] === undefined ) {\r\n\r\n\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate vertices\r\n\r\n\t\tfor ( key in edges ) {\r\n\r\n\t\t\te = edges[ key ];\r\n\r\n\t\t\tvertex = geometry.vertices[ e.index1 ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\tvertex = geometry.vertices[ e.index2 ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t} else if ( geometry && geometry.isBufferGeometry ) {\r\n\r\n\t\tvar position, indices, groups;\r\n\t\tvar group, start, count;\r\n\t\tvar index1, index2;\r\n\r\n\t\tvertex = new Vector3();\r\n\r\n\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t// indexed BufferGeometry\r\n\r\n\t\t\tposition = geometry.attributes.position;\r\n\t\t\tindices = geometry.index;\r\n\t\t\tgroups = geometry.groups;\r\n\r\n\t\t\tif ( groups.length === 0 ) {\r\n\r\n\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// create a data structure that contains all eges without duplicates\r\n\r\n\t\t\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\r\n\r\n\t\t\t\tgroup = groups[ o ];\r\n\r\n\t\t\t\tstart = group.start;\r\n\t\t\t\tcount = group.count;\r\n\r\n\t\t\t\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\r\n\r\n\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\tedge1 = indices.getX( i + j );\r\n\t\t\t\t\t\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\r\n\t\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\r\n\t\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\r\n\r\n\t\t\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\r\n\r\n\t\t\t\t\t\tif ( edges[ key ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// generate vertices\r\n\r\n\t\t\tfor ( key in edges ) {\r\n\r\n\t\t\t\te = edges[ key ];\r\n\r\n\t\t\t\tvertex.fromBufferAttribute( position, e.index1 );\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\tvertex.fromBufferAttribute( position, e.index2 );\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// non-indexed BufferGeometry\r\n\r\n\t\t\tposition = geometry.attributes.position;\r\n\r\n\t\t\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\r\n\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\r\n\r\n\t\t\t\t\tindex1 = 3 * i + j;\r\n\t\t\t\t\tvertex.fromBufferAttribute( position, index1 );\r\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\r\n\t\t\t\t\tvertex.fromBufferAttribute( position, index2 );\r\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\r\n}\r\n\r\nWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nWireframeGeometry.prototype.constructor = WireframeGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar LineSegmentsGeometry = function () {\r\n\r\n\tInstancedBufferGeometry.call( this );\r\n\r\n\tthis.type = 'LineSegmentsGeometry';\r\n\r\n\tvar plane = new BufferGeometry();\r\n\r\n\tvar positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\r\n\tvar uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\r\n\tvar index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\r\n\r\n\tthis.setIndex( index );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nLineSegmentsGeometry.prototype = Object.assign( Object.create( InstancedBufferGeometry.prototype ), {\r\n\r\n\tconstructor: LineSegmentsGeometry,\r\n\r\n\tisLineSegmentsGeometry: true,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar start = this.attributes.instanceStart;\r\n\t\tvar end = this.attributes.instanceEnd;\r\n\r\n\t\tif ( start !== undefined ) {\r\n\r\n\t\t\tmatrix.applyToBufferAttribute( start );\r\n\r\n\t\t\tmatrix.applyToBufferAttribute( end );\r\n\r\n\t\t\tstart.data.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetPositions: function ( array ) {\r\n\r\n\t\tvar lineSegments;\r\n\r\n\t\tif ( array instanceof Float32Array ) {\r\n\r\n\t\t\tlineSegments = array;\r\n\r\n\t\t} else if ( Array.isArray( array ) ) {\r\n\r\n\t\t\tlineSegments = new Float32Array( array );\r\n\r\n\t\t}\r\n\r\n\t\tvar instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\r\n\r\n\t\tthis.addAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\r\n\t\tthis.addAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\r\n\r\n\t\t//\r\n\r\n\t\tthis.computeBoundingBox();\r\n\t\tthis.computeBoundingSphere();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetColors: function ( array ) {\r\n\r\n\t\tvar colors;\r\n\r\n\t\tif ( array instanceof Float32Array ) {\r\n\r\n\t\t\tcolors = array;\r\n\r\n\t\t} else if ( Array.isArray( array ) ) {\r\n\r\n\t\t\tcolors = new Float32Array( array );\r\n\r\n\t\t}\r\n\r\n\t\tvar instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\r\n\r\n\t\tthis.addAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\r\n\t\tthis.addAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromWireframeGeometry: function ( geometry ) {\r\n\r\n\t\tthis.setPositions( geometry.attributes.position.array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromEdgesGeometry: function ( geometry ) {\r\n\r\n\t\tthis.setPositions( geometry.attributes.position.array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromMesh: function ( mesh ) {\r\n\r\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\r\n\r\n\t\t// set colors, maybe\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromLineSegements: function ( lineSegments ) {\r\n\r\n\t\tvar geometry = lineSegments.geometry;\r\n\r\n\t\tif ( geometry.isGeometry ) {\r\n\r\n\t\t\tthis.setPositions( geometry.vertices );\r\n\r\n\t\t} else if ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthis.setPositions( geometry.position.array ); // assumes non-indexed\r\n\r\n\t\t}\r\n\r\n\t\t// set colors, maybe\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tvar box = new Box3();\r\n\r\n\t\treturn function computeBoundingBox() {\r\n\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\t\tthis.boundingBox = new Box3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar start = this.attributes.instanceStart;\r\n\t\t\tvar end = this.attributes.instanceEnd;\r\n\r\n\t\t\tif ( start !== undefined && end !== undefined ) {\r\n\r\n\t\t\t\tthis.boundingBox.setFromBufferAttribute( start );\r\n\r\n\t\t\t\tbox.setFromBufferAttribute( end );\r\n\r\n\t\t\t\tthis.boundingBox.union( box );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tvar vector = new Vector3();\r\n\r\n\t\treturn function computeBoundingSphere() {\r\n\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = new Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar start = this.attributes.instanceStart;\r\n\t\t\tvar end = this.attributes.instanceEnd;\r\n\r\n\t\t\tif ( start !== undefined && end !== undefined ) {\r\n\r\n\t\t\t\tvar center = this.boundingSphere.center;\r\n\r\n\t\t\t\tthis.boundingBox.getCenter( center );\r\n\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, il = start.count; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvector.fromBufferAttribute( start, i );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t\tvector.fromBufferAttribute( end, i );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\t// todo\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t// todo\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\t// todo\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nUniformsLib.line = {\r\n\r\n\tlinewidth: { value: 1 },\r\n\tresolution: { value: new Vector2( 1, 1 ) },\r\n\tdashScale: { value: 1 },\r\n\tdashSize: { value: 1 },\r\n\tgapSize: { value: 1 } // todo FIX - maybe change to totalSize\r\n\r\n};\r\n\r\nShaderLib[ 'line' ] = {\r\n\r\n\tuniforms: UniformsUtils.merge( [\r\n\t\tUniformsLib.common,\r\n\t\tUniformsLib.fog,\r\n\t\tUniformsLib.line\r\n\t] ),\r\n\r\n\tvertexShader:\r\n\t\t\"\\n\\t\\t#include <common>\\n\\t\\t#include <color_pars_vertex>\\n\\t\\t#include <fog_pars_vertex>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\t\\t#include <clipping_planes_pars_vertex>\\n\\n\\t\\tuniform float linewidth;\\n\\t\\tuniform vec2 resolution;\\n\\n\\t\\tattribute vec3 instanceStart;\\n\\t\\tattribute vec3 instanceEnd;\\n\\n\\t\\tattribute vec3 instanceColorStart;\\n\\t\\tattribute vec3 instanceColorEnd;\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\tuniform float dashScale;\\n\\t\\t\\tattribute float instanceDistanceStart;\\n\\t\\t\\tattribute float instanceDistanceEnd;\\n\\t\\t\\tvarying float vLineDistance;\\n\\n\\t\\t#endif\\n\\n\\t\\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\\n\\n\\t\\t\\t// trim end segment so it terminates between the camera plane and the near plane\\n\\n\\t\\t\\t// conservative estimate of the near plane\\n\\t\\t\\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\\n\\t\\t\\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\\n\\t\\t\\tfloat nearEstimate = - 0.5 * b / a;\\n\\n\\t\\t\\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\\n\\n\\t\\t\\tend.xyz = mix( start.xyz, end.xyz, alpha );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#ifdef USE_COLOR\\n\\n\\t\\t\\t\\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\t\\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat aspect = resolution.x / resolution.y;\\n\\n\\t\\t\\tvUv = uv;\\n\\n\\t\\t\\t// camera space\\n\\t\\t\\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\\n\\t\\t\\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\\n\\n\\t\\t\\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\\n\\t\\t\\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\\n\\t\\t\\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\\n\\t\\t\\t// perhaps there is a more elegant solution -- WestLangley\\n\\n\\t\\t\\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\\n\\n\\t\\t\\tif ( perspective ) {\\n\\n\\t\\t\\t\\tif ( start.z < 0.0 && end.z >= 0.0 ) {\\n\\n\\t\\t\\t\\t\\ttrimSegment( start, end );\\n\\n\\t\\t\\t\\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\\n\\n\\t\\t\\t\\t\\ttrimSegment( end, start );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// clip space\\n\\t\\t\\tvec4 clipStart = projectionMatrix * start;\\n\\t\\t\\tvec4 clipEnd = projectionMatrix * end;\\n\\n\\t\\t\\t// ndc space\\n\\t\\t\\tvec2 ndcStart = clipStart.xy / clipStart.w;\\n\\t\\t\\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\\n\\n\\t\\t\\t// direction\\n\\t\\t\\tvec2 dir = ndcEnd - ndcStart;\\n\\n\\t\\t\\t// account for clip-space aspect ratio\\n\\t\\t\\tdir.x *= aspect;\\n\\t\\t\\tdir = normalize( dir );\\n\\n\\t\\t\\t// perpendicular to dir\\n\\t\\t\\tvec2 offset = vec2( dir.y, - dir.x );\\n\\n\\t\\t\\t// undo aspect ratio adjustment\\n\\t\\t\\tdir.x /= aspect;\\n\\t\\t\\toffset.x /= aspect;\\n\\n\\t\\t\\t// sign flip\\n\\t\\t\\tif ( position.x < 0.0 ) offset *= - 1.0;\\n\\n\\t\\t\\t// endcaps\\n\\t\\t\\tif ( position.y < 0.0 ) {\\n\\n\\t\\t\\t\\toffset += - dir;\\n\\n\\t\\t\\t} else if ( position.y > 1.0 ) {\\n\\n\\t\\t\\t\\toffset += dir;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// adjust for linewidth\\n\\t\\t\\toffset *= linewidth;\\n\\n\\t\\t\\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\\n\\t\\t\\toffset /= resolution.y;\\n\\n\\t\\t\\t// select end\\n\\t\\t\\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\\n\\n\\t\\t\\t// back to clip space\\n\\t\\t\\toffset *= clip.w;\\n\\n\\t\\t\\tclip.xy += offset;\\n\\n\\t\\t\\tgl_Position = clip;\\n\\n\\t\\t\\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t#include <clipping_planes_vertex>\\n\\t\\t\\t#include <fog_vertex>\\n\\n\\t\\t}\\n\\t\\t\",\r\n\r\n\tfragmentShader:\r\n\t\t\"\\n\\t\\tuniform vec3 diffuse;\\n\\t\\tuniform float opacity;\\n\\n\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\tuniform float dashSize;\\n\\t\\t\\tuniform float gapSize;\\n\\n\\t\\t#endif\\n\\n\\t\\tvarying float vLineDistance;\\n\\n\\t\\t#include <common>\\n\\t\\t#include <color_pars_fragment>\\n\\t\\t#include <fog_pars_fragment>\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\t\\t#include <clipping_planes_pars_fragment>\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <clipping_planes_fragment>\\n\\n\\t\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\t\\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\\n\\n\\t\\t\\t\\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tif ( abs( vUv.y ) > 1.0 ) {\\n\\n\\t\\t\\t\\tfloat a = vUv.x;\\n\\t\\t\\t\\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\n\\t\\t\\t\\tfloat len2 = a * a + b * b;\\n\\n\\t\\t\\t\\tif ( len2 > 1.0 ) discard;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\t\\t\\t#include <color_fragment>\\n\\n\\t\\t\\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\\n\\n\\t\\t\\t#include <premultiplied_alpha_fragment>\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <encodings_fragment>\\n\\t\\t\\t#include <fog_fragment>\\n\\n\\t\\t}\\n\\t\\t\"\r\n};\r\n\r\nvar LineMaterial = function ( parameters ) {\r\n\r\n\tShaderMaterial.call( this, {\r\n\r\n\t\ttype: 'LineMaterial',\r\n\r\n\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\r\n\r\n\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\r\n\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader\r\n\r\n\t} );\r\n\r\n\tthis.dashed = false;\r\n\r\n\tObject.defineProperties( this, {\r\n\r\n\t\tcolor: {\r\n\r\n\t\t\tenumerable: true,\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.uniforms.diffuse.value;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.uniforms.diffuse.value = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tlinewidth: {\r\n\r\n\t\t\tenumerable: true,\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.uniforms.linewidth.value;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.uniforms.linewidth.value = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tdashScale: {\r\n\r\n\t\t\tenumerable: true,\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.uniforms.dashScale.value;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.uniforms.dashScale.value = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tdashSize: {\r\n\r\n\t\t\tenumerable: true,\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.uniforms.dashSize.value;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.uniforms.dashSize.value = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tgapSize: {\r\n\r\n\t\t\tenumerable: true,\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.uniforms.gapSize.value;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.uniforms.gapSize.value = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tresolution: {\r\n\r\n\t\t\tenumerable: true,\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.uniforms.resolution.value;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.uniforms.resolution.value.copy( value );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nLineMaterial.prototype = Object.create( ShaderMaterial.prototype );\r\nLineMaterial.prototype.constructor = LineMaterial;\r\n\r\nLineMaterial.prototype.isLineMaterial = true;\r\n\r\nLineMaterial.prototype.copy = function ( source ) {\r\n\r\n\tShaderMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.linewidth = source.linewidth;\r\n\r\n\tthis.resolution = source.resolution;\r\n\r\n\t// todo\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar LineSegments2 = function ( geometry, material ) {\r\n\r\n\tMesh.call( this );\r\n\r\n\tthis.type = 'LineSegments2';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new LineSegmentsGeometry();\r\n\tthis.material = material !== undefined ? material : new LineMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nLineSegments2.prototype = Object.assign( Object.create( Mesh.prototype ), {\r\n\r\n\tconstructor: LineSegments2,\r\n\r\n\tisLineSegments2: true,\r\n\r\n\tcomputeLineDistances: ( function () { // for backwards-compatability, but could be a method of LineSegmentsGeometry...\r\n\r\n\t\tvar start = new Vector3();\r\n\t\tvar end = new Vector3();\r\n\r\n\t\treturn function computeLineDistances() {\r\n\r\n\t\t\tvar geometry = this.geometry;\r\n\r\n\t\t\tvar instanceStart = geometry.attributes.instanceStart;\r\n\t\t\tvar instanceEnd = geometry.attributes.instanceEnd;\r\n\t\t\tvar lineDistances = new Float32Array( 2 * instanceStart.data.count );\r\n\r\n\t\t\tfor ( var i = 0, j = 0, l = instanceStart.data.count; i < l; i ++, j += 2 ) {\r\n\r\n\t\t\t\tstart.fromBufferAttribute( instanceStart, i );\r\n\t\t\t\tend.fromBufferAttribute( instanceEnd, i );\r\n\r\n\t\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\r\n\t\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + start.distanceTo( end );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\r\n\r\n\t\t\tgeometry.addAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\r\n\t\t\tgeometry.addAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\t// todo\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar LineGeometry = function () {\r\n\r\n\tLineSegmentsGeometry.call( this );\r\n\r\n\tthis.type = 'LineGeometry';\r\n\r\n};\r\n\r\nLineGeometry.prototype = Object.assign( Object.create( LineSegmentsGeometry.prototype ), {\r\n\r\n\tconstructor: LineGeometry,\r\n\r\n\tisLineGeometry: true,\r\n\r\n\tsetPositions: function ( array ) {\r\n\r\n\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\r\n\r\n\t\tvar length = array.length - 3;\r\n\t\tvar points = new Float32Array( 2 * length );\r\n\r\n\t\tfor ( var i = 0; i < length; i += 3 ) {\r\n\r\n\t\t\tpoints[ 2 * i ] = array[ i ];\r\n\t\t\tpoints[ 2 * i + 1 ] = array[ i + 1 ];\r\n\t\t\tpoints[ 2 * i + 2 ] = array[ i + 2 ];\r\n\r\n\t\t\tpoints[ 2 * i + 3 ] = array[ i + 3 ];\r\n\t\t\tpoints[ 2 * i + 4 ] = array[ i + 4 ];\r\n\t\t\tpoints[ 2 * i + 5 ] = array[ i + 5 ];\r\n\r\n\t\t}\r\n\r\n\t\tLineSegmentsGeometry.prototype.setPositions.call( this, points );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetColors: function ( array ) {\r\n\r\n\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\r\n\r\n\t\tvar length = array.length - 3;\r\n\t\tvar colors = new Float32Array( 2 * length );\r\n\r\n\t\tfor ( var i = 0; i < length; i += 3 ) {\r\n\r\n\t\t\tcolors[ 2 * i ] = array[ i ];\r\n\t\t\tcolors[ 2 * i + 1 ] = array[ i + 1 ];\r\n\t\t\tcolors[ 2 * i + 2 ] = array[ i + 2 ];\r\n\r\n\t\t\tcolors[ 2 * i + 3 ] = array[ i + 3 ];\r\n\t\t\tcolors[ 2 * i + 4 ] = array[ i + 4 ];\r\n\t\t\tcolors[ 2 * i + 5 ] = array[ i + 5 ];\r\n\r\n\t\t}\r\n\r\n\t\tLineSegmentsGeometry.prototype.setColors.call( this, colors );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromLine: function ( line ) {\r\n\r\n\t\tvar geometry = line.geometry;\r\n\r\n\t\tif ( geometry.isGeometry ) {\r\n\r\n\t\t\tthis.setPositions( geometry.vertices );\r\n\r\n\t\t} else if ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthis.setPositions( geometry.position.array ); // assumes non-indexed\r\n\r\n\t\t}\r\n\r\n\t\t// set colors, maybe\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\t// todo\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Line2 = function ( geometry, material ) {\r\n\r\n\tLineSegments2.call( this );\r\n\r\n\tthis.type = 'Line2';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new LineGeometry();\r\n\tthis.material = material !== undefined ? material : new LineMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nLine2.prototype = Object.assign( Object.create( LineSegments2.prototype ), {\r\n\r\n\tconstructor: Line2,\r\n\r\n\tisLine2: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\t// todo\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Wireframe = function ( geometry, material ) {\r\n\r\n\tMesh.call( this );\r\n\r\n\tthis.type = 'Wireframe';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new LineSegmentsGeometry();\r\n\tthis.material = material !== undefined ? material : new LineMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nWireframe.prototype = Object.assign( Object.create( Mesh.prototype ), {\r\n\r\n\tconstructor: Wireframe,\r\n\r\n\tisWireframe: true,\r\n\r\n\tcomputeLineDistances: ( function () { // for backwards-compatability, but could be a method of LineSegmentsGeometry...\r\n\r\n\t\tvar start = new Vector3();\r\n\t\tvar end = new Vector3();\r\n\r\n\t\treturn function computeLineDistances() {\r\n\r\n\t\t\tvar geometry = this.geometry;\r\n\r\n\t\t\tvar instanceStart = geometry.attributes.instanceStart;\r\n\t\t\tvar instanceEnd = geometry.attributes.instanceEnd;\r\n\t\t\tvar lineDistances = new Float32Array( 2 * instanceStart.data.count );\r\n\r\n\t\t\tfor ( var i = 0, j = 0, l = instanceStart.data.count; i < l; i ++, j += 2 ) {\r\n\r\n\t\t\t\tstart.fromBufferAttribute( instanceStart, i );\r\n\t\t\t\tend.fromBufferAttribute( instanceEnd, i );\r\n\r\n\t\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\r\n\t\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + start.distanceTo( end );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\r\n\r\n\t\t\tgeometry.addAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\r\n\t\t\tgeometry.addAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\t// todo\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar WireframeGeometry2 = function ( geometry ) {\r\n\r\n\tLineSegmentsGeometry.call( this );\r\n\r\n\tthis.type = 'WireframeGeometry2';\r\n\r\n\tthis.fromWireframeGeometry( new WireframeGeometry( geometry ) );\r\n\r\n\t// set colors, maybe\r\n\r\n};\r\n\r\nWireframeGeometry2.prototype = Object.assign( Object.create( LineSegmentsGeometry.prototype ), {\r\n\r\n\tconstructor: WireframeGeometry2,\r\n\r\n\tisWireframeGeometry2: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\t// todo\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Group() {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'Group';\r\n\r\n}\r\n\r\nGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: Group,\r\n\r\n\tisGroup: true\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ThreeMFLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\tthis.availableExtensions = [];\r\n\r\n};\r\n\r\nThreeMFLoader.prototype = {\r\n\r\n\tconstructor: ThreeMFLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tonLoad( scope.parse( buffer ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( data ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tfunction loadDocument( data ) {\r\n\r\n\t\t\tvar zip = null;\r\n\t\t\tvar file = null;\r\n\r\n\t\t\tvar relsName;\r\n\t\t\tvar modelPartNames = [];\r\n\t\t\tvar texturesPartNames = [];\r\n\r\n\t\t\tvar rels;\r\n\t\t\tvar modelParts = {};\r\n\t\t\tvar printTicketParts = {};\r\n\t\t\tvar texturesParts = {};\r\n\t\t\tvar otherParts = {};\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tzip = new JSZip( data ); // eslint-disable-line no-undef\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( e instanceof ReferenceError ) {\r\n\r\n\t\t\t\t\tconsole.error( 'ThreeMFLoader: jszip missing and file is compressed.' );\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( file in zip.files ) {\r\n\r\n\t\t\t\tif ( file.match( /\\.rels$/ ) ) {\r\n\r\n\t\t\t\t\trelsName = file;\r\n\r\n\t\t\t\t} else if ( file.match( /^3D\\/.*\\.model$/ ) ) {\r\n\r\n\t\t\t\t\tmodelPartNames.push( file );\r\n\r\n\t\t\t\t} else if ( file.match( /^3D\\/Metadata\\/.*\\.xml$/ ) ) ; else if ( file.match( /^3D\\/Textures\\/.*/ ) ) {\r\n\r\n\t\t\t\t\ttexturesPartNames.push( file );\r\n\r\n\t\t\t\t} else if ( file.match( /^3D\\/Other\\/.*/ ) ) ;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar relsView = new Uint8Array( zip.file( relsName ).asArrayBuffer() );\r\n\t\t\tvar relsFileText = LoaderUtils.decodeText( relsView );\r\n\t\t\trels = parseRelsXml( relsFileText );\r\n\r\n\t\t\tfor ( var i = 0; i < modelPartNames.length; i ++ ) {\r\n\r\n\t\t\t\tvar modelPart = modelPartNames[ i ];\r\n\t\t\t\tvar view = new Uint8Array( zip.file( modelPart ).asArrayBuffer() );\r\n\r\n\t\t\t\tvar fileText = LoaderUtils.decodeText( view );\r\n\t\t\t\tvar xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );\r\n\r\n\t\t\t\tif ( xmlData.documentElement.nodeName.toLowerCase() !== 'model' ) {\r\n\r\n\t\t\t\t\tconsole.error( 'ThreeMFLoader: Error loading 3MF - no 3MF document found: ', modelPart );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar modelNode = xmlData.querySelector( 'model' );\r\n\t\t\t\tvar extensions = {};\r\n\r\n\t\t\t\tfor ( var i = 0; i < modelNode.attributes.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar attr = modelNode.attributes[ i ];\r\n\t\t\t\t\tif ( attr.name.match( /^xmlns:(.+)$/ ) ) {\r\n\r\n\t\t\t\t\t\textensions[ attr.value ] = RegExp.$1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar modelData = parseModelNode( modelNode );\r\n\t\t\t\tmodelData[ 'xml' ] = modelNode;\r\n\r\n\t\t\t\tif ( 0 < Object.keys( extensions ).length ) {\r\n\r\n\t\t\t\t\tmodelData[ 'extensions' ] = extensions;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmodelParts[ modelPart ] = modelData;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < texturesPartNames.length; i ++ ) {\r\n\r\n\t\t\t\tvar texturesPartName = texturesPartNames[ i ];\r\n\t\t\t\ttexturesParts[ texturesPartName ] = zip.file( texturesPartName ).asBinary();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\trels: rels,\r\n\t\t\t\tmodel: modelParts,\r\n\t\t\t\tprintTicket: printTicketParts,\r\n\t\t\t\ttexture: texturesParts,\r\n\t\t\t\tother: otherParts\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseRelsXml( relsFileText ) {\r\n\r\n\t\t\tvar relsXmlData = new DOMParser().parseFromString( relsFileText, 'application/xml' );\r\n\t\t\tvar relsNode = relsXmlData.querySelector( 'Relationship' );\r\n\t\t\tvar target = relsNode.getAttribute( 'Target' );\r\n\t\t\tvar id = relsNode.getAttribute( 'Id' );\r\n\t\t\tvar type = relsNode.getAttribute( 'Type' );\r\n\r\n\t\t\treturn {\r\n\t\t\t\ttarget: target,\r\n\t\t\t\tid: id,\r\n\t\t\t\ttype: type\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseMetadataNodes( metadataNodes ) {\r\n\r\n\t\t\tvar metadataData = {};\r\n\r\n\t\t\tfor ( var i = 0; i < metadataNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar metadataNode = metadataNodes[ i ];\r\n\t\t\t\tvar name = metadataNode.getAttribute( 'name' );\r\n\t\t\t\tvar validNames = [\r\n\t\t\t\t\t'Title',\r\n\t\t\t\t\t'Designer',\r\n\t\t\t\t\t'Description',\r\n\t\t\t\t\t'Copyright',\r\n\t\t\t\t\t'LicenseTerms',\r\n\t\t\t\t\t'Rating',\r\n\t\t\t\t\t'CreationDate',\r\n\t\t\t\t\t'ModificationDate'\r\n\t\t\t\t];\r\n\r\n\t\t\t\tif ( 0 <= validNames.indexOf( name ) ) {\r\n\r\n\t\t\t\t\tmetadataData[ name ] = metadataNode.textContent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn metadataData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseBasematerialsNode( basematerialsNode ) {\r\n\t\t}\r\n\r\n\t\tfunction parseMeshNode( meshNode, extensions ) {\r\n\r\n\t\t\tvar meshData = {};\r\n\r\n\t\t\tvar vertices = [];\r\n\t\t\tvar vertexNodes = meshNode.querySelectorAll( 'vertices vertex' );\r\n\r\n\t\t\tfor ( var i = 0; i < vertexNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar vertexNode = vertexNodes[ i ];\r\n\t\t\t\tvar x = vertexNode.getAttribute( 'x' );\r\n\t\t\t\tvar y = vertexNode.getAttribute( 'y' );\r\n\t\t\t\tvar z = vertexNode.getAttribute( 'z' );\r\n\r\n\t\t\t\tvertices.push( parseFloat( x ), parseFloat( y ), parseFloat( z ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmeshData[ 'vertices' ] = new Float32Array( vertices.length );\r\n\r\n\t\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\r\n\r\n\t\t\t\tmeshData[ 'vertices' ][ i ] = vertices[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar triangleProperties = [];\r\n\t\t\tvar triangles = [];\r\n\t\t\tvar triangleNodes = meshNode.querySelectorAll( 'triangles triangle' );\r\n\r\n\t\t\tfor ( var i = 0; i < triangleNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar triangleNode = triangleNodes[ i ];\r\n\t\t\t\tvar v1 = triangleNode.getAttribute( 'v1' );\r\n\t\t\t\tvar v2 = triangleNode.getAttribute( 'v2' );\r\n\t\t\t\tvar v3 = triangleNode.getAttribute( 'v3' );\r\n\t\t\t\tvar p1 = triangleNode.getAttribute( 'p1' );\r\n\t\t\t\tvar p2 = triangleNode.getAttribute( 'p2' );\r\n\t\t\t\tvar p3 = triangleNode.getAttribute( 'p3' );\r\n\t\t\t\tvar pid = triangleNode.getAttribute( 'pid' );\r\n\r\n\t\t\t\ttriangles.push( parseInt( v1, 10 ), parseInt( v2, 10 ), parseInt( v3, 10 ) );\r\n\r\n\t\t\t\tvar triangleProperty = {};\r\n\r\n\t\t\t\tif ( p1 ) {\r\n\r\n\t\t\t\t\ttriangleProperty[ 'p1' ] = parseInt( p1, 10 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p2 ) {\r\n\r\n\t\t\t\t\ttriangleProperty[ 'p2' ] = parseInt( p2, 10 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p3 ) {\r\n\r\n\t\t\t\t\ttriangleProperty[ 'p3' ] = parseInt( p3, 10 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( pid ) {\r\n\r\n\t\t\t\t\ttriangleProperty[ 'pid' ] = pid;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( 0 < Object.keys( triangleProperty ).length ) {\r\n\r\n\t\t\t\t\ttriangleProperties.push( triangleProperty );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmeshData[ 'triangleProperties' ] = triangleProperties;\r\n\t\t\tmeshData[ 'triangles' ] = new Uint32Array( triangles.length );\r\n\r\n\t\t\tfor ( var i = 0; i < triangles.length; i ++ ) {\r\n\r\n\t\t\t\tmeshData[ 'triangles' ][ i ] = triangles[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn meshData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseComponentsNode( componentsNode ) {\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseObjectNode( objectNode ) {\r\n\r\n\t\t\tvar objectData = {\r\n\t\t\t\ttype: objectNode.getAttribute( 'type' )\r\n\t\t\t};\r\n\r\n\t\t\tvar id = objectNode.getAttribute( 'id' );\r\n\r\n\t\t\tif ( id ) {\r\n\r\n\t\t\t\tobjectData[ 'id' ] = id;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar pid = objectNode.getAttribute( 'pid' );\r\n\r\n\t\t\tif ( pid ) {\r\n\r\n\t\t\t\tobjectData[ 'pid' ] = pid;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar pindex = objectNode.getAttribute( 'pindex' );\r\n\r\n\t\t\tif ( pindex ) {\r\n\r\n\t\t\t\tobjectData[ 'pindex' ] = pindex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar thumbnail = objectNode.getAttribute( 'thumbnail' );\r\n\r\n\t\t\tif ( thumbnail ) {\r\n\r\n\t\t\t\tobjectData[ 'thumbnail' ] = thumbnail;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar partnumber = objectNode.getAttribute( 'partnumber' );\r\n\r\n\t\t\tif ( partnumber ) {\r\n\r\n\t\t\t\tobjectData[ 'partnumber' ] = partnumber;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar name = objectNode.getAttribute( 'name' );\r\n\r\n\t\t\tif ( name ) {\r\n\r\n\t\t\t\tobjectData[ 'name' ] = name;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar meshNode = objectNode.querySelector( 'mesh' );\r\n\r\n\t\t\tif ( meshNode ) {\r\n\r\n\t\t\t\tobjectData[ 'mesh' ] = parseMeshNode( meshNode );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar componentsNode = objectNode.querySelector( 'components' );\r\n\r\n\t\t\tif ( componentsNode ) {\r\n\r\n\t\t\t\tobjectData[ 'components' ] = parseComponentsNode( componentsNode );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn objectData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseResourcesNode( resourcesNode ) {\r\n\r\n\t\t\tvar resourcesData = {};\r\n\t\t\tvar basematerialsNode = resourcesNode.querySelector( 'basematerials' );\r\n\r\n\t\t\tif ( basematerialsNode ) {\r\n\r\n\t\t\t\tresourcesData[ 'basematerial' ] = parseBasematerialsNode( basematerialsNode );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresourcesData[ 'object' ] = {};\r\n\t\t\tvar objectNodes = resourcesNode.querySelectorAll( 'object' );\r\n\r\n\t\t\tfor ( var i = 0; i < objectNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar objectNode = objectNodes[ i ];\r\n\t\t\t\tvar objectData = parseObjectNode( objectNode );\r\n\t\t\t\tresourcesData[ 'object' ][ objectData[ 'id' ] ] = objectData;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn resourcesData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseBuildNode( buildNode ) {\r\n\r\n\t\t\tvar buildData = [];\r\n\t\t\tvar itemNodes = buildNode.querySelectorAll( 'item' );\r\n\r\n\t\t\tfor ( var i = 0; i < itemNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar itemNode = itemNodes[ i ];\r\n\t\t\t\tvar buildItem = {\r\n\t\t\t\t\tobjectid: itemNode.getAttribute( 'objectid' )\r\n\t\t\t\t};\r\n\t\t\t\tvar transform = itemNode.getAttribute( 'transform' );\r\n\r\n\t\t\t\tif ( transform ) {\r\n\r\n\t\t\t\t\tvar t = [];\r\n\t\t\t\t\ttransform.split( ' ' ).forEach( function ( s ) {\r\n\r\n\t\t\t\t\t\tt.push( parseFloat( s ) );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tvar mat4 = new Matrix4();\r\n\t\t\t\t\tbuildItem[ 'transform' ] = mat4.set(\r\n\t\t\t\t\t\tt[ 0 ], t[ 3 ], t[ 6 ], t[ 9 ],\r\n\t\t\t\t\t\tt[ 1 ], t[ 4 ], t[ 7 ], t[ 10 ],\r\n\t\t\t\t\t\tt[ 2 ], t[ 5 ], t[ 8 ], t[ 11 ],\r\n\t\t\t\t\t\t 0.0, 0.0, 0.0, 1.0\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbuildData.push( buildItem );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buildData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseModelNode( modelNode ) {\r\n\r\n\t\t\tvar modelData = { unit: modelNode.getAttribute( 'unit' ) || 'millimeter' };\r\n\t\t\tvar metadataNodes = modelNode.querySelectorAll( 'metadata' );\r\n\r\n\t\t\tif ( metadataNodes ) {\r\n\r\n\t\t\t\tmodelData[ 'metadata' ] = parseMetadataNodes( metadataNodes );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar resourcesNode = modelNode.querySelector( 'resources' );\r\n\r\n\t\t\tif ( resourcesNode ) {\r\n\r\n\t\t\t\tmodelData[ 'resources' ] = parseResourcesNode( resourcesNode );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar buildNode = modelNode.querySelector( 'build' );\r\n\r\n\t\t\tif ( buildNode ) {\r\n\r\n\t\t\t\tmodelData[ 'build' ] = parseBuildNode( buildNode );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn modelData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildMesh( meshData, data3mf ) {\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\t\t\tgeometry.setIndex( new BufferAttribute( meshData[ 'triangles' ], 1 ) );\r\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( meshData[ 'vertices' ], 3 ) );\r\n\r\n\t\t\tif ( meshData[ 'colors' ] ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'color', new BufferAttribute( meshData[ 'colors' ], 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t\tvar materialOpts = {\r\n\t\t\t\tflatShading: true\r\n\t\t\t};\r\n\r\n\t\t\tif ( meshData[ 'colors' ] && 0 < meshData[ 'colors' ].length ) {\r\n\r\n\t\t\t\tmaterialOpts[ 'vertexColors' ] = VertexColors;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterialOpts[ 'color' ] = 0xaaaaff;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar material = new MeshPhongMaterial( materialOpts );\r\n\t\t\treturn new Mesh( geometry, material );\r\n\r\n\t\t}\r\n\r\n\t\tfunction applyExtensions( extensions, meshData, modelXml, data3mf ) {\r\n\r\n\t\t\tif ( ! extensions ) {\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar availableExtensions = [];\r\n\t\t\tvar keys = Object.keys( extensions );\r\n\r\n\t\t\tfor ( var i = 0; i < keys.length; i ++ ) {\r\n\r\n\t\t\t\tvar ns = keys[ i ];\r\n\r\n\t\t\t\tfor ( var j = 0; j < scope.availableExtensions.length; j ++ ) {\r\n\r\n\t\t\t\t\tvar extension = scope.availableExtensions[ j ];\r\n\r\n\t\t\t\t\tif ( extension.ns === ns ) {\r\n\r\n\t\t\t\t\t\tavailableExtensions.push( extension );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < availableExtensions.length; i ++ ) {\r\n\r\n\t\t\t\tvar extension = availableExtensions[ i ];\r\n\t\t\t\textension.apply( modelXml, extensions[ extension[ 'ns' ] ], meshData );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildMeshes( data3mf ) {\r\n\r\n\t\t\tvar modelsData = data3mf.model;\r\n\t\t\tvar meshes = {};\r\n\t\t\tvar modelsKeys = Object.keys( modelsData );\r\n\r\n\t\t\tfor ( var i = 0; i < modelsKeys.length; i ++ ) {\r\n\r\n\t\t\t\tvar modelsKey = modelsKeys[ i ];\r\n\t\t\t\tvar modelData = modelsData[ modelsKey ];\r\n\t\t\t\tvar modelXml = modelData[ 'xml' ];\r\n\t\t\t\tvar extensions = modelData[ 'extensions' ];\r\n\r\n\t\t\t\tvar objectIds = Object.keys( modelData[ 'resources' ][ 'object' ] );\r\n\r\n\t\t\t\tfor ( var j = 0; j < objectIds.length; j ++ ) {\r\n\r\n\t\t\t\t\tvar objectId = objectIds[ j ];\r\n\t\t\t\t\tvar objectData = modelData[ 'resources' ][ 'object' ][ objectId ];\r\n\t\t\t\t\tvar meshData = objectData[ 'mesh' ];\r\n\t\t\t\t\tapplyExtensions( extensions, meshData, modelXml, data3mf );\r\n\t\t\t\t\tmeshes[ objectId ] = buildMesh( meshData, data3mf );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn meshes;\r\n\r\n\t\t}\r\n\r\n\t\tfunction build( meshes, refs, data3mf ) {\r\n\r\n\t\t\tvar group = new Group();\r\n\t\t\tvar buildData = data3mf.model[ refs[ 'target' ].substring( 1 ) ][ 'build' ];\r\n\r\n\t\t\tfor ( var i = 0; i < buildData.length; i ++ ) {\r\n\r\n\t\t\t\tvar buildItem = buildData[ i ];\r\n\t\t\t\tvar mesh = meshes[ buildItem[ 'objectid' ] ];\r\n\r\n\t\t\t\tif ( buildItem[ 'transform' ] ) {\r\n\r\n\t\t\t\t\tmesh.geometry.applyMatrix( buildItem[ 'transform' ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgroup.add( mesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn group;\r\n\r\n\t\t}\r\n\r\n\t\tvar data3mf = loadDocument( data );\r\n\t\tvar meshes = buildMeshes( data3mf );\r\n\r\n\t\treturn build( meshes, data3mf[ 'rels' ], data3mf );\r\n\r\n\t},\r\n\r\n\taddExtension: function ( extension ) {\r\n\r\n\t\tthis.availableExtensions.push( extension );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar AMFLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nAMFLoader.prototype = {\r\n\r\n\tconstructor: AMFLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( data ) {\r\n\r\n\t\tfunction loadDocument( data ) {\r\n\r\n\t\t\tvar view = new DataView( data );\r\n\t\t\tvar magic = String.fromCharCode( view.getUint8( 0 ), view.getUint8( 1 ) );\r\n\r\n\t\t\tif ( magic === 'PK' ) {\r\n\r\n\t\t\t\tvar zip = null;\r\n\t\t\t\tvar file = null;\r\n\r\n\t\t\t\tconsole.log( 'AMFLoader: Loading Zip' );\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tzip = new JSZip( data ); // eslint-disable-line no-undef\r\n\r\n\t\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t\tif ( e instanceof ReferenceError ) {\r\n\r\n\t\t\t\t\t\tconsole.log( 'AMFLoader: jszip missing and file is compressed.' );\r\n\t\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( file in zip.files ) {\r\n\r\n\t\t\t\t\tif ( file.toLowerCase().substr( - 4 ) === '.amf' ) {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconsole.log( 'AMFLoader: Trying to load file asset: ' + file );\r\n\t\t\t\tview = new DataView( zip.file( file ).asArrayBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar fileText = LoaderUtils.decodeText( view );\r\n\t\t\tvar xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );\r\n\r\n\t\t\tif ( xmlData.documentElement.nodeName.toLowerCase() !== 'amf' ) {\r\n\r\n\t\t\t\tconsole.log( 'AMFLoader: Error loading AMF - no AMF document found.' );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn xmlData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadDocumentScale( node ) {\r\n\r\n\t\t\tvar scale = 1.0;\r\n\t\t\tvar unit = 'millimeter';\r\n\r\n\t\t\tif ( node.documentElement.attributes.unit !== undefined ) {\r\n\r\n\t\t\t\tunit = node.documentElement.attributes.unit.value.toLowerCase();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar scaleUnits = {\r\n\t\t\t\tmillimeter: 1.0,\r\n\t\t\t\tinch: 25.4,\r\n\t\t\t\tfeet: 304.8,\r\n\t\t\t\tmeter: 1000.0,\r\n\t\t\t\tmicron: 0.001\r\n\t\t\t};\r\n\r\n\t\t\tif ( scaleUnits[ unit ] !== undefined ) {\r\n\r\n\t\t\t\tscale = scaleUnits[ unit ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.log( 'AMFLoader: Unit scale: ' + scale );\r\n\t\t\treturn scale;\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadMaterials( node ) {\r\n\r\n\t\t\tvar matName = 'AMF Material';\r\n\t\t\tvar matId = node.attributes.id.textContent;\r\n\t\t\tvar color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\r\n\r\n\t\t\tvar loadedMaterial = null;\r\n\r\n\t\t\tfor ( var i = 0; i < node.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar matChildEl = node.childNodes[ i ];\r\n\r\n\t\t\t\tif ( matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined ) {\r\n\r\n\t\t\t\t\tif ( matChildEl.attributes.type.value === 'name' ) {\r\n\r\n\t\t\t\t\t\tmatName = matChildEl.textContent;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( matChildEl.nodeName === 'color' ) {\r\n\r\n\t\t\t\t\tcolor = loadColor( matChildEl );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tloadedMaterial = new MeshPhongMaterial( {\r\n\t\t\t\tflatShading: true,\r\n\t\t\t\tcolor: new Color( color.r, color.g, color.b ),\r\n\t\t\t\tname: matName\r\n\t\t\t} );\r\n\r\n\t\t\tif ( color.a !== 1.0 ) {\r\n\r\n\t\t\t\tloadedMaterial.transparent = true;\r\n\t\t\t\tloadedMaterial.opacity = color.a;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { id: matId, material: loadedMaterial };\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadColor( node ) {\r\n\r\n\t\t\tvar color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\r\n\r\n\t\t\tfor ( var i = 0; i < node.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar matColor = node.childNodes[ i ];\r\n\r\n\t\t\t\tif ( matColor.nodeName === 'r' ) {\r\n\r\n\t\t\t\t\tcolor.r = matColor.textContent;\r\n\r\n\t\t\t\t} else if ( matColor.nodeName === 'g' ) {\r\n\r\n\t\t\t\t\tcolor.g = matColor.textContent;\r\n\r\n\t\t\t\t} else if ( matColor.nodeName === 'b' ) {\r\n\r\n\t\t\t\t\tcolor.b = matColor.textContent;\r\n\r\n\t\t\t\t} else if ( matColor.nodeName === 'a' ) {\r\n\r\n\t\t\t\t\tcolor.a = matColor.textContent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn color;\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadMeshVolume( node ) {\r\n\r\n\t\t\tvar volume = { name: '', triangles: [], materialid: null };\r\n\r\n\t\t\tvar currVolumeNode = node.firstElementChild;\r\n\r\n\t\t\tif ( node.attributes.materialid !== undefined ) {\r\n\r\n\t\t\t\tvolume.materialId = node.attributes.materialid.nodeValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( currVolumeNode ) {\r\n\r\n\t\t\t\tif ( currVolumeNode.nodeName === 'metadata' ) {\r\n\r\n\t\t\t\t\tif ( currVolumeNode.attributes.type !== undefined ) {\r\n\r\n\t\t\t\t\t\tif ( currVolumeNode.attributes.type.value === 'name' ) {\r\n\r\n\t\t\t\t\t\t\tvolume.name = currVolumeNode.textContent;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( currVolumeNode.nodeName === 'triangle' ) {\r\n\r\n\t\t\t\t\tvar v1 = currVolumeNode.getElementsByTagName( 'v1' )[ 0 ].textContent;\r\n\t\t\t\t\tvar v2 = currVolumeNode.getElementsByTagName( 'v2' )[ 0 ].textContent;\r\n\t\t\t\t\tvar v3 = currVolumeNode.getElementsByTagName( 'v3' )[ 0 ].textContent;\r\n\r\n\t\t\t\t\tvolume.triangles.push( v1, v2, v3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrVolumeNode = currVolumeNode.nextElementSibling;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn volume;\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadMeshVertices( node ) {\r\n\r\n\t\t\tvar vertArray = [];\r\n\t\t\tvar normalArray = [];\r\n\t\t\tvar currVerticesNode = node.firstElementChild;\r\n\r\n\t\t\twhile ( currVerticesNode ) {\r\n\r\n\t\t\t\tif ( currVerticesNode.nodeName === 'vertex' ) {\r\n\r\n\t\t\t\t\tvar vNode = currVerticesNode.firstElementChild;\r\n\r\n\t\t\t\t\twhile ( vNode ) {\r\n\r\n\t\t\t\t\t\tif ( vNode.nodeName === 'coordinates' ) {\r\n\r\n\t\t\t\t\t\t\tvar x = vNode.getElementsByTagName( 'x' )[ 0 ].textContent;\r\n\t\t\t\t\t\t\tvar y = vNode.getElementsByTagName( 'y' )[ 0 ].textContent;\r\n\t\t\t\t\t\t\tvar z = vNode.getElementsByTagName( 'z' )[ 0 ].textContent;\r\n\r\n\t\t\t\t\t\t\tvertArray.push( x, y, z );\r\n\r\n\t\t\t\t\t\t} else if ( vNode.nodeName === 'normal' ) {\r\n\r\n\t\t\t\t\t\t\tvar nx = vNode.getElementsByTagName( 'nx' )[ 0 ].textContent;\r\n\t\t\t\t\t\t\tvar ny = vNode.getElementsByTagName( 'ny' )[ 0 ].textContent;\r\n\t\t\t\t\t\t\tvar nz = vNode.getElementsByTagName( 'nz' )[ 0 ].textContent;\r\n\r\n\t\t\t\t\t\t\tnormalArray.push( nx, ny, nz );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvNode = vNode.nextElementSibling;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tcurrVerticesNode = currVerticesNode.nextElementSibling;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { 'vertices': vertArray, 'normals': normalArray };\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadObject( node ) {\r\n\r\n\t\t\tvar objId = node.attributes.id.textContent;\r\n\t\t\tvar loadedObject = { name: 'amfobject', meshes: [] };\r\n\t\t\tvar currColor = null;\r\n\t\t\tvar currObjNode = node.firstElementChild;\r\n\r\n\t\t\twhile ( currObjNode ) {\r\n\r\n\t\t\t\tif ( currObjNode.nodeName === 'metadata' ) {\r\n\r\n\t\t\t\t\tif ( currObjNode.attributes.type !== undefined ) {\r\n\r\n\t\t\t\t\t\tif ( currObjNode.attributes.type.value === 'name' ) {\r\n\r\n\t\t\t\t\t\t\tloadedObject.name = currObjNode.textContent;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( currObjNode.nodeName === 'color' ) {\r\n\r\n\t\t\t\t\tcurrColor = loadColor( currObjNode );\r\n\r\n\t\t\t\t} else if ( currObjNode.nodeName === 'mesh' ) {\r\n\r\n\t\t\t\t\tvar currMeshNode = currObjNode.firstElementChild;\r\n\t\t\t\t\tvar mesh = { vertices: [], normals: [], volumes: [], color: currColor };\r\n\r\n\t\t\t\t\twhile ( currMeshNode ) {\r\n\r\n\t\t\t\t\t\tif ( currMeshNode.nodeName === 'vertices' ) {\r\n\r\n\t\t\t\t\t\t\tvar loadedVertices = loadMeshVertices( currMeshNode );\r\n\r\n\t\t\t\t\t\t\tmesh.normals = mesh.normals.concat( loadedVertices.normals );\r\n\t\t\t\t\t\t\tmesh.vertices = mesh.vertices.concat( loadedVertices.vertices );\r\n\r\n\t\t\t\t\t\t} else if ( currMeshNode.nodeName === 'volume' ) {\r\n\r\n\t\t\t\t\t\t\tmesh.volumes.push( loadMeshVolume( currMeshNode ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcurrMeshNode = currMeshNode.nextElementSibling;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tloadedObject.meshes.push( mesh );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrObjNode = currObjNode.nextElementSibling;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { 'id': objId, 'obj': loadedObject };\r\n\r\n\t\t}\r\n\r\n\t\tvar xmlData = loadDocument( data );\r\n\t\tvar amfName = '';\r\n\t\tvar amfAuthor = '';\r\n\t\tvar amfScale = loadDocumentScale( xmlData );\r\n\t\tvar amfMaterials = {};\r\n\t\tvar amfObjects = {};\r\n\t\tvar childNodes = xmlData.documentElement.childNodes;\r\n\r\n\t\tvar i, j;\r\n\r\n\t\tfor ( i = 0; i < childNodes.length; i ++ ) {\r\n\r\n\t\t\tvar child = childNodes[ i ];\r\n\r\n\t\t\tif ( child.nodeName === 'metadata' ) {\r\n\r\n\t\t\t\tif ( child.attributes.type !== undefined ) {\r\n\r\n\t\t\t\t\tif ( child.attributes.type.value === 'name' ) {\r\n\r\n\t\t\t\t\t\tamfName = child.textContent;\r\n\r\n\t\t\t\t\t} else if ( child.attributes.type.value === 'author' ) {\r\n\r\n\t\t\t\t\t\tamfAuthor = child.textContent;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( child.nodeName === 'material' ) {\r\n\r\n\t\t\t\tvar loadedMaterial = loadMaterials( child );\r\n\r\n\t\t\t\tamfMaterials[ loadedMaterial.id ] = loadedMaterial.material;\r\n\r\n\t\t\t} else if ( child.nodeName === 'object' ) {\r\n\r\n\t\t\t\tvar loadedObject = loadObject( child );\r\n\r\n\t\t\t\tamfObjects[ loadedObject.id ] = loadedObject.obj;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar sceneObject = new Group();\r\n\t\tvar defaultMaterial = new MeshPhongMaterial( { color: 0xaaaaff, flatShading: true } );\r\n\r\n\t\tsceneObject.name = amfName;\r\n\t\tsceneObject.userData.author = amfAuthor;\r\n\t\tsceneObject.userData.loader = 'AMF';\r\n\r\n\t\tfor ( var id in amfObjects ) {\r\n\r\n\t\t\tvar part = amfObjects[ id ];\r\n\t\t\tvar meshes = part.meshes;\r\n\t\t\tvar newObject = new Group();\r\n\t\t\tnewObject.name = part.name || '';\r\n\r\n\t\t\tfor ( i = 0; i < meshes.length; i ++ ) {\r\n\r\n\t\t\t\tvar objDefaultMaterial = defaultMaterial;\r\n\t\t\t\tvar mesh = meshes[ i ];\r\n\t\t\t\tvar vertices = new Float32BufferAttribute( mesh.vertices, 3 );\r\n\t\t\t\tvar normals = null;\r\n\r\n\t\t\t\tif ( mesh.normals.length ) {\r\n\r\n\t\t\t\t\tnormals = new Float32BufferAttribute( mesh.normals, 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( mesh.color ) {\r\n\r\n\t\t\t\t\tvar color = mesh.color;\r\n\r\n\t\t\t\t\tobjDefaultMaterial = defaultMaterial.clone();\r\n\t\t\t\t\tobjDefaultMaterial.color = new Color( color.r, color.g, color.b );\r\n\r\n\t\t\t\t\tif ( color.a !== 1.0 ) {\r\n\r\n\t\t\t\t\t\tobjDefaultMaterial.transparent = true;\r\n\t\t\t\t\t\tobjDefaultMaterial.opacity = color.a;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar volumes = mesh.volumes;\r\n\r\n\t\t\t\tfor ( j = 0; j < volumes.length; j ++ ) {\r\n\r\n\t\t\t\t\tvar volume = volumes[ j ];\r\n\t\t\t\t\tvar newGeometry = new BufferGeometry();\r\n\t\t\t\t\tvar material = objDefaultMaterial;\r\n\r\n\t\t\t\t\tnewGeometry.setIndex( volume.triangles );\r\n\t\t\t\t\tnewGeometry.addAttribute( 'position', vertices.clone() );\r\n\r\n\t\t\t\t\tif ( normals ) {\r\n\r\n\t\t\t\t\t\tnewGeometry.addAttribute( 'normal', normals.clone() );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( amfMaterials[ volume.materialId ] !== undefined ) {\r\n\r\n\t\t\t\t\t\tmaterial = amfMaterials[ volume.materialId ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnewGeometry.scale( amfScale, amfScale, amfScale );\r\n\t\t\t\t\tnewObject.add( new Mesh( newGeometry, material.clone() ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsceneObject.add( newObject );\r\n\r\n\t\t}\r\n\r\n\t\treturn sceneObject;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar AssimpJSONLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nAssimpJSONLoader.prototype = {\r\n\r\n\tconstructor: AssimpJSONLoader,\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar path = LoaderUtils.extractUrlBase( url );\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tvar json = JSON.parse( text );\r\n\t\t\tvar metadata = json.__metadata__;\r\n\r\n\t\t\t// check if __metadata__ meta header is present\r\n\t\t\t// this header is used to disambiguate between different JSON-based file formats\r\n\r\n\t\t\tif ( typeof metadata !== 'undefined' ) {\r\n\r\n\t\t\t\t// check if assimp2json at all\r\n\r\n\t\t\t\tif ( metadata.format !== 'assimp2json' ) {\r\n\r\n\t\t\t\t\tonError( 'AssimpJSONLoader: Not an assimp2json scene.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t// check major format version\r\n\r\n\t\t\t\t} else if ( metadata.version < 100 && metadata.version >= 200 ) {\r\n\r\n\t\t\t\t\tonError( 'AssimpJSONLoader: Unsupported assimp2json file format version.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tonLoad( scope.parse( json, path ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tparse: function ( json, path ) {\r\n\r\n\t\tfunction parseList( json, handler ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar meshes = new Array( json.length );\r\n\r\n\t\t\tfor ( var i = 0; i < json.length; ++ i ) {\r\n\r\n\t\t\t\tmeshes[ i ] = handler.call( this$1, json[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn meshes;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseMesh( json ) {\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\tvar i, l, face;\r\n\r\n\t\t\tvar indices = [];\r\n\r\n\t\t\tvar vertices = json.vertices || [];\r\n\t\t\tvar normals = json.normals || [];\r\n\t\t\tvar uvs = json.texturecoords || [];\r\n\t\t\tvar colors = json.colors || [];\r\n\r\n\t\t\tuvs = uvs[ 0 ] || []; // only support for a single set of uvs\r\n\r\n\t\t\tfor ( i = 0, l = json.faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tface = json.faces[ i ];\r\n\t\t\t\tindices.push( face[ 0 ], face[ 1 ], face[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.setIndex( indices );\r\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\r\n\t\t\tif ( normals.length > 0 ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs.length > 0 ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colors.length > 0 ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseMaterial( json ) {\r\n\r\n\t\t\tvar material = new MeshPhongMaterial();\r\n\r\n\t\t\tfor ( var i in json.properties ) {\r\n\r\n\t\t\t\tvar property = json.properties[ i ];\r\n\t\t\t\tvar key = property.key;\r\n\t\t\t\tvar value = property.value;\r\n\r\n\t\t\t\tswitch ( key ) {\r\n\r\n\t\t\t\t\tcase '$tex.file': {\r\n\r\n\t\t\t\t\t\tvar semantic = property.semantic;\r\n\r\n\t\t\t\t\t\t// prop.semantic gives the type of the texture\r\n\t\t\t\t\t\t// 1: diffuse\r\n\t\t\t\t\t\t// 2: specular mao\r\n\t\t\t\t\t\t// 5: height map (bumps)\r\n\t\t\t\t\t\t// 6: normal map\r\n\t\t\t\t\t\t// more values (i.e. emissive, environment) are known by assimp and may be relevant\r\n\r\n\t\t\t\t\t\tif ( semantic === 1 || semantic === 2 || semantic === 5 || semantic === 6 ) {\r\n\r\n\t\t\t\t\t\t\tvar keyname;\r\n\r\n\t\t\t\t\t\t\tswitch ( semantic ) {\r\n\r\n\t\t\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\t\t\tkeyname = 'map';\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t\tkeyname = 'specularMap';\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\t\t\tkeyname = 'bumpMap';\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\t\t\tkeyname = 'normalMap';\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tvar texture = textureLoader.load( value );\r\n\r\n\t\t\t\t\t\t\t// TODO: read texture settings from assimp.\r\n\t\t\t\t\t\t\t// Wrapping is the default, though.\r\n\r\n\t\t\t\t\t\t\ttexture.wrapS = texture.wrapT = RepeatWrapping;\r\n\r\n\t\t\t\t\t\t\tmaterial[ keyname ] = texture;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase '?mat.name':\r\n\t\t\t\t\t\tmaterial.name = value;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '$clr.diffuse':\r\n\t\t\t\t\t\tmaterial.color.fromArray( value );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '$clr.specular':\r\n\t\t\t\t\t\tmaterial.specular.fromArray( value );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '$clr.emissive':\r\n\t\t\t\t\t\tmaterial.emissive.fromArray( value );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '$mat.shininess':\r\n\t\t\t\t\t\tmaterial.shininess = value;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '$mat.shadingm':\r\n\t\t\t\t\t\t// aiShadingMode_Flat\r\n\t\t\t\t\t\tmaterial.flatShading = ( value === 1 ) ? true : false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '$mat.opacity':\r\n\t\t\t\t\t\tif ( value < 1 ) {\r\n\r\n\t\t\t\t\t\t\tmaterial.opacity = value;\r\n\t\t\t\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseObject( json, node, meshes, materials ) {\r\n\r\n\t\t\tvar obj = new Object3D(),\ti, idx;\r\n\r\n\t\t\tobj.name = node.name || '';\r\n\t\t\tobj.matrix = new Matrix4().fromArray( node.transformation ).transpose();\r\n\t\t\tobj.matrix.decompose( obj.position, obj.quaternion, obj.scale );\r\n\r\n\t\t\tfor ( i = 0; node.meshes && i < node.meshes.length; i ++ ) {\r\n\r\n\t\t\t\tidx = node.meshes[ i ];\r\n\t\t\t\tobj.add( new Mesh( meshes[ idx ], materials[ json.meshes[ idx ].materialindex ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; node.children && i < node.children.length; i ++ ) {\r\n\r\n\t\t\t\tobj.add( parseObject( json, node.children[ i ], meshes, materials ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn obj;\r\n\r\n\t\t}\r\n\r\n\t\tvar textureLoader = new TextureLoader( this.manager );\r\n\t\ttextureLoader.setPath( path ).setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tvar meshes = parseList( json.meshes, parseMesh );\r\n\t\tvar materials = parseList( json.materials, parseMaterial );\r\n\t\treturn parseObject( json, json.rootnode, meshes, materials );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Skeleton( bones, boneInverses ) {\n\tvar this$1 = this;\n\r\n\r\n\t// copy the bone array\r\n\r\n\tbones = bones || [];\r\n\r\n\tthis.bones = bones.slice( 0 );\r\n\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\r\n\r\n\t// use the supplied bone inverses or calculate the inverses\r\n\r\n\tif ( boneInverses === undefined ) {\r\n\r\n\t\tthis.calculateInverses();\r\n\r\n\t} else {\r\n\r\n\t\tif ( this.bones.length === boneInverses.length ) {\r\n\r\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'Skeleton boneInverses is the wrong length.' );\r\n\r\n\t\t\tthis.boneInverses = [];\r\n\r\n\t\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tthis$1.boneInverses.push( new Matrix4() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nObject.assign( Skeleton.prototype, {\r\n\r\n\tcalculateInverses: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.boneInverses = [];\r\n\r\n\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar inverse = new Matrix4();\r\n\r\n\t\t\tif ( this$1.bones[ i ] ) {\r\n\r\n\t\t\t\tinverse.getInverse( this$1.bones[ i ].matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis$1.boneInverses.push( inverse );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tpose: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar bone, i, il;\r\n\r\n\t\t// recover the bind-time world matrices\r\n\r\n\t\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\tbone = this$1.bones[ i ];\r\n\r\n\t\t\tif ( bone ) {\r\n\r\n\t\t\t\tbone.matrixWorld.getInverse( this$1.boneInverses[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// compute the local matrices, positions, rotations and scales\r\n\r\n\t\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\tbone = this$1.bones[ i ];\r\n\r\n\t\t\tif ( bone ) {\r\n\r\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\r\n\r\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdate: ( function () {\r\n\r\n\t\tvar offsetMatrix = new Matrix4();\r\n\t\tvar identityMatrix = new Matrix4();\r\n\r\n\t\treturn function update() {\r\n\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tvar boneInverses = this.boneInverses;\r\n\t\t\tvar boneMatrices = this.boneMatrices;\r\n\t\t\tvar boneTexture = this.boneTexture;\r\n\r\n\t\t\t// flatten bone matrices to array\r\n\r\n\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t// compute the offset between the current and the original transform\r\n\r\n\t\t\t\tvar matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;\r\n\r\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\r\n\t\t\t\toffsetMatrix.toArray( boneMatrices, i * 16 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( boneTexture !== undefined ) {\r\n\r\n\t\t\t\tboneTexture.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new Skeleton( this.bones, this.boneInverses );\r\n\r\n\t},\r\n\r\n\tgetBoneByName: function ( name ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar bone = this$1.bones[ i ];\r\n\r\n\t\t\tif ( bone.name === name ) {\r\n\r\n\t\t\t\treturn bone;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction SkinnedMesh( geometry, material ) {\r\n\r\n\tMesh.call( this, geometry, material );\r\n\r\n\tthis.type = 'SkinnedMesh';\r\n\r\n\tthis.bindMode = 'attached';\r\n\tthis.bindMatrix = new Matrix4();\r\n\tthis.bindMatrixInverse = new Matrix4();\r\n\r\n\tvar bones = this.initBones();\r\n\tvar skeleton = new Skeleton( bones );\r\n\r\n\tthis.bind( skeleton, this.matrixWorld );\r\n\r\n\tthis.normalizeSkinWeights();\r\n\r\n}\r\n\r\nSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\r\n\r\n\tconstructor: SkinnedMesh,\r\n\r\n\tisSkinnedMesh: true,\r\n\r\n\tinitBones: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar bones = [], bone, gbone;\r\n\t\tvar i, il;\r\n\r\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n\t\t\t// first, create array of 'Bone' objects from geometry data\r\n\r\n\t\t\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgbone = this$1.geometry.bones[ i ];\r\n\r\n\t\t\t\t// create new 'Bone' object\r\n\r\n\t\t\t\tbone = new Bone();\r\n\t\t\t\tbones.push( bone );\r\n\r\n\t\t\t\t// apply values\r\n\r\n\t\t\t\tbone.name = gbone.name;\r\n\t\t\t\tbone.position.fromArray( gbone.pos );\r\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\r\n\t\t\t\tif ( gbone.scl !== undefined ) { bone.scale.fromArray( gbone.scl ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// second, create bone hierarchy\r\n\r\n\t\t\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgbone = this$1.geometry.bones[ i ];\r\n\r\n\t\t\t\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\r\n\r\n\t\t\t\t\t// subsequent bones in the hierarchy\r\n\r\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ i ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// topmost bone, immediate child of the skinned mesh\r\n\r\n\t\t\t\t\tthis$1.add( bones[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// now the bones are part of the scene graph and children of the skinned mesh.\r\n\t\t// let's update the corresponding matrices\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\treturn bones;\r\n\r\n\t},\r\n\r\n\tbind: function ( skeleton, bindMatrix ) {\r\n\r\n\t\tthis.skeleton = skeleton;\r\n\r\n\t\tif ( bindMatrix === undefined ) {\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.skeleton.calculateInverses();\r\n\r\n\t\t\tbindMatrix = this.matrixWorld;\r\n\r\n\t\t}\r\n\r\n\t\tthis.bindMatrix.copy( bindMatrix );\r\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\r\n\t},\r\n\r\n\tpose: function () {\r\n\r\n\t\tthis.skeleton.pose();\r\n\r\n\t},\r\n\r\n\tnormalizeSkinWeights: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar scale, i;\r\n\r\n\t\tif ( this.geometry && this.geometry.isGeometry ) {\r\n\r\n\t\t\tfor ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {\r\n\r\n\t\t\t\tvar sw = this$1.geometry.skinWeights[ i ];\r\n\r\n\t\t\t\tscale = 1.0 / sw.manhattanLength();\r\n\r\n\t\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\t\tsw.multiplyScalar( scale );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( this.geometry && this.geometry.isBufferGeometry ) {\r\n\r\n\t\t\tvar vec = new Vector4();\r\n\r\n\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\r\n\r\n\t\t\tfor ( i = 0; i < skinWeight.count; i ++ ) {\r\n\r\n\t\t\t\tvec.x = skinWeight.getX( i );\r\n\t\t\t\tvec.y = skinWeight.getY( i );\r\n\t\t\t\tvec.z = skinWeight.getZ( i );\r\n\t\t\t\tvec.w = skinWeight.getW( i );\r\n\r\n\t\t\t\tscale = 1.0 / vec.manhattanLength();\r\n\r\n\t\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\t\tvec.multiplyScalar( scale );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tMesh.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\tif ( this.bindMode === 'attached' ) {\r\n\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\r\n\t\t} else if ( this.bindMode === 'detached' ) {\r\n\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar AssimpLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nAssimpLoader.prototype = {\r\n\r\n\tconstructor: AssimpLoader,\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar path = LoaderUtils.extractUrlBase( url );\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tonLoad( scope.parse( buffer, path ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tparse: function ( buffer, path ) {\r\n\r\n\t\tvar textureLoader = new TextureLoader( this.manager );\r\n\t\ttextureLoader.setPath( path ).setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tvar Virtulous = {};\r\n\r\n\t\tVirtulous.KeyFrame = function ( time, matrix ) {\r\n\r\n\t\t\tthis.time = time;\r\n\t\t\tthis.matrix = matrix.clone();\r\n\t\t\tthis.position = new Vector3();\r\n\t\t\tthis.quaternion = new Quaternion();\r\n\t\t\tthis.scale = new Vector3( 1, 1, 1 );\r\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\t\t\tthis.clone = function () {\r\n\r\n\t\t\t\tvar n = new Virtulous.KeyFrame( this.time, this.matrix );\r\n\t\t\t\treturn n;\r\n\r\n\t\t\t};\r\n\t\t\tthis.lerp = function ( nextKey, time ) {\r\n\r\n\t\t\t\ttime -= this.time;\r\n\t\t\t\tvar dist = ( nextKey.time - this.time );\r\n\t\t\t\tvar l = time / dist;\r\n\t\t\t\tvar l2 = 1 - l;\r\n\t\t\t\tvar keypos = this.position;\r\n\t\t\t\tvar keyrot = this.quaternion;\r\n\t\t\t\t//      var keyscl =  key.parentspaceScl || key.scl;\r\n\t\t\t\tvar key2pos = nextKey.position;\r\n\t\t\t\tvar key2rot = nextKey.quaternion;\r\n\t\t\t\t//  var key2scl =  key2.parentspaceScl || key2.scl;\r\n\t\t\t\tVirtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\r\n\t\t\t\tVirtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\r\n\t\t\t\tVirtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;\r\n\t\t\t\t//     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\r\n\t\t\t\t//     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\r\n\t\t\t\t//     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\r\n\t\t\t\tVirtulous.KeyFrame.tempAniQuat.set( keyrot.x, keyrot.y, keyrot.z, keyrot.w );\r\n\t\t\t\tVirtulous.KeyFrame.tempAniQuat.slerp( key2rot, l );\r\n\t\t\t\treturn Virtulous.KeyFrame.tempAniMatrix.compose( Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale );\r\n\r\n\t\t\t};\r\n\r\n\t\t};\r\n\r\n\t\tVirtulous.KeyFrame.tempAniPos = new Vector3();\r\n\t\tVirtulous.KeyFrame.tempAniQuat = new Quaternion();\r\n\t\tVirtulous.KeyFrame.tempAniScale = new Vector3( 1, 1, 1 );\r\n\t\tVirtulous.KeyFrame.tempAniMatrix = new Matrix4();\r\n\t\tVirtulous.KeyFrameTrack = function () {\r\n\r\n\t\t\tthis.keys = [];\r\n\t\t\tthis.target = null;\r\n\t\t\tthis.time = 0;\r\n\t\t\tthis.length = 0;\r\n\t\t\tthis._accelTable = {};\r\n\t\t\tthis.fps = 20;\r\n\t\t\tthis.addKey = function ( key ) {\r\n\r\n\t\t\t\tthis.keys.push( key );\r\n\r\n\t\t\t};\r\n\t\t\tthis.init = function () {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tthis.sortKeys();\r\n\r\n\t\t\t\tif ( this.keys.length > 0 )\r\n\t\t\t\t\t{ this.length = this.keys[ this.keys.length - 1 ].time; }\r\n\t\t\t\telse\r\n\t\t\t\t\t{ this.length = 0; }\r\n\r\n\t\t\t\tif ( ! this.fps ) { return; }\r\n\r\n\t\t\t\tfor ( var j = 0; j < this.length * this.fps; j ++ ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < this.keys.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( this$1.keys[ i ].time == j ) {\r\n\r\n\t\t\t\t\t\t\tthis$1._accelTable[ j ] = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t} else if ( this$1.keys[ i ].time < j / this$1.fps && this$1.keys[ i + 1 ] && this$1.keys[ i + 1 ].time >= j / this$1.fps ) {\r\n\r\n\t\t\t\t\t\t\tthis$1._accelTable[ j ] = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.parseFromThree = function ( data ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tvar fps = data.fps;\r\n\t\t\t\tthis.target = data.node;\r\n\t\t\t\tvar track = data.hierarchy[ 0 ].keys;\r\n\t\t\t\tfor ( var i = 0; i < track.length; i ++ ) {\r\n\r\n\t\t\t\t\tthis$1.addKey( new Virtulous.KeyFrame( i / fps || track[ i ].time, track[ i ].targets[ 0 ].data ) );\r\n\r\n\t\t\t\t}\r\n\t\t\t\tthis.init();\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.parseFromCollada = function ( data ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tvar track = data.keys;\r\n\t\t\t\tvar fps = this.fps;\r\n\r\n\t\t\t\tfor ( var i = 0; i < track.length; i ++ ) {\r\n\r\n\t\t\t\t\tthis$1.addKey( new Virtulous.KeyFrame( i / fps || track[ i ].time, track[ i ].matrix ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.init();\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.sortKeys = function () {\r\n\r\n\t\t\t\tthis.keys.sort( this.keySortFunc );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.keySortFunc = function ( a, b ) {\r\n\r\n\t\t\t\treturn a.time - b.time;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.clone = function () {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tvar t = new Virtulous.KeyFrameTrack();\r\n\t\t\t\tt.target = this.target;\r\n\t\t\t\tt.time = this.time;\r\n\t\t\t\tt.length = this.length;\r\n\r\n\t\t\t\tfor ( var i = 0; i < this.keys.length; i ++ ) {\r\n\r\n\t\t\t\t\tt.addKey( this$1.keys[ i ].clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt.init();\r\n\t\t\t\treturn t;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.reTarget = function ( root, compareitor ) {\r\n\r\n\t\t\t\tif ( ! compareitor ) { compareitor = Virtulous.TrackTargetNodeNameCompare; }\r\n\t\t\t\tthis.target = compareitor( root, this.target );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.keySearchAccel = function ( time ) {\r\n\r\n\t\t\t\ttime *= this.fps;\r\n\t\t\t\ttime = Math.floor( time );\r\n\t\t\t\treturn this._accelTable[ time ] || 0;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.setTime = function ( time ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\ttime = Math.abs( time );\r\n\t\t\t\tif ( this.length )\r\n\t\t\t\t\t{ time = time % this.length + .05; }\r\n\t\t\t\tvar key0 = null;\r\n\t\t\t\tvar key1 = null;\r\n\r\n\t\t\t\tfor ( var i = this.keySearchAccel( time ); i < this.keys.length; i ++ ) {\r\n\r\n\t\t\t\t\tif ( this$1.keys[ i ].time == time ) {\r\n\r\n\t\t\t\t\t\tkey0 = this$1.keys[ i ];\r\n\t\t\t\t\t\tkey1 = this$1.keys[ i ];\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t} else if ( this$1.keys[ i ].time < time && this$1.keys[ i + 1 ] && this$1.keys[ i + 1 ].time > time ) {\r\n\r\n\t\t\t\t\t\tkey0 = this$1.keys[ i ];\r\n\t\t\t\t\t\tkey1 = this$1.keys[ i + 1 ];\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t} else if ( this$1.keys[ i ].time < time && i == this$1.keys.length - 1 ) {\r\n\r\n\t\t\t\t\t\tkey0 = this$1.keys[ i ];\r\n\t\t\t\t\t\tkey1 = this$1.keys[ 0 ].clone();\r\n\t\t\t\t\t\tkey1.time += this$1.length + .05;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( key0 && key1 && key0 !== key1 ) {\r\n\r\n\t\t\t\t\tthis.target.matrixAutoUpdate = false;\r\n\t\t\t\t\tthis.target.matrix.copy( key0.lerp( key1, time ) );\r\n\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( key0 && key1 && key0 == key1 ) {\r\n\r\n\t\t\t\t\tthis.target.matrixAutoUpdate = false;\r\n\t\t\t\t\tthis.target.matrix.copy( key0.matrix );\r\n\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t};\r\n\r\n\t\tVirtulous.TrackTargetNodeNameCompare = function ( root, target ) {\r\n\r\n\t\t\tfunction find( node, name ) {\r\n\r\n\t\t\t\tif ( node.name == name )\r\n\t\t\t\t\t{ return node; }\r\n\r\n\t\t\t\tfor ( var i = 0; i < node.children.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar r = find( node.children[ i ], name );\r\n\t\t\t\t\tif ( r ) { return r; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn find( root, target.name );\r\n\r\n\t\t};\r\n\r\n\t\tVirtulous.Animation = function () {\r\n\r\n\t\t\tthis.tracks = [];\r\n\t\t\tthis.length = 0;\r\n\r\n\t\t\tthis.addTrack = function ( track ) {\r\n\r\n\t\t\t\tthis.tracks.push( track );\r\n\t\t\t\tthis.length = Math.max( track.length, this.length );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.setTime = function ( time ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tthis.time = time;\r\n\r\n\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ )\r\n\t\t\t\t\t{ this$1.tracks[ i ].setTime( time ); }\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.clone = function ( target, compareitor ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tif ( ! compareitor ) { compareitor = Virtulous.TrackTargetNodeNameCompare; }\r\n\t\t\t\tvar n = new Virtulous.Animation();\r\n\t\t\t\tn.target = target;\r\n\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar track = this$1.tracks[ i ].clone();\r\n\t\t\t\t\ttrack.reTarget( target, compareitor );\r\n\t\t\t\t\tn.addTrack( track );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn n;\r\n\r\n\t\t\t};\r\n\r\n\t\t};\r\n\r\n\t\tvar ASSBIN_CHUNK_AICAMERA = 0x1234;\r\n\t\tvar ASSBIN_CHUNK_AILIGHT = 0x1235;\r\n\t\tvar ASSBIN_CHUNK_AITEXTURE = 0x1236;\r\n\t\tvar ASSBIN_CHUNK_AIMESH = 0x1237;\r\n\t\tvar ASSBIN_CHUNK_AINODEANIM = 0x1238;\r\n\t\tvar ASSBIN_CHUNK_AISCENE = 0x1239;\r\n\t\tvar ASSBIN_CHUNK_AIBONE = 0x123a;\r\n\t\tvar ASSBIN_CHUNK_AIANIMATION = 0x123b;\r\n\t\tvar ASSBIN_CHUNK_AINODE = 0x123c;\r\n\t\tvar ASSBIN_CHUNK_AIMATERIAL = 0x123d;\r\n\t\tvar ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\r\n\t\tvar ASSBIN_MESH_HAS_POSITIONS = 0x1;\r\n\t\tvar ASSBIN_MESH_HAS_NORMALS = 0x2;\r\n\t\tvar ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\r\n\t\tvar ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\r\n\t\tvar ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\r\n\t\tvar AI_MAX_NUMBER_OF_COLOR_SETS = 1;\r\n\t\tvar AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;\r\n\t\t//! A directional light source has a well-defined direction\r\n\t\t//! but is infinitely far away. That's quite a good\r\n\t\t//! approximation for sun light.\r\n\t\tvar aiLightSource_DIRECTIONAL = 0x1;\r\n\t\t//! A spot light source emits light in a specific\r\n\t\t//! angle. It has a position and a direction it is pointing to.\r\n\t\t//! A good example for a spot light is a light spot in\r\n\t\t//! sport arenas.\r\n\t\tvar aiLightSource_SPOT = 0x3;\r\n\t\t\r\n\t\tvar aiTextureType_DIFFUSE = 0x1;\r\n\t\t\r\n\t\tvar aiTextureType_NORMALS = 0x6;\r\n\t\t\r\n\t\tvar aiTextureType_OPACITY = 0x8;\r\n\t\t\r\n\t\tvar aiTextureType_LIGHTMAP = 0xA;\r\n\t\tvar BONESPERVERT = 4;\r\n\r\n\t\tfunction ASSBIN_MESH_HAS_TEXCOORD( n ) {\r\n\r\n\t\t\treturn ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\r\n\r\n\t\t}\r\n\r\n\t\tfunction ASSBIN_MESH_HAS_COLOR( n ) {\r\n\r\n\t\t\treturn ASSBIN_MESH_HAS_COLOR_BASE << n;\r\n\r\n\t\t}\r\n\r\n\t\tfunction markBones( scene ) {\r\n\r\n\t\t\tfor ( var i in scene.mMeshes ) {\r\n\r\n\t\t\t\tvar mesh = scene.mMeshes[ i ];\r\n\t\t\t\tfor ( var k in mesh.mBones ) {\r\n\r\n\t\t\t\t\tvar boneNode = scene.findNode( mesh.mBones[ k ].mName );\r\n\t\t\t\t\tif ( boneNode )\r\n\t\t\t\t\t\t{ boneNode.isBone = true; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tfunction cloneTreeToBones( root, scene ) {\r\n\r\n\t\t\tvar rootBone = new Bone();\r\n\t\t\trootBone.matrix.copy( root.matrix );\r\n\t\t\trootBone.matrixWorld.copy( root.matrixWorld );\r\n\t\t\trootBone.position.copy( root.position );\r\n\t\t\trootBone.quaternion.copy( root.quaternion );\r\n\t\t\trootBone.scale.copy( root.scale );\r\n\t\t\tscene.nodeCount ++;\r\n\t\t\trootBone.name = \"bone_\" + root.name + scene.nodeCount.toString();\r\n\r\n\t\t\tif ( ! scene.nodeToBoneMap[ root.name ] )\r\n\t\t\t\t{ scene.nodeToBoneMap[ root.name ] = []; }\r\n\t\t\tscene.nodeToBoneMap[ root.name ].push( rootBone );\r\n\t\t\tfor ( var i in root.children ) {\r\n\r\n\t\t\t\tvar child = cloneTreeToBones( root.children[ i ], scene );\r\n\t\t\t\tif ( child )\r\n\t\t\t\t\t{ rootBone.add( child ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn rootBone;\r\n\r\n\t\t}\r\n\r\n\t\tfunction sortWeights( indexes, weights ) {\r\n\r\n\t\t\tvar pairs = [];\r\n\r\n\t\t\tfor ( var i = 0; i < indexes.length; i ++ ) {\r\n\r\n\t\t\t\tpairs.push( {\r\n\t\t\t\t\ti: indexes[ i ],\r\n\t\t\t\t\tw: weights[ i ]\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tpairs.sort( function ( a, b ) {\r\n\r\n\t\t\t\treturn b.w - a.w;\r\n\r\n\t\t\t } );\r\n\r\n\t\t\twhile ( pairs.length < 4 ) {\r\n\r\n\t\t\t\tpairs.push( {\r\n\t\t\t\t\ti: 0,\r\n\t\t\t\t\tw: 0\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( pairs.length > 4 )\r\n\t\t\t\t{ pairs.length = 4; }\r\n\t\t\tvar sum = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tsum += pairs[ i ].w * pairs[ i ].w;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsum = Math.sqrt( sum );\r\n\r\n\t\t\tfor ( var i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tpairs[ i ].w = pairs[ i ].w / sum;\r\n\t\t\t\tindexes[ i ] = pairs[ i ].i;\r\n\t\t\t\tweights[ i ] = pairs[ i ].w;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction findMatchingBone( root, name ) {\r\n\r\n\t\t\tif ( root.name.indexOf( \"bone_\" + name ) == 0 )\r\n\t\t\t\t{ return root; }\r\n\r\n\t\t\tfor ( var i in root.children ) {\r\n\r\n\t\t\t\tvar ret = findMatchingBone( root.children[ i ], name );\r\n\r\n\t\t\t\tif ( ret )\r\n\t\t\t\t\t{ return ret; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn undefined;\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiMesh() {\r\n\r\n\t\t\tthis.mPrimitiveTypes = 0;\r\n\t\t\tthis.mNumVertices = 0;\r\n\t\t\tthis.mNumFaces = 0;\r\n\t\t\tthis.mNumBones = 0;\r\n\t\t\tthis.mMaterialIndex = 0;\r\n\t\t\tthis.mVertices = [];\r\n\t\t\tthis.mNormals = [];\r\n\t\t\tthis.mTangents = [];\r\n\t\t\tthis.mBitangents = [];\r\n\t\t\tthis.mColors = [\r\n\t\t\t\t[]\r\n\t\t\t];\r\n\t\t\tthis.mTextureCoords = [\r\n\t\t\t\t[]\r\n\t\t\t];\r\n\t\t\tthis.mFaces = [];\r\n\t\t\tthis.mBones = [];\r\n\t\t\tthis.hookupSkeletons = function ( scene, threeScene ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tif ( this.mBones.length == 0 ) { return; }\r\n\r\n\t\t\t\tvar allBones = [];\r\n\t\t\t\tvar offsetMatrix = [];\r\n\t\t\t\tvar skeletonRoot = scene.findNode( this.mBones[ 0 ].mName );\r\n\r\n\t\t\t\twhile ( skeletonRoot.mParent && skeletonRoot.mParent.isBone ) {\r\n\r\n\t\t\t\t\tskeletonRoot = skeletonRoot.mParent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE( scene );\r\n\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones( threeSkeletonRoot, scene );\r\n\t\t\t\tthis.threeNode.add( threeSkeletonRootBone );\r\n\r\n\t\t\t\tfor ( var i = 0; i < this.mBones.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar bone = findMatchingBone( threeSkeletonRootBone, this$1.mBones[ i ].mName );\r\n\r\n\t\t\t\t\tif ( bone ) {\r\n\r\n\t\t\t\t\t\tvar tbone = bone;\r\n\t\t\t\t\t\tallBones.push( tbone );\r\n\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\r\n\t\t\t\t\t\toffsetMatrix.push( this$1.mBones[ i ].mOffsetMatrix.toTHREE() );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar skeletonRoot = scene.findNode( this$1.mBones[ i ].mName );\r\n\t\t\t\t\t\tif ( ! skeletonRoot ) { return; }\r\n\t\t\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE( scene );\r\n\t\t\t\t\t\tvar threeSkeletonRootParent = threeSkeletonRoot.parent;\r\n\t\t\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones( threeSkeletonRoot, scene );\r\n\t\t\t\t\t\tthis$1.threeNode.add( threeSkeletonRootBone );\r\n\t\t\t\t\t\tvar bone = findMatchingBone( threeSkeletonRootBone, this$1.mBones[ i ].mName );\r\n\t\t\t\t\t\tvar tbone = bone;\r\n\t\t\t\t\t\tallBones.push( tbone );\r\n\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\r\n\t\t\t\t\t\toffsetMatrix.push( this$1.mBones[ i ].mOffsetMatrix.toTHREE() );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tvar skeleton = new Skeleton( allBones, offsetMatrix );\r\n\r\n\t\t\t\tthis.threeNode.bind( skeleton, new Matrix4() );\r\n\t\t\t\tthis.threeNode.material.skinning = true;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.toTHREE = function ( scene ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tif ( this.threeNode ) { return this.threeNode; }\r\n\t\t\t\tvar geometry = new BufferGeometry();\r\n\t\t\t\tvar mat;\r\n\t\t\t\tif ( scene.mMaterials[ this.mMaterialIndex ] )\r\n\t\t\t\t\t{ mat = scene.mMaterials[ this.mMaterialIndex ].toTHREE( scene ); }\r\n\t\t\t\telse\r\n\t\t\t\t\t{ mat = new MeshLambertMaterial(); }\r\n\t\t\t\tgeometry.setIndex( new BufferAttribute( new Uint32Array( this.mIndexArray ), 1 ) );\r\n\t\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( this.mVertexBuffer, 3 ) );\r\n\t\t\t\tif ( this.mNormalBuffer && this.mNormalBuffer.length > 0 )\r\n\t\t\t\t\t{ geometry.addAttribute( 'normal', new BufferAttribute( this.mNormalBuffer, 3 ) ); }\r\n\t\t\t\tif ( this.mColorBuffer && this.mColorBuffer.length > 0 )\r\n\t\t\t\t\t{ geometry.addAttribute( 'color', new BufferAttribute( this.mColorBuffer, 4 ) ); }\r\n\t\t\t\tif ( this.mTexCoordsBuffers[ 0 ] && this.mTexCoordsBuffers[ 0 ].length > 0 )\r\n\t\t\t\t\t{ geometry.addAttribute( 'uv', new BufferAttribute( new Float32Array( this.mTexCoordsBuffers[ 0 ] ), 2 ) ); }\r\n\t\t\t\tif ( this.mTexCoordsBuffers[ 1 ] && this.mTexCoordsBuffers[ 1 ].length > 0 )\r\n\t\t\t\t\t{ geometry.addAttribute( 'uv1', new BufferAttribute( new Float32Array( this.mTexCoordsBuffers[ 1 ] ), 2 ) ); }\r\n\t\t\t\tif ( this.mTangentBuffer && this.mTangentBuffer.length > 0 )\r\n\t\t\t\t\t{ geometry.addAttribute( 'tangents', new BufferAttribute( this.mTangentBuffer, 3 ) ); }\r\n\t\t\t\tif ( this.mBitangentBuffer && this.mBitangentBuffer.length > 0 )\r\n\t\t\t\t\t{ geometry.addAttribute( 'bitangents', new BufferAttribute( this.mBitangentBuffer, 3 ) ); }\r\n\t\t\t\tif ( this.mBones.length > 0 ) {\r\n\r\n\t\t\t\t\tvar weights = [];\r\n\t\t\t\t\tvar bones = [];\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < this.mBones.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tfor ( var j = 0; j < this.mBones[ i ].mWeights.length; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar weight = this$1.mBones[ i ].mWeights[ j ];\r\n\t\t\t\t\t\t\tif ( weight ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( ! weights[ weight.mVertexId ] ) { weights[ weight.mVertexId ] = []; }\r\n\t\t\t\t\t\t\t\tif ( ! bones[ weight.mVertexId ] ) { bones[ weight.mVertexId ] = []; }\r\n\t\t\t\t\t\t\t\tweights[ weight.mVertexId ].push( weight.mWeight );\r\n\t\t\t\t\t\t\t\tbones[ weight.mVertexId ].push( parseInt( i ) );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i in bones ) {\r\n\r\n\t\t\t\t\t\tsortWeights( bones[ i ], weights[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar _weights = [];\r\n\t\t\t\t\tvar _bones = [];\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < weights.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tfor ( var j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( weights[ i ] && bones[ i ] ) {\r\n\r\n\t\t\t\t\t\t\t\t_weights.push( weights[ i ][ j ] );\r\n\t\t\t\t\t\t\t\t_bones.push( bones[ i ][ j ] );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t_weights.push( 0 );\r\n\t\t\t\t\t\t\t\t_bones.push( 0 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.addAttribute( 'skinWeight', new BufferAttribute( new Float32Array( _weights ), BONESPERVERT ) );\r\n\t\t\t\t\tgeometry.addAttribute( 'skinIndex', new BufferAttribute( new Float32Array( _bones ), BONESPERVERT ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar mesh;\r\n\r\n\t\t\t\tif ( this.mBones.length == 0 )\r\n\t\t\t\t\t{ mesh = new Mesh( geometry, mat ); }\r\n\r\n\t\t\t\tif ( this.mBones.length > 0 )\r\n\t\t\t\t\t{ mesh = new SkinnedMesh( geometry, mat ); }\r\n\r\n\t\t\t\tthis.threeNode = mesh;\r\n\t\t\t\t//mesh.matrixAutoUpdate = false;\r\n\t\t\t\treturn mesh;\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiFace() {\r\n\r\n\t\t\tthis.mNumIndices = 0;\r\n\t\t\tthis.mIndices = [];\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiVector3D() {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t\tthis.toTHREE = function () {\r\n\r\n\t\t\t\treturn new Vector3( this.x, this.y, this.z );\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiColor3D() {\r\n\r\n\t\t\tthis.r = 0;\r\n\t\t\tthis.g = 0;\r\n\t\t\tthis.b = 0;\r\n\t\t\tthis.a = 0;\r\n\t\t\tthis.toTHREE = function () {\r\n\r\n\t\t\t\treturn new Color( this.r, this.g, this.b, 1 );\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiQuaternion() {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 0;\r\n\t\t\tthis.toTHREE = function () {\r\n\r\n\t\t\t\treturn new Quaternion( this.x, this.y, this.z, this.w );\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiVertexWeight() {\r\n\r\n\t\t\tthis.mVertexId = 0;\r\n\t\t\tthis.mWeight = 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiString() {\r\n\r\n\t\t\tthis.data = [];\r\n\t\t\tthis.toString = function () {\r\n\r\n\t\t\t\tvar str = '';\r\n\t\t\t\tthis.data.forEach( function ( i ) {\r\n\r\n\t\t\t\t\tstr += ( String.fromCharCode( i ) );\r\n\r\n\t\t\t\t} );\r\n\t\t\t\treturn str.replace( /[^\\x20-\\x7E]+/g, '' );\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiVectorKey() {\r\n\r\n\t\t\tthis.mTime = 0;\r\n\t\t\tthis.mValue = null;\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiQuatKey() {\r\n\r\n\t\t\tthis.mTime = 0;\r\n\t\t\tthis.mValue = null;\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiNode() {\r\n\r\n\t\t\tthis.mName = '';\r\n\t\t\tthis.mTransformation = [];\r\n\t\t\tthis.mNumChildren = 0;\r\n\t\t\tthis.mNumMeshes = 0;\r\n\t\t\tthis.mMeshes = [];\r\n\t\t\tthis.mChildren = [];\r\n\t\t\tthis.toTHREE = function ( scene ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tif ( this.threeNode ) { return this.threeNode; }\r\n\t\t\t\tvar o = new Object3D();\r\n\t\t\t\to.name = this.mName;\r\n\t\t\t\to.matrix = this.mTransformation.toTHREE();\r\n\r\n\t\t\t\tfor ( var i = 0; i < this.mChildren.length; i ++ ) {\r\n\r\n\t\t\t\t\to.add( this$1.mChildren[ i ].toTHREE( scene ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0; i < this.mMeshes.length; i ++ ) {\r\n\r\n\t\t\t\t\to.add( scene.mMeshes[ this$1.mMeshes[ i ] ].toTHREE( scene ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.threeNode = o;\r\n\t\t\t\t//o.matrixAutoUpdate = false;\r\n\t\t\t\to.matrix.decompose( o.position, o.quaternion, o.scale );\r\n\t\t\t\treturn o;\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiBone() {\r\n\r\n\t\t\tthis.mName = '';\r\n\t\t\tthis.mNumWeights = 0;\r\n\t\t\tthis.mOffsetMatrix = 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiMaterialProperty() {\r\n\r\n\t\t\tthis.mKey = \"\";\r\n\t\t\tthis.mSemantic = 0;\r\n\t\t\tthis.mIndex = 0;\r\n\t\t\tthis.mData = [];\r\n\t\t\tthis.mDataLength = 0;\r\n\t\t\tthis.mType = 0;\r\n\t\t\tthis.dataAsColor = function () {\r\n\r\n\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\r\n\t\t\t\tvar reader = new DataView( array );\r\n\t\t\t\tvar r = reader.getFloat32( 0, true );\r\n\t\t\t\tvar g = reader.getFloat32( 4, true );\r\n\t\t\t\tvar b = reader.getFloat32( 8, true );\r\n\t\t\t\t//var a = reader.getFloat32(12, true);\r\n\t\t\t\treturn new Color( r, g, b );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.dataAsFloat = function () {\r\n\r\n\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\r\n\t\t\t\tvar reader = new DataView( array );\r\n\t\t\t\tvar r = reader.getFloat32( 0, true );\r\n\t\t\t\treturn r;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.dataAsBool = function () {\r\n\r\n\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\r\n\t\t\t\tvar reader = new DataView( array );\r\n\t\t\t\tvar r = reader.getFloat32( 0, true );\r\n\t\t\t\treturn !! r;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.dataAsString = function () {\r\n\r\n\t\t\t\tvar s = new aiString();\r\n\t\t\t\ts.data = this.mData;\r\n\t\t\t\treturn s.toString();\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.dataAsMap = function () {\r\n\r\n\t\t\t\tvar s = new aiString();\r\n\t\t\t\ts.data = this.mData;\r\n\t\t\t\tvar path = s.toString();\r\n\t\t\t\tpath = path.replace( /\\\\/g, '/' );\r\n\r\n\t\t\t\tif ( path.indexOf( '/' ) != - 1 ) {\r\n\r\n\t\t\t\t\tpath = path.substr( path.lastIndexOf( '/' ) + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn textureLoader.load( path );\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\t\tvar namePropMapping = {\r\n\r\n\t\t\t\"?mat.name\": \"name\",\r\n\t\t\t\"$mat.shadingm\": \"shading\",\r\n\t\t\t\"$mat.twosided\": \"twoSided\",\r\n\t\t\t\"$mat.wireframe\": \"wireframe\",\r\n\t\t\t\"$clr.ambient\": \"ambient\",\r\n\t\t\t\"$clr.diffuse\": \"color\",\r\n\t\t\t\"$clr.specular\": \"specular\",\r\n\t\t\t\"$clr.emissive\": \"emissive\",\r\n\t\t\t\"$clr.transparent\": \"transparent\",\r\n\t\t\t\"$clr.reflective\": \"reflect\",\r\n\t\t\t\"$mat.shininess\": \"shininess\",\r\n\t\t\t\"$mat.reflectivity\": \"reflectivity\",\r\n\t\t\t\"$mat.refracti\": \"refraction\",\r\n\t\t\t\"$tex.file\": \"map\"\r\n\r\n\t\t};\r\n\r\n\t\tvar nameTypeMapping = {\r\n\r\n\t\t\t\"?mat.name\": \"string\",\r\n\t\t\t\"$mat.shadingm\": \"bool\",\r\n\t\t\t\"$mat.twosided\": \"bool\",\r\n\t\t\t\"$mat.wireframe\": \"bool\",\r\n\t\t\t\"$clr.ambient\": \"color\",\r\n\t\t\t\"$clr.diffuse\": \"color\",\r\n\t\t\t\"$clr.specular\": \"color\",\r\n\t\t\t\"$clr.emissive\": \"color\",\r\n\t\t\t\"$clr.transparent\": \"color\",\r\n\t\t\t\"$clr.reflective\": \"color\",\r\n\t\t\t\"$mat.shininess\": \"float\",\r\n\t\t\t\"$mat.reflectivity\": \"float\",\r\n\t\t\t\"$mat.refracti\": \"float\",\r\n\t\t\t\"$tex.file\": \"map\"\r\n\r\n\t\t};\r\n\r\n\t\tfunction aiMaterial() {\r\n\r\n\t\t\tthis.mNumAllocated = 0;\r\n\t\t\tthis.mNumProperties = 0;\r\n\t\t\tthis.mProperties = [];\r\n\t\t\tthis.toTHREE = function ( scene ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tvar name = this.mProperties[ 0 ].dataAsString();\r\n\t\t\t\tvar mat = new MeshPhongMaterial();\r\n\r\n\t\t\t\tfor ( var i = 0; i < this.mProperties.length; i ++ ) {\r\n\r\n\t\t\t\t\tif ( nameTypeMapping[ this$1.mProperties[ i ].mKey ] == 'float' )\r\n\t\t\t\t\t\t{ mat[ namePropMapping[ this$1.mProperties[ i ].mKey ] ] = this$1.mProperties[ i ].dataAsFloat(); }\r\n\t\t\t\t\tif ( nameTypeMapping[ this$1.mProperties[ i ].mKey ] == 'color' )\r\n\t\t\t\t\t\t{ mat[ namePropMapping[ this$1.mProperties[ i ].mKey ] ] = this$1.mProperties[ i ].dataAsColor(); }\r\n\t\t\t\t\tif ( nameTypeMapping[ this$1.mProperties[ i ].mKey ] == 'bool' )\r\n\t\t\t\t\t\t{ mat[ namePropMapping[ this$1.mProperties[ i ].mKey ] ] = this$1.mProperties[ i ].dataAsBool(); }\r\n\t\t\t\t\tif ( nameTypeMapping[ this$1.mProperties[ i ].mKey ] == 'string' )\r\n\t\t\t\t\t\t{ mat[ namePropMapping[ this$1.mProperties[ i ].mKey ] ] = this$1.mProperties[ i ].dataAsString(); }\r\n\t\t\t\t\tif ( nameTypeMapping[ this$1.mProperties[ i ].mKey ] == 'map' ) {\r\n\r\n\t\t\t\t\t\tvar prop = this$1.mProperties[ i ];\r\n\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_DIFFUSE )\r\n\t\t\t\t\t\t\t{ mat.map = this$1.mProperties[ i ].dataAsMap(); }\r\n\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_NORMALS )\r\n\t\t\t\t\t\t\t{ mat.normalMap = this$1.mProperties[ i ].dataAsMap(); }\r\n\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_LIGHTMAP )\r\n\t\t\t\t\t\t\t{ mat.lightMap = this$1.mProperties[ i ].dataAsMap(); }\r\n\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_OPACITY )\r\n\t\t\t\t\t\t\t{ mat.alphaMap = this$1.mProperties[ i ].dataAsMap(); }\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmat.ambient.r = .53;\r\n\t\t\t\tmat.ambient.g = .53;\r\n\t\t\t\tmat.ambient.b = .53;\r\n\t\t\t\tmat.color.r = 1;\r\n\t\t\t\tmat.color.g = 1;\r\n\t\t\t\tmat.color.b = 1;\r\n\t\t\t\treturn mat;\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction veclerp( v1, v2, l ) {\r\n\r\n\t\t\tvar v = new Vector3();\r\n\t\t\tvar lm1 = 1 - l;\r\n\t\t\tv.x = v1.x * l + v2.x * lm1;\r\n\t\t\tv.y = v1.y * l + v2.y * lm1;\r\n\t\t\tv.z = v1.z * l + v2.z * lm1;\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t\tfunction quatlerp( q1, q2, l ) {\r\n\r\n\t\t\treturn q1.clone().slerp( q2, 1 - l );\r\n\r\n\t\t}\r\n\r\n\t\tfunction sampleTrack( keys, time, lne, lerp ) {\r\n\r\n\t\t\tif ( keys.length == 1 ) { return keys[ 0 ].mValue.toTHREE(); }\r\n\r\n\t\t\tvar dist = Infinity;\r\n\t\t\tvar key = null;\r\n\t\t\tvar nextKey = null;\r\n\r\n\t\t\tfor ( var i = 0; i < keys.length; i ++ ) {\r\n\r\n\t\t\t\tvar timeDist = Math.abs( keys[ i ].mTime - time );\r\n\r\n\t\t\t\tif ( timeDist < dist && keys[ i ].mTime <= time ) {\r\n\r\n\t\t\t\t\tdist = timeDist;\r\n\t\t\t\t\tkey = keys[ i ];\r\n\t\t\t\t\tnextKey = keys[ i + 1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! key ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} else if ( nextKey ) {\r\n\r\n\t\t\t\tvar dT = nextKey.mTime - key.mTime;\r\n\t\t\t\tvar T = key.mTime - time;\r\n\t\t\t\tvar l = T / dT;\r\n\r\n\t\t\t\treturn lerp( key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnextKey = keys[ 0 ].clone();\r\n\t\t\t\tnextKey.mTime += lne;\r\n\r\n\t\t\t\tvar dT = nextKey.mTime - key.mTime;\r\n\t\t\t\tvar T = key.mTime - time;\r\n\t\t\t\tvar l = T / dT;\r\n\r\n\t\t\t\treturn lerp( key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiNodeAnim() {\r\n\r\n\t\t\tthis.mNodeName = \"\";\r\n\t\t\tthis.mNumPositionKeys = 0;\r\n\t\t\tthis.mNumRotationKeys = 0;\r\n\t\t\tthis.mNumScalingKeys = 0;\r\n\t\t\tthis.mPositionKeys = [];\r\n\t\t\tthis.mRotationKeys = [];\r\n\t\t\tthis.mScalingKeys = [];\r\n\t\t\tthis.mPreState = \"\";\r\n\t\t\tthis.mPostState = \"\";\r\n\t\t\tthis.init = function ( tps ) {\r\n\r\n\t\t\t\tif ( ! tps ) { tps = 1; }\r\n\r\n\t\t\t\tfunction t( t ) {\r\n\r\n\t\t\t\t\tt.mTime /= tps;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.mPositionKeys.forEach( t );\r\n\t\t\t\tthis.mRotationKeys.forEach( t );\r\n\t\t\t\tthis.mScalingKeys.forEach( t );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.sortKeys = function () {\r\n\r\n\t\t\t\tfunction comp( a, b ) {\r\n\r\n\t\t\t\t\treturn a.mTime - b.mTime;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.mPositionKeys.sort( comp );\r\n\t\t\t\tthis.mRotationKeys.sort( comp );\r\n\t\t\t\tthis.mScalingKeys.sort( comp );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.getLength = function () {\r\n\r\n\t\t\t\treturn Math.max(\r\n\t\t\t\t\tMath.max.apply( null, this.mPositionKeys.map( function ( a ) {\r\n\r\n\t\t\t\t\t\treturn a.mTime;\r\n\r\n\t\t\t\t\t} ) ),\r\n\t\t\t\t\tMath.max.apply( null, this.mRotationKeys.map( function ( a ) {\r\n\r\n\t\t\t\t\t\treturn a.mTime;\r\n\r\n\t\t\t\t\t} ) ),\r\n\t\t\t\t\tMath.max.apply( null, this.mScalingKeys.map( function ( a ) {\r\n\r\n\t\t\t\t\t\treturn a.mTime;\r\n\r\n\t\t\t\t } ) )\r\n\t\t\t\t);\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.toTHREE = function ( o, tps ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tthis.sortKeys();\r\n\t\t\t\tvar length = this.getLength();\r\n\t\t\t\tvar track = new Virtulous.KeyFrameTrack();\r\n\r\n\t\t\t\tfor ( var i = 0; i < length; i += .05 ) {\r\n\r\n\t\t\t\t\tvar matrix = new Matrix4();\r\n\t\t\t\t\tvar time = i;\r\n\t\t\t\t\tvar pos = sampleTrack( this$1.mPositionKeys, time, length, veclerp );\r\n\t\t\t\t\tvar scale = sampleTrack( this$1.mScalingKeys, time, length, veclerp );\r\n\t\t\t\t\tvar rotation = sampleTrack( this$1.mRotationKeys, time, length, quatlerp );\r\n\t\t\t\t\tmatrix.compose( pos, rotation, scale );\r\n\r\n\t\t\t\t\tvar key = new Virtulous.KeyFrame( time, matrix );\r\n\t\t\t\t\ttrack.addKey( key );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttrack.target = o.findNode( this.mNodeName ).toTHREE();\r\n\r\n\t\t\t\tvar tracks = [ track ];\r\n\r\n\t\t\t\tif ( o.nodeToBoneMap[ this.mNodeName ] ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < o.nodeToBoneMap[ this.mNodeName ].length; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar t2 = track.clone();\r\n\t\t\t\t\t\tt2.target = o.nodeToBoneMap[ this$1.mNodeName ][ i ];\r\n\t\t\t\t\t\ttracks.push( t2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn tracks;\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiAnimation() {\r\n\r\n\t\t\tthis.mName = \"\";\r\n\t\t\tthis.mDuration = 0;\r\n\t\t\tthis.mTicksPerSecond = 0;\r\n\t\t\tthis.mNumChannels = 0;\r\n\t\t\tthis.mChannels = [];\r\n\t\t\tthis.toTHREE = function ( root ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tvar animationHandle = new Virtulous.Animation();\r\n\r\n\t\t\t\tfor ( var i in this$1.mChannels ) {\r\n\r\n\t\t\t\t\tthis$1.mChannels[ i ].init( this$1.mTicksPerSecond );\r\n\r\n\t\t\t\t\tvar tracks = this$1.mChannels[ i ].toTHREE( root );\r\n\r\n\t\t\t\t\tfor ( var j in tracks ) {\r\n\r\n\t\t\t\t\t\ttracks[ j ].init();\r\n\t\t\t\t\t\tanimationHandle.addTrack( tracks[ j ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationHandle.length = Math.max.apply( null, animationHandle.tracks.map( function ( e ) {\r\n\r\n\t\t\t\t\treturn e.length;\r\n\r\n\t\t\t\t} ) );\r\n\t\t\t\treturn animationHandle;\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiTexture() {\r\n\r\n\t\t\tthis.mWidth = 0;\r\n\t\t\tthis.mHeight = 0;\r\n\t\t\tthis.texAchFormatHint = [];\r\n\t\t\tthis.pcData = [];\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiLight() {\r\n\r\n\t\t\tthis.mName = '';\r\n\t\t\tthis.mType = 0;\r\n\t\t\tthis.mAttenuationConstant = 0;\r\n\t\t\tthis.mAttenuationLinear = 0;\r\n\t\t\tthis.mAttenuationQuadratic = 0;\r\n\t\t\tthis.mAngleInnerCone = 0;\r\n\t\t\tthis.mAngleOuterCone = 0;\r\n\t\t\tthis.mColorDiffuse = null;\r\n\t\t\tthis.mColorSpecular = null;\r\n\t\t\tthis.mColorAmbient = null;\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiCamera() {\r\n\r\n\t\t\tthis.mName = '';\r\n\t\t\tthis.mPosition = null;\r\n\t\t\tthis.mLookAt = null;\r\n\t\t\tthis.mUp = null;\r\n\t\t\tthis.mHorizontalFOV = 0;\r\n\t\t\tthis.mClipPlaneNear = 0;\r\n\t\t\tthis.mClipPlaneFar = 0;\r\n\t\t\tthis.mAspect = 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiScene() {\r\n\r\n\t\t\tthis.mFlags = 0;\r\n\t\t\tthis.mNumMeshes = 0;\r\n\t\t\tthis.mNumMaterials = 0;\r\n\t\t\tthis.mNumAnimations = 0;\r\n\t\t\tthis.mNumTextures = 0;\r\n\t\t\tthis.mNumLights = 0;\r\n\t\t\tthis.mNumCameras = 0;\r\n\t\t\tthis.mRootNode = null;\r\n\t\t\tthis.mMeshes = [];\r\n\t\t\tthis.mMaterials = [];\r\n\t\t\tthis.mAnimations = [];\r\n\t\t\tthis.mLights = [];\r\n\t\t\tthis.mCameras = [];\r\n\t\t\tthis.nodeToBoneMap = {};\r\n\t\t\tthis.findNode = function ( name, root ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tif ( ! root ) {\r\n\r\n\t\t\t\t\troot = this.mRootNode;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( root.mName == name ) {\r\n\r\n\t\t\t\t\treturn root;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0; i < root.mChildren.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar ret = this$1.findNode( name, root.mChildren[ i ] );\r\n\t\t\t\t\tif ( ret ) { return ret; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.toTHREE = function () {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tthis.nodeCount = 0;\r\n\r\n\t\t\t\tmarkBones( this );\r\n\r\n\t\t\t\tvar o = this.mRootNode.toTHREE( this );\r\n\r\n\t\t\t\tfor ( var i in this$1.mMeshes )\r\n\t\t\t\t\t{ this$1.mMeshes[ i ].hookupSkeletons( this$1, o ); }\r\n\r\n\t\t\t\tif ( this.mAnimations.length > 0 ) {\r\n\r\n\t\t\t\t\tvar a = this.mAnimations[ 0 ].toTHREE( this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn { object: o, animation: a };\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction aiMatrix4() {\r\n\r\n\t\t\tthis.elements = [\r\n\t\t\t\t[],\r\n\t\t\t\t[],\r\n\t\t\t\t[],\r\n\t\t\t\t[]\r\n\t\t\t];\r\n\t\t\tthis.toTHREE = function () {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tvar m = new Matrix4();\r\n\r\n\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\r\n\r\n\t\t\t\t\tfor ( var i2 = 0; i2 < 4; ++ i2 ) {\r\n\r\n\t\t\t\t\t\tm.elements[ i * 4 + i2 ] = this$1.elements[ i2 ][ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn m;\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar littleEndian = true;\r\n\r\n\t\tfunction readFloat( dataview ) {\r\n\r\n\t\t\tvar val = dataview.getFloat32( dataview.readOffset, littleEndian );\r\n\t\t\tdataview.readOffset += 4;\r\n\t\t\treturn val;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_double( dataview ) {\r\n\r\n\t\t\tvar val = dataview.getFloat64( dataview.readOffset, littleEndian );\r\n\t\t\tdataview.readOffset += 8;\r\n\t\t\treturn val;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_uint8_t( dataview ) {\r\n\r\n\t\t\tvar val = dataview.getUint8( dataview.readOffset );\r\n\t\t\tdataview.readOffset += 1;\r\n\t\t\treturn val;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_uint16_t( dataview ) {\r\n\r\n\t\t\tvar val = dataview.getUint16( dataview.readOffset, littleEndian );\r\n\t\t\tdataview.readOffset += 2;\r\n\t\t\treturn val;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_unsigned_int( dataview ) {\r\n\r\n\t\t\tvar val = dataview.getUint32( dataview.readOffset, littleEndian );\r\n\t\t\tdataview.readOffset += 4;\r\n\t\t\treturn val;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_uint32_t( dataview ) {\r\n\r\n\t\t\tvar val = dataview.getUint32( dataview.readOffset, littleEndian );\r\n\t\t\tdataview.readOffset += 4;\r\n\t\t\treturn val;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_aiVector3D( stream ) {\r\n\r\n\t\t\tvar v = new aiVector3D();\r\n\t\t\tv.x = readFloat( stream );\r\n\t\t\tv.y = readFloat( stream );\r\n\t\t\tv.z = readFloat( stream );\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_aiColor3D( stream ) {\r\n\r\n\t\t\tvar c = new aiColor3D();\r\n\t\t\tc.r = readFloat( stream );\r\n\t\t\tc.g = readFloat( stream );\r\n\t\t\tc.b = readFloat( stream );\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_aiQuaternion( stream ) {\r\n\r\n\t\t\tvar v = new aiQuaternion();\r\n\t\t\tv.w = readFloat( stream );\r\n\t\t\tv.x = readFloat( stream );\r\n\t\t\tv.y = readFloat( stream );\r\n\t\t\tv.z = readFloat( stream );\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_aiString( stream ) {\r\n\r\n\t\t\tvar s = new aiString();\r\n\t\t\tvar stringlengthbytes = Read_unsigned_int( stream );\r\n\t\t\tstream.ReadBytes( s.data, 1, stringlengthbytes );\r\n\t\t\treturn s.toString();\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_aiVertexWeight( stream ) {\r\n\r\n\t\t\tvar w = new aiVertexWeight();\r\n\t\t\tw.mVertexId = Read_unsigned_int( stream );\r\n\t\t\tw.mWeight = readFloat( stream );\r\n\t\t\treturn w;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_aiMatrix4x4( stream ) {\r\n\r\n\t\t\tvar m = new aiMatrix4();\r\n\r\n\t\t\tfor ( var i = 0; i < 4; ++ i ) {\r\n\r\n\t\t\t\tfor ( var i2 = 0; i2 < 4; ++ i2 ) {\r\n\r\n\t\t\t\t\tm.elements[ i ][ i2 ] = readFloat( stream );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn m;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_aiVectorKey( stream ) {\r\n\r\n\t\t\tvar v = new aiVectorKey();\r\n\t\t\tv.mTime = Read_double( stream );\r\n\t\t\tv.mValue = Read_aiVector3D( stream );\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Read_aiQuatKey( stream ) {\r\n\r\n\t\t\tvar v = new aiQuatKey();\r\n\t\t\tv.mTime = Read_double( stream );\r\n\t\t\tv.mValue = Read_aiQuaternion( stream );\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t\tfunction ReadArray_aiVertexWeight( stream, data, size ) {\r\n\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) { data[ i ] = Read_aiVertexWeight( stream ); }\r\n\r\n\t\t}\r\n\r\n\t\tfunction ReadArray_aiVectorKey( stream, data, size ) {\r\n\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) { data[ i ] = Read_aiVectorKey( stream ); }\r\n\r\n\t\t}\r\n\r\n\t\tfunction ReadArray_aiQuatKey( stream, data, size ) {\r\n\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) { data[ i ] = Read_aiQuatKey( stream ); }\r\n\r\n\t\t}\r\n\r\n\t\tfunction ReadBounds( stream, T , n ) {\r\n\r\n\t\t\t// not sure what to do here, the data isn't really useful.\r\n\t\t\treturn stream.Seek( sizeof( T ) * n, aiOrigin_CUR );\r\n\r\n\t\t}\r\n\r\n\t\tfunction ai_assert( bool ) {\r\n\r\n\t\t\tif ( ! bool )\r\n\t\t\t\t{ throw ( \"asset failed\" ); }\r\n\r\n\t\t}\r\n\r\n\t\tfunction ReadBinaryNode( stream, parent, depth ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AINODE );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\tvar node = new aiNode();\r\n\t\t\tnode.mParent = parent;\r\n\t\t\tnode.mDepth = depth;\r\n\t\t\tnode.mName = Read_aiString( stream );\r\n\t\t\tnode.mTransformation = Read_aiMatrix4x4( stream );\r\n\t\t\tnode.mNumChildren = Read_unsigned_int( stream );\r\n\t\t\tnode.mNumMeshes = Read_unsigned_int( stream );\r\n\r\n\t\t\tif ( node.mNumMeshes ) {\r\n\r\n\t\t\t\tnode.mMeshes = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < node.mNumMeshes; ++ i ) {\r\n\r\n\t\t\t\t\tnode.mMeshes[ i ] = Read_unsigned_int( stream );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.mNumChildren ) {\r\n\r\n\t\t\t\tnode.mChildren = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < node.mNumChildren; ++ i ) {\r\n\r\n\t\t\t\t\tvar node2 = ReadBinaryNode( stream, node, depth ++ );\r\n\t\t\t\t\tnode.mChildren[ i ] = node2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\t// -----------------------------------------------------------------------------------\r\n\r\n\t\tfunction ReadBinaryBone( stream, b ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIBONE );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\tb.mName = Read_aiString( stream );\r\n\t\t\tb.mNumWeights = Read_unsigned_int( stream );\r\n\t\t\tb.mOffsetMatrix = Read_aiMatrix4x4( stream );\r\n\t\t\t// for the moment we write dumb min/max values for the bones, too.\r\n\t\t\t// maybe I'll add a better, hash-like solution later\r\n\t\t\tif ( shortened ) {\r\n\r\n\t\t\t\tReadBounds( stream, b.mWeights, b.mNumWeights );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// else write as usual\r\n\r\n\t\t\t\tb.mWeights = [];\r\n\t\t\t\tReadArray_aiVertexWeight( stream, b.mWeights, b.mNumWeights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn b;\r\n\r\n\t\t}\r\n\r\n\t\tfunction ReadBinaryMesh( stream, mesh ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMESH );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\tmesh.mPrimitiveTypes = Read_unsigned_int( stream );\r\n\t\t\tmesh.mNumVertices = Read_unsigned_int( stream );\r\n\t\t\tmesh.mNumFaces = Read_unsigned_int( stream );\r\n\t\t\tmesh.mNumBones = Read_unsigned_int( stream );\r\n\t\t\tmesh.mMaterialIndex = Read_unsigned_int( stream );\r\n\t\t\tmesh.mNumUVComponents = [];\r\n\t\t\t// first of all, write bits for all existent vertex components\r\n\t\t\tvar c = Read_unsigned_int( stream );\r\n\r\n\t\t\tif ( c & ASSBIN_MESH_HAS_POSITIONS ) {\r\n\r\n\t\t\t\tif ( shortened ) {\r\n\r\n\t\t\t\t\tReadBounds( stream, mesh.mVertices, mesh.mNumVertices );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// else write as usual\r\n\r\n\t\t\t\t\tmesh.mVertices = [];\r\n\t\t\t\t\tmesh.mVertexBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\r\n\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c & ASSBIN_MESH_HAS_NORMALS ) {\r\n\r\n\t\t\t\tif ( shortened ) {\r\n\r\n\t\t\t\t\tReadBounds( stream, mesh.mNormals, mesh.mNumVertices );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// else write as usual\r\n\r\n\t\t\t\t\tmesh.mNormals = [];\r\n\t\t\t\t\tmesh.mNormalBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\r\n\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS ) {\r\n\r\n\t\t\t\tif ( shortened ) {\r\n\r\n\t\t\t\t\tReadBounds( stream, mesh.mTangents, mesh.mNumVertices );\r\n\t\t\t\t\tReadBounds( stream, mesh.mBitangents, mesh.mNumVertices );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// else write as usual\r\n\r\n\t\t\t\t\tmesh.mTangents = [];\r\n\t\t\t\t\tmesh.mTangentBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\r\n\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\r\n\t\t\t\t\tmesh.mBitangents = [];\r\n\t\t\t\t\tmesh.mBitangentBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\r\n\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++ n ) {\r\n\r\n\t\t\t\tif ( ! ( c & ASSBIN_MESH_HAS_COLOR( n ) ) ) { break; }\r\n\r\n\t\t\t\tif ( shortened ) {\r\n\r\n\t\t\t\t\tReadBounds( stream, mesh.mColors[ n ], mesh.mNumVertices );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// else write as usual\r\n\r\n\t\t\t\t\tmesh.mColors[ n ] = [];\r\n\t\t\t\t\tmesh.mColorBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4 );\r\n\t\t\t\t\tstream.Seek( mesh.mNumVertices * 4 * 4, aiOrigin_CUR );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmesh.mTexCoordsBuffers = [];\r\n\r\n\t\t\tfor ( var n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++ n ) {\r\n\r\n\t\t\t\tif ( ! ( c & ASSBIN_MESH_HAS_TEXCOORD( n ) ) ) { break; }\r\n\r\n\t\t\t\t// write number of UV components\r\n\t\t\t\tmesh.mNumUVComponents[ n ] = Read_unsigned_int( stream );\r\n\r\n\t\t\t\tif ( shortened ) {\r\n\r\n\t\t\t\t\tReadBounds( stream, mesh.mTextureCoords[ n ], mesh.mNumVertices );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t// else write as usual\r\n\r\n\t\t\t\t\tmesh.mTextureCoords[ n ] = [];\r\n\t\t\t\t\t//note that assbin always writes 3d texcoords\r\n\t\t\t\t\tmesh.mTexCoordsBuffers[ n ] = [];\r\n\r\n\t\t\t\t\tfor ( var uv = 0; uv < mesh.mNumVertices; uv ++ ) {\r\n\r\n\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ].push( readFloat( stream ) );\r\n\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ].push( readFloat( stream ) );\r\n\t\t\t\t\t\treadFloat( stream );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// write faces. There are no floating-point calculations involved\r\n\t\t\t// in these, so we can write a simple hash over the face data\r\n\t\t\t// to the dump file. We generate a single 32 Bit hash for 512 faces\r\n\t\t\t// using Assimp's standard hashing function.\r\n\t\t\tif ( shortened ) {\r\n\r\n\t\t\t\tRead_unsigned_int( stream );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// else write as usual\r\n\r\n\t\t\t\t// if there are less than 2^16 vertices, we can simply use 16 bit integers ...\r\n\t\t\t\tmesh.mFaces = [];\r\n\t\t\t\tmesh.mIndexArray = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < mesh.mNumFaces; ++ i ) {\r\n\r\n\t\t\t\t\tvar f = mesh.mFaces[ i ] = new aiFace();\r\n\t\t\t\t\t// BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\r\n\t\t\t\t\tf.mNumIndices = Read_uint16_t( stream );\r\n\t\t\t\t\tf.mIndices = [];\r\n\r\n\t\t\t\t\tfor ( var a = 0; a < f.mNumIndices; ++ a ) {\r\n\r\n\t\t\t\t\t\tif ( mesh.mNumVertices < ( 1 << 16 ) ) {\r\n\r\n\t\t\t\t\t\t\tf.mIndices[ a ] = Read_uint16_t( stream );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tf.mIndices[ a ] = Read_unsigned_int( stream );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( f.mNumIndices === 3 ) {\r\n\r\n\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\r\n\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 1 ] );\r\n\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\r\n\r\n\t\t\t\t\t} else if ( f.mNumIndices === 4 ) {\r\n\r\n\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\r\n\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 1 ] );\r\n\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\r\n\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\r\n\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 3 ] );\r\n\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthrow ( new Error( \"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\" ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// write bones\r\n\t\t\tif ( mesh.mNumBones ) {\r\n\r\n\t\t\t\tmesh.mBones = [];\r\n\r\n\t\t\t\tfor ( var a = 0; a < mesh.mNumBones; ++ a ) {\r\n\r\n\t\t\t\t\tmesh.mBones[ a ] = new aiBone();\r\n\t\t\t\t\tReadBinaryBone( stream, mesh.mBones[ a ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction ReadBinaryMaterialProperty( stream, prop ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\tprop.mKey = Read_aiString( stream );\r\n\t\t\tprop.mSemantic = Read_unsigned_int( stream );\r\n\t\t\tprop.mIndex = Read_unsigned_int( stream );\r\n\t\t\tprop.mDataLength = Read_unsigned_int( stream );\r\n\t\t\tprop.mType = Read_unsigned_int( stream );\r\n\t\t\tprop.mData = [];\r\n\t\t\tstream.ReadBytes( prop.mData, 1, prop.mDataLength );\r\n\r\n\t\t}\r\n\r\n\t\t// -----------------------------------------------------------------------------------\r\n\r\n\t\tfunction ReadBinaryMaterial( stream, mat ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMATERIAL );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\tmat.mNumAllocated = mat.mNumProperties = Read_unsigned_int( stream );\r\n\r\n\t\t\tif ( mat.mNumProperties ) {\r\n\r\n\t\t\t\tif ( mat.mProperties ) {\r\n\r\n\t\t\t\t\tdelete mat.mProperties;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmat.mProperties = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < mat.mNumProperties; ++ i ) {\r\n\r\n\t\t\t\t\tmat.mProperties[ i ] = new aiMaterialProperty();\r\n\t\t\t\t\tReadBinaryMaterialProperty( stream, mat.mProperties[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t// -----------------------------------------------------------------------------------\r\n\t\tfunction ReadBinaryNodeAnim( stream, nd ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AINODEANIM );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\tnd.mNodeName = Read_aiString( stream );\r\n\t\t\tnd.mNumPositionKeys = Read_unsigned_int( stream );\r\n\t\t\tnd.mNumRotationKeys = Read_unsigned_int( stream );\r\n\t\t\tnd.mNumScalingKeys = Read_unsigned_int( stream );\r\n\t\t\tnd.mPreState = Read_unsigned_int( stream );\r\n\t\t\tnd.mPostState = Read_unsigned_int( stream );\r\n\r\n\t\t\tif ( nd.mNumPositionKeys ) {\r\n\r\n\t\t\t\tif ( shortened ) {\r\n\r\n\t\t\t\t\tReadBounds( stream, nd.mPositionKeys, nd.mNumPositionKeys );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// else write as usual\r\n\r\n\t\t\t\t\tnd.mPositionKeys = [];\r\n\t\t\t\t\tReadArray_aiVectorKey( stream, nd.mPositionKeys, nd.mNumPositionKeys );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nd.mNumRotationKeys ) {\r\n\r\n\t\t\t\tif ( shortened ) {\r\n\r\n\t\t\t\t\tReadBounds( stream, nd.mRotationKeys, nd.mNumRotationKeys );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t \t\t\t// else write as usual\r\n\r\n\t\t\t\t\tnd.mRotationKeys = [];\r\n\t\t\t\t\tReadArray_aiQuatKey( stream, nd.mRotationKeys, nd.mNumRotationKeys );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nd.mNumScalingKeys ) {\r\n\r\n\t\t\t\tif ( shortened ) {\r\n\r\n\t\t\t\t\tReadBounds( stream, nd.mScalingKeys, nd.mNumScalingKeys );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t \t\t\t\t// else write as usual\r\n\r\n\t\t\t\t\tnd.mScalingKeys = [];\r\n\t\t\t\t\tReadArray_aiVectorKey( stream, nd.mScalingKeys, nd.mNumScalingKeys );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t// -----------------------------------------------------------------------------------\r\n\t\tfunction ReadBinaryAnim( stream, anim ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIANIMATION );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\tanim.mName = Read_aiString( stream );\r\n\t\t\tanim.mDuration = Read_double( stream );\r\n\t\t\tanim.mTicksPerSecond = Read_double( stream );\r\n\t\t\tanim.mNumChannels = Read_unsigned_int( stream );\r\n\r\n\t\t\tif ( anim.mNumChannels ) {\r\n\r\n\t\t\t\tanim.mChannels = [];\r\n\r\n\t\t\t\tfor ( var a = 0; a < anim.mNumChannels; ++ a ) {\r\n\r\n\t\t\t\t\tanim.mChannels[ a ] = new aiNodeAnim();\r\n\t\t\t\t\tReadBinaryNodeAnim( stream, anim.mChannels[ a ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction ReadBinaryTexture( stream, tex ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AITEXTURE );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\ttex.mWidth = Read_unsigned_int( stream );\r\n\t\t\ttex.mHeight = Read_unsigned_int( stream );\r\n\t\t\tstream.ReadBytes( tex.achFormatHint, 1, 4 );\r\n\r\n\t\t\tif ( ! shortened ) {\r\n\r\n\t\t\t\tif ( ! tex.mHeight ) {\r\n\r\n\t\t\t\t\ttex.pcData = [];\r\n\t\t\t\t\tstream.ReadBytes( tex.pcData, 1, tex.mWidth );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttex.pcData = [];\r\n\t\t\t\t\tstream.ReadBytes( tex.pcData, 1, tex.mWidth * tex.mHeight * 4 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t// -----------------------------------------------------------------------------------\r\n\t\tfunction ReadBinaryLight( stream, l ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AILIGHT );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\tl.mName = Read_aiString( stream );\r\n\t\t\tl.mType = Read_unsigned_int( stream );\r\n\r\n\t\t\tif ( l.mType != aiLightSource_DIRECTIONAL ) {\r\n\r\n\t\t\t\tl.mAttenuationConstant = readFloat( stream );\r\n\t\t\t\tl.mAttenuationLinear = readFloat( stream );\r\n\t\t\t\tl.mAttenuationQuadratic = readFloat( stream );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl.mColorDiffuse = Read_aiColor3D( stream );\r\n\t\t\tl.mColorSpecular = Read_aiColor3D( stream );\r\n\t\t\tl.mColorAmbient = Read_aiColor3D( stream );\r\n\r\n\t\t\tif ( l.mType == aiLightSource_SPOT ) {\r\n\r\n\t\t\t\tl.mAngleInnerCone = readFloat( stream );\r\n\t\t\t\tl.mAngleOuterCone = readFloat( stream );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t// -----------------------------------------------------------------------------------\r\n\t\tfunction ReadBinaryCamera( stream, cam ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AICAMERA );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\tcam.mName = Read_aiString( stream );\r\n\t\t\tcam.mPosition = Read_aiVector3D( stream );\r\n\t\t\tcam.mLookAt = Read_aiVector3D( stream );\r\n\t\t\tcam.mUp = Read_aiVector3D( stream );\r\n\t\t\tcam.mHorizontalFOV = readFloat( stream );\r\n\t\t\tcam.mClipPlaneNear = readFloat( stream );\r\n\t\t\tcam.mClipPlaneFar = readFloat( stream );\r\n\t\t\tcam.mAspect = readFloat( stream );\r\n\r\n\t\t}\r\n\r\n\t\tfunction ReadBinaryScene( stream, scene ) {\r\n\r\n\t\t\tvar chunkID = Read_uint32_t( stream );\r\n\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AISCENE );\r\n\t\t\t\r\n\t\t\tRead_uint32_t( stream );\r\n\t\t\tscene.mFlags = Read_unsigned_int( stream );\r\n\t\t\tscene.mNumMeshes = Read_unsigned_int( stream );\r\n\t\t\tscene.mNumMaterials = Read_unsigned_int( stream );\r\n\t\t\tscene.mNumAnimations = Read_unsigned_int( stream );\r\n\t\t\tscene.mNumTextures = Read_unsigned_int( stream );\r\n\t\t\tscene.mNumLights = Read_unsigned_int( stream );\r\n\t\t\tscene.mNumCameras = Read_unsigned_int( stream );\r\n\t\t\t// Read node graph\r\n\t\t\tscene.mRootNode = new aiNode();\r\n\t\t\tscene.mRootNode = ReadBinaryNode( stream, null, 0 );\r\n\t\t\t// Read all meshes\r\n\t\t\tif ( scene.mNumMeshes ) {\r\n\r\n\t\t\t\tscene.mMeshes = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < scene.mNumMeshes; ++ i ) {\r\n\r\n\t\t\t\t\tscene.mMeshes[ i ] = new aiMesh();\r\n\t\t\t\t\tReadBinaryMesh( stream, scene.mMeshes[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// Read materials\r\n\t\t\tif ( scene.mNumMaterials ) {\r\n\r\n\t\t\t\tscene.mMaterials = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < scene.mNumMaterials; ++ i ) {\r\n\r\n\t\t\t\t\tscene.mMaterials[ i ] = new aiMaterial();\r\n\t\t\t\t\tReadBinaryMaterial( stream, scene.mMaterials[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// Read all animations\r\n\t\t\tif ( scene.mNumAnimations ) {\r\n\r\n\t\t\t\tscene.mAnimations = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < scene.mNumAnimations; ++ i ) {\r\n\r\n\t\t\t\t\tscene.mAnimations[ i ] = new aiAnimation();\r\n\t\t\t\t\tReadBinaryAnim( stream, scene.mAnimations[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// Read all textures\r\n\t\t\tif ( scene.mNumTextures ) {\r\n\r\n\t\t\t\tscene.mTextures = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < scene.mNumTextures; ++ i ) {\r\n\r\n\t\t\t\t\tscene.mTextures[ i ] = new aiTexture();\r\n\t\t\t\t\tReadBinaryTexture( stream, scene.mTextures[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// Read lights\r\n\t\t\tif ( scene.mNumLights ) {\r\n\r\n\t\t\t\tscene.mLights = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < scene.mNumLights; ++ i ) {\r\n\r\n\t\t\t\t\tscene.mLights[ i ] = new aiLight();\r\n\t\t\t\t\tReadBinaryLight( stream, scene.mLights[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// Read cameras\r\n\t\t\tif ( scene.mNumCameras ) {\r\n\r\n\t\t\t\tscene.mCameras = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < scene.mNumCameras; ++ i ) {\r\n\r\n\t\t\t\t\tscene.mCameras[ i ] = new aiCamera();\r\n\t\t\t\t\tReadBinaryCamera( stream, scene.mCameras[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tvar aiOrigin_CUR = 0;\r\n\t\tvar aiOrigin_BEG = 1;\r\n\r\n\t\tfunction extendStream( stream ) {\r\n\r\n\t\t\tstream.readOffset = 0;\r\n\t\t\tstream.Seek = function ( off, ori ) {\r\n\r\n\t\t\t\tif ( ori == aiOrigin_CUR ) {\r\n\r\n\t\t\t\t\tstream.readOffset += off;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( ori == aiOrigin_BEG ) {\r\n\r\n\t\t\t\t\tstream.readOffset = off;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t\tstream.ReadBytes = function ( buff, size, n ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tvar bytes = size * n;\r\n\t\t\t\tfor ( var i = 0; i < bytes; i ++ )\r\n\t\t\t\t\t{ buff[ i ] = Read_uint8_t( this$1 ); }\r\n\r\n\t\t\t};\r\n\r\n\t\t\tstream.subArray32 = function ( start, end ) {\r\n\r\n\t\t\t\tvar buff = this.buffer;\r\n\t\t\t\tvar newbuff = buff.slice( start, end );\r\n\t\t\t\treturn new Float32Array( newbuff );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tstream.subArrayUint16 = function ( start, end ) {\r\n\r\n\t\t\t\tvar buff = this.buffer;\r\n\t\t\t\tvar newbuff = buff.slice( start, end );\r\n\t\t\t\treturn new Uint16Array( newbuff );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tstream.subArrayUint8 = function ( start, end ) {\r\n\r\n\t\t\t\tvar buff = this.buffer;\r\n\t\t\t\tvar newbuff = buff.slice( start, end );\r\n\t\t\t\treturn new Uint8Array( newbuff );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tstream.subArrayUint32 = function ( start, end ) {\r\n\r\n\t\t\t\tvar buff = this.buffer;\r\n\t\t\t\tvar newbuff = buff.slice( start, end );\r\n\t\t\t\treturn new Uint32Array( newbuff );\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar shortened, compressed;\r\n\r\n\t\tfunction InternReadFile( pFiledata ) {\r\n\r\n\t\t\tvar pScene = new aiScene();\r\n\t\t\tvar stream = new DataView( pFiledata );\r\n\t\t\textendStream( stream );\r\n\t\t\tstream.Seek( 44, aiOrigin_CUR ); // signature\r\n\t\t\t\r\n\t\t\tvar versionMajor = Read_unsigned_int( stream );\r\n\t\t\t\r\n\t\t\tvar versionMinor = Read_unsigned_int( stream );\r\n\t\t\t\r\n\t\t\tvar versionRevision = Read_unsigned_int( stream );\r\n\t\t\t\r\n\t\t\tvar compileFlags = Read_unsigned_int( stream );\r\n\t\t\tshortened = Read_uint16_t( stream ) > 0;\r\n\t\t\tcompressed = Read_uint16_t( stream ) > 0;\r\n\t\t\tif ( shortened )\r\n\t\t\t\t{ throw \"Shortened binaries are not supported!\"; }\r\n\t\t\tstream.Seek( 256, aiOrigin_CUR ); // original filename\r\n\t\t\tstream.Seek( 128, aiOrigin_CUR ); // options\r\n\t\t\tstream.Seek( 64, aiOrigin_CUR ); // padding\r\n\t\t\tif ( compressed ) {\r\n\r\n\t\t\t\tvar uncompressedSize = Read_uint32_t( stream );\r\n\t\t\t\tvar compressedSize = stream.FileSize() - stream.Tell();\r\n\t\t\t\tvar compressedData = [];\r\n\t\t\t\tstream.Read( compressedData, 1, compressedSize );\r\n\t\t\t\tvar uncompressedData = [];\r\n\t\t\t\tuncompress( uncompressedData, uncompressedSize, compressedData, compressedSize );\r\n\t\t\t\tvar buff = new ArrayBuffer( uncompressedData );\r\n\t\t\t\tReadBinaryScene( buff, pScene );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tReadBinaryScene( stream, pScene );\r\n\t\t\t\treturn pScene.toTHREE();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn InternReadFile( buffer );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\tvar AWD_FIELD_INT8 = 1,\r\n\t\tAWD_FIELD_INT16 = 2,\r\n\t\tAWD_FIELD_INT32 = 3,\r\n\t\tAWD_FIELD_UINT8 = 4,\r\n\t\tAWD_FIELD_UINT16 = 5,\r\n\t\tAWD_FIELD_UINT32 = 6,\r\n\t\tAWD_FIELD_FLOAT32 = 7,\r\n\t\tAWD_FIELD_FLOAT64 = 8,\r\n\t\tAWD_FIELD_BOOL = 21,\r\n\t\tAWD_FIELD_BADDR = 23,\r\n\t\tAWD_FIELD_VECTOR2x1 = 41,\r\n\t\tAWD_FIELD_VECTOR3x1 = 42,\r\n\t\tAWD_FIELD_VECTOR4x1 = 43,\r\n\t\tAWD_FIELD_MTX3x2 = 44,\r\n\t\tAWD_FIELD_MTX3x3 = 45,\r\n\t\tAWD_FIELD_MTX4x3 = 46,\r\n\t\tAWD_FIELD_MTX4x4 = 47,\r\n\r\n\t\tBOOL = 21,\r\n\t\tBADDR = 23,\r\n\r\n\t\tUINT8 = 4,\r\n\t\tUINT16 = 5,\r\n\t\tFLOAT32 = 7,\r\n\t\tFLOAT64 = 8;\r\n\r\n\tvar littleEndian = true;\r\n\r\n\tfunction Block() {\r\n\r\n\t\tthis.id = 0;\r\n\t\tthis.data = null;\r\n\r\n\t}\r\n\r\n\tfunction AWDProperties() {}\r\n\r\n\tAWDProperties.prototype = {\r\n\t\tset: function ( key, value ) {\r\n\r\n\t\t\tthis[ key ] = value;\r\n\r\n\t\t},\r\n\r\n\t\tget: function ( key, fallback ) {\r\n\r\n\t\t\tif ( this.hasOwnProperty( key ) ) {\r\n\r\n\t\t\t\treturn this[ key ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn fallback;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t};\r\n\r\n\tvar AWDLoader = function ( manager ) {\r\n\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\t\tthis.trunk = new Object3D();\r\n\r\n\t\tthis.materialFactory = undefined;\r\n\r\n\t\tthis._url = '';\r\n\t\tthis._baseDir = '';\r\n\r\n\t\tthis._data = undefined;\r\n\t\tthis._ptr = 0;\r\n\r\n\t\tthis._version = [];\r\n\t\tthis._streaming = false;\r\n\t\tthis._optimized_for_accuracy = false;\r\n\t\tthis._compression = 0;\r\n\t\tthis._bodylen = 0xFFFFFFFF;\r\n\r\n\t\tthis._blocks = [ new Block() ];\r\n\r\n\t\tthis._accuracyMatrix = false;\r\n\t\tthis._accuracyGeo = false;\r\n\t\tthis._accuracyProps = false;\r\n\r\n\t};\r\n\r\n\tAWDLoader.prototype = {\r\n\r\n\t\tconstructor: AWDLoader,\r\n\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tthis._url = url;\r\n\t\t\tthis._baseDir = url.substr( 0, url.lastIndexOf( '/' ) + 1 );\r\n\r\n\t\t\tvar loader = new FileLoader( this.manager );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( data ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar blen = data.byteLength;\r\n\r\n\t\t\tthis._ptr = 0;\r\n\t\t\tthis._data = new DataView( data );\r\n\r\n\t\t\tthis._parseHeader( );\r\n\r\n\t\t\tif ( this._compression != 0 ) {\r\n\r\n\t\t\t\tconsole.error( 'compressed AWD not supported' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! this._streaming && this._bodylen != data.byteLength - this._ptr ) {\r\n\r\n\t\t\t\tconsole.error( 'AWDLoader: body len does not match file length', this._bodylen, blen - this._ptr );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( this._ptr < blen ) {\r\n\r\n\t\t\t\tthis$1.parseNextBlock();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.trunk;\r\n\r\n\t\t},\r\n\r\n\t\tparseNextBlock: function () {\r\n\r\n\t\t\tvar assetData,\r\n\t\t\t\tns, type, len, block,\r\n\t\t\t\tblockId = this.readU32(),\r\n\t\t\t\tns = this.readU8(),\r\n\t\t\t\ttype = this.readU8(),\r\n\t\t\t\tflags = this.readU8(),\r\n\t\t\t\tlen = this.readU32();\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tassetData = this.parseMeshData( len );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 22:\r\n\t\t\t\t\tassetData = this.parseContainer( len );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 23:\r\n\t\t\t\t\tassetData = this.parseMeshInstance( len );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 81:\r\n\t\t\t\t\tassetData = this.parseMaterial( len );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 82:\r\n\t\t\t\t\tassetData = this.parseTexture( len );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 101:\r\n\t\t\t\t\tassetData = this.parseSkeleton( len );\r\n\t\t\t\t\tbreak;\r\n\r\n\t    //  case 111:\r\n\t    //    assetData = this.parseMeshPoseAnimation(len, true);\r\n\t    //    break;\r\n\r\n\t\t\t\tcase 112:\r\n\t\t\t\t\tassetData = this.parseMeshPoseAnimation( len, false );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 113:\r\n\t\t\t\t\tassetData = this.parseVertexAnimationSet( len );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 102:\r\n\t\t\t\t\tassetData = this.parseSkeletonPose( len );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 103:\r\n\t\t\t\t\tassetData = this.parseSkeletonAnimation( len );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 122:\r\n\t\t\t\t\tassetData = this.parseAnimatorSet( len );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// case 121:\r\n\t\t\t\t//  assetData = parseUVAnimation(len);\r\n\t\t\t\t//  break;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t//debug('Ignoring block!',type, len);\r\n\t\t\t\t\tthis._ptr += len;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Store block reference for later use\r\n\t\t\tthis._blocks[ blockId ] = block = new Block();\r\n\t\t\tblock.data = assetData;\r\n\t\t\tblock.id = blockId;\r\n\r\n\t\t},\r\n\r\n\t\t_parseHeader: function () {\r\n\r\n\t\t\tvar version = this._version,\r\n\t\t\t\tawdmagic = ( this.readU8() << 16 ) | ( this.readU8() << 8 ) | this.readU8();\r\n\r\n\t\t\tif ( awdmagic != 4282180 )\r\n\t\t\t\t{ throw new Error( \"AWDLoader - bad magic\" ); }\r\n\r\n\t\t\tversion[ 0 ] = this.readU8();\r\n\t\t\tversion[ 1 ] = this.readU8();\r\n\r\n\t\t\tvar flags = this.readU16();\r\n\r\n\t\t\tthis._streaming = ( flags & 0x1 ) == 0x1;\r\n\r\n\t\t\tif ( ( version[ 0 ] === 2 ) && ( version[ 1 ] === 1 ) ) {\r\n\r\n\t\t\t\tthis._accuracyMatrix = ( flags & 0x2 ) === 0x2;\r\n\t\t\t\tthis._accuracyGeo = ( flags & 0x4 ) === 0x4;\r\n\t\t\t\tthis._accuracyProps = ( flags & 0x8 ) === 0x8;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._geoNrType = this._accuracyGeo ? FLOAT64 : FLOAT32;\r\n\t\t\tthis._matrixNrType = this._accuracyMatrix ? FLOAT64 : FLOAT32;\r\n\t\t\tthis._propsNrType = this._accuracyProps ? FLOAT64 : FLOAT32;\r\n\r\n\t\t\tthis._optimized_for_accuracy = ( flags & 0x2 ) === 0x2;\r\n\r\n\t\t\tthis._compression = this.readU8();\r\n\t\t\tthis._bodylen = this.readU32();\r\n\r\n\t\t},\r\n\r\n\t\tparseContainer: function ( len ) {\r\n\r\n\t\t\tvar parent,\r\n\t\t\t\tctr = new Object3D(),\r\n\t\t\t\tpar_id = this.readU32(),\r\n\t\t\t\tmtx = this.parseMatrix4();\r\n\r\n\t\t\tctr.name = this.readUTF();\r\n\t\t\tctr.applyMatrix( mtx );\r\n\r\n\t\t\tparent = this._blocks[ par_id ].data || this.trunk;\r\n\t\t\tparent.add( ctr );\r\n\r\n\t\t\tthis.parseProperties( {\r\n\t\t\t\t1: this._matrixNrType,\r\n\t\t\t\t2: this._matrixNrType,\r\n\t\t\t\t3: this._matrixNrType,\r\n\t\t\t\t4: UINT8\r\n\t\t\t} );\r\n\r\n\t\t\tctr.extra = this.parseUserAttributes();\r\n\r\n\t\t\treturn ctr;\r\n\r\n\t\t},\r\n\r\n\t\tparseMeshInstance: function ( len ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar name,\r\n\t\t\t\tmesh, geometries, meshLen, meshes,\r\n\t\t\t\tpar_id, data_id,\r\n\t\t\t\tmtx,\r\n\t\t\t\tmaterials, mat, mat_id,\r\n\t\t\t\tnum_materials,\r\n\t\t\t\tparent,\r\n\t\t\t\ti;\r\n\r\n\t\t\tpar_id = this.readU32();\r\n\t\t\tmtx = this.parseMatrix4();\r\n\t\t\tname = this.readUTF();\r\n\t\t\tdata_id = this.readU32();\r\n\t\t\tnum_materials = this.readU16();\r\n\r\n\t\t\tgeometries = this.getBlock( data_id );\r\n\r\n\t\t\tmaterials = [];\r\n\r\n\t\t\tfor ( i = 0; i < num_materials; i ++ ) {\r\n\r\n\t\t\t\tmat_id = this$1.readU32();\r\n\t\t\t\tmat = this$1.getBlock( mat_id );\r\n\t\t\t\tmaterials.push( mat );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmeshLen = geometries.length;\r\n\t\t\tmeshes = [];\r\n\r\n\t\t\t// TODO : BufferGeometry don't support \"geometryGroups\" for now.\r\n\t\t\t// so we create sub meshes for each groups\r\n\t\t\tif ( meshLen > 1 ) {\r\n\r\n\t\t\t\tmesh = new Object3D();\r\n\t\t\t\tfor ( i = 0; i < meshLen; i ++ ) {\r\n\r\n\t\t\t\t\tvar sm = new Mesh( geometries[ i ] );\r\n\t\t\t\t\tmeshes.push( sm );\r\n\t\t\t\t\tmesh.add( sm );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmesh = new Mesh( geometries[ 0 ] );\r\n\t\t\t\tmeshes.push( mesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmesh.applyMatrix( mtx );\r\n\t\t\tmesh.name = name;\r\n\r\n\t\t\tparent = this.getBlock( par_id ) || this.trunk;\r\n\t\t\tparent.add( mesh );\r\n\r\n\t\t\tvar matLen = materials.length;\r\n\t\t\tvar maxLen = Math.max( meshLen, matLen );\r\n\t\t\tfor ( i = 0; i < maxLen; i ++ )\r\n\t\t\t\t{ meshes[ i % meshLen ].material = materials[ i % matLen ]; }\r\n\r\n\t\t\t// Ignore for now\r\n\t\t\tthis.parseProperties( null );\r\n\t\t\tmesh.extra = this.parseUserAttributes();\r\n\r\n\t\t\treturn mesh;\r\n\r\n\t\t},\r\n\r\n\t\tparseMaterial: function ( len ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar name,\r\n\t\t\t\ttype,\r\n\t\t\t\tprops,\r\n\t\t\t\tmat,\r\n\t\t\t\tattributes,\r\n\t\t\t\tnum_methods,\r\n\t\t\t\tmethods_parsed;\r\n\r\n\t\t\tname = this.readUTF();\r\n\t\t\ttype = this.readU8();\r\n\t\t\tnum_methods = this.readU8();\r\n\r\n\t\t\t//log( \"AWDLoader parseMaterial \",name )\r\n\r\n\t\t\t// Read material numerical properties\r\n\t\t\t// (1=color, 2=bitmap url, 11=alpha_blending, 12=alpha_threshold, 13=repeat)\r\n\t\t\tprops = this.parseProperties( {\r\n\t\t\t\t1: AWD_FIELD_INT32,\r\n\t\t\t\t2: AWD_FIELD_BADDR,\r\n\t\t\t\t11: AWD_FIELD_BOOL,\r\n\t\t\t\t12: AWD_FIELD_FLOAT32,\r\n\t\t\t\t13: AWD_FIELD_BOOL\r\n\t\t\t} );\r\n\r\n\t\t\tmethods_parsed = 0;\r\n\r\n\t\t\twhile ( methods_parsed < num_methods ) {\r\n\r\n\t\t\t\tvar method_type = this$1.readU16();\r\n\t\t\t\tthis$1.parseProperties( null );\r\n\t\t\t\tthis$1.parseUserAttributes();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattributes = this.parseUserAttributes();\r\n\r\n\t\t\tif ( this.materialFactory !== undefined ) {\r\n\r\n\t\t\t\tmat = this.materialFactory( name );\r\n\t\t\t\tif ( mat ) { return mat; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmat = new MeshPhongMaterial();\r\n\r\n\t\t\tif ( type === 1 ) {\r\n\r\n\t\t\t\t// Color material\r\n\t\t\t\tmat.color.setHex( props.get( 1, 0xcccccc ) );\r\n\r\n\t\t\t} else if ( type === 2 ) {\r\n\r\n\t\t\t\t// Bitmap material\r\n\t\t\t\tvar tex_addr = props.get( 2, 0 );\r\n\t\t\t\tmat.map = this.getBlock( tex_addr );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmat.extra = attributes;\r\n\t\t\tmat.alphaThreshold = props.get( 12, 0.0 );\r\n\t\t\tmat.repeat = props.get( 13, false );\r\n\r\n\t\t\treturn mat;\r\n\r\n\t\t},\r\n\r\n\t\tparseTexture: function ( len ) {\r\n\r\n\t\t\tvar name = this.readUTF(),\r\n\t\t\t\ttype = this.readU8(),\r\n\t\t\t\tasset,\r\n\t\t\t\tdata_len;\r\n\r\n\t\t\t// External\r\n\t\t\tif ( type === 0 ) {\r\n\r\n\t\t\t\tdata_len = this.readU32();\r\n\t\t\t\tvar url = this.readUTFBytes( data_len );\r\n\t\t\t\tconsole.log( url );\r\n\r\n\t\t\t\tasset = this.loadTexture( url );\r\n\r\n\t\t\t}\r\n\t\t\t// Ignore for now\r\n\t\t\tthis.parseProperties( null );\r\n\r\n\t\t\tthis.parseUserAttributes();\r\n\t\t\treturn asset;\r\n\r\n\t\t},\r\n\r\n\t\tloadTexture: function ( url ) {\r\n\r\n\t\t\tvar tex = new Texture();\r\n\r\n\t\t\tvar loader = new ImageLoader( this.manager );\r\n\r\n\t\t\tloader.load( this._baseDir + url, function ( image ) {\r\n\r\n\t\t\t\ttex.image = image;\r\n\t\t\t\ttex.needsUpdate = true;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn tex;\r\n\r\n\t\t},\r\n\r\n\t\tparseSkeleton: function ( len ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t// Array<Bone>\r\n\t\t\tvar name = this.readUTF(),\r\n\t\t\t\tnum_joints = this.readU16(),\r\n\t\t\t\tskeleton = [],\r\n\t\t\t\tjoints_parsed = 0;\r\n\r\n\t\t\tthis.parseProperties( null );\r\n\r\n\t\t\twhile ( joints_parsed < num_joints ) {\r\n\r\n\t\t\t\tvar joint, ibp;\r\n\r\n\t\t\t\t// Ignore joint id\r\n\t\t\t\tthis$1.readU16();\r\n\r\n\t\t\t\tjoint = new Bone();\r\n\t\t\t\tjoint.parent = this$1.readU16() - 1; // 0=null in AWD\r\n\t\t\t\tjoint.name = this$1.readUTF();\r\n\r\n\t\t\t\tibp = this$1.parseMatrix4();\r\n\t\t\t\tjoint.skinMatrix = ibp;\r\n\r\n\t\t\t\t// Ignore joint props/attributes for now\r\n\t\t\t\tthis$1.parseProperties( null );\r\n\t\t\t\tthis$1.parseUserAttributes();\r\n\r\n\t\t\t\tskeleton.push( joint );\r\n\t\t\t\tjoints_parsed ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Discard attributes for now\r\n\t\t\tthis.parseUserAttributes();\r\n\r\n\t\t\treturn skeleton;\r\n\r\n\t\t},\r\n\r\n\t\tparseSkeletonPose: function ( blockID ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar name = this.readUTF();\r\n\r\n\t\t\tvar num_joints = this.readU16();\r\n\t\t\tthis.parseProperties( null );\r\n\r\n\t\t\t// debug( 'parse Skeleton Pose. joints : ' + num_joints);\r\n\r\n\t\t\tvar pose = [];\r\n\r\n\t\t\tvar joints_parsed = 0;\r\n\r\n\t\t\twhile ( joints_parsed < num_joints ) {\r\n\r\n\t\t\t\tvar has_transform; //:uint;\r\n\t\t\t\tvar mtx_data;\r\n\r\n\t\t\t\thas_transform = this$1.readU8();\r\n\r\n\t\t\t\tif ( has_transform === 1 ) {\r\n\r\n\t\t\t\t\tmtx_data = this$1.parseMatrix4();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmtx_data = new Matrix4();\r\n\r\n\t\t\t\t}\r\n\t\t\t\tpose[ joints_parsed ] = mtx_data;\r\n\t\t\t\tjoints_parsed ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Skip attributes for now\r\n\t\t\tthis.parseUserAttributes();\r\n\r\n\t\t\treturn pose;\r\n\r\n\t\t},\r\n\r\n\t\tparseSkeletonAnimation: function ( blockID ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar frame_dur;\r\n\t\t\tvar pose_addr;\r\n\t\t\tvar pose;\r\n\r\n\t\t\tvar name = this.readUTF();\r\n\r\n\t\t\tvar clip = [];\r\n\r\n\t\t\tvar num_frames = this.readU16();\r\n\t\t\tthis.parseProperties( null );\r\n\r\n\t\t\tvar frames_parsed = 0;\r\n\r\n\t\t\t// debug( 'parse Skeleton Animation. frames : ' + num_frames);\r\n\r\n\t\t\twhile ( frames_parsed < num_frames ) {\r\n\r\n\t\t\t\tpose_addr = this$1.readU32();\r\n\t\t\t\tframe_dur = this$1.readU16();\r\n\r\n\t\t\t\tpose = this$1._blocks[ pose_addr ].data;\r\n\t\t\t\t// debug( 'pose address ',pose[2].elements[12],pose[2].elements[13],pose[2].elements[14] );\r\n\t\t\t\tclip.push( {\r\n\t\t\t\t\tpose: pose,\r\n\t\t\t\t\tduration: frame_dur\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tframes_parsed ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( clip.length === 0 ) {\r\n\r\n\t\t\t\t// debug(\"Could not this SkeletonClipNode, because no Frames where set.\");\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\t\t\t// Ignore attributes for now\r\n\t\t\tthis.parseUserAttributes();\r\n\t\t\treturn clip;\r\n\r\n\t\t},\r\n\r\n\t\tparseVertexAnimationSet: function ( len ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar poseBlockAdress,\r\n\t\t\t\tname = this.readUTF(),\r\n\t\t\t\tnum_frames = this.readU16(),\r\n\t\t\t\tprops = this.parseProperties( { 1: UINT16 } ),\r\n\t\t\t\tframes_parsed = 0,\r\n\t\t\t\tskeletonFrames = [];\r\n\r\n\t\t\twhile ( frames_parsed < num_frames ) {\r\n\r\n\t\t\t\tposeBlockAdress = this$1.readU32();\r\n\t\t\t\tskeletonFrames.push( this$1._blocks[ poseBlockAdress ].data );\r\n\t\t\t\tframes_parsed ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.parseUserAttributes();\r\n\r\n\t\t\treturn skeletonFrames;\r\n\r\n\t\t},\r\n\r\n\t\tparseAnimatorSet: function ( len ) {\n\t\t\tvar this$1 = this;\n\r\n\t\t\tvar animSetBlockAdress; //:int\r\n\r\n\t\t\tvar targetAnimationSet; //:AnimationSetBase;\r\n\t\t\tvar name = this.readUTF();\r\n\t\t\tvar type = this.readU16();\r\n\r\n\t\t\tvar props = this.parseProperties( { 1: BADDR } );\r\n\r\n\t\t\tanimSetBlockAdress = this.readU32();\r\n\t\t\tvar targetMeshLength = this.readU16();\r\n\r\n\t\t\tvar meshAdresses = []; //:Vector.<uint> = new Vector.<uint>;\r\n\r\n\t\t\tfor ( var i = 0; i < targetMeshLength; i ++ )\r\n\t\t\t\t{ meshAdresses.push( this$1.readU32() ); }\r\n\r\n\t\t\tvar activeState = this.readU16();\r\n\t\t\tvar autoplay = Boolean( this.readU8() );\r\n\t\t\tthis.parseUserAttributes();\r\n\t\t\tthis.parseUserAttributes();\r\n\t\t\tvar targetMeshes = []; //:Vector.<Mesh> = new Vector.<Mesh>;\r\n\r\n\t\t\tfor ( i = 0; i < meshAdresses.length; i ++ ) {\r\n\r\n\t\t\t\t//      returnedArray = getAssetByID(meshAdresses[i], [AssetType.MESH]);\r\n\t\t\t\t//      if (returnedArray[0])\r\n\t\t\t\ttargetMeshes.push( this$1._blocks[ meshAdresses[ i ] ].data );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetAnimationSet = this._blocks[ animSetBlockAdress ].data;\r\n\t\t\tvar thisAnimator;\r\n\r\n\t\t\tif ( type == 1 ) {\r\n\r\n\t\t\t\tthisAnimator = {\r\n\t\t\t\t\tanimationSet: targetAnimationSet,\r\n\t\t\t\t\tskeleton: this._blocks[ props.get( 1, 0 ) ].data\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < targetMeshes.length; i ++ ) {\r\n\r\n\t\t\t\ttargetMeshes[ i ].animator = thisAnimator;\r\n\r\n\t\t\t}\r\n\t\t\t// debug(\"Parsed a Animator: Name = \" + name);\r\n\r\n\t\t\treturn thisAnimator;\r\n\r\n\t\t},\r\n\r\n\t\tparseMeshData: function ( len ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar name = this.readUTF(),\r\n\t\t\t\tnum_subs = this.readU16(),\r\n\t\t\t\tgeom,\r\n\t\t\t\tsubs_parsed = 0,\r\n\t\t\t\tbuffer,\r\n\t\t\t\tgeometries = [];\r\n\r\n\t\t\t// Ignore for now\r\n\t\t\tthis.parseProperties( { 1: this._geoNrType, 2: this._geoNrType } );\r\n\r\n\t\t\t// Loop through sub meshes\r\n\t\t\twhile ( subs_parsed < num_subs ) {\r\n\r\n\t\t\t\tvar sm_len, sm_end, attrib;\r\n\r\n\t\t\t\tgeom = new BufferGeometry();\r\n\t\t\t\tgeom.name = name;\r\n\t\t\t\tgeometries.push( geom );\r\n\r\n\t\t\t\tsm_len = this$1.readU32();\r\n\t\t\t\tsm_end = this$1._ptr + sm_len;\r\n\r\n\t\t\t\t// Ignore for now\r\n\t\t\t\tthis$1.parseProperties( { 1: this$1._geoNrType, 2: this$1._geoNrType } );\r\n\r\n\t\t\t\t// Loop through data streams\r\n\t\t\t\twhile ( this._ptr < sm_end ) {\r\n\r\n\t\t\t\t\tvar idx = 0,\r\n\t\t\t\t\t\tstr_type = this$1.readU8(),\r\n\t\t\t\t\t\tstr_ftype = this$1.readU8(),\r\n\t\t\t\t\t\tstr_len = this$1.readU32(),\r\n\t\t\t\t\t\tstr_end = str_len + this$1._ptr;\r\n\r\n\t\t\t\t\tif ( str_type === 1 ) {\r\n\r\n\t\t\t\t\t\t// VERTICES\r\n\r\n\t\t\t\t\t\tbuffer = new Float32Array( ( str_len / 12 ) * 3 );\r\n\t\t\t\t\t\tattrib = new BufferAttribute( buffer, 3 );\r\n\r\n\t\t\t\t\t\tgeom.addAttribute( 'position', attrib );\r\n\t\t\t\t\t\tidx = 0;\r\n\r\n\t\t\t\t\t\twhile ( this._ptr < str_end ) {\r\n\r\n\t\t\t\t\t\t\tbuffer[ idx ] = - this$1.readF32();\r\n\t\t\t\t\t\t\tbuffer[ idx + 1 ] = this$1.readF32();\r\n\t\t\t\t\t\t\tbuffer[ idx + 2 ] = this$1.readF32();\r\n\t\t\t\t\t\t\tidx += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( str_type === 2 ) {\r\n\r\n\t\t\t\t\t\t// INDICES\r\n\r\n\t\t\t\t\t\tbuffer = new Uint16Array( str_len / 2 );\r\n\t\t\t\t\t\tattrib = new BufferAttribute( buffer, 1 );\r\n\t\t\t\t\t\tgeom.setIndex( attrib );\r\n\r\n\t\t\t\t\t\tidx = 0;\r\n\r\n\t\t\t\t\t\twhile ( this._ptr < str_end ) {\r\n\r\n\t\t\t\t\t\t\tbuffer[ idx + 1 ] = this$1.readU16();\r\n\t\t\t\t\t\t\tbuffer[ idx ] = this$1.readU16();\r\n\t\t\t\t\t\t\tbuffer[ idx + 2 ] = this$1.readU16();\r\n\t\t\t\t\t\t\tidx += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( str_type === 3 ) {\r\n\r\n\t\t\t\t\t\t// UVS\r\n\r\n\t\t\t\t\t\tbuffer = new Float32Array( ( str_len / 8 ) * 2 );\r\n\t\t\t\t\t\tattrib = new BufferAttribute( buffer, 2 );\r\n\r\n\t\t\t\t\t\tgeom.addAttribute( 'uv', attrib );\r\n\t\t\t\t\t\tidx = 0;\r\n\r\n\t\t\t\t\t\twhile ( this._ptr < str_end ) {\r\n\r\n\t\t\t\t\t\t\tbuffer[ idx ] = this$1.readF32();\r\n\t\t\t\t\t\t\tbuffer[ idx + 1 ] = 1.0 - this$1.readF32();\r\n\t\t\t\t\t\t\tidx += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( str_type === 4 ) {\r\n\r\n\t\t\t\t\t\t// NORMALS\r\n\r\n\t\t\t\t\t\tbuffer = new Float32Array( ( str_len / 12 ) * 3 );\r\n\t\t\t\t\t\tattrib = new BufferAttribute( buffer, 3 );\r\n\t\t\t\t\t\tgeom.addAttribute( 'normal', attrib );\r\n\t\t\t\t\t\tidx = 0;\r\n\r\n\t\t\t\t\t\twhile ( this._ptr < str_end ) {\r\n\r\n\t\t\t\t\t\t\tbuffer[ idx ] = - this$1.readF32();\r\n\t\t\t\t\t\t\tbuffer[ idx + 1 ] = this$1.readF32();\r\n\t\t\t\t\t\t\tbuffer[ idx + 2 ] = this$1.readF32();\r\n\t\t\t\t\t\t\tidx += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis$1._ptr = str_end;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis$1.parseUserAttributes();\r\n\r\n\t\t\t\tgeom.computeBoundingSphere();\r\n\t\t\t\tsubs_parsed ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//geom.computeFaceNormals();\r\n\r\n\t\t\tthis.parseUserAttributes();\r\n\t\t\t//finalizeAsset(geom, name);\r\n\r\n\t\t\treturn geometries;\r\n\r\n\t\t},\r\n\r\n\t\tparseMeshPoseAnimation: function ( len, poseOnly ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar num_frames = 1,\r\n\t\t\t\tnum_submeshes,\r\n\t\t\t\tframes_parsed,\r\n\t\t\t\tsubMeshParsed,\r\n\t\t\t\tframe_dur,\r\n\t\t\t\tstr_len,\r\n\t\t\t\tstr_end,\r\n\t\t\t\tgeom,\r\n\t\t\t\tidx = 0,\r\n\t\t\t\tclip = {},\r\n\t\t\t\tnum_Streams,\r\n\t\t\t\tstreamsParsed,\r\n\t\t\t\tstreamtypes = [],\r\n\r\n\t\t\t\tprops,\r\n\t\t\t\tname = this.readUTF(),\r\n\t\t\t\tgeoAdress = this.readU32();\r\n\r\n\t\t\tvar mesh = this.getBlock( geoAdress );\r\n\r\n\t\t\tif ( mesh === null ) {\r\n\r\n\t\t\t\tconsole.log( \"parseMeshPoseAnimation target mesh not found at:\", geoAdress );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeom = mesh.geometry;\r\n\t\t\tgeom.morphTargets = [];\r\n\r\n\t\t\tif ( ! poseOnly )\r\n\t\t\t\t{ num_frames = this.readU16(); }\r\n\r\n\t\t\tnum_submeshes = this.readU16();\r\n\t\t\tnum_Streams = this.readU16();\r\n\r\n\t\t\t// debug(\"VA num_frames : \", num_frames );\r\n\t\t\t// debug(\"VA num_submeshes : \", num_submeshes );\r\n\t\t\t// debug(\"VA numstreams : \", num_Streams );\r\n\r\n\t\t\tstreamsParsed = 0;\r\n\t\t\twhile ( streamsParsed < num_Streams ) {\r\n\r\n\t\t\t\tstreamtypes.push( this$1.readU16() );\r\n\t\t\t\tstreamsParsed ++;\r\n\r\n\t\t\t}\r\n\t\t\tprops = this.parseProperties( { 1: BOOL, 2: BOOL } );\r\n\r\n\t\t\tclip.looping = props.get( 1, true );\r\n\t\t\tclip.stitchFinalFrame = props.get( 2, false );\r\n\r\n\t\t\tframes_parsed = 0;\r\n\r\n\t\t\twhile ( frames_parsed < num_frames ) {\r\n\r\n\t\t\t\tframe_dur = this$1.readU16();\r\n\t\t\t\tsubMeshParsed = 0;\r\n\r\n\t\t\t\twhile ( subMeshParsed < num_submeshes ) {\r\n\r\n\t\t\t\t\tstreamsParsed = 0;\r\n\t\t\t\t\tstr_len = this$1.readU32();\r\n\t\t\t\t\tstr_end = this$1._ptr + str_len;\r\n\r\n\t\t\t\t\twhile ( streamsParsed < num_Streams ) {\r\n\r\n\t\t\t\t\t\tif ( streamtypes[ streamsParsed ] === 1 ) {\r\n\r\n\t\t\t\t\t\t\t//geom.addAttribute( 'morphTarget'+frames_parsed, Float32Array, str_len/12, 3 );\r\n\t\t\t\t\t\t\tvar buffer = new Float32Array( str_len / 4 );\r\n\t\t\t\t\t\t\tgeom.morphTargets.push( {\r\n\t\t\t\t\t\t\t\tarray: buffer\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t\t//buffer = geom.attributes['morphTarget'+frames_parsed].array\r\n\t\t\t\t\t\t\tidx = 0;\r\n\r\n\t\t\t\t\t\t\twhile ( this._ptr < str_end ) {\r\n\r\n\t\t\t\t\t\t\t\tbuffer[ idx ] = this$1.readF32();\r\n\t\t\t\t\t\t\t\tbuffer[ idx + 1 ] = this$1.readF32();\r\n\t\t\t\t\t\t\t\tbuffer[ idx + 2 ] = this$1.readF32();\r\n\t\t\t\t\t\t\t\tidx += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tsubMeshParsed ++;\r\n\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t{ this$1._ptr = str_end; }\r\n\t\t\t\t\t\tstreamsParsed ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tframes_parsed ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.parseUserAttributes();\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t},\r\n\r\n\t\tgetBlock: function ( id ) {\r\n\r\n\t\t\treturn this._blocks[ id ].data;\r\n\r\n\t\t},\r\n\r\n\t\tparseMatrix4: function () {\r\n\r\n\t\t\tvar mtx = new Matrix4();\r\n\t\t\tvar e = mtx.elements;\r\n\r\n\t\t\te[ 0 ] = this.readF32();\r\n\t\t\te[ 1 ] = this.readF32();\r\n\t\t\te[ 2 ] = this.readF32();\r\n\t\t\te[ 3 ] = 0.0;\r\n\t\t\t//e[3] = 0.0;\r\n\r\n\t\t\te[ 4 ] = this.readF32();\r\n\t\t\te[ 5 ] = this.readF32();\r\n\t\t\te[ 6 ] = this.readF32();\r\n\t\t\t//e[7] = this.readF32();\r\n\t\t\te[ 7 ] = 0.0;\r\n\r\n\t\t\te[ 8 ] = this.readF32();\r\n\t\t\te[ 9 ] = this.readF32();\r\n\t\t\te[ 10 ] = this.readF32();\r\n\t\t\t//e[11] = this.readF32();\r\n\t\t\te[ 11 ] = 0.0;\r\n\r\n\t\t\te[ 12 ] = - this.readF32();\r\n\t\t\te[ 13 ] = this.readF32();\r\n\t\t\te[ 14 ] = this.readF32();\r\n\t\t\t//e[15] = this.readF32();\r\n\t\t\te[ 15 ] = 1.0;\r\n\t\t\treturn mtx;\r\n\r\n\t\t},\r\n\r\n\t\tparseProperties: function ( expected ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar list_len = this.readU32();\r\n\t\t\tvar list_end = this._ptr + list_len;\r\n\r\n\t\t\tvar props = new AWDProperties();\r\n\r\n\t\t\tif ( expected ) {\r\n\r\n\t\t\t\twhile ( this._ptr < list_end ) {\r\n\r\n\t\t\t\t\tvar key = this$1.readU16();\r\n\t\t\t\t\tvar len = this$1.readU32();\r\n\t\t\t\t\tvar type;\r\n\r\n\t\t\t\t\tif ( expected.hasOwnProperty( key ) ) {\r\n\r\n\t\t\t\t\t\ttype = expected[ key ];\r\n\t\t\t\t\t\tprops.set( key, this$1.parseAttrValue( type, len ) );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis$1._ptr += len;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn props;\r\n\r\n\t\t},\r\n\r\n\t\tparseUserAttributes: function () {\r\n\r\n\t\t\t// skip for now\r\n\t\t\tthis._ptr = this.readU32() + this._ptr;\r\n\t\t\treturn null;\r\n\r\n\t\t},\r\n\r\n\t\tparseAttrValue: function ( type, len ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar elem_len;\r\n\t\t\tvar read_func;\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase AWD_FIELD_INT8:\r\n\t\t\t\t\telem_len = 1;\r\n\t\t\t\t\tread_func = this.readI8;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase AWD_FIELD_INT16:\r\n\t\t\t\t\telem_len = 2;\r\n\t\t\t\t\tread_func = this.readI16;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase AWD_FIELD_INT32:\r\n\t\t\t\t\telem_len = 4;\r\n\t\t\t\t\tread_func = this.readI32;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase AWD_FIELD_BOOL:\r\n\t\t\t\tcase AWD_FIELD_UINT8:\r\n\t\t\t\t\telem_len = 1;\r\n\t\t\t\t\tread_func = this.readU8;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase AWD_FIELD_UINT16:\r\n\t\t\t\t\telem_len = 2;\r\n\t\t\t\t\tread_func = this.readU16;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase AWD_FIELD_UINT32:\r\n\t\t\t\tcase AWD_FIELD_BADDR:\r\n\t\t\t\t\telem_len = 4;\r\n\t\t\t\t\tread_func = this.readU32;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase AWD_FIELD_FLOAT32:\r\n\t\t\t\t\telem_len = 4;\r\n\t\t\t\t\tread_func = this.readF32;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase AWD_FIELD_FLOAT64:\r\n\t\t\t\t\telem_len = 8;\r\n\t\t\t\t\tread_func = this.readF64;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase AWD_FIELD_VECTOR2x1:\r\n\t\t\t\tcase AWD_FIELD_VECTOR3x1:\r\n\t\t\t\tcase AWD_FIELD_VECTOR4x1:\r\n\t\t\t\tcase AWD_FIELD_MTX3x2:\r\n\t\t\t\tcase AWD_FIELD_MTX3x3:\r\n\t\t\t\tcase AWD_FIELD_MTX4x3:\r\n\t\t\t\tcase AWD_FIELD_MTX4x4:\r\n\t\t\t\t\telem_len = 8;\r\n\t\t\t\t\tread_func = this.readF64;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( elem_len < len ) {\r\n\r\n\t\t\t\tvar list;\r\n\t\t\t\tvar num_read;\r\n\t\t\t\tvar num_elems;\r\n\r\n\t\t\t\tlist = [];\r\n\t\t\t\tnum_read = 0;\r\n\t\t\t\tnum_elems = len / elem_len;\r\n\r\n\t\t\t\twhile ( num_read < num_elems ) {\r\n\r\n\t\t\t\t\tlist.push( read_func.call( this$1 ) );\r\n\t\t\t\t\tnum_read ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn list;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn read_func.call( this );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\treadU8: function () {\r\n\r\n\t\t\treturn this._data.getUint8( this._ptr ++ );\r\n\r\n\t\t},\r\n\t\treadI8: function () {\r\n\r\n\t\t\treturn this._data.getInt8( this._ptr ++ );\r\n\r\n\t\t},\r\n\t\treadU16: function () {\r\n\r\n\t\t\tvar a = this._data.getUint16( this._ptr, littleEndian );\r\n\t\t\tthis._ptr += 2;\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\t\treadI16: function () {\r\n\r\n\t\t\tvar a = this._data.getInt16( this._ptr, littleEndian );\r\n\t\t\tthis._ptr += 2;\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\t\treadU32: function () {\r\n\r\n\t\t\tvar a = this._data.getUint32( this._ptr, littleEndian );\r\n\t\t\tthis._ptr += 4;\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\t\treadI32: function () {\r\n\r\n\t\t\tvar a = this._data.getInt32( this._ptr, littleEndian );\r\n\t\t\tthis._ptr += 4;\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\t\treadF32: function () {\r\n\r\n\t\t\tvar a = this._data.getFloat32( this._ptr, littleEndian );\r\n\t\t\tthis._ptr += 4;\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\t\treadF64: function () {\r\n\r\n\t\t\tvar a = this._data.getFloat64( this._ptr, littleEndian );\r\n\t\t\tthis._ptr += 8;\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\t\t\r\n\t\treadUTF: function () {\r\n\r\n\t\t\tvar len = this.readU16();\r\n\t\t\treturn this.readUTFBytes( len );\r\n\r\n\t\t},\r\n\t\t\r\n\t\treadUTFBytes: function ( len ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t// TODO(user): Use native implementations if/when available\r\n\t\t\tvar out = [], c = 0;\r\n\r\n\t\t\twhile ( out.length < len ) {\r\n\r\n\t\t\t\tvar c1 = this$1._data.getUint8( this$1._ptr ++, littleEndian );\r\n\t\t\t\tif ( c1 < 128 ) {\r\n\r\n\t\t\t\t\tout[ c ++ ] = String.fromCharCode( c1 );\r\n\r\n\t\t\t\t} else if ( c1 > 191 && c1 < 224 ) {\r\n\r\n\t\t\t\t\tvar c2 = this$1._data.getUint8( this$1._ptr ++, littleEndian );\r\n\t\t\t\t\tout[ c ++ ] = String.fromCharCode( ( c1 & 31 ) << 6 | c2 & 63 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvar c2 = this$1._data.getUint8( this$1._ptr ++, littleEndian );\r\n\t\t\t\t\tvar c3 = this$1._data.getUint8( this$1._ptr ++, littleEndian );\r\n\t\t\t\t\tout[ c ++ ] = String.fromCharCode( ( c1 & 15 ) << 12 | ( c2 & 63 ) << 6 | c3 & 63 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\treturn out.join( '' );\r\n\r\n\t\t}\r\n\r\n\t};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Light( color, intensity ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'Light';\r\n\r\n\tthis.color = new Color( color );\r\n\tthis.intensity = intensity !== undefined ? intensity : 1;\r\n\r\n\tthis.receiveShadow = undefined;\r\n\r\n}\r\n\r\nLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: Light,\r\n\r\n\tisLight: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tObject3D.prototype.copy.call( this, source );\r\n\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.intensity = source.intensity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\t\tdata.object.color = this.color.getHex();\r\n\t\tdata.object.intensity = this.intensity;\r\n\r\n\t\tif ( this.groundColor !== undefined ) { data.object.groundColor = this.groundColor.getHex(); }\r\n\r\n\t\tif ( this.distance !== undefined ) { data.object.distance = this.distance; }\r\n\t\tif ( this.angle !== undefined ) { data.object.angle = this.angle; }\r\n\t\tif ( this.decay !== undefined ) { data.object.decay = this.decay; }\r\n\t\tif ( this.penumbra !== undefined ) { data.object.penumbra = this.penumbra; }\r\n\r\n\t\tif ( this.shadow !== undefined ) { data.object.shadow = this.shadow.toJSON(); }\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LightShadow( camera ) {\r\n\r\n\tthis.camera = camera;\r\n\r\n\tthis.bias = 0;\r\n\tthis.radius = 1;\r\n\r\n\tthis.mapSize = new Vector2( 512, 512 );\r\n\r\n\tthis.map = null;\r\n\tthis.matrix = new Matrix4();\r\n\r\n}\r\n\r\nObject.assign( LightShadow.prototype, {\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.camera = source.camera.clone();\r\n\r\n\t\tthis.bias = source.bias;\r\n\t\tthis.radius = source.radius;\r\n\r\n\t\tthis.mapSize.copy( source.mapSize );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar object = {};\r\n\r\n\t\tif ( this.bias !== 0 ) { object.bias = this.bias; }\r\n\t\tif ( this.radius !== 1 ) { object.radius = this.radius; }\r\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) { object.mapSize = this.mapSize.toArray(); }\r\n\r\n\t\tobject.camera = this.camera.toJSON( false ).object;\r\n\t\tdelete object.camera.matrix;\r\n\r\n\t\treturn object;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PointLight( color, intensity, distance, decay ) {\r\n\r\n\tLight.call( this, color, intensity );\r\n\r\n\tthis.type = 'PointLight';\r\n\r\n\tObject.defineProperty( this, 'power', {\r\n\t\tget: function () {\r\n\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n\t\t\treturn this.intensity * 4 * Math.PI;\r\n\r\n\t\t},\r\n\t\tset: function ( power ) {\r\n\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\r\n\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\r\n\r\n}\r\n\r\nPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\r\n\r\n\tconstructor: PointLight,\r\n\r\n\tisPointLight: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tLight.prototype.copy.call( this, source );\r\n\r\n\t\tthis.distance = source.distance;\r\n\t\tthis.decay = source.decay;\r\n\r\n\t\tthis.shadow = source.shadow.clone();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction DirectionalLightShadow( ) {\r\n\r\n\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\r\n\r\n}\r\n\r\nDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\r\n\r\n\tconstructor: DirectionalLightShadow\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction DirectionalLight( color, intensity ) {\r\n\r\n\tLight.call( this, color, intensity );\r\n\r\n\tthis.type = 'DirectionalLight';\r\n\r\n\tthis.position.copy( Object3D.DefaultUp );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.target = new Object3D();\r\n\r\n\tthis.shadow = new DirectionalLightShadow();\r\n\r\n}\r\n\r\nDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\r\n\r\n\tconstructor: DirectionalLight,\r\n\r\n\tisDirectionalLight: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tLight.prototype.copy.call( this, source );\r\n\r\n\t\tthis.target = source.target.clone();\r\n\r\n\t\tthis.shadow = source.shadow.clone();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction SpotLightShadow() {\r\n\r\n\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\r\n\r\n}\r\n\r\nSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\r\n\r\n\tconstructor: SpotLightShadow,\r\n\r\n\tisSpotLightShadow: true,\r\n\r\n\tupdate: function ( light ) {\r\n\r\n\t\tvar camera = this.camera;\r\n\r\n\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\r\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\r\n\t\tvar far = light.distance || camera.far;\r\n\r\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\r\n\r\n\t\t\tcamera.fov = fov;\r\n\t\t\tcamera.aspect = aspect;\r\n\t\t\tcamera.far = far;\r\n\t\t\tcamera.updateProjectionMatrix();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\r\n\r\n\tLight.call( this, color, intensity );\r\n\r\n\tthis.type = 'SpotLight';\r\n\r\n\tthis.position.copy( Object3D.DefaultUp );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.target = new Object3D();\r\n\r\n\tObject.defineProperty( this, 'power', {\r\n\t\tget: function () {\r\n\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n\t\t\treturn this.intensity * Math.PI;\r\n\r\n\t\t},\r\n\t\tset: function ( power ) {\r\n\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n\t\t\tthis.intensity = power / Math.PI;\r\n\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n\tthis.shadow = new SpotLightShadow();\r\n\r\n}\r\n\r\nSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\r\n\r\n\tconstructor: SpotLight,\r\n\r\n\tisSpotLight: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tLight.prototype.copy.call( this, source );\r\n\r\n\t\tthis.distance = source.distance;\r\n\t\tthis.angle = source.angle;\r\n\t\tthis.penumbra = source.penumbra;\r\n\t\tthis.decay = source.decay;\r\n\r\n\t\tthis.target = source.target.clone();\r\n\r\n\t\tthis.shadow = source.shadow.clone();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction HemisphereLight( skyColor, groundColor, intensity ) {\r\n\r\n\tLight.call( this, skyColor, intensity );\r\n\r\n\tthis.type = 'HemisphereLight';\r\n\r\n\tthis.castShadow = undefined;\r\n\r\n\tthis.position.copy( Object3D.DefaultUp );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.groundColor = new Color( groundColor );\r\n\r\n}\r\n\r\nHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\r\n\r\n\tconstructor: HemisphereLight,\r\n\r\n\tisHemisphereLight: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tLight.prototype.copy.call( this, source );\r\n\r\n\t\tthis.groundColor.copy( source.groundColor );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BabylonLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nBabylonLoader.prototype = {\r\n\r\n\tconstructor: BabylonLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tfunction parseMaterials( json ) {\r\n\r\n\t\t\tvar materials = {};\r\n\r\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json.materials[ i ];\r\n\r\n\t\t\t\tvar material = new MeshPhongMaterial();\r\n\t\t\t\tmaterial.name = data.name;\r\n\t\t\t\tmaterial.color.fromArray( data.diffuse );\r\n\t\t\t\tmaterial.emissive.fromArray( data.emissive );\r\n\t\t\t\tmaterial.specular.fromArray( data.specular );\r\n\t\t\t\tmaterial.shininess = data.specularPower;\r\n\t\t\t\tmaterial.opacity = data.alpha;\r\n\r\n\t\t\t\tmaterials[ data.id ] = material;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.multiMaterials ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.multiMaterials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar data = json.multiMaterials[ i ];\r\n\r\n\t\t\t\t\tconsole.warn( 'BabylonLoader: Multi materials not yet supported.' );\r\n\r\n\t\t\t\t\tmaterials[ data.id ] = new MeshPhongMaterial();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn materials;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseGeometry( json ) {\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\tvar indices = json.indices;\r\n\t\t\tvar positions = json.positions;\r\n\t\t\tvar normals = json.normals;\r\n\t\t\tvar uvs = json.uvs;\r\n\r\n\t\t\t// indices\r\n\r\n\t\t\tgeometry.setIndex( indices );\r\n\r\n\t\t\t// positions\r\n\r\n\t\t\tfor ( var j = 2, jl = positions.length; j < jl; j += 3 ) {\r\n\r\n\t\t\t\tpositions[ j ] = - positions[ j ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\r\n\r\n\t\t\t// normals\r\n\r\n\t\t\tif ( normals ) {\r\n\r\n\t\t\t\tfor ( var j = 2, jl = normals.length; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\tnormals[ j ] = - normals[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// uvs\r\n\r\n\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// offsets\r\n\r\n\t\t\tvar subMeshes = json.subMeshes;\r\n\r\n\t\t\tif ( subMeshes ) {\r\n\r\n\t\t\t\tfor ( var j = 0, jl = subMeshes.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar subMesh = subMeshes[ j ];\r\n\r\n\t\t\t\t\tgeometry.addGroup( subMesh.indexStart, subMesh.indexCount );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseObjects( json, materials ) {\r\n\r\n\t\t\tvar objects = {};\r\n\t\t\tvar scene = new Scene();\r\n\r\n\t\t\tvar cameras = json.cameras;\r\n\r\n\t\t\tfor ( var i = 0, l = cameras.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = cameras[ i ];\r\n\r\n\t\t\t\tvar camera = new PerspectiveCamera( ( data.fov / Math.PI ) * 180, 1.33, data.minZ, data.maxZ );\r\n\r\n\t\t\t\tcamera.name = data.name;\r\n\t\t\t\tcamera.position.fromArray( data.position );\r\n\t\t\t\tif ( data.rotation ) { camera.rotation.fromArray( data.rotation ); }\r\n\r\n\t\t\t\tobjects[ data.id ] = camera;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar lights = json.lights;\r\n\r\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = lights[ i ];\r\n\r\n\t\t\t\tvar light;\r\n\r\n\t\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tlight = new PointLight();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tlight = new DirectionalLight();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tlight = new SpotLight();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tlight = new HemisphereLight();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlight.name = data.name;\r\n\t\t\t\tif ( data.position ) { light.position.set( data.position[ 0 ], data.position[ 1 ], - data.position[ 2 ] ); }\r\n\t\t\t\tlight.color.fromArray( data.diffuse );\r\n\t\t\t\tif ( data.groundColor ) { light.groundColor.fromArray( data.groundColor ); }\r\n\t\t\t\tif ( data.intensity ) { light.intensity = data.intensity; }\r\n\r\n\t\t\t\tobjects[ data.id ] = light;\r\n\r\n\t\t\t\tscene.add( light );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar meshes = json.meshes;\r\n\r\n\t\t\tfor ( var i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = meshes[ i ];\r\n\r\n\t\t\t\tvar object;\r\n\r\n\t\t\t\tif ( data.indices ) {\r\n\r\n\t\t\t\t\tvar geometry = parseGeometry( data );\r\n\r\n\t\t\t\t\tobject = new Mesh( geometry, materials[ data.materialId ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tobject = new Group();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.name = data.name;\r\n\t\t\t\tobject.position.set( data.position[ 0 ], data.position[ 1 ], - data.position[ 2 ] );\r\n\t\t\t\tobject.rotation.fromArray( data.rotation );\r\n\t\t\t\tif ( data.rotationQuaternion ) { object.quaternion.fromArray( data.rotationQuaternion ); }\r\n\t\t\t\tobject.scale.fromArray( data.scaling );\r\n\t\t\t\t// object.visible = data.isVisible;\r\n\r\n\t\t\t\tif ( data.parentId ) {\r\n\r\n\t\t\t\t\tobjects[ data.parentId ].add( object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tscene.add( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobjects[ data.id ] = object;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn scene;\r\n\r\n\t\t}\r\n\r\n\t\tvar materials = parseMaterials( json );\r\n\t\tvar scene = parseObjects( json, materials );\r\n\r\n\t\treturn scene;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BVHLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\tthis.animateBonePositions = true;\r\n\tthis.animateBoneRotations = true;\r\n\r\n};\r\n\r\nBVHLoader.prototype = {\r\n\r\n\tconstructor: BVHLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( text ) {\r\n\t\t\r\n\t\tfunction readBvh( lines ) {\r\n\r\n\t\t\t// read model structure\r\n\r\n\t\t\tif ( nextLine( lines ) !== 'HIERARCHY' ) {\r\n\r\n\t\t\t\tconsole.error( 'BVHLoader: HIERARCHY expected.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar list = []; // collects flat array of all bones\r\n\t\t\tvar root = readNode( lines, nextLine( lines ), list );\r\n\r\n\t\t\t// read motion data\r\n\r\n\t\t\tif ( nextLine( lines ) !== 'MOTION' ) {\r\n\r\n\t\t\t\tconsole.error( 'BVHLoader: MOTION expected.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// number of frames\r\n\r\n\t\t\tvar tokens = nextLine( lines ).split( /[\\s]+/ );\r\n\t\t\tvar numFrames = parseInt( tokens[ 1 ] );\r\n\r\n\t\t\tif ( isNaN( numFrames ) ) {\r\n\r\n\t\t\t\tconsole.error( 'BVHLoader: Failed to read number of frames.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// frame time\r\n\r\n\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\r\n\t\t\tvar frameTime = parseFloat( tokens[ 2 ] );\r\n\r\n\t\t\tif ( isNaN( frameTime ) ) {\r\n\r\n\t\t\t\tconsole.error( 'BVHLoader: Failed to read frame time.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// read frame data line by line\r\n\r\n\t\t\tfor ( var i = 0; i < numFrames; i ++ ) {\r\n\r\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\r\n\t\t\t\treadFrameData( tokens, i * frameTime, root );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn list;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction readFrameData( data, frameTime, bone ) {\r\n\r\n\t\t\t// end sites have no motion data\r\n\r\n\t\t\tif ( bone.type === 'ENDSITE' ) { return; }\r\n\r\n\t\t\t// add keyframe\r\n\r\n\t\t\tvar keyframe = {\r\n\t\t\t\ttime: frameTime,\r\n\t\t\t\tposition: new Vector3(),\r\n\t\t\t\trotation: new Quaternion()\r\n\t\t\t};\r\n\r\n\t\t\tbone.frames.push( keyframe );\r\n\r\n\t\t\tvar quat = new Quaternion();\r\n\r\n\t\t\tvar vx = new Vector3( 1, 0, 0 );\r\n\t\t\tvar vy = new Vector3( 0, 1, 0 );\r\n\t\t\tvar vz = new Vector3( 0, 0, 1 );\r\n\r\n\t\t\t// parse values for each channel in node\r\n\r\n\t\t\tfor ( var i = 0; i < bone.channels.length; i ++ ) {\r\n\r\n\t\t\t\tswitch ( bone.channels[ i ] ) {\r\n\r\n\t\t\t\t\tcase 'Xposition':\r\n\t\t\t\t\t\tkeyframe.position.x = parseFloat( data.shift().trim() );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'Yposition':\r\n\t\t\t\t\t\tkeyframe.position.y = parseFloat( data.shift().trim() );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'Zposition':\r\n\t\t\t\t\t\tkeyframe.position.z = parseFloat( data.shift().trim() );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'Xrotation':\r\n\t\t\t\t\t\tquat.setFromAxisAngle( vx, parseFloat( data.shift().trim() ) * Math.PI / 180 );\r\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'Yrotation':\r\n\t\t\t\t\t\tquat.setFromAxisAngle( vy, parseFloat( data.shift().trim() ) * Math.PI / 180 );\r\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'Zrotation':\r\n\t\t\t\t\t\tquat.setFromAxisAngle( vz, parseFloat( data.shift().trim() ) * Math.PI / 180 );\r\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.warn( 'BVHLoader: Invalid channel type.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// parse child nodes\r\n\r\n\t\t\tfor ( var i = 0; i < bone.children.length; i ++ ) {\r\n\r\n\t\t\t\treadFrameData( data, frameTime, bone.children[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction readNode( lines, firstline, list ) {\r\n\r\n\t\t\tvar node = { name: '', type: '', frames: [] };\r\n\t\t\tlist.push( node );\r\n\r\n\t\t\t// parse node type and name\r\n\r\n\t\t\tvar tokens = firstline.split( /[\\s]+/ );\r\n\r\n\t\t\tif ( tokens[ 0 ].toUpperCase() === 'END' && tokens[ 1 ].toUpperCase() === 'SITE' ) {\r\n\r\n\t\t\t\tnode.type = 'ENDSITE';\r\n\t\t\t\tnode.name = 'ENDSITE'; // bvh end sites have no name\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode.name = tokens[ 1 ];\r\n\t\t\t\tnode.type = tokens[ 0 ].toUpperCase();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nextLine( lines ) !== '{' ) {\r\n\r\n\t\t\t\tconsole.error( 'BVHLoader: Expected opening { after type & name' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// parse OFFSET\r\n\r\n\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\r\n\r\n\t\t\tif ( tokens[ 0 ] !== 'OFFSET' ) {\r\n\r\n\t\t\t\tconsole.error( 'BVHLoader: Expected OFFSET but got: ' + tokens[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tokens.length !== 4 ) {\r\n\r\n\t\t\t\tconsole.error( 'BVHLoader: Invalid number of values for OFFSET.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar offset = new Vector3(\r\n\t\t\t\tparseFloat( tokens[ 1 ] ),\r\n\t\t\t\tparseFloat( tokens[ 2 ] ),\r\n\t\t\t\tparseFloat( tokens[ 3 ] )\r\n\t\t\t);\r\n\r\n\t\t\tif ( isNaN( offset.x ) || isNaN( offset.y ) || isNaN( offset.z ) ) {\r\n\r\n\t\t\t\tconsole.error( 'BVHLoader: Invalid values of OFFSET.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnode.offset = offset;\r\n\r\n\t\t\t// parse CHANNELS definitions\r\n\r\n\t\t\tif ( node.type !== 'ENDSITE' ) {\r\n\r\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\r\n\r\n\t\t\t\tif ( tokens[ 0 ] !== 'CHANNELS' ) {\r\n\r\n\t\t\t\t\tconsole.error( 'BVHLoader: Expected CHANNELS definition.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar numChannels = parseInt( tokens[ 1 ] );\r\n\t\t\t\tnode.channels = tokens.splice( 2, numChannels );\r\n\t\t\t\tnode.children = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// read children\r\n\r\n\t\t\twhile ( true ) {\r\n\r\n\t\t\t\tvar line = nextLine( lines );\r\n\r\n\t\t\t\tif ( line === '}' ) {\r\n\r\n\t\t\t\t\treturn node;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnode.children.push( readNode( lines, line, list ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction toTHREEBone( source, list ) {\r\n\r\n\t\t\tvar bone = new Bone();\r\n\t\t\tlist.push( bone );\r\n\r\n\t\t\tbone.position.add( source.offset );\r\n\t\t\tbone.name = source.name;\r\n\r\n\t\t\tif ( source.type !== 'ENDSITE' ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\r\n\r\n\t\t\t\t\tbone.add( toTHREEBone( source.children[ i ], list ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn bone;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction toTHREEAnimation( bones ) {\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\t// create a position and quaternion animation track for each node\r\n\r\n\t\t\tfor ( var i = 0; i < bones.length; i ++ ) {\r\n\r\n\t\t\t\tvar bone = bones[ i ];\r\n\r\n\t\t\t\tif ( bone.type === 'ENDSITE' )\r\n\t\t\t\t\t{ continue; }\r\n\r\n\t\t\t\t// track data\r\n\r\n\t\t\t\tvar times = [];\r\n\t\t\t\tvar positions = [];\r\n\t\t\t\tvar rotations = [];\r\n\r\n\t\t\t\tfor ( var j = 0; j < bone.frames.length; j ++ ) {\r\n\r\n\t\t\t\t\tvar frame = bone.frames[ j ];\r\n\r\n\t\t\t\t\ttimes.push( frame.time );\r\n\r\n\t\t\t\t\t// the animation system animates the position property,\r\n\t\t\t\t\t// so we have to add the joint offset to all values\r\n\r\n\t\t\t\t\tpositions.push( frame.position.x + bone.offset.x );\r\n\t\t\t\t\tpositions.push( frame.position.y + bone.offset.y );\r\n\t\t\t\t\tpositions.push( frame.position.z + bone.offset.z );\r\n\r\n\t\t\t\t\trotations.push( frame.rotation.x );\r\n\t\t\t\t\trotations.push( frame.rotation.y );\r\n\t\t\t\t\trotations.push( frame.rotation.z );\r\n\t\t\t\t\trotations.push( frame.rotation.w );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( scope.animateBonePositions ) {\r\n\r\n\t\t\t\t\ttracks.push( new VectorKeyframeTrack$1( '.bones[' + bone.name + '].position', times, positions ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( scope.animateBoneRotations ) {\r\n\r\n\t\t\t\t\ttracks.push( new QuaternionKeyframeTrack$1( '.bones[' + bone.name + '].quaternion', times, rotations ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new AnimationClip( 'animation', - 1, tracks );\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction nextLine( lines ) {\r\n\r\n\t\t\tvar line;\r\n\t\t\t// skip empty lines\r\n\t\t\twhile ( ( line = lines.shift().trim() ).length === 0 ) { }\r\n\t\t\treturn line;\r\n\r\n\t\t}\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar lines = text.split( /[\\r\\n]+/g );\r\n\r\n\t\tvar bones = readBvh( lines );\r\n\r\n\t\tvar threeBones = [];\r\n\t\ttoTHREEBone( bones[ 0 ], threeBones );\r\n\r\n\t\tvar threeClip = toTHREEAnimation( bones );\r\n\r\n\t\treturn {\r\n\t\t\tskeleton: new Skeleton( threeBones ),\r\n\t\t\tclip: threeClip\r\n\t\t};\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AmbientLight( color, intensity ) {\r\n\r\n\tLight.call( this, color, intensity );\r\n\r\n\tthis.type = 'AmbientLight';\r\n\r\n\tthis.castShadow = undefined;\r\n\r\n}\r\n\r\nAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\r\n\r\n\tconstructor: AmbientLight,\r\n\r\n\tisAmbientLight: true\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LineSegments( geometry, material ) {\r\n\r\n\tLine.call( this, geometry, material );\r\n\r\n\tthis.type = 'LineSegments';\r\n\r\n}\r\n\r\nLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\r\n\r\n\tconstructor: LineSegments,\r\n\r\n\tisLineSegments: true,\r\n\r\n\tcomputeLineDistances: ( function () {\r\n\r\n\t\tvar start = new Vector3();\r\n\t\tvar end = new Vector3();\r\n\r\n\t\treturn function computeLineDistances() {\r\n\r\n\t\t\tvar geometry = this.geometry;\r\n\r\n\t\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t// we assume non-indexed geometry\r\n\r\n\t\t\t\tif ( geometry.index === null ) {\r\n\r\n\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\r\n\t\t\t\t\tvar lineDistances = [];\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {\r\n\r\n\t\t\t\t\t\tstart.fromBufferAttribute( positionAttribute, i );\r\n\t\t\t\t\t\tend.fromBufferAttribute( positionAttribute, i + 1 );\r\n\r\n\t\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\r\n\t\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( geometry.isGeometry ) {\r\n\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar lineDistances = geometry.lineDistances;\r\n\r\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\t\tstart.copy( vertices[ i ] );\r\n\t\t\t\t\tend.copy( vertices[ i + 1 ] );\r\n\r\n\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\r\n\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}() )\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TGALoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nTGALoader.prototype = {\r\n\r\n\tconstructor: TGALoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texture = new Texture();\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.setPath( this.path );\r\n\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\ttexture.image = scope.parse( buffer );\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\t\tonLoad( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tparse: function ( buffer ) {\r\n\r\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\r\n\r\n\t\tfunction tgaCheckHeader( header ) {\r\n\r\n\t\t\tswitch ( header.image_type ) {\r\n\r\n\t\t\t\t// check indexed type\r\n\r\n\t\t\t\tcase TGA_TYPE_INDEXED:\r\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\r\n\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'TGALoader: Invalid type colormap data for indexed type.' );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// check colormap type\r\n\r\n\t\t\t\tcase TGA_TYPE_RGB:\r\n\t\t\t\tcase TGA_TYPE_GREY:\r\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\r\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\r\n\t\t\t\t\tif ( header.colormap_type ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'TGALoader: Invalid type colormap data for colormap type.' );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// What the need of a file without data ?\r\n\r\n\t\t\t\tcase TGA_TYPE_NO_DATA:\r\n\t\t\t\t\tconsole.error( 'TGALoader: No data.' );\r\n\r\n\t\t\t\t// Invalid type ?\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tconsole.error( 'TGALoader: Invalid type \"%s\".', header.image_type );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check image width and height\r\n\r\n\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\r\n\r\n\t\t\t\tconsole.error( 'TGALoader: Invalid image size.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check image pixel size\r\n\r\n\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\r\n\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\r\n\r\n\t\t\t\tconsole.error( 'TGALoader: Invalid pixel size \"%s\".', header.pixel_size );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// parse tga image buffer\r\n\r\n\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\r\n\r\n\t\t\tvar pixel_data,\r\n\t\t\t\tpixel_size,\r\n\t\t\t\tpixel_total,\r\n\t\t\t\tpalettes;\r\n\r\n\t\t\tpixel_size = header.pixel_size >> 3;\r\n\t\t\tpixel_total = header.width * header.height * pixel_size;\r\n\r\n\t\t\t // read palettes\r\n\r\n\t\t\t if ( use_pal ) {\r\n\r\n\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\r\n\r\n\t\t\t }\r\n\r\n\t\t\t // read RLE\r\n\r\n\t\t\t if ( use_rle ) {\r\n\r\n\t\t\t\t pixel_data = new Uint8Array( pixel_total );\r\n\r\n\t\t\t\tvar c, count, i;\r\n\t\t\t\tvar shift = 0;\r\n\t\t\t\tvar pixels = new Uint8Array( pixel_size );\r\n\r\n\t\t\t\twhile ( shift < pixel_total ) {\r\n\r\n\t\t\t\t\tc = data[ offset ++ ];\r\n\t\t\t\t\tcount = ( c & 0x7f ) + 1;\r\n\r\n\t\t\t\t\t// RLE pixels\r\n\r\n\t\t\t\t\tif ( c & 0x80 ) {\r\n\r\n\t\t\t\t\t\t// bind pixel tmp array\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\r\n\r\n\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// copy pixel array\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\r\n\r\n\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tshift += pixel_size * count;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// raw pixels\r\n\r\n\t\t\t\t\t\tcount *= pixel_size;\r\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\r\n\r\n\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tshift += count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t } else {\r\n\r\n\t\t\t\t// raw pixels\r\n\r\n\t\t\t\tpixel_data = data.subarray(\r\n\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\r\n\t\t\t\t);\r\n\r\n\t\t\t }\r\n\r\n\t\t\t return {\r\n\t\t\t\tpixel_data: pixel_data,\r\n\t\t\t\tpalettes: palettes\r\n\t\t\t };\r\n\r\n\t\t}\r\n\r\n\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\r\n\r\n\t\t\tvar colormap = palettes;\r\n\t\t\tvar color, i = 0, x, y;\r\n\t\t\tvar width = header.width;\r\n\r\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\r\n\r\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\r\n\r\n\t\t\t\t\tcolor = image[ i ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn imageData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\r\n\r\n\t\t\tvar color, i = 0, x, y;\r\n\t\t\tvar width = header.width;\r\n\r\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\r\n\r\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\r\n\r\n\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn imageData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\r\n\r\n\t\t\tvar i = 0, x, y;\r\n\t\t\tvar width = header.width;\r\n\r\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\r\n\r\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\r\n\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn imageData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\r\n\r\n\t\t\tvar i = 0, x, y;\r\n\t\t\tvar width = header.width;\r\n\r\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\r\n\r\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\r\n\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn imageData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\r\n\r\n\t\t\tvar color, i = 0, x, y;\r\n\t\t\tvar width = header.width;\r\n\r\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\r\n\r\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\r\n\r\n\t\t\t\t\tcolor = image[ i ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn imageData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\r\n\r\n\t\t\tvar i = 0, x, y;\r\n\t\t\tvar width = header.width;\r\n\r\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\r\n\r\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\r\n\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\r\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn imageData;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\r\n\r\n\t\t\tvar x_start,\r\n\t\t\t\ty_start,\r\n\t\t\t\tx_step,\r\n\t\t\t\ty_step,\r\n\t\t\t\tx_end,\r\n\t\t\t\ty_end;\r\n\r\n\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\tcase TGA_ORIGIN_UL:\r\n\t\t\t\t\tx_start = 0;\r\n\t\t\t\t\tx_step = 1;\r\n\t\t\t\t\tx_end = width;\r\n\t\t\t\t\ty_start = 0;\r\n\t\t\t\t\ty_step = 1;\r\n\t\t\t\t\ty_end = height;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase TGA_ORIGIN_BL:\r\n\t\t\t\t\tx_start = 0;\r\n\t\t\t\t\tx_step = 1;\r\n\t\t\t\t\tx_end = width;\r\n\t\t\t\t\ty_start = height - 1;\r\n\t\t\t\t\ty_step = - 1;\r\n\t\t\t\t\ty_end = - 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase TGA_ORIGIN_UR:\r\n\t\t\t\t\tx_start = width - 1;\r\n\t\t\t\t\tx_step = - 1;\r\n\t\t\t\t\tx_end = - 1;\r\n\t\t\t\t\ty_start = 0;\r\n\t\t\t\t\ty_step = 1;\r\n\t\t\t\t\ty_end = height;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase TGA_ORIGIN_BR:\r\n\t\t\t\t\tx_start = width - 1;\r\n\t\t\t\t\tx_step = - 1;\r\n\t\t\t\t\tx_end = - 1;\r\n\t\t\t\t\ty_start = height - 1;\r\n\t\t\t\t\ty_step = - 1;\r\n\t\t\t\t\ty_end = - 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( use_grey ) {\r\n\r\n\t\t\t\tswitch ( header.pixel_size ) {\r\n\r\n\t\t\t\t\tcase 8:\r\n\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 16:\r\n\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.error( 'TGALoader: Format not supported.' );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tswitch ( header.pixel_size ) {\r\n\r\n\t\t\t\t\tcase 8:\r\n\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 16:\r\n\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 24:\r\n\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 32:\r\n\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.error( 'TGALoader: Format not supported.' );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Load image data according to specific method\r\n\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\r\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\t// TGA constants\r\n\r\n\t\tvar TGA_TYPE_NO_DATA = 0,\r\n\t\t\tTGA_TYPE_INDEXED = 1,\r\n\t\t\tTGA_TYPE_RGB = 2,\r\n\t\t\tTGA_TYPE_GREY = 3,\r\n\t\t\tTGA_TYPE_RLE_INDEXED = 9,\r\n\t\t\tTGA_TYPE_RLE_RGB = 10,\r\n\t\t\tTGA_TYPE_RLE_GREY = 11,\r\n\r\n\t\t\tTGA_ORIGIN_MASK = 0x30,\r\n\t\t\tTGA_ORIGIN_SHIFT = 0x04,\r\n\t\t\tTGA_ORIGIN_BL = 0x00,\r\n\t\t\tTGA_ORIGIN_BR = 0x01,\r\n\t\t\tTGA_ORIGIN_UL = 0x02,\r\n\t\t\tTGA_ORIGIN_UR = 0x03;\r\n\r\n\t\tif ( buffer.length < 19 ) { console.error( 'TGALoader: Not enough data to contain header.' ); }\r\n\r\n\t\tvar content = new Uint8Array( buffer ),\r\n\t\t\toffset = 0,\r\n\t\t\theader = {\r\n\t\t\t\tid_length: content[ offset ++ ],\r\n\t\t\t\tcolormap_type: content[ offset ++ ],\r\n\t\t\t\timage_type: content[ offset ++ ],\r\n\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\r\n\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\r\n\t\t\t\tcolormap_size: content[ offset ++ ],\r\n\t\t\t\torigin: [\r\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\r\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\r\n\t\t\t\t],\r\n\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\r\n\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\r\n\t\t\t\tpixel_size: content[ offset ++ ],\r\n\t\t\t\tflags: content[ offset ++ ]\r\n\t\t\t};\r\n\r\n\t\t\t// check tga if it is valid format\r\n\r\n\t\ttgaCheckHeader( header );\r\n\r\n\t\tif ( header.id_length + offset > buffer.length ) {\r\n\r\n\t\t\tconsole.error( 'TGALoader: No data.' );\r\n\r\n\t\t}\r\n\r\n\t\t// skip the needn't data\r\n\r\n\t\toffset += header.id_length;\r\n\r\n\t\t// get targa information about RLE compression and palette\r\n\r\n\t\tvar use_rle = false,\r\n\t\t\tuse_pal = false,\r\n\t\t\tuse_grey = false;\r\n\r\n\t\tswitch ( header.image_type ) {\r\n\r\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\r\n\t\t\t\tuse_rle = true;\r\n\t\t\t\tuse_pal = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TGA_TYPE_INDEXED:\r\n\t\t\t\tuse_pal = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TGA_TYPE_RLE_RGB:\r\n\t\t\t\tuse_rle = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TGA_TYPE_RGB:\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TGA_TYPE_RLE_GREY:\r\n\t\t\t\tuse_rle = true;\r\n\t\t\t\tuse_grey = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TGA_TYPE_GREY:\r\n\t\t\t\tuse_grey = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = header.width;\r\n\t\tcanvas.height = header.height;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tvar imageData = context.createImageData( header.width, header.height );\r\n\r\n\t\tvar result = tgaParse( use_rle, use_pal, header, offset, content );\r\n\t\tvar rgbaData = getTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );\r\n\r\n\t\tcontext.putImageData( imageData, 0, 0 );\r\n\r\n\t\treturn canvas;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ColladaLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nColladaLoader.prototype = {\r\n\r\n\tconstructor: ColladaLoader,\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar path = scope.path === undefined ? LoaderUtils.extractUrlBase( url ) : scope.path;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text, path ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\toptions: {\r\n\r\n\t\tset convertUpAxis( value ) {\r\n\r\n\t\t\tconsole.warn( 'ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tparse: function ( text, path ) {\r\n\r\n\t\tfunction getElementsByTagName( xml, name ) {\r\n\r\n\t\t\t// Non recursive xml.getElementsByTagName() ...\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar childNodes = xml.childNodes;\r\n\r\n\t\t\tfor ( var i = 0, l = childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeName === name ) {\r\n\r\n\t\t\t\t\tarray.push( child );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseStrings( text ) {\r\n\r\n\t\t\tif ( text.length === 0 ) { return []; }\r\n\r\n\t\t\tvar parts = text.trim().split( /\\s+/ );\r\n\t\t\tvar array = new Array( parts.length );\r\n\r\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = parts[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseFloats( text ) {\r\n\r\n\t\t\tif ( text.length === 0 ) { return []; }\r\n\r\n\t\t\tvar parts = text.trim().split( /\\s+/ );\r\n\t\t\tvar array = new Array( parts.length );\r\n\r\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseInts( text ) {\r\n\r\n\t\t\tif ( text.length === 0 ) { return []; }\r\n\r\n\t\t\tvar parts = text.trim().split( /\\s+/ );\r\n\t\t\tvar array = new Array( parts.length );\r\n\r\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseId( text ) {\r\n\r\n\t\t\treturn text.substring( 1 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction generateId() {\r\n\r\n\t\t\treturn 'three_default_' + ( count ++ );\r\n\r\n\t\t}\r\n\r\n\t\tfunction isEmpty( object ) {\r\n\r\n\t\t\treturn Object.keys( object ).length === 0;\r\n\r\n\t\t}\r\n\r\n\t\t// asset\r\n\r\n\t\tfunction parseAsset( xml ) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\r\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseAssetUnit( xml ) {\r\n\r\n\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\r\n\r\n\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn 1; // default 1 meter\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseAssetUpAxis( xml ) {\r\n\r\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\r\n\r\n\t\t}\r\n\r\n\t\t// library\r\n\r\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\r\n\r\n\t\t\tvar library = getElementsByTagName( xml, libraryName )[ 0 ];\r\n\r\n\t\t\tif ( library !== undefined ) {\r\n\r\n\t\t\t\tvar elements = getElementsByTagName( library, nodeName );\r\n\r\n\t\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\r\n\r\n\t\t\t\t\tparser( elements[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildLibrary( data, builder ) {\r\n\r\n\t\t\tfor ( var name in data ) {\r\n\r\n\t\t\t\tvar object = data[ name ];\r\n\t\t\t\tobject.build = builder( data[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// get\r\n\r\n\t\tfunction getBuild( data, builder ) {\r\n\r\n\t\t\tif ( data.build !== undefined ) { return data.build; }\r\n\r\n\t\t\tdata.build = builder( data );\r\n\r\n\t\t\treturn data.build;\r\n\r\n\t\t}\r\n\r\n\t\t// animation\r\n\r\n\t\tfunction parseAnimation( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tsources: {},\r\n\t\t\t\tsamplers: {},\r\n\t\t\t\tchannels: {}\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tvar id;\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'source':\r\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\r\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'sampler':\r\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\r\n\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'channel':\r\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\r\n\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.log( child );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseAnimationSampler( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tinputs: {},\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'input':\r\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\r\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\r\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseAnimationChannel( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tvar target = xml.getAttribute( 'target' );\r\n\r\n\t\t\t// parsing SID Addressing Syntax\r\n\r\n\t\t\tvar parts = target.split( '/' );\r\n\r\n\t\t\tvar id = parts.shift();\r\n\t\t\tvar sid = parts.shift();\r\n\r\n\t\t\t// check selection syntax\r\n\r\n\t\t\tvar arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\r\n\t\t\tvar memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\r\n\r\n\t\t\tif ( memberSyntax ) {\r\n\r\n\t\t\t\t//  member selection access\r\n\r\n\t\t\t\tparts = sid.split( '.' );\r\n\t\t\t\tsid = parts.shift();\r\n\t\t\t\tdata.member = parts.shift();\r\n\r\n\t\t\t} else if ( arraySyntax ) {\r\n\r\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\r\n\r\n\t\t\t\tvar indices = sid.split( '(' );\r\n\t\t\t\tsid = indices.shift();\r\n\r\n\t\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\r\n\r\n\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.indices = indices;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdata.id = id;\r\n\t\t\tdata.sid = sid;\r\n\r\n\t\t\tdata.arraySyntax = arraySyntax;\r\n\t\t\tdata.memberSyntax = memberSyntax;\r\n\r\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildAnimation( data ) {\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\tvar channels = data.channels;\r\n\t\t\tvar samplers = data.samplers;\r\n\t\t\tvar sources = data.sources;\r\n\r\n\t\t\tfor ( var target in channels ) {\r\n\r\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\r\n\r\n\t\t\t\t\tvar channel = channels[ target ];\r\n\t\t\t\t\tvar sampler = samplers[ channel.sampler ];\r\n\r\n\t\t\t\t\tvar inputId = sampler.inputs.INPUT;\r\n\t\t\t\t\tvar outputId = sampler.inputs.OUTPUT;\r\n\r\n\t\t\t\t\tvar inputSource = sources[ inputId ];\r\n\t\t\t\t\tvar outputSource = sources[ outputId ];\r\n\r\n\t\t\t\t\tvar animation = buildAnimationChannel( channel, inputSource, outputSource );\r\n\r\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn tracks;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getAnimation( id ) {\r\n\r\n\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\r\n\r\n\t\t\tvar node = library.nodes[ channel.id ];\r\n\t\t\tvar object3D = getNode( node.id );\r\n\r\n\t\t\tvar transform = node.transforms[ channel.sid ];\r\n\t\t\tvar defaultMatrix = node.matrix.clone().transpose();\r\n\r\n\t\t\tvar time, stride;\r\n\t\t\tvar i, il, j, jl;\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\t// the collada spec allows the animation of data in various ways.\r\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\r\n\r\n\t\t\tswitch ( transform ) {\r\n\r\n\t\t\t\tcase 'matrix':\r\n\r\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\ttime = inputSource.array[ i ];\r\n\t\t\t\t\t\tstride = i * outputSource.stride;\r\n\r\n\t\t\t\t\t\tif ( data[ time ] === undefined ) { data[ time ] = {}; }\r\n\r\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\r\n\r\n\t\t\t\t\t\t\tvar value = outputSource.array[ stride ];\r\n\t\t\t\t\t\t\tvar index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\r\n\r\n\t\t\t\t\t\t\tdata[ time ][ index ] = value;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'translate':\r\n\t\t\t\t\tconsole.warn( 'ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'rotate':\r\n\t\t\t\t\tconsole.warn( 'ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'scale':\r\n\t\t\t\t\tconsole.warn( 'ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar keyframes = prepareAnimationData( data, defaultMatrix );\r\n\r\n\t\t\tvar animation = {\r\n\t\t\t\tname: object3D.uuid,\r\n\t\t\t\tkeyframes: keyframes\r\n\t\t\t};\r\n\r\n\t\t\treturn animation;\r\n\r\n\t\t}\r\n\r\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\r\n\r\n\t\t\tvar keyframes = [];\r\n\r\n\t\t\t// transfer data into a sortable array\r\n\r\n\t\t\tfor ( var time in data ) {\r\n\r\n\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// ensure keyframes are sorted by time\r\n\r\n\t\t\tkeyframes.sort( ascending );\r\n\r\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\r\n\r\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn keyframes;\r\n\r\n\t\t\t// array sort function\r\n\r\n\t\t\tfunction ascending( a, b ) {\r\n\r\n\t\t\t\treturn a.time - b.time;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar position = new Vector3();\r\n\t\tvar scale = new Vector3();\r\n\t\tvar quaternion = new Quaternion();\r\n\r\n\t\tfunction createKeyframeTracks( animation, tracks ) {\r\n\r\n\t\t\tvar keyframes = animation.keyframes;\r\n\t\t\tvar name = animation.name;\r\n\r\n\t\t\tvar times = [];\r\n\t\t\tvar positionData = [];\r\n\t\t\tvar quaternionData = [];\r\n\t\t\tvar scaleData = [];\r\n\r\n\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar keyframe = keyframes[ i ];\r\n\r\n\t\t\t\tvar time = keyframe.time;\r\n\t\t\t\tvar value = keyframe.value;\r\n\r\n\t\t\t\tmatrix.fromArray( value ).transpose();\r\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\r\n\r\n\t\t\t\ttimes.push( time );\r\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\r\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\r\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( positionData.length > 0 ) { tracks.push( new VectorKeyframeTrack$1( name + '.position', times, positionData ) ); }\r\n\t\t\tif ( quaternionData.length > 0 ) { tracks.push( new QuaternionKeyframeTrack$1( name + '.quaternion', times, quaternionData ) ); }\r\n\t\t\tif ( scaleData.length > 0 ) { tracks.push( new VectorKeyframeTrack$1( name + '.scale', times, scaleData ) ); }\r\n\r\n\t\t\treturn tracks;\r\n\r\n\t\t}\r\n\r\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\r\n\r\n\t\t\tvar keyframe;\r\n\r\n\t\t\tvar empty = true;\r\n\t\t\tvar i, l;\r\n\r\n\t\t\t// check, if values of a property are missing in our keyframes\r\n\r\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tkeyframe = keyframes[ i ];\r\n\r\n\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\r\n\r\n\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tempty = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( empty === true ) {\r\n\r\n\t\t\t\t// no values at all, so we set a default value\r\n\r\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tkeyframe = keyframes[ i ];\r\n\r\n\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// filling gaps\r\n\r\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction createMissingKeyframes( keyframes, property ) {\r\n\r\n\t\t\tvar prev, next;\r\n\r\n\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar keyframe = keyframes[ i ];\r\n\r\n\t\t\t\tif ( keyframe.value[ property ] === null ) {\r\n\r\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\r\n\t\t\t\t\tnext = getNext( keyframes, i, property );\r\n\r\n\t\t\t\t\tif ( prev === null ) {\r\n\r\n\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( next === null ) {\r\n\r\n\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction getPrev( keyframes, i, property ) {\r\n\r\n\t\t\twhile ( i >= 0 ) {\r\n\r\n\t\t\t\tvar keyframe = keyframes[ i ];\r\n\r\n\t\t\t\tif ( keyframe.value[ property ] !== null ) { return keyframe; }\r\n\r\n\t\t\t\ti --;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNext( keyframes, i, property ) {\r\n\r\n\t\t\twhile ( i < keyframes.length ) {\r\n\r\n\t\t\t\tvar keyframe = keyframes[ i ];\r\n\r\n\t\t\t\tif ( keyframe.value[ property ] !== null ) { return keyframe; }\r\n\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tfunction interpolate( key, prev, next, property ) {\r\n\r\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\r\n\r\n\t\t\t\tkey.value[ property ] = prev.value[ property ];\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\r\n\r\n\t\t}\r\n\r\n\t\t// animation clips\r\n\r\n\t\tfunction parseAnimationClip( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\r\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\r\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\r\n\t\t\t\tanimations: []\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'instance_animation':\r\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildAnimationClip( data ) {\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\tvar name = data.name;\r\n\t\t\tvar duration = ( data.end - data.start ) || - 1;\r\n\t\t\tvar animations = data.animations;\r\n\r\n\t\t\tfor ( var i = 0, il = animations.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar animationTracks = getAnimation( animations[ i ] );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = animationTracks.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\ttracks.push( animationTracks[ j ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new AnimationClip( name, duration, tracks );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getAnimationClip( id ) {\r\n\r\n\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\r\n\r\n\t\t}\r\n\r\n\t\t// controller\r\n\r\n\t\tfunction parseController( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'skin':\r\n\t\t\t\t\t\t// there is exactly one skin per controller\r\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\r\n\t\t\t\t\t\tdata.skin = parseSkin( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'morph':\r\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\r\n\t\t\t\t\t\tconsole.warn( 'ColladaLoader: Morph target animation not supported yet.' );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseSkin( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tsources: {}\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'bind_shape_matrix':\r\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'source':\r\n\t\t\t\t\t\tvar id = child.getAttribute( 'id' );\r\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'joints':\r\n\t\t\t\t\t\tdata.joints = parseJoints( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'vertex_weights':\r\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseJoints( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tinputs: {}\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'input':\r\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\r\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\r\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseVertexWeights( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tinputs: {}\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'input':\r\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\r\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\r\n\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\r\n\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'vcount':\r\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildController( data ) {\r\n\r\n\t\t\tvar build = {\r\n\t\t\t\tid: data.id\r\n\t\t\t};\r\n\r\n\t\t\tvar geometry = library.geometries[ build.id ];\r\n\r\n\t\t\tif ( data.skin !== undefined ) {\r\n\r\n\t\t\t\tbuild.skin = buildSkin( data.skin );\r\n\r\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\r\n\r\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\r\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn build;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildSkin( data ) {\r\n\r\n\t\t\tvar BONE_LIMIT = 4;\r\n\r\n\t\t\tvar build = {\r\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\r\n\t\t\t\tindices: {\r\n\t\t\t\t\tarray: [],\r\n\t\t\t\t\tstride: BONE_LIMIT\r\n\t\t\t\t},\r\n\t\t\t\tweights: {\r\n\t\t\t\t\tarray: [],\r\n\t\t\t\t\tstride: BONE_LIMIT\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tvar sources = data.sources;\r\n\t\t\tvar vertexWeights = data.vertexWeights;\r\n\r\n\t\t\tvar vcount = vertexWeights.vcount;\r\n\t\t\tvar v = vertexWeights.v;\r\n\t\t\tvar jointOffset = vertexWeights.inputs.JOINT.offset;\r\n\t\t\tvar weightOffset = vertexWeights.inputs.WEIGHT.offset;\r\n\r\n\t\t\tvar jointSource = data.sources[ data.joints.inputs.JOINT ];\r\n\t\t\tvar inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\r\n\r\n\t\t\tvar weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\r\n\t\t\tvar stride = 0;\r\n\r\n\t\t\tvar i, j, l;\r\n\r\n\t\t\t// procces skin data for each vertex\r\n\r\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\r\n\t\t\t\tvar vertexSkinData = [];\r\n\r\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\r\n\r\n\t\t\t\t\tvar skinIndex = v[ stride + jointOffset ];\r\n\t\t\t\t\tvar weightId = v[ stride + weightOffset ];\r\n\t\t\t\t\tvar skinWeight = weights[ weightId ];\r\n\r\n\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\r\n\r\n\t\t\t\t\tstride += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// we sort the joints in descending order based on the weights.\r\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\r\n\r\n\t\t\t\tvertexSkinData.sort( descending );\r\n\r\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\r\n\t\t\t\t// the order of the skin data matches the order of vertices\r\n\r\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\r\n\r\n\t\t\t\t\tvar d = vertexSkinData[ j ];\r\n\r\n\t\t\t\t\tif ( d !== undefined ) {\r\n\r\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\r\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\r\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// setup bind matrix\r\n\r\n\t\t\tif ( data.bindShapeMatrix ) {\r\n\r\n\t\t\t\tbuild.bindMatrix = new Matrix4().fromArray( data.bindShapeMatrix ).transpose();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbuild.bindMatrix = new Matrix4().identity();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// process bones and inverse bind matrix data\r\n\r\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar name = jointSource.array[ i ];\r\n\t\t\t\tvar boneInverse = new Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\r\n\r\n\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn build;\r\n\r\n\t\t\t// array sort function\r\n\r\n\t\t\tfunction descending( a, b ) {\r\n\r\n\t\t\t\treturn b.weight - a.weight;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction getController( id ) {\r\n\r\n\t\t\treturn getBuild( library.controllers[ id ], buildController );\r\n\r\n\t\t}\r\n\r\n\t\t// image\r\n\r\n\t\tfunction parseImage( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\r\n\t\t\t};\r\n\r\n\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildImage( data ) {\r\n\r\n\t\t\tif ( data.build !== undefined ) { return data.build; }\r\n\r\n\t\t\treturn data.init_from;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getImage( id ) {\r\n\r\n\t\t\tvar data = library.images[ id ];\r\n\r\n\t\t\tif ( data !== undefined ) {\r\n\r\n\t\t\t\treturn getBuild( data, buildImage );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.warn( 'ColladaLoader: Couldn\\'t find image with ID:', id );\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// effect\r\n\r\n\t\tfunction parseEffect( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'profile_COMMON':\r\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectProfileCOMMON( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tsurfaces: {},\r\n\t\t\t\tsamplers: {}\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'newparam':\r\n\t\t\t\t\t\tparseEffectNewparam( child, data );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'technique':\r\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'extra':\r\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectNewparam( xml, data ) {\r\n\r\n\t\t\tvar sid = xml.getAttribute( 'sid' );\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'surface':\r\n\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'sampler2D':\r\n\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectSurface( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'init_from':\r\n\t\t\t\t\t\tdata.init_from = child.textContent;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectSampler( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'source':\r\n\t\t\t\t\t\tdata.source = child.textContent;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectTechnique( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'constant':\r\n\t\t\t\t\tcase 'lambert':\r\n\t\t\t\t\tcase 'blinn':\r\n\t\t\t\t\tcase 'phong':\r\n\t\t\t\t\t\tdata.type = child.nodeName;\r\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectParameters( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'emission':\r\n\t\t\t\t\tcase 'diffuse':\r\n\t\t\t\t\tcase 'specular':\r\n\t\t\t\t\tcase 'shininess':\r\n\t\t\t\t\tcase 'transparency':\r\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'transparent':\r\n\t\t\t\t\t\tdata[ child.nodeName ] = {\r\n\t\t\t\t\t\t\topaque: child.getAttribute( 'opaque' ),\r\n\t\t\t\t\t\t\tdata: parseEffectParameter( child )\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectParameter( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'color':\r\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'float':\r\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'texture':\r\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectParameterTexture( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\ttechnique: {}\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'extra':\r\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'technique':\r\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'repeatU':\r\n\t\t\t\t\tcase 'repeatV':\r\n\t\t\t\t\tcase 'offsetU':\r\n\t\t\t\t\tcase 'offsetV':\r\n\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'wrapU':\r\n\t\t\t\t\tcase 'wrapV':\r\n\r\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\r\n\r\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\r\n\r\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\r\n\r\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\r\n\r\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectExtra( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'technique':\r\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEffectExtraTechnique( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'double_sided':\r\n\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildEffect( data ) {\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getEffect( id ) {\r\n\r\n\t\t\treturn getBuild( library.effects[ id ], buildEffect );\r\n\r\n\t\t}\r\n\r\n\t\t// material\r\n\r\n\t\tfunction parseMaterial( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tname: xml.getAttribute( 'name' )\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'instance_effect':\r\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTextureLoader( image ) {\r\n\r\n\t\t\tvar loader;\r\n\r\n\t\t\tvar extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\r\n\t\t\textension = extension.toLowerCase();\r\n\r\n\t\t\tswitch ( extension ) {\r\n\r\n\t\t\t\tcase 'tga':\r\n\t\t\t\t\tloader = tgaLoader;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tloader = textureLoader;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn loader;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildMaterial( data ) {\r\n\r\n\t\t\tvar effect = getEffect( data.url );\r\n\t\t\tvar technique = effect.profile.technique;\r\n\t\t\tvar extra = effect.profile.extra;\r\n\r\n\t\t\tvar material;\r\n\r\n\t\t\tswitch ( technique.type ) {\r\n\r\n\t\t\t\tcase 'phong':\r\n\t\t\t\tcase 'blinn':\r\n\t\t\t\t\tmaterial = new MeshPhongMaterial();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'lambert':\r\n\t\t\t\t\tmaterial = new MeshLambertMaterial();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tmaterial = new MeshBasicMaterial();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.name = data.name;\r\n\r\n\t\t\tfunction getTexture( textureObject ) {\r\n\r\n\t\t\t\tvar sampler = effect.profile.samplers[ textureObject.id ];\r\n\t\t\t\tvar image = null;\r\n\r\n\t\t\t\t// get image\r\n\r\n\t\t\t\tif ( sampler !== undefined ) {\r\n\r\n\t\t\t\t\tvar surface = effect.profile.surfaces[ sampler.source ];\r\n\t\t\t\t\timage = getImage( surface.init_from );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\r\n\t\t\t\t\timage = getImage( textureObject.id );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// create texture if image is avaiable\r\n\r\n\t\t\t\tif ( image !== null ) {\r\n\r\n\t\t\t\t\tvar loader = getTextureLoader( image );\r\n\r\n\t\t\t\t\tif ( loader !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar texture = loader.load( image );\r\n\r\n\t\t\t\t\t\tvar extra = textureObject.extra;\r\n\r\n\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\r\n\r\n\t\t\t\t\t\t\tvar technique = extra.technique;\r\n\r\n\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\r\n\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\r\n\r\n\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\r\n\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttexture.wrapS = RepeatWrapping;\r\n\t\t\t\t\t\t\ttexture.wrapT = RepeatWrapping;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn texture;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'ColladaLoader: Loader for texture %s not found.', image );\r\n\r\n\t\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\r\n\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parameters = technique.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tvar parameter = parameters[ key ];\r\n\r\n\t\t\t\tswitch ( key ) {\r\n\r\n\t\t\t\t\tcase 'diffuse':\r\n\t\t\t\t\t\tif ( parameter.color ) { material.color.fromArray( parameter.color ); }\r\n\t\t\t\t\t\tif ( parameter.texture ) { material.map = getTexture( parameter.texture ); }\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'specular':\r\n\t\t\t\t\t\tif ( parameter.color && material.specular ) { material.specular.fromArray( parameter.color ); }\r\n\t\t\t\t\t\tif ( parameter.texture ) { material.specularMap = getTexture( parameter.texture ); }\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'shininess':\r\n\t\t\t\t\t\tif ( parameter.float && material.shininess ) { material.shininess = parameter.float; }\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'emission':\r\n\t\t\t\t\t\tif ( parameter.color && material.emissive ) { material.emissive.fromArray( parameter.color ); }\r\n\t\t\t\t\t\tif ( parameter.texture ) { material.emissiveMap = getTexture( parameter.texture ); }\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tvar transparent = parameters[ 'transparent' ];\r\n\t\t\tvar transparency = parameters[ 'transparency' ];\r\n\r\n\t\t\t// <transparency> does not exist but <transparent>\r\n\r\n\t\t\tif ( transparency === undefined && transparent ) {\r\n\r\n\t\t\t\ttransparency = {\r\n\t\t\t\t\tfloat: 1\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// <transparent> does not exist but <transparency>\r\n\r\n\t\t\tif ( transparent === undefined && transparency ) {\r\n\r\n\t\t\t\ttransparent = {\r\n\t\t\t\t\topaque: 'A_ONE',\r\n\t\t\t\t\tdata: {\r\n\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\r\n\t\t\t\t\t} };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( transparent && transparency ) {\r\n\r\n\t\t\t\t// handle case if a texture exists but no color\r\n\r\n\t\t\t\tif ( transparent.data.texture ) {\r\n\r\n\t\t\t\t\t// we do not set an alpha map (see #13792)\r\n\r\n\t\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvar color = transparent.data.color;\r\n\r\n\t\t\t\t\tswitch ( transparent.opaque ) {\r\n\r\n\t\t\t\t\t\tcase 'A_ONE':\r\n\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'RGB_ZERO':\r\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'A_ZERO':\r\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'RGB_ONE':\r\n\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.warn( 'ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( material.opacity < 1 ) { material.transparent = true; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tif ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {\r\n\r\n\t\t\t\tmaterial.side = DoubleSide;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getMaterial( id ) {\r\n\r\n\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\r\n\r\n\t\t}\r\n\r\n\t\t// camera\r\n\r\n\t\tfunction parseCamera( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tname: xml.getAttribute( 'name' )\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'optics':\r\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCameraOptics( xml ) {\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'technique_common':\r\n\t\t\t\t\t\treturn parseCameraTechnique( child );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn {};\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCameraTechnique( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'perspective':\r\n\t\t\t\t\tcase 'orthographic':\r\n\r\n\t\t\t\t\t\tdata.technique = child.nodeName;\r\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCameraParameters( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'xfov':\r\n\t\t\t\t\tcase 'yfov':\r\n\t\t\t\t\tcase 'xmag':\r\n\t\t\t\t\tcase 'ymag':\r\n\t\t\t\t\tcase 'znear':\r\n\t\t\t\t\tcase 'zfar':\r\n\t\t\t\t\tcase 'aspect_ratio':\r\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildCamera( data ) {\r\n\r\n\t\t\tvar camera;\r\n\r\n\t\t\tswitch ( data.optics.technique ) {\r\n\r\n\t\t\t\tcase 'perspective':\r\n\t\t\t\t\tcamera = new PerspectiveCamera(\r\n\t\t\t\t\t\tdata.optics.parameters.yfov,\r\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\r\n\t\t\t\t\t\tdata.optics.parameters.znear,\r\n\t\t\t\t\t\tdata.optics.parameters.zfar\r\n\t\t\t\t\t);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'orthographic':\r\n\t\t\t\t\tvar ymag = data.optics.parameters.ymag;\r\n\t\t\t\t\tvar xmag = data.optics.parameters.xmag;\r\n\t\t\t\t\tvar aspectRatio = data.optics.parameters.aspect_ratio;\r\n\r\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\r\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\r\n\r\n\t\t\t\t\txmag *= 0.5;\r\n\t\t\t\t\tymag *= 0.5;\r\n\r\n\t\t\t\t\tcamera = new OrthographicCamera(\r\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\r\n\t\t\t\t\t\tdata.optics.parameters.znear,\r\n\t\t\t\t\t\tdata.optics.parameters.zfar\r\n\t\t\t\t\t);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tcamera = new PerspectiveCamera();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcamera.name = data.name;\r\n\r\n\t\t\treturn camera;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getCamera( id ) {\r\n\r\n\t\t\tvar data = library.cameras[ id ];\r\n\r\n\t\t\tif ( data !== undefined ) {\r\n\r\n\t\t\t\treturn getBuild( data, buildCamera );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.warn( 'ColladaLoader: Couldn\\'t find camera with ID:', id );\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// light\r\n\r\n\t\tfunction parseLight( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'technique_common':\r\n\t\t\t\t\t\tdata = parseLightTechnique( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseLightTechnique( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'directional':\r\n\t\t\t\t\tcase 'point':\r\n\t\t\t\t\tcase 'spot':\r\n\t\t\t\t\tcase 'ambient':\r\n\r\n\t\t\t\t\t\tdata.technique = child.nodeName;\r\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseLightParameters( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'color':\r\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\r\n\t\t\t\t\t\tdata.color = new Color().fromArray( array );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'falloff_angle':\r\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'quadratic_attenuation':\r\n\t\t\t\t\t\tvar f = parseFloat( child.textContent );\r\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildLight( data ) {\r\n\r\n\t\t\tvar light;\r\n\r\n\t\t\tswitch ( data.technique ) {\r\n\r\n\t\t\t\tcase 'directional':\r\n\t\t\t\t\tlight = new DirectionalLight();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'point':\r\n\t\t\t\t\tlight = new PointLight();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'spot':\r\n\t\t\t\t\tlight = new SpotLight();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ambient':\r\n\t\t\t\t\tlight = new AmbientLight();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.parameters.color ) { light.color.copy( data.parameters.color ); }\r\n\t\t\tif ( data.parameters.distance ) { light.distance = data.parameters.distance; }\r\n\r\n\t\t\treturn light;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getLight( id ) {\r\n\r\n\t\t\tvar data = library.lights[ id ];\r\n\r\n\t\t\tif ( data !== undefined ) {\r\n\r\n\t\t\t\treturn getBuild( data, buildLight );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.warn( 'ColladaLoader: Couldn\\'t find light with ID:', id );\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// geometry\r\n\r\n\t\tfunction parseGeometry( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tname: xml.getAttribute( 'name' ),\r\n\t\t\t\tsources: {},\r\n\t\t\t\tvertices: {},\r\n\t\t\t\tprimitives: []\r\n\t\t\t};\r\n\r\n\t\t\tvar mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\r\n\r\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\r\n\t\t\tif ( mesh === undefined ) { return; }\r\n\r\n\t\t\tfor ( var i = 0; i < mesh.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = mesh.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tvar id = child.getAttribute( 'id' );\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'source':\r\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'vertices':\r\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\r\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'polygons':\r\n\t\t\t\t\t\tconsole.warn( 'ColladaLoader: Unsupported primitive type: ', child.nodeName );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'lines':\r\n\t\t\t\t\tcase 'linestrips':\r\n\t\t\t\t\tcase 'polylist':\r\n\t\t\t\t\tcase 'triangles':\r\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.log( child );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseSource( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tarray: [],\r\n\t\t\t\tstride: 3\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'float_array':\r\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Name_array':\r\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'technique_common':\r\n\t\t\t\t\t\tvar accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\r\n\r\n\t\t\t\t\t\tif ( accessor !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseGeometryVertices( xml ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseGeometryPrimitive( xml ) {\r\n\r\n\t\t\tvar primitive = {\r\n\t\t\t\ttype: xml.nodeName,\r\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\r\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\r\n\t\t\t\tinputs: {},\r\n\t\t\t\tstride: 0,\r\n\t\t\t\thasUV: false\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'input':\r\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\r\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\r\n\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\r\n\t\t\t\t\t\tprimitive.inputs[ semantic ] = { id: id, offset: offset };\r\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\r\n\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) { primitive.hasUV = true; }\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'vcount':\r\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'p':\r\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn primitive;\r\n\r\n\t\t}\r\n\r\n\t\tfunction groupPrimitives( primitives ) {\r\n\r\n\t\t\tvar build = {};\r\n\r\n\t\t\tfor ( var i = 0; i < primitives.length; i ++ ) {\r\n\r\n\t\t\t\tvar primitive = primitives[ i ];\r\n\r\n\t\t\t\tif ( build[ primitive.type ] === undefined ) { build[ primitive.type ] = []; }\r\n\r\n\t\t\t\tbuild[ primitive.type ].push( primitive );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn build;\r\n\r\n\t\t}\r\n\r\n\t\tfunction checkUVCoordinates( primitives ) {\r\n\r\n\t\t\tvar count = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = primitives.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar primitive = primitives[ i ];\r\n\r\n\t\t\t\tif ( primitive.hasUV === true ) {\r\n\r\n\t\t\t\t\tcount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( count > 0 && count < primitives.length ) {\r\n\r\n\t\t\t\tprimitives.uvsNeedsFix = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildGeometry( data ) {\r\n\r\n\t\t\tvar build = {};\r\n\r\n\t\t\tvar sources = data.sources;\r\n\t\t\tvar vertices = data.vertices;\r\n\t\t\tvar primitives = data.primitives;\r\n\r\n\t\t\tif ( primitives.length === 0 ) { return {}; }\r\n\r\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\r\n\t\t\t// first, we group all primitives by their type\r\n\r\n\t\t\tvar groupedPrimitives = groupPrimitives( primitives );\r\n\r\n\t\t\tfor ( var type in groupedPrimitives ) {\r\n\r\n\t\t\t\tvar primitiveType = groupedPrimitives[ type ];\r\n\r\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\r\n\r\n\t\t\t\tcheckUVCoordinates( primitiveType );\r\n\r\n\t\t\t\t// third, create a buffer geometry for each type of primitives\r\n\r\n\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn build;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\r\n\r\n\t\t\tvar build = {};\r\n\r\n\t\t\tvar position = { array: [], stride: 0 };\r\n\t\t\tvar normal = { array: [], stride: 0 };\r\n\t\t\tvar uv = { array: [], stride: 0 };\r\n\t\t\tvar color = { array: [], stride: 0 };\r\n\r\n\t\t\tvar skinIndex = { array: [], stride: 4 };\r\n\t\t\tvar skinWeight = { array: [], stride: 4 };\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\tvar materialKeys = [];\r\n\r\n\t\t\tvar start = 0;\r\n\r\n\t\t\tfor ( var p = 0; p < primitives.length; p ++ ) {\r\n\r\n\t\t\t\tvar primitive = primitives[ p ];\r\n\t\t\t\tvar inputs = primitive.inputs;\r\n\r\n\t\t\t\t// groups\r\n\r\n\t\t\t\tvar count = 0;\r\n\r\n\t\t\t\tswitch ( primitive.type ) {\r\n\r\n\t\t\t\t\tcase 'lines':\r\n\t\t\t\t\tcase 'linestrips':\r\n\t\t\t\t\t\tcount = primitive.count * 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'triangles':\r\n\t\t\t\t\t\tcount = primitive.count * 3;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'polylist':\r\n\r\n\t\t\t\t\t\tfor ( var g = 0; g < primitive.count; g ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar vc = primitive.vcount[ g ];\r\n\r\n\t\t\t\t\t\t\tswitch ( vc ) {\r\n\r\n\t\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.warn( 'ColladaLoader: Unknow primitive type:', primitive.type );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.addGroup( start, count, p );\r\n\t\t\t\tstart += count;\r\n\r\n\t\t\t\t// material\r\n\r\n\t\t\t\tif ( primitive.material ) {\r\n\r\n\t\t\t\t\tmaterialKeys.push( primitive.material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// geometry data\r\n\r\n\t\t\t\tfor ( var name in inputs ) {\r\n\r\n\t\t\t\t\tvar input = inputs[ name ];\r\n\r\n\t\t\t\t\tswitch ( name )\t{\r\n\r\n\t\t\t\t\t\tcase 'VERTEX':\r\n\t\t\t\t\t\t\tfor ( var key in vertices ) {\r\n\r\n\t\t\t\t\t\t\t\tvar id = vertices[ key ];\r\n\r\n\t\t\t\t\t\t\t\tswitch ( key ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\r\n\t\t\t\t\t\t\t\t\t\tvar prevLength = position.array.length;\r\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\r\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\r\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// see #3803\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvar count = ( position.array.length - prevLength ) / position.stride;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\r\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\r\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\r\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\r\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\r\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\r\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'NORMAL':\r\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\r\n\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'COLOR':\r\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array );\r\n\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'TEXCOORD':\r\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\r\n\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// build geometry\r\n\r\n\t\t\tif ( position.array.length > 0 ) { geometry.addAttribute( 'position', new Float32BufferAttribute( position.array, position.stride ) ); }\r\n\t\t\tif ( normal.array.length > 0 ) { geometry.addAttribute( 'normal', new Float32BufferAttribute( normal.array, normal.stride ) ); }\r\n\t\t\tif ( color.array.length > 0 ) { geometry.addAttribute( 'color', new Float32BufferAttribute( color.array, color.stride ) ); }\r\n\t\t\tif ( uv.array.length > 0 ) { geometry.addAttribute( 'uv', new Float32BufferAttribute( uv.array, uv.stride ) ); }\r\n\r\n\t\t\tif ( skinIndex.array.length > 0 ) { geometry.addAttribute( 'skinIndex', new Float32BufferAttribute( skinIndex.array, skinIndex.stride ) ); }\r\n\t\t\tif ( skinWeight.array.length > 0 ) { geometry.addAttribute( 'skinWeight', new Float32BufferAttribute( skinWeight.array, skinWeight.stride ) ); }\r\n\r\n\t\t\tbuild.data = geometry;\r\n\t\t\tbuild.type = primitives[ 0 ].type;\r\n\t\t\tbuild.materialKeys = materialKeys;\r\n\r\n\t\t\treturn build;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildGeometryData( primitive, source, offset, array ) {\r\n\r\n\t\t\tvar indices = primitive.p;\r\n\t\t\tvar stride = primitive.stride;\r\n\t\t\tvar vcount = primitive.vcount;\r\n\r\n\t\t\tfunction pushVector( i ) {\r\n\r\n\t\t\t\tvar index = indices[ i + offset ] * sourceStride;\r\n\t\t\t\tvar length = index + sourceStride;\r\n\r\n\t\t\t\tfor ( ; index < length; index ++ ) {\r\n\r\n\t\t\t\t\tarray.push( sourceArray[ index ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar sourceArray = source.array;\r\n\t\t\tvar sourceStride = source.stride;\r\n\r\n\t\t\tif ( primitive.vcount !== undefined ) {\r\n\r\n\t\t\t\tvar index = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, l = vcount.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar count = vcount[ i ];\r\n\r\n\t\t\t\t\tif ( count === 4 ) {\r\n\r\n\t\t\t\t\t\tvar a = index + stride * 0;\r\n\t\t\t\t\t\tvar b = index + stride * 1;\r\n\t\t\t\t\t\tvar c = index + stride * 2;\r\n\t\t\t\t\t\tvar d = index + stride * 3;\r\n\r\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\r\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\r\n\r\n\t\t\t\t\t} else if ( count === 3 ) {\r\n\r\n\t\t\t\t\t\tvar a = index + stride * 0;\r\n\t\t\t\t\t\tvar b = index + stride * 1;\r\n\t\t\t\t\t\tvar c = index + stride * 2;\r\n\r\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\r\n\r\n\t\t\t\t\t} else if ( count > 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( var k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar a = index + stride * 0;\r\n\t\t\t\t\t\t\tvar b = index + stride * k;\r\n\t\t\t\t\t\t\tvar c = index + stride * ( k + 1 );\r\n\r\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tindex += stride * count;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += stride ) {\r\n\r\n\t\t\t\t\tpushVector( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction getGeometry( id ) {\r\n\r\n\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\r\n\r\n\t\t}\r\n\r\n\t\t// kinematics\r\n\r\n\t\tfunction parseKinematicsModel( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\r\n\t\t\t\tjoints: {},\r\n\t\t\t\tlinks: []\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'technique_common':\r\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildKinematicsModel( data ) {\r\n\r\n\t\t\tif ( data.build !== undefined ) { return data.build; }\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getKinematicsModel( id ) {\r\n\r\n\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'joint':\r\n\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'link':\r\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseKinematicsJoint( xml ) {\r\n\r\n\t\t\tvar data;\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'prismatic':\r\n\t\t\t\t\tcase 'revolute':\r\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseKinematicsJointParameter( xml, data ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\r\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\r\n\t\t\t\taxis: new Vector3(),\r\n\t\t\t\tlimits: {\r\n\t\t\t\t\tmin: 0,\r\n\t\t\t\t\tmax: 0\r\n\t\t\t\t},\r\n\t\t\t\ttype: xml.nodeName,\r\n\t\t\t\tstatic: false,\r\n\t\t\t\tzeroPosition: 0,\r\n\t\t\t\tmiddlePosition: 0\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'axis':\r\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\r\n\t\t\t\t\t\tdata.axis.fromArray( array );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'limits':\r\n\t\t\t\t\t\tvar max = child.getElementsByTagName( 'max' )[ 0 ];\r\n\t\t\t\t\t\tvar min = child.getElementsByTagName( 'min' )[ 0 ];\r\n\r\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\r\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if min is equal to or greater than max, consider the joint static\r\n\r\n\t\t\tif ( data.limits.min >= data.limits.max ) {\r\n\r\n\t\t\t\tdata.static = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// calculate middle position\r\n\r\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseKinematicsLink( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\r\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\r\n\t\t\t\tattachments: [],\r\n\t\t\t\ttransforms: []\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'attachment_full':\r\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseKinematicsAttachment( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\r\n\t\t\t\ttransforms: [],\r\n\t\t\t\tlinks: []\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'link':\r\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseKinematicsTransform( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\ttype: xml.nodeName\r\n\t\t\t};\r\n\r\n\t\t\tvar array = parseFloats( xml.textContent );\r\n\r\n\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\tcase 'matrix':\r\n\t\t\t\t\tdata.obj = new Matrix4();\r\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'translate':\r\n\t\t\t\t\tdata.obj = new Vector3();\r\n\t\t\t\t\tdata.obj.fromArray( array );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'rotate':\r\n\t\t\t\t\tdata.obj = new Vector3();\r\n\t\t\t\t\tdata.obj.fromArray( array );\r\n\t\t\t\t\tdata.angle = _Math.degToRad( array[ 3 ] );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\t// physics\r\n\r\n\t\tfunction parsePhysicsModel( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\r\n\t\t\t\trigidBodies: {}\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'rigid_body':\r\n\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\r\n\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePhysicsRigidBody( xml, data ) {\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'technique_common':\r\n\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'inertia':\r\n\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'mass':\r\n\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[0];\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// scene\r\n\r\n\t\tfunction parseKinematicsScene( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tbindJointAxis: []\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'bind_joint_axis':\r\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'axis':\r\n\t\t\t\t\t\tvar param = child.getElementsByTagName( 'param' )[ 0 ];\r\n\t\t\t\t\t\tdata.axis = param.textContent;\r\n\t\t\t\t\t\tvar tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\r\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildKinematicsScene( data ) {\r\n\r\n\t\t\tif ( data.build !== undefined ) { return data.build; }\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getKinematicsScene( id ) {\r\n\r\n\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\r\n\r\n\t\t}\r\n\r\n\t\tfunction setupKinematics() {\r\n\r\n\t\t\tvar kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\r\n\t\t\tvar kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\r\n\t\t\tvar visualSceneId = Object.keys( library.visualScenes )[ 0 ];\r\n\r\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) { return; }\r\n\r\n\t\t\tvar kinematicsModel = getKinematicsModel( kinematicsModelId );\r\n\t\t\tvar kinematicsScene = getKinematicsScene( kinematicsSceneId );\r\n\t\t\tvar visualScene = getVisualScene( visualSceneId );\r\n\r\n\t\t\tvar bindJointAxis = kinematicsScene.bindJointAxis;\r\n\t\t\tvar jointMap = {};\r\n\r\n\t\t\tfor ( var i = 0, l = bindJointAxis.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar axis = bindJointAxis[ i ];\r\n\r\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\r\n\r\n\t\t\t\tvar targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\r\n\r\n\t\t\t\tif ( targetElement ) {\r\n\r\n\t\t\t\t\t// get the parent of the transfrom element\r\n\r\n\t\t\t\t\tvar parentVisualElement = targetElement.parentElement;\r\n\r\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\r\n\r\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction connect( jointIndex, visualElement ) {\r\n\r\n\t\t\t\tvar visualElementName = visualElement.getAttribute( 'name' );\r\n\t\t\t\tvar joint = kinematicsModel.joints[ jointIndex ];\r\n\r\n\t\t\t\tvisualScene.traverse( function ( object ) {\r\n\r\n\t\t\t\t\tif ( object.name === visualElementName ) {\r\n\r\n\t\t\t\t\t\tjointMap[ jointIndex ] = {\r\n\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\r\n\t\t\t\t\t\t\tjoint: joint,\r\n\t\t\t\t\t\t\tposition: joint.zeroPosition\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar m0 = new Matrix4();\r\n\r\n\t\t\tkinematics = {\r\n\r\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\r\n\r\n\t\t\t\tgetJointValue: function ( jointIndex ) {\r\n\r\n\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\r\n\r\n\t\t\t\t\tif ( jointData ) {\r\n\r\n\t\t\t\t\t\treturn jointData.position;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tsetJointValue: function ( jointIndex, value ) {\r\n\r\n\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\r\n\r\n\t\t\t\t\tif ( jointData ) {\r\n\r\n\t\t\t\t\t\tvar joint = jointData.joint;\r\n\r\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( 'ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\r\n\r\n\t\t\t\t\t\t} else if ( joint.static ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( 'ColladaLoader: Joint ' + jointIndex + ' is static.' );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar object = jointData.object;\r\n\t\t\t\t\t\t\tvar axis = joint.axis;\r\n\t\t\t\t\t\t\tvar transforms = jointData.transforms;\r\n\r\n\t\t\t\t\t\t\tmatrix.identity();\r\n\r\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < transforms.length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar transform = transforms[ i ];\r\n\r\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\r\n\r\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\r\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, _Math.degToRad( value ) ) );\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\r\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'ColladaLoader: Unknown joint type: ' + joint.type );\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\r\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\r\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.log( 'ColladaLoader: ' + jointIndex + ' does not exist.' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildTransformList( node ) {\r\n\r\n\t\t\tvar transforms = [];\r\n\r\n\t\t\tvar xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\r\n\t\t\t\t\t\tvar matrix = new Matrix4().fromArray( array ).transpose();\r\n\t\t\t\t\t\ttransforms.push( {\r\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\r\n\t\t\t\t\t\t\ttype: child.nodeName,\r\n\t\t\t\t\t\t\tobj: matrix\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\tcase 'scale':\r\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\r\n\t\t\t\t\t\tvar vector = new Vector3().fromArray( array );\r\n\t\t\t\t\t\ttransforms.push( {\r\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\r\n\t\t\t\t\t\t\ttype: child.nodeName,\r\n\t\t\t\t\t\t\tobj: vector\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\r\n\t\t\t\t\t\tvar vector = new Vector3().fromArray( array );\r\n\t\t\t\t\t\tvar angle = _Math.degToRad( array[ 3 ] );\r\n\t\t\t\t\t\ttransforms.push( {\r\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\r\n\t\t\t\t\t\t\ttype: child.nodeName,\r\n\t\t\t\t\t\t\tobj: vector,\r\n\t\t\t\t\t\t\tangle: angle\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transforms;\r\n\r\n\t\t}\r\n\r\n\t\t// nodes\r\n\r\n\t\tfunction prepareNodes( xml ) {\r\n\r\n\t\t\tvar elements = xml.getElementsByTagName( 'node' );\r\n\r\n\t\t\t// ensure all node elements have id attributes\r\n\r\n\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\r\n\r\n\t\t\t\tvar element = elements[ i ];\r\n\r\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\r\n\r\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar matrix = new Matrix4();\r\n\t\tvar vector = new Vector3();\r\n\r\n\t\tfunction parseNode( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\r\n\t\t\t\ttype: xml.getAttribute( 'type' ),\r\n\t\t\t\tid: xml.getAttribute( 'id' ),\r\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\r\n\t\t\t\tmatrix: new Matrix4(),\r\n\t\t\t\tnodes: [],\r\n\t\t\t\tinstanceCameras: [],\r\n\t\t\t\tinstanceControllers: [],\r\n\t\t\t\tinstanceLights: [],\r\n\t\t\t\tinstanceGeometries: [],\r\n\t\t\t\tinstanceNodes: [],\r\n\t\t\t\ttransforms: {}\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tif ( child.nodeType !== 1 ) { continue; }\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'node':\r\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\r\n\t\t\t\t\t\tparseNode( child );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'instance_camera':\r\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'instance_controller':\r\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'instance_light':\r\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'instance_geometry':\r\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'instance_node':\r\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'matrix':\r\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\r\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\r\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'translate':\r\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\r\n\t\t\t\t\t\tvector.fromArray( array );\r\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\r\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'rotate':\r\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\r\n\t\t\t\t\t\tvar angle = _Math.degToRad( array[ 3 ] );\r\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\r\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'scale':\r\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\r\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\r\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'extra':\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.log( child );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasNode( data.id ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlibrary.nodes[ data.id ] = data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseNodeInstance( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\r\n\t\t\t\tmaterials: {},\r\n\t\t\t\tskeletons: []\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = xml.childNodes[ i ];\r\n\r\n\t\t\t\tswitch ( child.nodeName ) {\r\n\r\n\t\t\t\t\tcase 'bind_material':\r\n\t\t\t\t\t\tvar instances = child.getElementsByTagName( 'instance_material' );\r\n\r\n\t\t\t\t\t\tfor ( var j = 0; j < instances.length; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar instance = instances[ j ];\r\n\t\t\t\t\t\t\tvar symbol = instance.getAttribute( 'symbol' );\r\n\t\t\t\t\t\t\tvar target = instance.getAttribute( 'target' );\r\n\r\n\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'skeleton':\r\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildSkeleton( skeletons, joints ) {\r\n\r\n\t\t\tvar boneData = [];\r\n\t\t\tvar sortedBoneData = [];\r\n\r\n\t\t\tvar i, j, data;\r\n\r\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\r\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\r\n\r\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\r\n\r\n\t\t\t\tvar skeleton = skeletons[ i ];\r\n\r\n\t\t\t\tvar root;\r\n\r\n\t\t\t\tif ( hasNode( skeleton ) ) {\r\n\r\n\t\t\t\t\troot = getNode( skeleton );\r\n\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\r\n\r\n\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\r\n\r\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\r\n\r\n\t\t\t\t\tvar visualScene = library.visualScenes[ skeleton ];\r\n\t\t\t\t\tvar children = visualScene.children;\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < children.length; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar child = children[ j ];\r\n\r\n\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\r\n\r\n\t\t\t\t\t\t\tvar root = getNode( child.id );\r\n\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( 'ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\r\n\r\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\r\n\r\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\r\n\r\n\t\t\t\t\tdata = boneData[ j ];\r\n\r\n\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\r\n\r\n\t\t\t\t\t\tsortedBoneData[ i ] = data;\r\n\t\t\t\t\t\tdata.processed = true;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// add unprocessed bone data at the end of the list\r\n\r\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\r\n\r\n\t\t\t\tdata = boneData[ i ];\r\n\r\n\t\t\t\tif ( data.processed === false ) {\r\n\r\n\t\t\t\t\tsortedBoneData.push( data );\r\n\t\t\t\t\tdata.processed = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// setup arrays for skeleton creation\r\n\r\n\t\t\tvar bones = [];\r\n\t\t\tvar boneInverses = [];\r\n\r\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\r\n\r\n\t\t\t\tdata = sortedBoneData[ i ];\r\n\r\n\t\t\t\tbones.push( data.bone );\r\n\t\t\t\tboneInverses.push( data.boneInverse );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new Skeleton( bones, boneInverses );\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\r\n\r\n\t\t\t// setup bone data from visual scene\r\n\r\n\t\t\troot.traverse( function ( object ) {\r\n\r\n\t\t\t\tif ( object.isBone === true ) {\r\n\r\n\t\t\t\t\tvar boneInverse;\r\n\r\n\t\t\t\t\t// retrieve the boneInverse from the controller data\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < joints.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar joint = joints[ i ];\r\n\r\n\t\t\t\t\t\tif ( joint.name === object.name ) {\r\n\r\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( boneInverse === undefined ) {\r\n\r\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\r\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\r\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\r\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\r\n\t\t\t\t\t\t// ensure a correct animation of the model.\r\n\r\n\t\t\t\t\t\tboneInverse = new Matrix4();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildNode( data ) {\r\n\r\n\t\t\tvar objects = [];\r\n\r\n\t\t\tvar matrix = data.matrix;\r\n\t\t\tvar nodes = data.nodes;\r\n\t\t\tvar type = data.type;\r\n\t\t\tvar instanceCameras = data.instanceCameras;\r\n\t\t\tvar instanceControllers = data.instanceControllers;\r\n\t\t\tvar instanceLights = data.instanceLights;\r\n\t\t\tvar instanceGeometries = data.instanceGeometries;\r\n\t\t\tvar instanceNodes = data.instanceNodes;\r\n\r\n\t\t\t// nodes\r\n\r\n\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// instance cameras\r\n\r\n\t\t\tfor ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar instanceCamera = getCamera( instanceCameras[ i ] );\r\n\r\n\t\t\t\tif ( instanceCamera !== null ) {\r\n\r\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// instance controllers\r\n\r\n\t\t\tfor ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar instance = instanceControllers[ i ];\r\n\t\t\t\tvar controller = getController( instance.id );\r\n\t\t\t\tvar geometries = getGeometry( controller.id );\r\n\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\r\n\r\n\t\t\t\tvar skeletons = instance.skeletons;\r\n\t\t\t\tvar joints = controller.skin.joints;\r\n\r\n\t\t\t\tvar skeleton = buildSkeleton( skeletons, joints );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar object = newObjects[ j ];\r\n\r\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\r\n\r\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\r\n\t\t\t\t\t\tobject.normalizeSkinWeights();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobjects.push( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// instance lights\r\n\r\n\t\t\tfor ( var i = 0, l = instanceLights.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar instanceLight = getLight( instanceLights[ i ] );\r\n\r\n\t\t\t\tif ( instanceLight !== null ) {\r\n\r\n\t\t\t\t\tobjects.push( instanceLight.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// instance geometries\r\n\r\n\t\t\tfor ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar instance = instanceGeometries[ i ];\r\n\r\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\r\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\r\n\r\n\t\t\t\tvar geometries = getGeometry( instance.id );\r\n\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tobjects.push( newObjects[ j ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// instance nodes\r\n\r\n\t\t\tfor ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar object;\r\n\r\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\r\n\r\n\t\t\t\tobject = objects[ 0 ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject = ( type === 'JOINT' ) ? new Bone() : new Group();\r\n\r\n\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\r\n\r\n\t\t\t\t\tobject.add( objects[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.name === '' ) {\r\n\r\n\t\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.matrix.copy( matrix );\r\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n\t\t\treturn object;\r\n\r\n\t\t}\r\n\r\n\t\tvar fallbackMaterial = new MeshBasicMaterial( { color: 0xff00ff } );\r\n\r\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\r\n\r\n\t\t\tvar materials = [];\r\n\r\n\t\t\tfor ( var i = 0, l = keys.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar id = instanceMaterials[ keys[ i ] ];\r\n\r\n\t\t\t\tif ( id === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\r\n\t\t\t\t\tmaterials.push( fallbackMaterial );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterials.push( getMaterial( id ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn materials;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\r\n\r\n\t\t\tvar objects = [];\r\n\r\n\t\t\tfor ( var type in geometries ) {\r\n\r\n\t\t\t\tvar geometry = geometries[ type ];\r\n\r\n\t\t\t\tvar materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\r\n\r\n\t\t\t\t// handle case if no materials are defined\r\n\r\n\t\t\t\tif ( materials.length === 0 ) {\r\n\r\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\r\n\r\n\t\t\t\t\t\tmaterials.push( new LineBasicMaterial() );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmaterials.push( new MeshPhongMaterial() );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// regard skinning\r\n\r\n\t\t\t\tvar skinning = ( geometry.data.attributes.skinIndex !== undefined );\r\n\r\n\t\t\t\tif ( skinning ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tmaterials[ i ].skinning = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// choose between a single or multi materials (material array)\r\n\r\n\t\t\t\tvar material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\r\n\r\n\t\t\t\t// now create a specific 3D object\r\n\r\n\t\t\t\tvar object;\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\tcase 'lines':\r\n\t\t\t\t\t\tobject = new LineSegments( geometry.data, material );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'linestrips':\r\n\t\t\t\t\t\tobject = new Line( geometry.data, material );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'triangles':\r\n\t\t\t\t\tcase 'polylist':\r\n\t\t\t\t\t\tif ( skinning ) {\r\n\r\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry.data, material );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tobject = new Mesh( geometry.data, material );\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobjects.push( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn objects;\r\n\r\n\t\t}\r\n\r\n\t\tfunction hasNode( id ) {\r\n\r\n\t\t\treturn library.nodes[ id ] !== undefined;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNode( id ) {\r\n\r\n\t\t\treturn getBuild( library.nodes[ id ], buildNode );\r\n\r\n\t\t}\r\n\r\n\t\t// visual scenes\r\n\r\n\t\tfunction parseVisualScene( xml ) {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tname: xml.getAttribute( 'name' ),\r\n\t\t\t\tchildren: []\r\n\t\t\t};\r\n\r\n\t\t\tprepareNodes( xml );\r\n\r\n\t\t\tvar elements = getElementsByTagName( xml, 'node' );\r\n\r\n\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\r\n\r\n\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildVisualScene( data ) {\r\n\r\n\t\t\tvar group = new Group();\r\n\t\t\tgroup.name = data.name;\r\n\r\n\t\t\tvar children = data.children;\r\n\r\n\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = children[ i ];\r\n\r\n\t\t\t\tgroup.add( getNode( child.id ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn group;\r\n\r\n\t\t}\r\n\r\n\t\tfunction hasVisualScene( id ) {\r\n\r\n\t\t\treturn library.visualScenes[ id ] !== undefined;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getVisualScene( id ) {\r\n\r\n\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\r\n\r\n\t\t}\r\n\r\n\t\t// scenes\r\n\r\n\t\tfunction parseScene( xml ) {\r\n\r\n\t\t\tvar instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\r\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction setupAnimations() {\r\n\r\n\t\t\tvar clips = library.clips;\r\n\r\n\t\t\tif ( isEmpty( clips ) === true ) {\r\n\r\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\r\n\r\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\r\n\r\n\t\t\t\t\tvar tracks = [];\r\n\r\n\t\t\t\t\tfor ( var id in library.animations ) {\r\n\r\n\t\t\t\t\t\tvar animationTracks = getAnimation( id );\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = animationTracks.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tanimations.push( new AnimationClip( 'default', - 1, tracks ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var id in clips ) {\r\n\r\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( text.length === 0 ) {\r\n\r\n\t\t\treturn { scene: new Scene() };\r\n\r\n\t\t}\r\n\r\n\t\tvar xml = new DOMParser().parseFromString( text, 'application/xml' );\r\n\r\n\t\tvar collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\r\n\r\n\t\t// metadata\r\n\r\n\t\tvar version = collada.getAttribute( 'version' );\r\n\t\tconsole.log( 'ColladaLoader: File version', version );\r\n\r\n\t\tvar asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\r\n\t\tvar textureLoader = new TextureLoader( this.manager );\r\n\t\ttextureLoader.setPath( path ).setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tvar tgaLoader;\r\n\r\n\t\tif ( TGALoader ) {\r\n\r\n\t\t\ttgaLoader = new TGALoader( this.manager );\r\n\t\t\ttgaLoader.setPath( path );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar animations = [];\r\n\t\tvar kinematics = {};\r\n\t\tvar count = 0;\r\n\r\n\t\t//\r\n\r\n\t\tvar library = {\r\n\t\t\tanimations: {},\r\n\t\t\tclips: {},\r\n\t\t\tcontrollers: {},\r\n\t\t\timages: {},\r\n\t\t\teffects: {},\r\n\t\t\tmaterials: {},\r\n\t\t\tcameras: {},\r\n\t\t\tlights: {},\r\n\t\t\tgeometries: {},\r\n\t\t\tnodes: {},\r\n\t\t\tvisualScenes: {},\r\n\t\t\tkinematicsModels: {},\r\n\t\t\tphysicsModels: {},\r\n\t\t\tkinematicsScenes: {}\r\n\t\t};\r\n\r\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\r\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\r\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\r\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\r\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\r\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\r\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\r\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\r\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\r\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\r\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\r\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\r\n\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\r\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\r\n\r\n\t\tbuildLibrary( library.animations, buildAnimation );\r\n\t\tbuildLibrary( library.clips, buildAnimationClip );\r\n\t\tbuildLibrary( library.controllers, buildController );\r\n\t\tbuildLibrary( library.images, buildImage );\r\n\t\tbuildLibrary( library.effects, buildEffect );\r\n\t\tbuildLibrary( library.materials, buildMaterial );\r\n\t\tbuildLibrary( library.cameras, buildCamera );\r\n\t\tbuildLibrary( library.lights, buildLight );\r\n\t\tbuildLibrary( library.geometries, buildGeometry );\r\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\r\n\r\n\t\tsetupAnimations();\r\n\t\tsetupKinematics();\r\n\r\n\t\tvar scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\r\n\r\n\t\tif ( asset.upAxis === 'Z_UP' ) {\r\n\r\n\t\t\tscene.quaternion.setFromEuler( new Euler( - Math.PI / 2, 0, 0 ) );\r\n\r\n\t\t}\r\n\r\n\t\tscene.scale.multiplyScalar( asset.unit );\r\n\r\n\t\treturn {\r\n\t\t\tanimations: animations,\r\n\t\t\tkinematics: kinematics,\r\n\t\t\tlibrary: library,\r\n\t\t\tscene: scene\r\n\t\t};\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\r\n\r\n\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\r\n\tthis.image = { width: width, height: height };\r\n\tthis.mipmaps = mipmaps;\r\n\r\n\t// no flipping for cube textures\r\n\t// (also flipping doesn't work for compressed textures )\r\n\r\n\tthis.flipY = false;\r\n\r\n\t// can't generate mipmaps for compressed textures\r\n\t// mips must be embedded in DDS files\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n}\r\n\r\nCompressedTexture.prototype = Object.create( Texture.prototype );\r\nCompressedTexture.prototype.constructor = CompressedTexture;\r\n\r\nCompressedTexture.prototype.isCompressedTexture = true;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CompressedTextureLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n}\r\n\r\nObject.assign( CompressedTextureLoader.prototype, {\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar images = [];\r\n\r\n\t\tvar texture = new CompressedTexture();\r\n\t\ttexture.image = images;\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tfunction loadTexture( i ) {\r\n\r\n\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\r\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\timages[ i ] = {\r\n\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t};\r\n\r\n\t\t\t\tloaded += 1;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\r\n\t\t\t\t\t\t{ texture.minFilter = LinearFilter; }\r\n\r\n\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) { onLoad( texture ); }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}\r\n\r\n\t\tif ( Array.isArray( url ) ) {\r\n\r\n\t\t\tvar loaded = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\r\n\t\t\t\tloadTexture( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\tif ( texDatas.isCubemap ) {\r\n\r\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\r\n\t\t\t\t\ttexture.minFilter = LinearFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\tif ( onLoad ) { onLoad( texture ); }\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar DDSLoader = function ( manager ) {\r\n\r\n\tCompressedTextureLoader.call( this, manager );\r\n\r\n\tthis._parser = DDSLoader.parse;\r\n\r\n};\r\n\r\nDDSLoader.prototype = Object.create( CompressedTextureLoader.prototype );\r\nDDSLoader.prototype.constructor = DDSLoader;\r\n\r\nDDSLoader.parse = function ( buffer, loadMipmaps ) {\r\n\r\n\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\r\n\r\n\t// Adapted from @toji's DDS utils\r\n\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\r\n\r\n\t// All values and structures referenced from:\r\n\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\n\r\n\tvar DDS_MAGIC = 0x20534444;\r\n\r\n\tvar DDSD_MIPMAPCOUNT = 0x20000;\r\r\n\r\n\tvar DDSCAPS2_CUBEMAP = 0x200,\r\n\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\r\n\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\r\n\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\r\n\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\r\n\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\r\n\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;\r\r\n\r\n\tvar DDPF_FOURCC = 0x4;\r\r\n\r\n\tfunction fourCCToInt32( value ) {\r\n\r\n\t\treturn value.charCodeAt( 0 ) +\r\n\t\t\t( value.charCodeAt( 1 ) << 8 ) +\r\n\t\t\t( value.charCodeAt( 2 ) << 16 ) +\r\n\t\t\t( value.charCodeAt( 3 ) << 24 );\r\n\r\n\t}\r\n\r\n\tfunction int32ToFourCC( value ) {\r\n\r\n\t\treturn String.fromCharCode(\r\n\t\t\tvalue & 0xff,\r\n\t\t\t( value >> 8 ) & 0xff,\r\n\t\t\t( value >> 16 ) & 0xff,\r\n\t\t\t( value >> 24 ) & 0xff\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\r\n\r\n\t\tvar dataLength = width * height * 4;\r\n\t\tvar srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\r\n\t\tvar byteArray = new Uint8Array( dataLength );\r\n\t\tvar dst = 0;\r\n\t\tvar src = 0;\r\n\t\tfor ( var y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tfor ( var x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tvar b = srcBuffer[ src ]; src ++;\r\n\t\t\t\tvar g = srcBuffer[ src ]; src ++;\r\n\t\t\t\tvar r = srcBuffer[ src ]; src ++;\r\n\t\t\t\tvar a = srcBuffer[ src ]; src ++;\r\n\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\r\n\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\r\n\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\r\n\t\t\t\tbyteArray[ dst ] = a; dst ++;\t//a\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn byteArray;\r\n\r\n\t}\r\n\r\n\tvar FOURCC_DXT1 = fourCCToInt32( \"DXT1\" );\r\n\tvar FOURCC_DXT3 = fourCCToInt32( \"DXT3\" );\r\n\tvar FOURCC_DXT5 = fourCCToInt32( \"DXT5\" );\r\n\tvar FOURCC_ETC1 = fourCCToInt32( \"ETC1\" );\r\n\r\n\tvar headerLengthInt = 31; // The header length in 32 bit ints\r\n\r\n\t// Offsets into the header array\r\n\r\n\tvar off_magic = 0;\r\n\r\n\tvar off_size = 1;\r\n\tvar off_flags = 2;\r\n\tvar off_height = 3;\r\n\tvar off_width = 4;\r\n\r\n\tvar off_mipmapCount = 7;\r\n\r\n\tvar off_pfFlags = 20;\r\n\tvar off_pfFourCC = 21;\r\n\tvar off_RGBBitCount = 22;\r\n\tvar off_RBitMask = 23;\r\n\tvar off_GBitMask = 24;\r\n\tvar off_BBitMask = 25;\r\n\tvar off_ABitMask = 26;\r\n\tvar off_caps2 = 28;\r\n\r\n\t// Parse header\r\n\r\n\tvar header = new Int32Array( buffer, 0, headerLengthInt );\r\n\r\n\tif ( header[ off_magic ] !== DDS_MAGIC ) {\r\n\r\n\t\tconsole.error( 'DDSLoader.parse: Invalid magic number in DDS header.' );\r\n\t\treturn dds;\r\n\r\n\t}\r\n\r\n\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\r\n\r\n\t\tconsole.error( 'DDSLoader.parse: Unsupported format, must contain a FourCC code.' );\r\n\t\treturn dds;\r\n\r\n\t}\r\n\r\n\tvar blockBytes;\r\n\r\n\tvar fourCC = header[ off_pfFourCC ];\r\n\r\n\tvar isRGBAUncompressed = false;\r\n\r\n\tswitch ( fourCC ) {\r\n\r\n\t\tcase FOURCC_DXT1:\r\n\r\n\t\t\tblockBytes = 8;\r\n\t\t\tdds.format = RGB_S3TC_DXT1_Format;\r\n\t\t\tbreak;\r\n\r\n\t\tcase FOURCC_DXT3:\r\n\r\n\t\t\tblockBytes = 16;\r\n\t\t\tdds.format = RGBA_S3TC_DXT3_Format;\r\n\t\t\tbreak;\r\n\r\n\t\tcase FOURCC_DXT5:\r\n\r\n\t\t\tblockBytes = 16;\r\n\t\t\tdds.format = RGBA_S3TC_DXT5_Format;\r\n\t\t\tbreak;\r\n\r\n\t\tcase FOURCC_ETC1:\r\n\r\n\t\t\tblockBytes = 8;\r\n\t\t\tdds.format = RGB_ETC1_Format;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\r\n\t\t\tif ( header[ off_RGBBitCount ] === 32\r\n\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\r\n\t\t\t\t&& header[ off_GBitMask ] & 0xff00\r\n\t\t\t\t&& header[ off_BBitMask ] & 0xff\r\n\t\t\t\t&& header[ off_ABitMask ] & 0xff000000 ) {\r\n\r\n\t\t\t\tisRGBAUncompressed = true;\r\n\t\t\t\tblockBytes = 64;\r\n\t\t\t\tdds.format = RGBAFormat;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );\r\n\t\t\t\treturn dds;\r\n\r\n\t\t\t}\r\n\r\n\t}\r\n\r\n\tdds.mipmapCount = 1;\r\n\r\n\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\r\n\r\n\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\r\n\r\n\t}\r\n\r\n\tvar caps2 = header[ off_caps2 ];\r\n\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\r\n\tif ( dds.isCubemap && (\r\n\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||\r\n\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||\r\n\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||\r\n\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||\r\n\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||\r\n\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )\r\n\t) ) {\r\n\r\n\t\tconsole.error( 'DDSLoader.parse: Incomplete cubemap faces' );\r\n\t\treturn dds;\r\n\r\n\t}\r\n\r\n\tdds.width = header[ off_width ];\r\n\tdds.height = header[ off_height ];\r\n\r\n\tvar dataOffset = header[ off_size ] + 4;\r\n\r\n\t// Extract mipmaps buffers\r\n\r\n\tvar faces = dds.isCubemap ? 6 : 1;\r\n\r\n\tfor ( var face = 0; face < faces; face ++ ) {\r\n\r\n\t\tvar width = dds.width;\r\n\t\tvar height = dds.height;\r\n\r\n\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\r\n\r\n\t\t\tif ( isRGBAUncompressed ) {\r\n\r\n\t\t\t\tvar byteArray = loadARGBMip( buffer, dataOffset, width, height );\r\n\t\t\t\tvar dataLength = byteArray.length;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\r\n\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\r\n\t\t\tdds.mipmaps.push( mipmap );\r\n\r\n\t\t\tdataOffset += dataLength;\r\n\r\n\t\t\twidth = Math.max( width >> 1, 1 );\r\n\t\t\theight = Math.max( height >> 1, 1 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn dds;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LineLoop( geometry, material ) {\r\n\r\n\tLine.call( this, geometry, material );\r\n\r\n\tthis.type = 'LineLoop';\r\n\r\n}\r\n\r\nLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\r\n\r\n\tconstructor: LineLoop,\r\n\r\n\tisLineLoop: true,\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar LegacyGLTFLoader = ( function () {\r\n\r\n\tfunction LegacyGLTFLoader( manager ) {\r\n\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\t}\r\n\r\n\tLegacyGLTFLoader.prototype = {\r\n\r\n\t\tconstructor: LegacyGLTFLoader,\r\n\r\n\t\tcrossOrigin: 'anonymous',\r\n\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tvar path = this.path && ( typeof this.path === \"string\" ) ? this.path : LoaderUtils.extractUrlBase( url );\r\n\r\n\t\t\tvar loader = new FileLoader( scope.manager );\r\n\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\t\tloader.load( url, function ( data ) {\r\n\r\n\t\t\t\tscope.parse( data, path, onLoad );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\t\tthis.crossOrigin = value;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetPath: function ( value ) {\r\n\r\n\t\t\tthis.path = value;\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( data, path, callback ) {\r\n\r\n\t\t\tvar content;\r\n\t\t\tvar extensions = {};\r\n\r\n\t\t\tvar magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\r\n\r\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_DEFAULTS.magic ) {\r\n\r\n\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\r\n\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcontent = LoaderUtils.decodeText( new Uint8Array( data ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar json = JSON.parse( content );\r\n\r\n\t\t\tif ( json.extensionsUsed && json.extensionsUsed.indexOf( EXTENSIONS.KHR_MATERIALS_COMMON ) >= 0 ) {\r\n\r\n\t\t\t\textensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] = new GLTFMaterialsCommonExtension( json );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parser = new GLTFParser( json, extensions, {\r\n\r\n\t\t\t\tcrossOrigin: this.crossOrigin,\r\n\t\t\t\tmanager: this.manager,\r\n\t\t\t\tpath: path || this.path\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tparser.parse( function ( scene, scenes, cameras, animations ) {\r\n\r\n\t\t\t\tvar glTF = {\r\n\t\t\t\t\t\"scene\": scene,\r\n\t\t\t\t\t\"scenes\": scenes,\r\n\t\t\t\t\t\"cameras\": cameras,\r\n\t\t\t\t\t\"animations\": animations\r\n\t\t\t\t};\r\n\r\n\t\t\t\tcallback( glTF );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction GLTFRegistry() {\r\n\r\n\t\tvar objects = {};\r\n\r\n\t\treturn\t{\r\n\r\n\t\t\tget: function ( key ) {\r\n\r\n\t\t\t\treturn objects[ key ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tadd: function ( key, object ) {\r\n\r\n\t\t\t\tobjects[ key ] = object;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tremove: function ( key ) {\r\n\r\n\t\t\t\tdelete objects[ key ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tremoveAll: function () {\r\n\r\n\t\t\t\tobjects = {};\r\n\r\n\t\t\t},\r\n\r\n\t\t\tupdate: function ( scene, camera ) {\r\n\r\n\t\t\t\tfor ( var name in objects ) {\r\n\r\n\t\t\t\t\tvar object = objects[ name ];\r\n\r\n\t\t\t\t\tif ( object.update ) {\r\n\r\n\t\t\t\t\t\tobject.update( scene, camera );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tLegacyGLTFLoader.Shaders = {\r\n\r\n\t\tupdate: function () {\r\n\r\n\t\t\tconsole.warn( 'LegacyGLTFLoader.Shaders has been deprecated, and now updates automatically.' );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction GLTFShader( targetNode, allNodes ) {\r\n\r\n\t\tvar boundUniforms = {};\r\n\r\n\t\t// bind each uniform to its source node\r\n\r\n\t\tvar uniforms = targetNode.material.uniforms;\r\n\r\n\t\tfor ( var uniformId in uniforms ) {\r\n\r\n\t\t\tvar uniform = uniforms[ uniformId ];\r\n\r\n\t\t\tif ( uniform.semantic ) {\r\n\r\n\t\t\t\tvar sourceNodeRef = uniform.node;\r\n\r\n\t\t\t\tvar sourceNode = targetNode;\r\n\r\n\t\t\t\tif ( sourceNodeRef ) {\r\n\r\n\t\t\t\t\tsourceNode = allNodes[ sourceNodeRef ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tboundUniforms[ uniformId ] = {\r\n\t\t\t\t\tsemantic: uniform.semantic,\r\n\t\t\t\t\tsourceNode: sourceNode,\r\n\t\t\t\t\ttargetNode: targetNode,\r\n\t\t\t\t\tuniform: uniform\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundUniforms = boundUniforms;\r\n\t\tthis._m4 = new Matrix4();\r\n\r\n\t}\r\n\r\n\t// Update - update all the uniform values\r\n\tGLTFShader.prototype.update = function ( scene, camera ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar boundUniforms = this.boundUniforms;\r\n\r\n\t\tfor ( var name in boundUniforms ) {\r\n\r\n\t\t\tvar boundUniform = boundUniforms[ name ];\r\n\r\n\t\t\tswitch ( boundUniform.semantic ) {\r\n\r\n\t\t\t\tcase \"MODELVIEW\":\r\n\r\n\t\t\t\t\tvar m4 = boundUniform.uniform.value;\r\n\t\t\t\t\tm4.multiplyMatrices( camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"MODELVIEWINVERSETRANSPOSE\":\r\n\r\n\t\t\t\t\tvar m3 = boundUniform.uniform.value;\r\n\t\t\t\t\tthis$1._m4.multiplyMatrices( camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld );\r\n\t\t\t\t\tm3.getNormalMatrix( this$1._m4 );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"PROJECTION\":\r\n\r\n\t\t\t\t\tvar m4 = boundUniform.uniform.value;\r\n\t\t\t\t\tm4.copy( camera.projectionMatrix );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"JOINTMATRIX\":\r\n\r\n\t\t\t\t\tvar m4v = boundUniform.uniform.value;\r\n\r\n\t\t\t\t\tfor ( var mi = 0; mi < m4v.length; mi ++ ) {\r\n\r\n\t\t\t\t\t\t// So it goes like this:\r\n\t\t\t\t\t\t// SkinnedMesh world matrix is already baked into MODELVIEW;\r\n\t\t\t\t\t\t// transform joints to local space,\r\n\t\t\t\t\t\t// then transform using joint's inverse\r\n\t\t\t\t\t\tm4v[ mi ]\r\n\t\t\t\t\t\t\t.getInverse( boundUniform.sourceNode.matrixWorld )\r\n\t\t\t\t\t\t\t.multiply( boundUniform.targetNode.skeleton.bones[ mi ].matrixWorld )\r\n\t\t\t\t\t\t\t.multiply( boundUniform.targetNode.skeleton.boneInverses[ mi ] )\r\n\t\t\t\t\t\t\t.multiply( boundUniform.targetNode.bindMatrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault :\r\n\r\n\t\t\t\t\tconsole.warn( \"Unhandled shader semantic: \" + boundUniform.semantic );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tLegacyGLTFLoader.Animations = {\r\n\r\n\t\tupdate: function () {\r\n\r\n\t\t\tconsole.warn( 'LegacyGLTFLoader.Animation has been deprecated. Use AnimationMixer instead.' );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar EXTENSIONS = {\r\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\r\n\t\tKHR_MATERIALS_COMMON: 'KHR_materials_common'\r\n\t};\r\n\r\n\tfunction GLTFMaterialsCommonExtension( json ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_COMMON;\r\n\r\n\t\tthis.lights = {};\r\n\r\n\t\tvar extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] ) || {};\r\n\t\tvar lights = extension.lights || {};\r\n\r\n\t\tfor ( var lightId in lights ) {\r\n\r\n\t\t\tvar light = lights[ lightId ];\r\n\t\t\tvar lightNode;\r\n\r\n\t\t\tvar lightParams = light[ light.type ];\r\n\t\t\tvar color = new Color().fromArray( lightParams.color );\r\n\r\n\t\t\tswitch ( light.type ) {\r\n\r\n\t\t\t\tcase \"directional\":\r\n\t\t\t\t\tlightNode = new DirectionalLight( color );\r\n\t\t\t\t\tlightNode.position.set( 0, 0, 1 );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"point\":\r\n\t\t\t\t\tlightNode = new PointLight( color );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"spot\":\r\n\t\t\t\t\tlightNode = new SpotLight( color );\r\n\t\t\t\t\tlightNode.position.set( 0, 0, 1 );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"ambient\":\r\n\t\t\t\t\tlightNode = new AmbientLight( color );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( lightNode ) {\r\n\r\n\t\t\t\tthis$1.lights[ lightId ] = lightNode;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';\r\n\r\n\tvar BINARY_EXTENSION_HEADER_DEFAULTS = { magic: 'glTF', version: 1, contentFormat: 0 };\r\n\r\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n\r\n\tfunction GLTFBinaryExtension( data ) {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\r\n\r\n\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\r\n\r\n\t\tvar header = {\r\n\t\t\tmagic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\r\n\t\t\tversion: headerView.getUint32( 4, true ),\r\n\t\t\tlength: headerView.getUint32( 8, true ),\r\n\t\t\tcontentLength: headerView.getUint32( 12, true ),\r\n\t\t\tcontentFormat: headerView.getUint32( 16, true )\r\n\t\t};\r\n\r\n\t\tfor ( var key in BINARY_EXTENSION_HEADER_DEFAULTS ) {\r\n\r\n\t\t\tvar value = BINARY_EXTENSION_HEADER_DEFAULTS[ key ];\r\n\r\n\t\t\tif ( header[ key ] !== value ) {\r\n\r\n\t\t\t\tthrow new Error( 'Unsupported glTF-Binary header: Expected \"%s\" to be \"%s\".', key, value );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH, header.contentLength );\r\n\r\n\t\tthis.header = header;\r\n\t\tthis.content = LoaderUtils.decodeText( contentArray );\r\n\t\tthis.body = data.slice( BINARY_EXTENSION_HEADER_LENGTH + header.contentLength, header.length );\r\n\r\n\t}\r\n\r\n\tGLTFBinaryExtension.prototype.loadShader = function ( shader, bufferViews ) {\r\n\r\n\t\tvar bufferView = bufferViews[ shader.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].bufferView ];\r\n\t\tvar array = new Uint8Array( bufferView );\r\n\r\n\t\treturn LoaderUtils.decodeText( array );\r\n\r\n\t};\r\n\r\n\tvar WEBGL_CONSTANTS = {\r\n\t\tFLOAT: 5126,\r\n\t\t//FLOAT_MAT2: 35674,\r\n\t\tFLOAT_MAT3: 35675,\r\n\t\tFLOAT_MAT4: 35676,\r\n\t\tFLOAT_VEC2: 35664,\r\n\t\tFLOAT_VEC3: 35665,\r\n\t\tFLOAT_VEC4: 35666,\r\n\t\tLINEAR: 9729,\r\n\t\tREPEAT: 10497,\r\n\t\tSAMPLER_2D: 35678,\r\n\t\tTRIANGLES: 4,\r\n\t\tLINES: 1,\r\n\t\tUNSIGNED_BYTE: 5121,\r\n\t\tUNSIGNED_SHORT: 5123,\r\n\r\n\t\tVERTEX_SHADER: 35633,\r\n\t\tFRAGMENT_SHADER: 35632\r\n\t};\r\n\r\n\tvar WEBGL_TYPE = {\r\n\t\t5126: Number,\r\n\t\t//35674: Matrix2,\r\n\t\t35675: Matrix3,\r\n\t\t35676: Matrix4,\r\n\t\t35664: Vector2,\r\n\t\t35665: Vector3,\r\n\t\t35666: Vector4,\r\n\t\t35678: Texture\r\n\t};\r\n\r\n\tvar WEBGL_COMPONENT_TYPES = {\r\n\t\t5120: Int8Array,\r\n\t\t5121: Uint8Array,\r\n\t\t5122: Int16Array,\r\n\t\t5123: Uint16Array,\r\n\t\t5125: Uint32Array,\r\n\t\t5126: Float32Array\r\n\t};\r\n\r\n\tvar WEBGL_FILTERS = {\r\n\t\t9728: NearestFilter,\r\n\t\t9729: LinearFilter,\r\n\t\t9984: NearestMipMapNearestFilter,\r\n\t\t9985: LinearMipMapNearestFilter,\r\n\t\t9986: NearestMipMapLinearFilter,\r\n\t\t9987: LinearMipMapLinearFilter\r\n\t};\r\n\r\n\tvar WEBGL_WRAPPINGS = {\r\n\t\t33071: ClampToEdgeWrapping,\r\n\t\t33648: MirroredRepeatWrapping,\r\n\t\t10497: RepeatWrapping\r\n\t};\r\n\r\n\tvar WEBGL_TEXTURE_FORMATS = {\r\n\t\t6406: AlphaFormat,\r\n\t\t6407: RGBFormat,\r\n\t\t6408: RGBAFormat,\r\n\t\t6409: LuminanceFormat,\r\n\t\t6410: LuminanceAlphaFormat\r\n\t};\r\n\r\n\tvar WEBGL_TEXTURE_DATATYPES = {\r\n\t\t5121: UnsignedByteType,\r\n\t\t32819: UnsignedShort4444Type,\r\n\t\t32820: UnsignedShort5551Type,\r\n\t\t33635: UnsignedShort565Type\r\n\t};\r\n\r\n\tvar WEBGL_SIDES = {\r\n\t\t1028: BackSide,  // Culling front\r\n\t\t1029: FrontSide  // Culling back\r\n\t\t//1032: NoSide   // Culling front and back, what to do?\r\n\t};\r\n\r\n\tvar WEBGL_DEPTH_FUNCS = {\r\n\t\t512: NeverDepth,\r\n\t\t513: LessDepth,\r\n\t\t514: EqualDepth,\r\n\t\t515: LessEqualDepth,\r\n\t\t516: GreaterEqualDepth,\r\n\t\t517: NotEqualDepth,\r\n\t\t518: GreaterEqualDepth,\r\n\t\t519: AlwaysDepth\r\n\t};\r\n\r\n\tvar WEBGL_BLEND_EQUATIONS = {\r\n\t\t32774: AddEquation,\r\n\t\t32778: SubtractEquation,\r\n\t\t32779: ReverseSubtractEquation\r\n\t};\r\n\r\n\tvar WEBGL_BLEND_FUNCS = {\r\n\t\t0: ZeroFactor,\r\n\t\t1: OneFactor,\r\n\t\t768: SrcColorFactor,\r\n\t\t769: OneMinusSrcColorFactor,\r\n\t\t770: SrcAlphaFactor,\r\n\t\t771: OneMinusSrcAlphaFactor,\r\n\t\t772: DstAlphaFactor,\r\n\t\t773: OneMinusDstAlphaFactor,\r\n\t\t774: DstColorFactor,\r\n\t\t775: OneMinusDstColorFactor,\r\n\t\t776: SrcAlphaSaturateFactor\r\n\t\t// The followings are not supported by Three.js yet\r\n\t\t//32769: CONSTANT_COLOR,\r\n\t\t//32770: ONE_MINUS_CONSTANT_COLOR,\r\n\t\t//32771: CONSTANT_ALPHA,\r\n\t\t//32772: ONE_MINUS_CONSTANT_COLOR\r\n\t};\r\n\r\n\tvar WEBGL_TYPE_SIZES = {\r\n\t\t'SCALAR': 1,\r\n\t\t'VEC2': 2,\r\n\t\t'VEC3': 3,\r\n\t\t'VEC4': 4,\r\n\t\t'MAT2': 4,\r\n\t\t'MAT3': 9,\r\n\t\t'MAT4': 16\r\n\t};\r\n\r\n\tvar PATH_PROPERTIES = {\r\n\t\tscale: 'scale',\r\n\t\ttranslation: 'position',\r\n\t\trotation: 'quaternion'\r\n\t};\r\n\r\n\tvar INTERPOLATION = {\r\n\t\tLINEAR: InterpolateLinear,\r\n\t\tSTEP: InterpolateDiscrete\r\n\t};\r\n\r\n\tvar STATES_ENABLES = {\r\n\t\t2884: 'CULL_FACE',\r\n\t\t2929: 'DEPTH_TEST',\r\n\t\t3042: 'BLEND',\r\n\t\t3089: 'SCISSOR_TEST',\r\n\t\t32823: 'POLYGON_OFFSET_FILL',\r\n\t\t32926: 'SAMPLE_ALPHA_TO_COVERAGE'\r\n\t};\r\n\r\n\tfunction _each( object, callback, thisObj ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( !object ) {\r\n\t\t\treturn Promise.resolve();\r\n\t\t}\r\n\r\n\t\tvar results;\r\n\t\tvar fns = [];\r\n\r\n\t\tif ( Object.prototype.toString.call( object ) === '[object Array]' ) {\r\n\r\n\t\t\tresults = [];\r\n\r\n\t\t\tvar length = object.length;\r\n\r\n\t\t\tfor ( var idx = 0; idx < length; idx ++ ) {\r\n\r\n\t\t\t\tvar value = callback.call( thisObj || this$1, object[ idx ], idx );\r\n\r\n\t\t\t\tif ( value ) {\r\n\r\n\t\t\t\t\tfns.push( value );\r\n\r\n\t\t\t\t\tif ( value instanceof Promise ) {\r\n\r\n\t\t\t\t\t\tvalue.then( function( key, value ) {\r\n\r\n\t\t\t\t\t\t\tresults[ key ] = value;\r\n\r\n\t\t\t\t\t\t}.bind( this$1, idx ));\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tresults[ idx ] = value;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresults = {};\r\n\r\n\t\t\tfor ( var key in object ) {\r\n\r\n\t\t\t\tif ( object.hasOwnProperty( key ) ) {\r\n\r\n\t\t\t\t\tvar value = callback.call( thisObj || this$1, object[ key ], key );\r\n\r\n\t\t\t\t\tif ( value ) {\r\n\r\n\t\t\t\t\t\tfns.push( value );\r\n\r\n\t\t\t\t\t\tif ( value instanceof Promise ) {\r\n\r\n\t\t\t\t\t\t\tvalue.then( function( key, value ) {\r\n\r\n\t\t\t\t\t\t\t\tresults[ key ] = value;\r\n\r\n\t\t\t\t\t\t\t}.bind( this$1, key ));\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tresults[ key ] = value;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( fns ).then( function() {\r\n\r\n\t\t\treturn results;\r\n\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tfunction resolveURL( url, path ) {\r\n\r\n\t\t// Invalid URL\r\n\t\tif ( typeof url !== 'string' || url === '' )\r\n\t\t\t{ return ''; }\r\n\r\n\t\t// Absolute URL http://,https://,//\r\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) {\r\n\r\n\t\t\treturn url;\r\n\r\n\t\t}\r\n\r\n\t\t// Data URI\r\n\t\tif ( /^data:.*,.*$/i.test( url ) ) {\r\n\r\n\t\t\treturn url;\r\n\r\n\t\t}\r\n\r\n\t\t// Blob URL\r\n\t\tif ( /^blob:.*$/i.test( url ) ) {\r\n\r\n\t\t\treturn url;\r\n\r\n\t\t}\r\n\r\n\t\t// Relative URL\r\n\t\treturn ( path || '' ) + url;\r\n\r\n\t}\r\n\r\n\t// Three.js seems too dependent on attribute names so globally\r\n\t// replace those in the shader code\r\n\tfunction replaceTHREEShaderAttributes( shaderText, technique ) {\r\n\r\n\t\t// Expected technique attributes\r\n\t\tvar attributes = {};\r\n\r\n\t\tfor ( var attributeId in technique.attributes ) {\r\n\r\n\t\t\tvar pname = technique.attributes[ attributeId ];\r\n\r\n\t\t\tvar param = technique.parameters[ pname ];\r\n\t\t\tvar atype = param.type;\r\n\t\t\tvar semantic = param.semantic;\r\n\r\n\t\t\tattributes[ attributeId ] = {\r\n\t\t\t\ttype: atype,\r\n\t\t\t\tsemantic: semantic\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// Figure out which attributes to change in technique\r\n\r\n\t\tvar shaderParams = technique.parameters;\r\n\t\tvar shaderAttributes = technique.attributes;\r\n\t\tvar params = {};\r\n\r\n\t\tfor ( var attributeId in attributes ) {\r\n\r\n\t\t\tvar pname = shaderAttributes[ attributeId ];\r\n\t\t\tvar shaderParam = shaderParams[ pname ];\r\n\t\t\tvar semantic = shaderParam.semantic;\r\n\t\t\tif ( semantic ) {\r\n\r\n\t\t\t\tparams[ attributeId ] = shaderParam;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var pname in params ) {\r\n\r\n\t\t\tvar param = params[ pname ];\r\n\t\t\tvar semantic = param.semantic;\r\n\r\n\t\t\tvar regEx = new RegExp( \"\\\\b\" + pname + \"\\\\b\", \"g\" );\r\n\r\n\t\t\tswitch ( semantic ) {\r\n\r\n\t\t\t\tcase \"POSITION\":\r\n\r\n\t\t\t\t\tshaderText = shaderText.replace( regEx, 'position' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"NORMAL\":\r\n\r\n\t\t\t\t\tshaderText = shaderText.replace( regEx, 'normal' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'TEXCOORD_0':\r\n\t\t\t\tcase 'TEXCOORD0':\r\n\t\t\t\tcase 'TEXCOORD':\r\n\r\n\t\t\t\t\tshaderText = shaderText.replace( regEx, 'uv' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'TEXCOORD_1':\r\n\r\n\t\t\t\t\tshaderText = shaderText.replace( regEx, 'uv2' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'COLOR_0':\r\n\t\t\t\tcase 'COLOR0':\r\n\t\t\t\tcase 'COLOR':\r\n\r\n\t\t\t\t\tshaderText = shaderText.replace( regEx, 'color' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"WEIGHT\":\r\n\r\n\t\t\t\t\tshaderText = shaderText.replace( regEx, 'skinWeight' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase \"JOINT\":\r\n\r\n\t\t\t\t\tshaderText = shaderText.replace( regEx, 'skinIndex' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn shaderText;\r\n\r\n\t}\r\n\r\n\tfunction createDefaultMaterial() {\r\n\r\n\t\treturn new MeshPhongMaterial( {\r\n\t\t\tcolor: 0x00000,\r\n\t\t\temissive: 0x888888,\r\n\t\t\tspecular: 0x000000,\r\n\t\t\tshininess: 0,\r\n\t\t\ttransparent: false,\r\n\t\t\tdepthTest: true,\r\n\t\t\tside: FrontSide\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t// Deferred constructor for RawShaderMaterial types\r\n\tfunction DeferredShaderMaterial( params ) {\r\n\r\n\t\tthis.isDeferredShaderMaterial = true;\r\n\r\n\t\tthis.params = params;\r\n\r\n\t}\r\n\r\n\tDeferredShaderMaterial.prototype.create = function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar uniforms = UniformsUtils.clone( this.params.uniforms );\r\n\r\n\t\tfor ( var uniformId in this$1.params.uniforms ) {\r\n\r\n\t\t\tvar originalUniform = this$1.params.uniforms[ uniformId ];\r\n\r\n\t\t\tif ( originalUniform.value instanceof Texture ) {\r\n\r\n\t\t\t\tuniforms[ uniformId ].value = originalUniform.value;\r\n\t\t\t\tuniforms[ uniformId ].value.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuniforms[ uniformId ].semantic = originalUniform.semantic;\r\n\t\t\tuniforms[ uniformId ].node = originalUniform.node;\r\n\r\n\t\t}\r\n\r\n\t\tthis.params.uniforms = uniforms;\r\n\r\n\t\treturn new RawShaderMaterial( this.params );\r\n\r\n\t};\r\n\r\n\tfunction GLTFParser( json, extensions, options ) {\r\n\r\n\t\tthis.json = json || {};\r\n\t\tthis.extensions = extensions || {};\r\n\t\tthis.options = options || {};\r\n\r\n\t\t// loader object cache\r\n\t\tthis.cache = new GLTFRegistry();\r\n\r\n\t}\r\n\r\n\tGLTFParser.prototype._withDependencies = function ( dependencies ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar _dependencies = {};\r\n\r\n\t\tfor ( var i = 0; i < dependencies.length; i ++ ) {\r\n\r\n\t\t\tvar dependency = dependencies[ i ];\r\n\t\t\tvar fnName = \"load\" + dependency.charAt( 0 ).toUpperCase() + dependency.slice( 1 );\r\n\r\n\t\t\tvar cached = this$1.cache.get( dependency );\r\n\r\n\t\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\t\t_dependencies[ dependency ] = cached;\r\n\r\n\t\t\t} else if ( this$1[ fnName ] ) {\r\n\r\n\t\t\t\tvar fn = this$1[ fnName ]();\r\n\t\t\t\tthis$1.cache.add( dependency, fn );\r\n\r\n\t\t\t\t_dependencies[ dependency ] = fn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn _each( _dependencies, function ( dependency ) {\r\n\r\n\t\t\treturn dependency;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.parse = function ( callback ) {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\t// Clear the loader cache\r\n\t\tthis.cache.removeAll();\r\n\r\n\t\t// Fire the callback on complete\r\n\t\tthis._withDependencies( [\r\n\r\n\t\t\t\"scenes\",\r\n\t\t\t\"cameras\",\r\n\t\t\t\"animations\"\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tvar scenes = [];\r\n\r\n\t\t\tfor ( var name in dependencies.scenes ) {\r\n\r\n\t\t\t\tscenes.push( dependencies.scenes[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar scene = json.scene !== undefined ? dependencies.scenes[ json.scene ] : scenes[ 0 ];\r\n\r\n\t\t\tvar cameras = [];\r\n\r\n\t\t\tfor ( var name in dependencies.cameras ) {\r\n\r\n\t\t\t\tvar camera = dependencies.cameras[ name ];\r\n\t\t\t\tcameras.push( camera );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar animations = [];\r\n\r\n\t\t\tfor ( var name in dependencies.animations ) {\r\n\r\n\t\t\t\tanimations.push( dependencies.animations[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcallback( scene, scenes, cameras, animations );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadShaders = function () {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar options = this.options;\r\n\r\n\t\treturn this._withDependencies( [\r\n\r\n\t\t\t\"bufferViews\"\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\treturn _each( json.shaders, function ( shader ) {\r\n\r\n\t\t\t\tif ( shader.extensions && shader.extensions[ EXTENSIONS.KHR_BINARY_GLTF ] ) {\r\n\r\n\t\t\t\t\treturn extensions[ EXTENSIONS.KHR_BINARY_GLTF ].loadShader( shader, dependencies.bufferViews );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new Promise( function ( resolve ) {\r\n\r\n\t\t\t\t\tvar loader = new FileLoader( options.manager );\r\n\t\t\t\t\tloader.setResponseType( 'text' );\r\n\t\t\t\t\tloader.load( resolveURL( shader.uri, options.path ), function ( shaderText ) {\r\n\r\n\t\t\t\t\t\tresolve( shaderText );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadBuffers = function () {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar options = this.options;\r\n\r\n\t\treturn _each( json.buffers, function ( buffer, name ) {\r\n\r\n\t\t\tif ( name === BINARY_EXTENSION_BUFFER_NAME ) {\r\n\r\n\t\t\t\treturn extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( buffer.type === 'arraybuffer' || buffer.type === undefined ) {\r\n\r\n\t\t\t\treturn new Promise( function ( resolve ) {\r\n\r\n\t\t\t\t\tvar loader = new FileLoader( options.manager );\r\n\t\t\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\t\t\t\tloader.load( resolveURL( buffer.uri, options.path ), function ( buffer ) {\r\n\r\n\t\t\t\t\t\tresolve( buffer );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'LegacyGLTFLoader: ' + buffer.type + ' buffer type is not supported' );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadBufferViews = function () {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\treturn this._withDependencies( [\r\n\r\n\t\t\t\"buffers\"\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\treturn _each( json.bufferViews, function ( bufferView ) {\r\n\r\n\t\t\t\tvar arraybuffer = dependencies.buffers[ bufferView.buffer ];\r\n\r\n\t\t\t\tvar byteLength = bufferView.byteLength !== undefined ? bufferView.byteLength : 0;\r\n\r\n\t\t\t\treturn arraybuffer.slice( bufferView.byteOffset, bufferView.byteOffset + byteLength );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadAccessors = function () {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\treturn this._withDependencies( [\r\n\r\n\t\t\t\"bufferViews\"\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\treturn _each( json.accessors, function ( accessor ) {\r\n\r\n\t\t\t\tvar arraybuffer = dependencies.bufferViews[ accessor.bufferView ];\r\n\t\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessor.type ];\r\n\t\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessor.componentType ];\r\n\r\n\t\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\r\n\t\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\r\n\t\t\t\tvar itemBytes = elementBytes * itemSize;\r\n\r\n\t\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\r\n\t\t\t\tif ( accessor.byteStride && accessor.byteStride !== itemBytes ) {\r\n\r\n\t\t\t\t\t// Use the full buffer if it's interleaved.\r\n\t\t\t\t\tvar array = new TypedArray( arraybuffer );\r\n\r\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\r\n\t\t\t\t\tvar ib = new InterleavedBuffer( array, accessor.byteStride / elementBytes );\r\n\r\n\t\t\t\t\treturn new InterleavedBufferAttribute( ib, itemSize, accessor.byteOffset / elementBytes );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tarray = new TypedArray( arraybuffer, accessor.byteOffset, accessor.count * itemSize );\r\n\r\n\t\t\t\t\treturn new BufferAttribute( array, itemSize );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadTextures = function () {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar options = this.options;\r\n\r\n\t\treturn this._withDependencies( [\r\n\r\n\t\t\t\"bufferViews\"\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\treturn _each( json.textures, function ( texture ) {\r\n\r\n\t\t\t\tif ( texture.source ) {\r\n\r\n\t\t\t\t\treturn new Promise( function ( resolve ) {\r\n\r\n\t\t\t\t\t\tvar source = json.images[ texture.source ];\r\n\t\t\t\t\t\tvar sourceUri = source.uri;\r\n\t\t\t\t\t\tvar isObjectURL = false;\r\n\r\n\t\t\t\t\t\tif ( source.extensions && source.extensions[ EXTENSIONS.KHR_BINARY_GLTF ] ) {\r\n\r\n\t\t\t\t\t\t\tvar metadata = source.extensions[ EXTENSIONS.KHR_BINARY_GLTF ];\r\n\t\t\t\t\t\t\tvar bufferView = dependencies.bufferViews[ metadata.bufferView ];\r\n\t\t\t\t\t\t\tvar blob = new Blob( [ bufferView ], { type: metadata.mimeType } );\r\n\t\t\t\t\t\t\tsourceUri = URL.createObjectURL( blob );\r\n\t\t\t\t\t\t\tisObjectURL = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar textureLoader = Loader$1.Handlers.get( sourceUri );\r\n\r\n\t\t\t\t\t\tif ( textureLoader === null ) {\r\n\r\n\t\t\t\t\t\t\ttextureLoader = new TextureLoader( options.manager );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( options.crossOrigin );\r\n\r\n\t\t\t\t\t\ttextureLoader.load( resolveURL( sourceUri, options.path ), function ( _texture ) {\r\n\r\n\t\t\t\t\t\t\tif ( isObjectURL ) { URL.revokeObjectURL( sourceUri ); }\r\n\r\n\t\t\t\t\t\t\t_texture.flipY = false;\r\n\r\n\t\t\t\t\t\t\tif ( texture.name !== undefined ) { _texture.name = texture.name; }\r\n\r\n\t\t\t\t\t\t\t_texture.format = texture.format !== undefined ? WEBGL_TEXTURE_FORMATS[ texture.format ] : RGBAFormat;\r\n\r\n\t\t\t\t\t\t\tif ( texture.internalFormat !== undefined && _texture.format !== WEBGL_TEXTURE_FORMATS[ texture.internalFormat ] ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'LegacyGLTFLoader: Three.js doesn\\'t support texture internalFormat which is different from texture format. ' +\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'internalFormat will be forced to be the same value as format.' );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t_texture.type = texture.type !== undefined ? WEBGL_TEXTURE_DATATYPES[ texture.type ] : UnsignedByteType;\r\n\r\n\t\t\t\t\t\t\tif ( texture.sampler ) {\r\n\r\n\t\t\t\t\t\t\t\tvar sampler = json.samplers[ texture.sampler ];\r\n\r\n\t\t\t\t\t\t\t\t_texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\r\n\t\t\t\t\t\t\t\t_texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || NearestMipMapLinearFilter;\r\n\t\t\t\t\t\t\t\t_texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\r\n\t\t\t\t\t\t\t\t_texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tresolve( _texture );\r\n\r\n\t\t\t\t\t\t}, undefined, function () {\r\n\r\n\t\t\t\t\t\t\tif ( isObjectURL ) { URL.revokeObjectURL( sourceUri ); }\r\n\r\n\t\t\t\t\t\t\tresolve();\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadMaterials = function () {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\treturn this._withDependencies( [\r\n\r\n\t\t\t\"shaders\",\r\n\t\t\t\"textures\"\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\treturn _each( json.materials, function ( material ) {\r\n\r\n\t\t\t\tvar materialType;\r\n\t\t\t\tvar materialValues = {};\r\n\t\t\t\tvar materialParams = {};\r\n\r\n\t\t\t\tvar khr_material;\r\n\r\n\t\t\t\tif ( material.extensions && material.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] ) {\r\n\r\n\t\t\t\t\tkhr_material = material.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( khr_material ) {\r\n\r\n\t\t\t\t\t// don't copy over unused values to avoid material warning spam\r\n\t\t\t\t\tvar keys = [ 'ambient', 'emission', 'transparent', 'transparency', 'doubleSided' ];\r\n\r\n\t\t\t\t\tswitch ( khr_material.technique ) {\r\n\r\n\t\t\t\t\t\tcase 'BLINN' :\r\n\t\t\t\t\t\tcase 'PHONG' :\r\n\t\t\t\t\t\t\tmaterialType = MeshPhongMaterial;\r\n\t\t\t\t\t\t\tkeys.push( 'diffuse', 'specular', 'shininess' );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'LAMBERT' :\r\n\t\t\t\t\t\t\tmaterialType = MeshLambertMaterial;\r\n\t\t\t\t\t\t\tkeys.push( 'diffuse' );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'CONSTANT' :\r\n\t\t\t\t\t\tdefault :\r\n\t\t\t\t\t\t\tmaterialType = MeshBasicMaterial;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tkeys.forEach( function( v ) {\r\n\r\n\t\t\t\t\t\tif ( khr_material.values[ v ] !== undefined ) { materialValues[ v ] = khr_material.values[ v ]; }\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tif ( khr_material.doubleSided || materialValues.doubleSided ) {\r\n\r\n\t\t\t\t\t\tmaterialParams.side = DoubleSide;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( khr_material.transparent || materialValues.transparent ) {\r\n\r\n\t\t\t\t\t\tmaterialParams.transparent = true;\r\n\t\t\t\t\t\tmaterialParams.opacity = ( materialValues.transparency !== undefined ) ? materialValues.transparency : 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( material.technique === undefined ) {\r\n\r\n\t\t\t\t\tmaterialType = MeshPhongMaterial;\r\n\r\n\t\t\t\t\tObject.assign( materialValues, material.values );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterialType = DeferredShaderMaterial;\r\n\r\n\t\t\t\t\tvar technique = json.techniques[ material.technique ];\r\n\r\n\t\t\t\t\tmaterialParams.uniforms = {};\r\n\r\n\t\t\t\t\tvar program = json.programs[ technique.program ];\r\n\r\n\t\t\t\t\tif ( program ) {\r\n\r\n\t\t\t\t\t\tmaterialParams.fragmentShader = dependencies.shaders[ program.fragmentShader ];\r\n\r\n\t\t\t\t\t\tif ( ! materialParams.fragmentShader ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( \"ERROR: Missing fragment shader definition:\", program.fragmentShader );\r\n\t\t\t\t\t\t\tmaterialType = MeshPhongMaterial;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar vertexShader = dependencies.shaders[ program.vertexShader ];\r\n\r\n\t\t\t\t\t\tif ( ! vertexShader ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( \"ERROR: Missing vertex shader definition:\", program.vertexShader );\r\n\t\t\t\t\t\t\tmaterialType = MeshPhongMaterial;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// IMPORTANT: FIX VERTEX SHADER ATTRIBUTE DEFINITIONS\r\n\t\t\t\t\t\tmaterialParams.vertexShader = replaceTHREEShaderAttributes( vertexShader, technique );\r\n\r\n\t\t\t\t\t\tvar uniforms = technique.uniforms;\r\n\r\n\t\t\t\t\t\tfor ( var uniformId in uniforms ) {\r\n\r\n\t\t\t\t\t\t\tvar pname = uniforms[ uniformId ];\r\n\t\t\t\t\t\t\tvar shaderParam = technique.parameters[ pname ];\r\n\r\n\t\t\t\t\t\t\tvar ptype = shaderParam.type;\r\n\r\n\t\t\t\t\t\t\tif ( WEBGL_TYPE[ ptype ] ) {\r\n\r\n\t\t\t\t\t\t\t\tvar pcount = shaderParam.count;\r\n\t\t\t\t\t\t\t\tvar value;\r\n\r\n\t\t\t\t\t\t\t\tif ( material.values !== undefined ) { value = material.values[ pname ]; }\r\n\r\n\t\t\t\t\t\t\t\tvar uvalue = new WEBGL_TYPE[ ptype ]();\r\n\t\t\t\t\t\t\t\tvar usemantic = shaderParam.semantic;\r\n\t\t\t\t\t\t\t\tvar unode = shaderParam.node;\r\n\r\n\t\t\t\t\t\t\t\tswitch ( ptype ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcase WEBGL_CONSTANTS.FLOAT:\r\n\r\n\t\t\t\t\t\t\t\t\t\tuvalue = shaderParam.value;\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( pname == \"transparency\" ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tmaterialParams.transparent = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tuvalue = value;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tcase WEBGL_CONSTANTS.FLOAT_VEC2:\r\n\t\t\t\t\t\t\t\t\tcase WEBGL_CONSTANTS.FLOAT_VEC3:\r\n\t\t\t\t\t\t\t\t\tcase WEBGL_CONSTANTS.FLOAT_VEC4:\r\n\t\t\t\t\t\t\t\t\tcase WEBGL_CONSTANTS.FLOAT_MAT3:\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( shaderParam && shaderParam.value ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tuvalue.fromArray( shaderParam.value );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( value ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tuvalue.fromArray( value );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tcase WEBGL_CONSTANTS.FLOAT_MAT2:\r\n\r\n\t\t\t\t\t\t\t\t\t\t// what to do?\r\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"FLOAT_MAT2 is not a supported uniform type\" );\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tcase WEBGL_CONSTANTS.FLOAT_MAT4:\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( pcount ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tuvalue = new Array( pcount );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tfor ( var mi = 0; mi < pcount; mi ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tuvalue[ mi ] = new WEBGL_TYPE[ ptype ]();\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( shaderParam && shaderParam.value ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tvar m4v = shaderParam.value;\r\n\t\t\t\t\t\t\t\t\t\t\t\tuvalue.fromArray( m4v );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( value ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tuvalue.fromArray( value );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( shaderParam && shaderParam.value ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tvar m4 = shaderParam.value;\r\n\t\t\t\t\t\t\t\t\t\t\t\tuvalue.fromArray( m4 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( value ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tuvalue.fromArray( value );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tcase WEBGL_CONSTANTS.SAMPLER_2D:\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tuvalue = dependencies.textures[ value ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t} else if ( shaderParam.value !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tuvalue = dependencies.textures[ shaderParam.value ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tuvalue = null;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tmaterialParams.uniforms[ uniformId ] = {\r\n\t\t\t\t\t\t\t\t\tvalue: uvalue,\r\n\t\t\t\t\t\t\t\t\tsemantic: usemantic,\r\n\t\t\t\t\t\t\t\t\tnode: unode\r\n\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tthrow new Error( \"Unknown shader uniform param type: \" + ptype );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar states = technique.states || {};\r\n\t\t\t\t\t\tvar enables = states.enable || [];\r\n\t\t\t\t\t\tvar functions = states.functions || {};\r\n\r\n\t\t\t\t\t\tvar enableCullFace = false;\r\n\t\t\t\t\t\tvar enableDepthTest = false;\r\n\t\t\t\t\t\tvar enableBlend = false;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, il = enables.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar enable = enables[ i ];\r\n\r\n\t\t\t\t\t\t\tswitch ( STATES_ENABLES[ enable ] ) {\r\n\r\n\t\t\t\t\t\t\t\tcase 'CULL_FACE':\r\n\r\n\t\t\t\t\t\t\t\t\tenableCullFace = true;\r\n\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase 'DEPTH_TEST':\r\n\r\n\t\t\t\t\t\t\t\t\tenableDepthTest = true;\r\n\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase 'BLEND':\r\n\r\n\t\t\t\t\t\t\t\t\tenableBlend = true;\r\n\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t// TODO: implement\r\n\t\t\t\t\t\t\t\tcase 'SCISSOR_TEST':\r\n\t\t\t\t\t\t\t\tcase 'POLYGON_OFFSET_FILL':\r\n\t\t\t\t\t\t\t\tcase 'SAMPLE_ALPHA_TO_COVERAGE':\r\n\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\t\t\tthrow new Error( \"Unknown technique.states.enable: \" + enable );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( enableCullFace ) {\r\n\r\n\t\t\t\t\t\t\tmaterialParams.side = functions.cullFace !== undefined ? WEBGL_SIDES[ functions.cullFace ] : FrontSide;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tmaterialParams.side = DoubleSide;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmaterialParams.depthTest = enableDepthTest;\r\n\t\t\t\t\t\tmaterialParams.depthFunc = functions.depthFunc !== undefined ? WEBGL_DEPTH_FUNCS[ functions.depthFunc ] : LessDepth;\r\n\t\t\t\t\t\tmaterialParams.depthWrite = functions.depthMask !== undefined ? functions.depthMask[ 0 ] : true;\r\n\r\n\t\t\t\t\t\tmaterialParams.blending = enableBlend ? CustomBlending : NoBlending;\r\n\t\t\t\t\t\tmaterialParams.transparent = enableBlend;\r\n\r\n\t\t\t\t\t\tvar blendEquationSeparate = functions.blendEquationSeparate;\r\n\r\n\t\t\t\t\t\tif ( blendEquationSeparate !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tmaterialParams.blendEquation = WEBGL_BLEND_EQUATIONS[ blendEquationSeparate[ 0 ] ];\r\n\t\t\t\t\t\t\tmaterialParams.blendEquationAlpha = WEBGL_BLEND_EQUATIONS[ blendEquationSeparate[ 1 ] ];\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tmaterialParams.blendEquation = AddEquation;\r\n\t\t\t\t\t\t\tmaterialParams.blendEquationAlpha = AddEquation;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar blendFuncSeparate = functions.blendFuncSeparate;\r\n\r\n\t\t\t\t\t\tif ( blendFuncSeparate !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tmaterialParams.blendSrc = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 0 ] ];\r\n\t\t\t\t\t\t\tmaterialParams.blendDst = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 1 ] ];\r\n\t\t\t\t\t\t\tmaterialParams.blendSrcAlpha = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 2 ] ];\r\n\t\t\t\t\t\t\tmaterialParams.blendDstAlpha = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 3 ] ];\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tmaterialParams.blendSrc = OneFactor;\r\n\t\t\t\t\t\t\tmaterialParams.blendDst = ZeroFactor;\r\n\t\t\t\t\t\t\tmaterialParams.blendSrcAlpha = OneFactor;\r\n\t\t\t\t\t\t\tmaterialParams.blendDstAlpha = ZeroFactor;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( Array.isArray( materialValues.diffuse ) ) {\r\n\r\n\t\t\t\t\tmaterialParams.color = new Color().fromArray( materialValues.diffuse );\r\n\r\n\t\t\t\t} else if ( typeof( materialValues.diffuse ) === 'string' ) {\r\n\r\n\t\t\t\t\tmaterialParams.map = dependencies.textures[ materialValues.diffuse ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete materialParams.diffuse;\r\n\r\n\t\t\t\tif ( typeof( materialValues.reflective ) === 'string' ) {\r\n\r\n\t\t\t\t\tmaterialParams.envMap = dependencies.textures[ materialValues.reflective ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( typeof( materialValues.bump ) === 'string' ) {\r\n\r\n\t\t\t\t\tmaterialParams.bumpMap = dependencies.textures[ materialValues.bump ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( Array.isArray( materialValues.emission ) ) {\r\n\r\n\t\t\t\t\tif ( materialType === MeshBasicMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterialParams.color = new Color().fromArray( materialValues.emission );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmaterialParams.emissive = new Color().fromArray( materialValues.emission );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( typeof( materialValues.emission ) === 'string' ) {\r\n\r\n\t\t\t\t\tif ( materialType === MeshBasicMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterialParams.map = dependencies.textures[ materialValues.emission ];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmaterialParams.emissiveMap = dependencies.textures[ materialValues.emission ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( Array.isArray( materialValues.specular ) ) {\r\n\r\n\t\t\t\t\tmaterialParams.specular = new Color().fromArray( materialValues.specular );\r\n\r\n\t\t\t\t} else if ( typeof( materialValues.specular ) === 'string' ) {\r\n\r\n\t\t\t\t\tmaterialParams.specularMap = dependencies.textures[ materialValues.specular ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( materialValues.shininess !== undefined ) {\r\n\r\n\t\t\t\t\tmaterialParams.shininess = materialValues.shininess;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar _material = new materialType( materialParams );\r\n\t\t\t\tif ( material.name !== undefined ) { _material.name = material.name; }\r\n\r\n\t\t\t\treturn _material;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadMeshes = function () {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\treturn this._withDependencies( [\r\n\r\n\t\t\t\"accessors\",\r\n\t\t\t\"materials\"\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\treturn _each( json.meshes, function ( mesh ) {\r\n\r\n\t\t\t\tvar group = new Group();\r\n\t\t\t\tif ( mesh.name !== undefined ) { group.name = mesh.name; }\r\n\r\n\t\t\t\tif ( mesh.extras ) { group.userData = mesh.extras; }\r\n\r\n\t\t\t\tvar primitives = mesh.primitives || [];\r\n\r\n\t\t\t\tfor ( var name in primitives ) {\r\n\r\n\t\t\t\t\tvar primitive = primitives[ name ];\r\n\r\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === undefined ) {\r\n\r\n\t\t\t\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\t\t\t\tvar attributes = primitive.attributes;\r\n\r\n\t\t\t\t\t\tfor ( var attributeId in attributes ) {\r\n\r\n\t\t\t\t\t\t\tvar attributeEntry = attributes[ attributeId ];\r\n\r\n\t\t\t\t\t\t\tif ( ! attributeEntry ) { return; }\r\n\r\n\t\t\t\t\t\t\tvar bufferAttribute = dependencies.accessors[ attributeEntry ];\r\n\r\n\t\t\t\t\t\t\tswitch ( attributeId ) {\r\n\r\n\t\t\t\t\t\t\t\tcase 'POSITION':\r\n\t\t\t\t\t\t\t\t\tgeometry.addAttribute( 'position', bufferAttribute );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase 'NORMAL':\r\n\t\t\t\t\t\t\t\t\tgeometry.addAttribute( 'normal', bufferAttribute );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase 'TEXCOORD_0':\r\n\t\t\t\t\t\t\t\tcase 'TEXCOORD0':\r\n\t\t\t\t\t\t\t\tcase 'TEXCOORD':\r\n\t\t\t\t\t\t\t\t\tgeometry.addAttribute( 'uv', bufferAttribute );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase 'TEXCOORD_1':\r\n\t\t\t\t\t\t\t\t\tgeometry.addAttribute( 'uv2', bufferAttribute );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase 'COLOR_0':\r\n\t\t\t\t\t\t\t\tcase 'COLOR0':\r\n\t\t\t\t\t\t\t\tcase 'COLOR':\r\n\t\t\t\t\t\t\t\t\tgeometry.addAttribute( 'color', bufferAttribute );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase 'WEIGHT':\r\n\t\t\t\t\t\t\t\t\tgeometry.addAttribute( 'skinWeight', bufferAttribute );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase 'JOINT':\r\n\t\t\t\t\t\t\t\t\tgeometry.addAttribute( 'skinIndex', bufferAttribute );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\t\t\tif ( ! primitive.material ) { break; }\r\n\r\n\t\t\t\t\t\t\t\t\tvar material = json.materials[ primitive.material ];\r\n\r\n\t\t\t\t\t\t\t\t\tif ( ! material.technique ) { break; }\r\n\r\n\t\t\t\t\t\t\t\t\tvar parameters = json.techniques[ material.technique ].parameters || {};\r\n\r\n\t\t\t\t\t\t\t\t\tfor( var attributeName in parameters ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( parameters [ attributeName ][ 'semantic' ] === attributeId ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tgeometry.addAttribute( attributeName, bufferAttribute );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( primitive.indices ) {\r\n\r\n\t\t\t\t\t\t\tgeometry.setIndex( dependencies.accessors[ primitive.indices ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar material = dependencies.materials !== undefined ? dependencies.materials[ primitive.material ] : createDefaultMaterial();\r\n\r\n\t\t\t\t\t\tvar meshNode = new Mesh( geometry, material );\r\n\t\t\t\t\t\tmeshNode.castShadow = true;\r\n\t\t\t\t\t\tmeshNode.name = ( name === \"0\" ? group.name : group.name + name );\r\n\r\n\t\t\t\t\t\tif ( primitive.extras ) { meshNode.userData = primitive.extras; }\r\n\r\n\t\t\t\t\t\tgroup.add( meshNode );\r\n\r\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\r\n\r\n\t\t\t\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\t\t\t\tvar attributes = primitive.attributes;\r\n\r\n\t\t\t\t\t\tfor ( var attributeId in attributes ) {\r\n\r\n\t\t\t\t\t\t\tvar attributeEntry = attributes[ attributeId ];\r\n\r\n\t\t\t\t\t\t\tif ( ! attributeEntry ) { return; }\r\n\r\n\t\t\t\t\t\t\tvar bufferAttribute = dependencies.accessors[ attributeEntry ];\r\n\r\n\t\t\t\t\t\t\tswitch ( attributeId ) {\r\n\r\n\t\t\t\t\t\t\t\tcase 'POSITION':\r\n\t\t\t\t\t\t\t\t\tgeometry.addAttribute( 'position', bufferAttribute );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase 'COLOR_0':\r\n\t\t\t\t\t\t\t\tcase 'COLOR0':\r\n\t\t\t\t\t\t\t\tcase 'COLOR':\r\n\t\t\t\t\t\t\t\t\tgeometry.addAttribute( 'color', bufferAttribute );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar material = dependencies.materials[ primitive.material ];\r\n\r\n\t\t\t\t\t\tvar meshNode;\r\n\r\n\t\t\t\t\t\tif ( primitive.indices ) {\r\n\r\n\t\t\t\t\t\t\tgeometry.setIndex( dependencies.accessors[ primitive.indices ] );\r\n\r\n\t\t\t\t\t\t\tmeshNode = new LineSegments( geometry, material );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tmeshNode = new Line( geometry, material );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmeshNode.name = ( name === \"0\" ? group.name : group.name + name );\r\n\r\n\t\t\t\t\t\tif ( primitive.extras ) { meshNode.userData = primitive.extras; }\r\n\r\n\t\t\t\t\t\tgroup.add( meshNode );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( \"Only triangular and line primitives are supported\" );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn group;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadCameras = function () {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\treturn _each( json.cameras, function ( camera ) {\r\n\r\n\t\t\tif ( camera.type == \"perspective\" && camera.perspective ) {\r\n\r\n\t\t\t\tvar yfov = camera.perspective.yfov;\r\n\t\t\t\tvar aspectRatio = camera.perspective.aspectRatio !== undefined ? camera.perspective.aspectRatio : 1;\r\n\r\n\t\t\t\t// According to COLLADA spec...\r\n\t\t\t\t// aspectRatio = xfov / yfov\r\n\t\t\t\tvar xfov = yfov * aspectRatio;\r\n\r\n\t\t\t\tvar _camera = new PerspectiveCamera( _Math.radToDeg( xfov ), aspectRatio, camera.perspective.znear || 1, camera.perspective.zfar || 2e6 );\r\n\t\t\t\tif ( camera.name !== undefined ) { _camera.name = camera.name; }\r\n\r\n\t\t\t\tif ( camera.extras ) { _camera.userData = camera.extras; }\r\n\r\n\t\t\t\treturn _camera;\r\n\r\n\t\t\t} else if ( camera.type == \"orthographic\" && camera.orthographic ) {\r\n\r\n\t\t\t\tvar _camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, camera.orthographic.znear, camera.orthographic.zfar );\r\n\t\t\t\tif ( camera.name !== undefined ) { _camera.name = camera.name; }\r\n\r\n\t\t\t\tif ( camera.extras ) { _camera.userData = camera.extras; }\r\n\r\n\t\t\t\treturn _camera;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadSkins = function () {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\treturn this._withDependencies( [\r\n\r\n\t\t\t\"accessors\"\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\treturn _each( json.skins, function ( skin ) {\r\n\r\n\t\t\t\tvar bindShapeMatrix = new Matrix4();\r\n\r\n\t\t\t\tif ( skin.bindShapeMatrix !== undefined ) { bindShapeMatrix.fromArray( skin.bindShapeMatrix ); }\r\n\r\n\t\t\t\tvar _skin = {\r\n\t\t\t\t\tbindShapeMatrix: bindShapeMatrix,\r\n\t\t\t\t\tjointNames: skin.jointNames,\r\n\t\t\t\t\tinverseBindMatrices: dependencies.accessors[ skin.inverseBindMatrices ]\r\n\t\t\t\t};\r\n\r\n\t\t\t\treturn _skin;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadAnimations = function () {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\treturn this._withDependencies( [\r\n\r\n\t\t\t\"accessors\",\r\n\t\t\t\"nodes\"\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\treturn _each( json.animations, function ( animation, animationId ) {\r\n\r\n\t\t\t\tvar tracks = [];\r\n\r\n\t\t\t\tfor ( var channelId in animation.channels ) {\r\n\r\n\t\t\t\t\tvar channel = animation.channels[ channelId ];\r\n\t\t\t\t\tvar sampler = animation.samplers[ channel.sampler ];\r\n\r\n\t\t\t\t\tif ( sampler ) {\r\n\r\n\t\t\t\t\t\tvar target = channel.target;\r\n\t\t\t\t\t\tvar name = target.id;\r\n\t\t\t\t\t\tvar input = animation.parameters !== undefined ? animation.parameters[ sampler.input ] : sampler.input;\r\n\t\t\t\t\t\tvar output = animation.parameters !== undefined ? animation.parameters[ sampler.output ] : sampler.output;\r\n\r\n\t\t\t\t\t\tvar inputAccessor = dependencies.accessors[ input ];\r\n\t\t\t\t\t\tvar outputAccessor = dependencies.accessors[ output ];\r\n\r\n\t\t\t\t\t\tvar node = dependencies.nodes[ name ];\r\n\r\n\t\t\t\t\t\tif ( node ) {\r\n\r\n\t\t\t\t\t\t\tnode.updateMatrix();\r\n\t\t\t\t\t\t\tnode.matrixAutoUpdate = true;\r\n\r\n\t\t\t\t\t\t\tvar TypedKeyframeTrack = PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.rotation\r\n\t\t\t\t\t\t\t\t? QuaternionKeyframeTrack$1\r\n\t\t\t\t\t\t\t\t: VectorKeyframeTrack$1;\r\n\r\n\t\t\t\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\r\n\t\t\t\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\r\n\r\n\t\t\t\t\t\t\t// KeyframeTrack.optimize() will modify given 'times' and 'values'\r\n\t\t\t\t\t\t\t// buffers before creating a truncated copy to keep. Because buffers may\r\n\t\t\t\t\t\t\t// be reused by other tracks, make copies here.\r\n\t\t\t\t\t\t\ttracks.push( new TypedKeyframeTrack(\r\n\t\t\t\t\t\t\t\ttargetName + '.' + PATH_PROPERTIES[ target.path ],\r\n\t\t\t\t\t\t\t\tAnimationUtils.arraySlice( inputAccessor.array, 0 ),\r\n\t\t\t\t\t\t\t\tAnimationUtils.arraySlice( outputAccessor.array, 0 ),\r\n\t\t\t\t\t\t\t\tinterpolation\r\n\t\t\t\t\t\t\t) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar name = animation.name !== undefined ? animation.name : \"animation_\" + animationId;\r\n\r\n\t\t\t\treturn new AnimationClip( name, undefined, tracks );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadNodes = function () {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar scope = this;\r\n\r\n\t\treturn _each( json.nodes, function ( node ) {\r\n\r\n\t\t\tvar matrix = new Matrix4();\r\n\r\n\t\t\tvar _node;\r\n\r\n\t\t\tif ( node.jointName ) {\r\n\r\n\t\t\t\t_node = new Bone();\r\n\t\t\t\t_node.name = node.name !== undefined ? node.name : node.jointName;\r\n\t\t\t\t_node.jointName = node.jointName;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_node = new Object3D();\r\n\t\t\t\tif ( node.name !== undefined ) { _node.name = node.name; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.extras ) { _node.userData = node.extras; }\r\n\r\n\t\t\tif ( node.matrix !== undefined ) {\r\n\r\n\t\t\t\tmatrix.fromArray( node.matrix );\r\n\t\t\t\t_node.applyMatrix( matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( node.translation !== undefined ) {\r\n\r\n\t\t\t\t\t_node.position.fromArray( node.translation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( node.rotation !== undefined ) {\r\n\r\n\t\t\t\t\t_node.quaternion.fromArray( node.rotation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( node.scale !== undefined ) {\r\n\r\n\t\t\t\t\t_node.scale.fromArray( node.scale );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn _node;\r\n\r\n\t\t} ).then( function ( __nodes ) {\r\n\r\n\t\t\treturn scope._withDependencies( [\r\n\r\n\t\t\t\t\"meshes\",\r\n\t\t\t\t\"skins\",\r\n\t\t\t\t\"cameras\"\r\n\r\n\t\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\t\treturn _each( __nodes, function ( _node, nodeId ) {\r\n\r\n\t\t\t\t\tvar node = json.nodes[ nodeId ];\r\n\r\n\t\t\t\t\tif ( node.meshes !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( var meshId in node.meshes ) {\r\n\r\n\t\t\t\t\t\t\tvar mesh = node.meshes[ meshId ];\r\n\t\t\t\t\t\t\tvar group = dependencies.meshes[ mesh ];\r\n\r\n\t\t\t\t\t\t\tif ( group === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'LegacyGLTFLoader: Couldn\\'t find node \"' + mesh + '\".' );\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tfor ( var childrenId in group.children ) {\r\n\r\n\t\t\t\t\t\t\t\tvar child = group.children[ childrenId ];\r\n\r\n\t\t\t\t\t\t\t\t// clone Mesh to add to _node\r\n\r\n\t\t\t\t\t\t\t\tvar originalMaterial = child.material;\r\n\t\t\t\t\t\t\t\tvar originalGeometry = child.geometry;\r\n\t\t\t\t\t\t\t\tvar originalUserData = child.userData;\r\n\t\t\t\t\t\t\t\tvar originalName = child.name;\r\n\r\n\t\t\t\t\t\t\t\tvar material;\r\n\r\n\t\t\t\t\t\t\t\tif ( originalMaterial.isDeferredShaderMaterial ) {\r\n\r\n\t\t\t\t\t\t\t\t\toriginalMaterial = material = originalMaterial.create();\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tmaterial = originalMaterial;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tswitch ( child.type ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcase 'LineSegments':\r\n\t\t\t\t\t\t\t\t\t\tchild = new LineSegments( originalGeometry, material );\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tcase 'LineLoop':\r\n\t\t\t\t\t\t\t\t\t\tchild = new LineLoop( originalGeometry, material );\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tcase 'Line':\r\n\t\t\t\t\t\t\t\t\t\tchild = new Line( originalGeometry, material );\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t\tchild = new Mesh( originalGeometry, material );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tchild.castShadow = true;\r\n\t\t\t\t\t\t\t\tchild.userData = originalUserData;\r\n\t\t\t\t\t\t\t\tchild.name = originalName;\r\n\r\n\t\t\t\t\t\t\t\tvar skinEntry;\r\n\r\n\t\t\t\t\t\t\t\tif ( node.skin ) {\r\n\r\n\t\t\t\t\t\t\t\t\tskinEntry = dependencies.skins[ node.skin ];\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// Replace Mesh with SkinnedMesh in library\r\n\t\t\t\t\t\t\t\tif ( skinEntry ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar getJointNode = function ( jointId ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tvar keys = Object.keys( __nodes );\r\n\r\n\t\t\t\t\t\t\t\t\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvar n = __nodes[ keys[ i ] ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( n.jointName === jointId ) { return n; }\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t\tvar geometry = originalGeometry;\r\n\t\t\t\t\t\t\t\t\tvar material = originalMaterial;\r\n\t\t\t\t\t\t\t\t\tmaterial.skinning = true;\r\n\r\n\t\t\t\t\t\t\t\t\tchild = new SkinnedMesh( geometry, material );\r\n\t\t\t\t\t\t\t\t\tchild.castShadow = true;\r\n\t\t\t\t\t\t\t\t\tchild.userData = originalUserData;\r\n\t\t\t\t\t\t\t\t\tchild.name = originalName;\r\n\r\n\t\t\t\t\t\t\t\t\tvar bones = [];\r\n\t\t\t\t\t\t\t\t\tvar boneInverses = [];\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( var i = 0, l = skinEntry.jointNames.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tvar jointId = skinEntry.jointNames[ i ];\r\n\t\t\t\t\t\t\t\t\t\tvar jointNode = getJointNode( jointId );\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( jointNode ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbones.push( jointNode );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvar m = skinEntry.inverseBindMatrices.array;\r\n\t\t\t\t\t\t\t\t\t\t\tvar mat = new Matrix4().fromArray( m, i * 16 );\r\n\t\t\t\t\t\t\t\t\t\t\tboneInverses.push( mat );\r\n\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( \"WARNING: joint: '\" + jointId + \"' could not be found\" );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tchild.bind( new Skeleton( bones, boneInverses ), skinEntry.bindShapeMatrix );\r\n\r\n\t\t\t\t\t\t\t\t\tvar buildBoneGraph = function ( parentJson, parentObject, property ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tvar children = parentJson[ property ];\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( children === undefined ) { return; }\r\n\r\n\t\t\t\t\t\t\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvar nodeId = children[ i ];\r\n\t\t\t\t\t\t\t\t\t\t\tvar bone = __nodes[ nodeId ];\r\n\t\t\t\t\t\t\t\t\t\t\tvar boneJson = json.nodes[ nodeId ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( bone !== undefined && bone.isBone === true && boneJson !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tparentObject.add( bone );\r\n\t\t\t\t\t\t\t\t\t\t\t\tbuildBoneGraph( boneJson, bone, 'children' );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t\tbuildBoneGraph( node, child, 'skeletons' );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t_node.add( child );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( node.camera !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar camera = dependencies.cameras[ node.camera ];\r\n\r\n\t\t\t\t\t\t_node.add( camera );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( node.extensions\r\n\t\t\t\t\t\t\t && node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ]\r\n\t\t\t\t\t\t\t && node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].light ) {\r\n\r\n\t\t\t\t\t\tvar extensionLights = extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].lights;\r\n\t\t\t\t\t\tvar light = extensionLights[ node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].light ];\r\n\r\n\t\t\t\t\t\t_node.add( light );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn _node;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tGLTFParser.prototype.loadScenes = function () {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\t// scene node hierachy builder\r\n\r\n\t\tfunction buildNodeHierachy( nodeId, parentObject, allNodes ) {\r\n\r\n\t\t\tvar _node = allNodes[ nodeId ];\r\n\t\t\tparentObject.add( _node );\r\n\r\n\t\t\tvar node = json.nodes[ nodeId ];\r\n\r\n\t\t\tif ( node.children ) {\r\n\r\n\t\t\t\tvar children = node.children;\r\n\r\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar child = children[ i ];\r\n\t\t\t\t\tbuildNodeHierachy( child, _node, allNodes );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this._withDependencies( [\r\n\r\n\t\t\t\"nodes\"\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\treturn _each( json.scenes, function ( scene ) {\r\n\r\n\t\t\t\tvar _scene = new Scene();\r\n\t\t\t\tif ( scene.name !== undefined ) { _scene.name = scene.name; }\r\n\r\n\t\t\t\tif ( scene.extras ) { _scene.userData = scene.extras; }\r\n\r\n\t\t\t\tvar nodes = scene.nodes || [];\r\n\r\n\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar nodeId = nodes[ i ];\r\n\t\t\t\t\tbuildNodeHierachy( nodeId, _scene, dependencies.nodes );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_scene.traverse( function ( child ) {\r\n\r\n\t\t\t\t\t// Register raw material meshes with LegacyGLTFLoader.Shaders\r\n\t\t\t\t\tif ( child.material && child.material.isRawShaderMaterial ) {\r\n\r\n\t\t\t\t\t\tchild.gltfShader = new GLTFShader( child, dependencies.nodes );\r\n\t\t\t\t\t\tchild.onBeforeRender = function(renderer, scene, camera){\r\n\t\t\t\t\t\t\tthis.gltfShader.update(scene, camera);\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\treturn _scene;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\treturn LegacyGLTFLoader;\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar DRACOLoader = function(manager) {\r\n    this.timeLoaded = 0;\r\n    this.manager = manager || DefaultLoadingManager;\r\n    this.materials = null;\r\n    this.verbosity = 0;\r\n    this.attributeOptions = {};\r\n    this.drawMode = TrianglesDrawMode;\r\n    // Native Draco attribute type to Three.JS attribute type.\r\n    this.nativeAttributeMap = {\r\n      'position' : 'POSITION',\r\n      'normal' : 'NORMAL',\r\n      'color' : 'COLOR',\r\n      'uv' : 'TEX_COORD'\r\n    };\r\n};\r\n\r\nDRACOLoader.prototype = {\r\n\r\n    constructor: DRACOLoader,\r\n\r\n    load: function(url, onLoad, onProgress, onError) {\r\n        var scope = this;\r\n        var loader = new FileLoader(scope.manager);\r\n        loader.setPath(this.path);\r\n        loader.setResponseType('arraybuffer');\r\n        loader.load(url, function(blob) {\r\n            scope.decodeDracoFile(blob, onLoad);\r\n        }, onProgress, onError);\r\n    },\r\n\r\n    setPath: function(value) {\r\n        this.path = value;\r\n        return this;\r\n    },\r\n\r\n    setVerbosity: function(level) {\r\n        this.verbosity = level;\r\n        return this;\r\n    },\r\n    \r\n    setDrawMode: function(drawMode) {\r\n        this.drawMode = drawMode;\r\n        return this;\r\n    },\r\n    \r\n    setSkipDequantization: function(attributeName, skip) {\r\n        var skipDequantization = true;\r\n        if (typeof skip !== 'undefined')\r\n          { skipDequantization = skip; }\r\n        this.getAttributeOptions(attributeName).skipDequantization =\r\n            skipDequantization;\r\n        return this;\r\n    },\r\n    \r\n    decodeDracoFile: function(rawBuffer, callback, attributeUniqueIdMap,\r\n                              attributeTypeMap) {\r\n      var scope = this;\r\n      DRACOLoader.getDecoderModule()\r\n          .then( function ( module ) {\r\n            scope.decodeDracoFileInternal( rawBuffer, module.decoder, callback,\r\n              attributeUniqueIdMap || {}, attributeTypeMap || {});\r\n          });\r\n    },\r\n\r\n    decodeDracoFileInternal: function(rawBuffer, dracoDecoder, callback,\r\n                                      attributeUniqueIdMap, attributeTypeMap) {\r\n      \r\n      var buffer = new dracoDecoder.DecoderBuffer();\r\n      buffer.Init(new Int8Array(rawBuffer), rawBuffer.byteLength);\r\n      var decoder = new dracoDecoder.Decoder();\r\n      \r\n      var geometryType = decoder.GetEncodedGeometryType(buffer);\r\n      if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\r\n        if (this.verbosity > 0) {\r\n          console.log('Loaded a mesh.');\r\n        }\r\n      } else if (geometryType == dracoDecoder.POINT_CLOUD) {\r\n        if (this.verbosity > 0) {\r\n          console.log('Loaded a point cloud.');\r\n        }\r\n      } else {\r\n        var errorMsg = 'DRACOLoader: Unknown geometry type.';\r\n        console.error(errorMsg);\r\n        throw new Error(errorMsg);\r\n      }\r\n      callback(this.convertDracoGeometryTo3JS(dracoDecoder, decoder,\r\n          geometryType, buffer, attributeUniqueIdMap, attributeTypeMap));\r\n    },\r\n\r\n    addAttributeToGeometry: function(dracoDecoder, decoder, dracoGeometry,\r\n                                     attributeName, attributeType, attribute,\r\n                                     geometry, geometryBuffer) {\r\n      if (attribute.ptr === 0) {\r\n        var errorMsg = 'DRACOLoader: No attribute ' + attributeName;\r\n        console.error(errorMsg);\r\n        throw new Error(errorMsg);\r\n      }\r\n\r\n      var numComponents = attribute.num_components();\r\n      var numPoints = dracoGeometry.num_points();\r\n      var numValues = numPoints * numComponents;\r\n      var attributeData;\r\n      var TypedBufferAttribute;\r\n\r\n      switch ( attributeType ) {\r\n\r\n        case Float32Array:\r\n          attributeData = new dracoDecoder.DracoFloat32Array();\r\n          decoder.GetAttributeFloatForAllPoints(\r\n            dracoGeometry, attribute, attributeData);\r\n          geometryBuffer[ attributeName ] = new Float32Array( numValues );\r\n          TypedBufferAttribute = Float32BufferAttribute;\r\n          break;\r\n\r\n        case Int8Array:\r\n          attributeData = new dracoDecoder.DracoInt8Array();\r\n          decoder.GetAttributeInt8ForAllPoints(\r\n            dracoGeometry, attribute, attributeData );\r\n          geometryBuffer[ attributeName ] = new Int8Array( numValues );\r\n          TypedBufferAttribute = Int8BufferAttribute;\r\n          break;\r\n\r\n        case Int16Array:\r\n          attributeData = new dracoDecoder.DracoInt16Array();\r\n          decoder.GetAttributeInt16ForAllPoints(\r\n            dracoGeometry, attribute, attributeData);\r\n          geometryBuffer[ attributeName ] = new Int16Array( numValues );\r\n          TypedBufferAttribute = Int16BufferAttribute;\r\n          break;\r\n\r\n        case Int32Array:\r\n          attributeData = new dracoDecoder.DracoInt32Array();\r\n          decoder.GetAttributeInt32ForAllPoints(\r\n            dracoGeometry, attribute, attributeData);\r\n          geometryBuffer[ attributeName ] = new Int32Array( numValues );\r\n          TypedBufferAttribute = Int32BufferAttribute;\r\n          break;\r\n\r\n        case Uint8Array:\r\n          attributeData = new dracoDecoder.DracoUInt8Array();\r\n          decoder.GetAttributeUInt8ForAllPoints(\r\n            dracoGeometry, attribute, attributeData);\r\n          geometryBuffer[ attributeName ] = new Uint8Array( numValues );\r\n          TypedBufferAttribute = Uint8BufferAttribute;\r\n          break;\r\n\r\n        case Uint16Array:\r\n          attributeData = new dracoDecoder.DracoUInt16Array();\r\n          decoder.GetAttributeUInt16ForAllPoints(\r\n            dracoGeometry, attribute, attributeData);\r\n          geometryBuffer[ attributeName ] = new Uint16Array( numValues );\r\n          TypedBufferAttribute = Uint16BufferAttribute;\r\n          break;\r\n\r\n        case Uint32Array:\r\n          attributeData = new dracoDecoder.DracoUInt32Array();\r\n          decoder.GetAttributeUInt32ForAllPoints(\r\n            dracoGeometry, attribute, attributeData);\r\n          geometryBuffer[ attributeName ] = new Uint32Array( numValues );\r\n          TypedBufferAttribute = Uint32BufferAttribute;\r\n          break;\r\n\r\n        default:\r\n          var errorMsg = 'DRACOLoader: Unexpected attribute type.';\r\n          console.error( errorMsg );\r\n          throw new Error( errorMsg );\r\n\r\n      }\r\n\r\n      // Copy data from decoder.\r\n      for (var i = 0; i < numValues; i++) {\r\n        geometryBuffer[attributeName][i] = attributeData.GetValue(i);\r\n      }\r\n      // Add attribute to THREEJS geometry for rendering.\r\n      geometry.addAttribute(attributeName,\r\n          new TypedBufferAttribute(geometryBuffer[attributeName],\r\n            numComponents));\r\n      dracoDecoder.destroy(attributeData);\r\n    },\r\n\r\n    convertDracoGeometryTo3JS: function(dracoDecoder, decoder, geometryType,\r\n                                        buffer, attributeUniqueIdMap,\r\n                                        attributeTypeMap) {\n        var this$1 = this;\n\r\n        if (this.getAttributeOptions('position').skipDequantization === true) {\r\n          decoder.SkipAttributeTransform(dracoDecoder.POSITION);\r\n        }\r\n        var dracoGeometry;\r\n        var decodingStatus;\r\n        var start_time = performance.now();\r\n        if (geometryType === dracoDecoder.TRIANGULAR_MESH) {\r\n          dracoGeometry = new dracoDecoder.Mesh();\r\n          decodingStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\r\n        } else {\r\n          dracoGeometry = new dracoDecoder.PointCloud();\r\n          decodingStatus =\r\n              decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\r\n        }\r\n        if (!decodingStatus.ok() || dracoGeometry.ptr == 0) {\r\n          var errorMsg = 'DRACOLoader: Decoding failed: ';\r\n          errorMsg += decodingStatus.error_msg();\r\n          console.error(errorMsg);\r\n          dracoDecoder.destroy(decoder);\r\n          dracoDecoder.destroy(dracoGeometry);\r\n          throw new Error(errorMsg);\r\n        }\r\n\r\n        var decode_end = performance.now();\r\n        dracoDecoder.destroy(buffer);\r\n        \r\n        var numFaces;\r\n        if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\r\n          numFaces = dracoGeometry.num_faces();\r\n          if (this.verbosity > 0) {\r\n            console.log('Number of faces loaded: ' + numFaces.toString());\r\n          }\r\n        } else {\r\n          numFaces = 0;\r\n        }\r\n\r\n        var numPoints = dracoGeometry.num_points();\r\n        var numAttributes = dracoGeometry.num_attributes();\r\n        if (this.verbosity > 0) {\r\n          console.log('Number of points loaded: ' + numPoints.toString());\r\n          console.log('Number of attributes loaded: ' +\r\n              numAttributes.toString());\r\n        }\r\n\r\n        // Verify if there is position attribute.\r\n        var posAttId = decoder.GetAttributeId(dracoGeometry,\r\n                                              dracoDecoder.POSITION);\r\n        if (posAttId == -1) {\r\n          var errorMsg = 'DRACOLoader: No position attribute found.';\r\n          console.error(errorMsg);\r\n          dracoDecoder.destroy(decoder);\r\n          dracoDecoder.destroy(dracoGeometry);\r\n          throw new Error(errorMsg);\r\n        }\r\n        var posAttribute = decoder.GetAttribute(dracoGeometry, posAttId);\r\n\r\n        // Structure for converting to THREEJS geometry later.\r\n        var geometryBuffer = {};\r\n        // Import data to Three JS geometry.\r\n        var geometry = new BufferGeometry();\r\n\r\n        // Add native Draco attribute type to geometry.\r\n        for (var attributeName in this$1.nativeAttributeMap) {\r\n          // The native attribute type is only used when no unique Id is\r\n          // provided. For example, loading .drc files.\r\n          if (attributeUniqueIdMap[attributeName] === undefined) {\r\n            var attId = decoder.GetAttributeId(dracoGeometry,\r\n                dracoDecoder[this$1.nativeAttributeMap[attributeName]]);\r\n            if (attId !== -1) {\r\n              if (this$1.verbosity > 0) {\r\n                console.log('Loaded ' + attributeName + ' attribute.');\r\n              }\r\n              var attribute = decoder.GetAttribute(dracoGeometry, attId);\r\n              this$1.addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry,\r\n                  attributeName, Float32Array, attribute, geometry, geometryBuffer);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Add attributes of user specified unique id. E.g. GLTF models.\r\n        for (var attributeName in attributeUniqueIdMap) {\r\n          var attributeType = attributeTypeMap[attributeName] || Float32Array;\r\n          var attributeId = attributeUniqueIdMap[attributeName];\r\n          var attribute = decoder.GetAttributeByUniqueId(dracoGeometry,\r\n                                                         attributeId);\r\n          this$1.addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry,\r\n              attributeName, attributeType, attribute, geometry, geometryBuffer);\r\n        }\r\n\r\n        // For mesh, we need to generate the faces.\r\n        if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\r\n          if (this.drawMode === TriangleStripDrawMode) {\r\n            var stripsArray = new dracoDecoder.DracoInt32Array();\r\n            var numStrips = decoder.GetTriangleStripsFromMesh(\r\n                dracoGeometry, stripsArray);\r\n            geometryBuffer.indices = new Uint32Array(stripsArray.size());\r\n            for (var i = 0; i < stripsArray.size(); ++i) {\r\n              geometryBuffer.indices[i] = stripsArray.GetValue(i);\r\n            }\r\n            dracoDecoder.destroy(stripsArray);\r\n          } else {\r\n            var numIndices = numFaces * 3;\r\n            geometryBuffer.indices = new Uint32Array(numIndices);\r\n            var ia = new dracoDecoder.DracoInt32Array();\r\n            for (var i = 0; i < numFaces; ++i) {\r\n              decoder.GetFaceFromMesh(dracoGeometry, i, ia);\r\n              var index = i * 3;\r\n              geometryBuffer.indices[index] = ia.GetValue(0);\r\n              geometryBuffer.indices[index + 1] = ia.GetValue(1);\r\n              geometryBuffer.indices[index + 2] = ia.GetValue(2);\r\n            }\r\n            dracoDecoder.destroy(ia);\r\n         }\r\n        }\r\n\r\n        geometry.drawMode = this.drawMode;\r\n        if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\r\n          geometry.setIndex(new(geometryBuffer.indices.length > 65535 ?\r\n                Uint32BufferAttribute : Uint16BufferAttribute)\r\n              (geometryBuffer.indices, 1));\r\n        }\r\n        var posTransform = new dracoDecoder.AttributeQuantizationTransform();\r\n        if (posTransform.InitFromAttribute(posAttribute)) {\r\n          // Quantized attribute. Store the quantization parameters into the\r\n          // js attribute.\r\n          geometry.attributes['position'].isQuantized = true;\r\n          geometry.attributes['position'].maxRange = posTransform.range();\r\n          geometry.attributes['position'].numQuantizationBits =\r\n              posTransform.quantization_bits();\r\n          geometry.attributes['position'].minValues = new Float32Array(3);\r\n          for (var i = 0; i < 3; ++i) {\r\n            geometry.attributes['position'].minValues[i] =\r\n                posTransform.min_value(i);\r\n          }\r\n        }\r\n        dracoDecoder.destroy(posTransform);\r\n        dracoDecoder.destroy(decoder);\r\n        dracoDecoder.destroy(dracoGeometry);\r\n\r\n        this.decode_time = decode_end - start_time;\r\n        this.import_time = performance.now() - decode_end;\r\n\r\n        if (this.verbosity > 0) {\r\n          console.log('Decode time: ' + this.decode_time);\r\n          console.log('Import time: ' + this.import_time);\r\n        }\r\n        return geometry;\r\n    },\r\n\r\n    isVersionSupported: function(version, callback) {\r\n        DRACOLoader.getDecoderModule()\r\n            .then( function ( module ) {\r\n              callback( module.decoder.isVersionSupported( version ) );\r\n            });\r\n    },\r\n\r\n    getAttributeOptions: function(attributeName) {\r\n        if (typeof this.attributeOptions[attributeName] === 'undefined')\r\n          { this.attributeOptions[attributeName] = {}; }\r\n        return this.attributeOptions[attributeName];\r\n    }\r\n};\r\n\r\nDRACOLoader.decoderPath = './';\r\nDRACOLoader.decoderConfig = {};\r\nDRACOLoader.decoderModulePromise = null;\r\n\r\nDRACOLoader.setDecoderPath = function ( path ) {\r\n  DRACOLoader.decoderPath = path;\r\n};\r\n\r\nDRACOLoader.setDecoderConfig = function ( config ) {\r\n  var wasmBinary = DRACOLoader.decoderConfig.wasmBinary;\r\n  DRACOLoader.decoderConfig = config || {};\r\n  DRACOLoader.releaseDecoderModule();\r\n\r\n  // Reuse WASM binary.\r\n  if ( wasmBinary ) { DRACOLoader.decoderConfig.wasmBinary = wasmBinary; }\r\n};\r\n\r\nDRACOLoader.releaseDecoderModule = function () {\r\n  DRACOLoader.decoderModulePromise = null;\r\n};\r\n\r\nDRACOLoader.getDecoderModule = function () {\r\n  var scope = this;\r\n  var path = DRACOLoader.decoderPath;\r\n  var config = DRACOLoader.decoderConfig;\r\n  var promise = DRACOLoader.decoderModulePromise;\r\n\r\n  if ( promise ) { return promise; }\r\n\r\n  // Load source files.\r\n  if ( typeof DracoDecoderModule !== 'undefined' ) {\r\n    // Loaded externally.\r\n    promise = Promise.resolve();\r\n  } else if ( typeof WebAssembly !== 'object' || config.type === 'js' ) {\r\n    // Load with asm.js.\r\n    promise = DRACOLoader._loadScript( path + 'draco_decoder.js' );\r\n  } else {\r\n    // Load with WebAssembly.\r\n    config.wasmBinaryFile = path + 'draco_decoder.wasm';\r\n    promise = DRACOLoader._loadScript( path + 'draco_wasm_wrapper.js' )\r\n        .then( function () {\r\n          return DRACOLoader._loadArrayBuffer( config.wasmBinaryFile );\r\n        } )\r\n        .then( function ( wasmBinary ) {\r\n          config.wasmBinary = wasmBinary;\r\n        } );\r\n  }\r\n\r\n  // Wait for source files, then create and return a decoder.\r\n  promise = promise.then( function () {\r\n    return new Promise( function ( resolve ) {\r\n      config.onModuleLoaded = function ( decoder ) {\r\n        scope.timeLoaded = performance.now();\r\n        // Module is Promise-like. Wrap before resolving to avoid loop.\r\n        resolve( { decoder: decoder } );\r\n      };\r\n      DracoDecoderModule( config );\r\n    } );\r\n  } );\r\n\r\n  DRACOLoader.decoderModulePromise = promise;\r\n  return promise;\r\n};\r\n\r\nDRACOLoader._loadScript = function ( src ) {\r\n  var prevScript = document.getElementById( 'decoder_script' );\r\n  if ( prevScript !== null ) {\r\n    prevScript.parentNode.removeChild( prevScript );\r\n  }\r\n  var head = document.getElementsByTagName( 'head' )[ 0 ];\r\n  var script = document.createElement( 'script' );\r\n  script.id = 'decoder_script';\r\n  script.type = 'text/javascript';\r\n  script.src = src;\r\n  return new Promise( function ( resolve ) {\r\n    script.onload = resolve;\r\n    head.appendChild( script );\r\n  });\r\n};\r\n\r\nDRACOLoader._loadArrayBuffer = function ( src ) {\r\n  var loader = new FileLoader();\r\n  loader.setResponseType( 'arraybuffer' );\r\n  return new Promise( function( resolve, reject ) {\r\n    loader.load( src, resolve, undefined, reject );\r\n  });\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLRenderTargetCube( width, height, options ) {\r\n\r\n\tWebGLRenderTarget.call( this, width, height, options );\r\n\r\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\tthis.activeMipMapLevel = 0;\r\n\r\n}\r\n\r\nWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\r\nWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\r\n\r\nWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar EquirectangularToCubeGenerator = function ( sourceTexture, options ) {\r\n\r\n\tthis.sourceTexture = sourceTexture;\r\n\tthis.resolution = options.resolution || 512;\r\n\r\n \tthis.views = [\r\n\t\t{ t: [ 1, 0, 0 ], u: [ 0, - 1, 0 ] },\r\n\t\t{ t: [ - 1, 0, 0 ], u: [ 0, - 1, 0 ] },\r\n\t\t{ t: [ 0, 1, 0 ], u: [ 0, 0, 1 ] },\r\n\t\t{ t: [ 0, - 1, 0 ], u: [ 0, 0, - 1 ] },\r\n\t\t{ t: [ 0, 0, 1 ], u: [ 0, - 1, 0 ] },\r\n\t\t{ t: [ 0, 0, - 1 ], u: [ 0, - 1, 0 ] } ];\r\n\r\n\tthis.camera = new PerspectiveCamera( 90, 1, 0.1, 10 );\r\n\tthis.boxMesh = new Mesh( new BoxBufferGeometry( 1, 1, 1 ), this.getShader() );\r\n\tthis.boxMesh.material.side = BackSide;\r\n\tthis.scene = new Scene();\r\n\tthis.scene.add( this.boxMesh );\r\n\r\n\tvar params = {\r\n\t\tformat: options.format || this.sourceTexture.format,\r\n\t\tmagFilter: this.sourceTexture.magFilter,\r\n\t\tminFilter: this.sourceTexture.minFilter,\r\n\t\ttype: options.type || this.sourceTexture.type,\r\n\t\tgenerateMipmaps: this.sourceTexture.generateMipmaps,\r\n\t\tanisotropy: this.sourceTexture.anisotropy,\r\n\t\tencoding: this.sourceTexture.encoding\r\n\t};\r\n\r\n\tthis.renderTarget = new WebGLRenderTargetCube( this.resolution, this.resolution, params );\r\n\r\n};\r\n\r\nEquirectangularToCubeGenerator.prototype = {\r\n\r\n\tconstructor: EquirectangularToCubeGenerator,\r\n\r\n\tupdate: function ( renderer ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tthis$1.renderTarget.activeCubeFace = i;\r\n\r\n\t\t\tvar v = this$1.views[ i ];\r\n\r\n\t\t\tthis$1.camera.position.set( 0, 0, 0 );\r\n\t\t\tthis$1.camera.up.set( v.u[ 0 ], v.u[ 1 ], v.u[ 2 ] );\r\n\t\t\tthis$1.camera.lookAt( v.t[ 0 ], v.t[ 1 ], v.t[ 2 ] );\r\n\r\n\t\t\trenderer.render( this$1.scene, this$1.camera, this$1.renderTarget, true );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.renderTarget.texture;\r\n\r\n\t},\r\n\r\n\tgetShader: function () {\r\n\r\n\t\tvar shaderMaterial = new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"equirectangularMap\": { value: this.sourceTexture },\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t\"varying vec3 localPosition;\\n\\\r\n\t\t\t\t\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tlocalPosition = position;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t\"#include <common>\\n\\\r\n\t\t\t\tvarying vec3 localPosition;\\n\\\r\n\t\t\t\tuniform sampler2D equirectangularMap;\\n\\\r\n\t\t\t\t\\n\\\r\n\t\t\t\tvec2 EquirectangularSampleUV(vec3 v) {\\n\\\r\n\t\t\t    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\\n\\\r\n\t\t\t    uv *= vec2(0.1591, 0.3183); // inverse atan\\n\\\r\n\t\t\t    uv += 0.5;\\n\\\r\n\t\t\t    return uv;\\n\\\r\n\t\t\t\t}\\n\\\r\n\t\t\t\t\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvec2 uv = EquirectangularSampleUV(normalize(localPosition));\\n\\\r\n    \t\t\tvec3 color = texture2D(equirectangularMap, uv).rgb;\\n\\\r\n    \t\t\t\\n\\\r\n\t\t\t\t\tgl_FragColor = vec4( color, 1.0 );\\n\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tblending: NoBlending\r\n\r\n\t\t} );\r\n\r\n\t\tshaderMaterial.type = 'EquirectangularToCubeGenerator';\r\n\r\n\t\treturn shaderMaterial;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.boxMesh.geometry.dispose();\r\n\t\tthis.boxMesh.material.dispose();\r\n\t\tthis.renderTarget.dispose();\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction DataTextureLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n}\r\n\r\nObject.assign( DataTextureLoader.prototype, {\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texture = new DataTexture();\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tvar texData = scope._parser( buffer );\r\n\r\n\t\t\tif ( ! texData ) { return; }\r\n\r\n\t\t\tif ( undefined !== texData.image ) {\r\n\r\n\t\t\t\ttexture.image = texData.image;\r\n\r\n\t\t\t} else if ( undefined !== texData.data ) {\r\n\r\n\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\ttexture.image.data = texData.data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\r\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\r\n\r\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\r\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\r\n\r\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\r\n\t\t\tif ( undefined !== texData.format ) {\r\n\r\n\t\t\t\ttexture.format = texData.format;\r\n\r\n\t\t\t}\r\n\t\t\tif ( undefined !== texData.type ) {\r\n\r\n\t\t\t\ttexture.type = texData.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\r\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\r\n\t\t\t\ttexture.minFilter = LinearFilter;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) { onLoad( texture, texData ); }\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// \r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\nvar EXRLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nEXRLoader.prototype = Object.create( DataTextureLoader.prototype );\r\n\r\nEXRLoader.prototype._parser = function ( buffer ) {\r\n\r\n\tvar USHORT_RANGE = (1 << 16);\r\n\tvar BITMAP_SIZE = (USHORT_RANGE >> 3);\r\n\r\n\tvar HUF_ENCBITS = 16;  // literal (value) bit length\r\n\tvar HUF_DECBITS = 14;  // decoding bit size (>= 8)\r\n\r\n\tvar HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;  // encoding table size\r\n\tvar HUF_DECSIZE = 1 << HUF_DECBITS;        // decoding table size\r\n\tvar HUF_DECMASK = HUF_DECSIZE - 1;\r\n\r\n\tvar SHORT_ZEROCODE_RUN = 59;\r\n\tvar LONG_ZEROCODE_RUN = 63;\r\n\tvar SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\r\n\r\n\tvar BYTES_PER_HALF = 2;\r\n\r\n\tvar ULONG_SIZE = 8;\r\n\tvar FLOAT32_SIZE = 4;\r\n\tvar INT32_SIZE = 4;\r\n\tvar INT16_SIZE = 2;\r\n\tvar INT8_SIZE = 1;\r\n\r\n\tfunction reverseLutFromBitmap( bitmap, lut ) {\r\n\r\n\t\tvar k = 0;\r\n\r\n\t\tfor ( var i = 0; i < USHORT_RANGE; ++ i ) {\r\n\r\n\t\t\tif ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {\r\n\r\n\t\t\t\tlut[ k ++ ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar n = k - 1;\r\n\r\n\t\twhile ( k < USHORT_RANGE ) { lut[ k ++ ] = 0; }\r\n\r\n\t\treturn n;\r\n\r\n\t}\r\n\r\n\tfunction hufClearDecTable( hdec ) {\r\n\r\n\t\tfor ( var i = 0; i < HUF_DECSIZE; i ++ ) {\r\n\r\n\t\t\thdec[ i ] = {};\r\n\t\t\thdec[ i ].len = 0;\r\n\t\t\thdec[ i ].lit = 0;\r\n\t\t\thdec[ i ].p = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar getBitsReturn = { l: 0, c: 0, lc: 0 };\r\n\r\n\tfunction getBits( nBits, c, lc, uInt8Array, inOffset ) {\r\n\r\n\t\twhile ( lc < nBits ) {\r\n\r\n\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\r\n\t\t\tlc += 8;\r\n\r\n\t\t}\r\n\r\n\t\tlc -= nBits;\r\n\r\n\t\tgetBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );\r\n\t\tgetBitsReturn.c = c;\r\n\t\tgetBitsReturn.lc = lc;\r\n\t}\r\n\r\n\tvar hufTableBuffer = new Array( 59 );\r\n\r\n\tfunction hufCanonicalCodeTable( hcode ) {\r\n\r\n\t\tfor ( var i = 0; i <= 58; ++ i ) { hufTableBuffer[ i ] = 0; }\r\n\t\tfor ( var i = 0; i < HUF_ENCSIZE; ++ i ) { hufTableBuffer[ hcode[ i ] ] += 1; }\r\n\r\n\t\tvar c = 0;\r\n\r\n\t\tfor ( var i = 58; i > 0; -- i ) {\r\n\r\n\t\t\tvar nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );\r\n\t\t\thufTableBuffer[ i ] = c;\r\n\t\t\tc = nc;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < HUF_ENCSIZE; ++ i ) {\r\n\r\n\t\t\tvar l = hcode[ i ];\r\n\t\t\tif ( l > 0 ) { hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 ); }\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction hufUnpackEncTable( uInt8Array, inDataView, inOffset, ni, im, iM, hcode ) {\r\n\r\n\t\tvar p = inOffset;\r\n\t\tvar c = 0;\r\n\t\tvar lc = 0;\r\n\r\n\t\tfor ( ; im <= iM; im ++ ) {\r\n\r\n\t\t\tif ( p.value - inOffset.value > ni ) { return false; }\r\n\r\n\t\t\tgetBits( 6, c, lc, uInt8Array, p );\r\n\r\n\t\t\tvar l = getBitsReturn.l;\r\n\t\t\tc = getBitsReturn.c;\r\n\t\t\tlc = getBitsReturn.lc;\r\n\r\n\t\t\thcode[ im ] = l;\r\n\r\n\t\t\tif ( l == LONG_ZEROCODE_RUN ) {\r\n\r\n\t\t\t\tif ( p.value - inOffset.value > ni ) {\r\n\r\n\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgetBits( 8, c, lc, uInt8Array, p );\r\n\r\n\t\t\t\tvar zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\r\n\t\t\t\tc = getBitsReturn.c;\r\n\t\t\t\tlc = getBitsReturn.lc;\r\n\r\n\t\t\t\tif ( im + zerun > iM + 1 ) {\r\n\r\n\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile ( zerun -- ) { hcode[ im ++ ] = 0; }\r\n\r\n\t\t\t\tim --;\r\n\r\n\t\t\t} else if ( l >= SHORT_ZEROCODE_RUN ) {\r\n\r\n\t\t\t\tvar zerun = l - SHORT_ZEROCODE_RUN + 2;\r\n\r\n\t\t\t\tif ( im + zerun > iM + 1 ) {\r\n\r\n\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile ( zerun -- ) { hcode[ im ++ ] = 0; }\r\n\r\n\t\t\t\tim --;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\thufCanonicalCodeTable( hcode );\r\n\r\n\t}\r\n\r\n\tfunction hufLength( code ) { return code & 63; }\r\n\r\n\tfunction hufCode( code ) { return code >> 6; }\r\n\r\n\tfunction hufBuildDecTable( hcode, im, iM, hdecod ) {\r\n\r\n\t\tfor ( ; im <= iM; im ++ ) {\r\n\r\n\t\t\tvar c = hufCode( hcode[ im ] );\r\n\t\t\tvar l = hufLength( hcode[ im ] );\r\n\r\n\t\t\tif ( c >> l ) {\r\n\r\n\t\t\t\tthrow 'Invalid table entry';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( l > HUF_DECBITS ) {\r\n\r\n\t\t\t\tvar pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];\r\n\r\n\t\t\t\tif ( pl.len ) {\r\n\r\n\t\t\t\t\tthrow 'Invalid table entry';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpl.lit ++;\r\n\r\n\t\t\t\tif ( pl.p ) {\r\n\r\n\t\t\t\t\tvar p = pl.p;\r\n\t\t\t\t\tpl.p = new Array( pl.lit );\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < pl.lit - 1; ++ i ) {\r\n\r\n\t\t\t\t\t\tpl.p[ i ] = p[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpl.p = new Array( 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpl.p[ pl.lit - 1 ] = im;\r\n\r\n\t\t\t} else if ( l ) {\r\n\r\n\t\t\t\tvar plOffset = 0;\r\n\r\n\t\t\t\tfor ( var i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {\r\n\r\n\t\t\t\t\tvar pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];\r\n\r\n\t\t\t\t\tif ( pl.len || pl.p ) {\r\n\r\n\t\t\t\t\t\tthrow 'Invalid table entry';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpl.len = l;\r\n\t\t\t\t\tpl.lit = im;\r\n\r\n\t\t\t\t\tplOffset ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tvar getCharReturn = { c: 0, lc: 0 };\r\n\r\n\tfunction getChar( c, lc, uInt8Array, inOffset ) {\r\n\r\n\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\r\n\t\tlc += 8;\r\n\r\n\t\tgetCharReturn.c = c;\r\n\t\tgetCharReturn.lc = lc;\r\n\r\n\t}\r\n\r\n\tvar getCodeReturn = { c: 0, lc: 0 };\r\n\r\n\tfunction getCode( po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {\r\n\r\n\t\tif ( po == rlc ) {\r\n\r\n\t\t\tif ( lc < 8 ) {\r\n\r\n\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\r\n\t\t\t\tc = getCharReturn.c;\r\n\t\t\t\tlc = getCharReturn.lc;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlc -= 8;\r\n\r\n\t\t\tvar cs = ( c >> lc );\r\n\t\t\tvar cs = new Uint8Array([cs])[0];\r\n\r\n\t\t\tif ( outBufferOffset.value + cs > outBufferEndOffset ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar s = outBuffer[ outBufferOffset.value - 1 ];\r\n\r\n\t\t\twhile ( cs-- > 0 ) {\r\n\r\n\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = s;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( outBufferOffset.value < outBufferEndOffset ) {\r\n\r\n\t\t\toutBuffer[ outBufferOffset.value ++ ] = po;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tgetCodeReturn.c = c;\r\n\t\tgetCodeReturn.lc = lc;\r\n\r\n\t}\r\n\r\n\tfunction UInt16( value ) {\r\n\r\n\t\treturn ( value & 0xFFFF );\r\n\r\n\t}\r\n\r\n\tfunction Int16( value ) {\r\n\r\n\t\tvar ref = UInt16( value );\r\n\t\treturn ( ref > 0x7FFF ) ? ref - 0x10000 : ref;\r\n\r\n\t}\r\n\r\n\tvar wdec14Return = { a: 0, b: 0 };\r\n\r\n\tfunction wdec14( l, h ) {\r\n\r\n\t\tvar ls = Int16( l );\r\n\t\tvar hs = Int16( h );\r\n\r\n\t\tvar hi = hs;\r\n\t\tvar ai = ls + ( hi & 1 ) + ( hi >> 1 );\r\n\r\n\t\tvar as = ai;\r\n\t\tvar bs = ai - hi;\r\n\r\n\t\twdec14Return.a = as;\r\n\t\twdec14Return.b = bs;\r\n\r\n\t}\r\n\r\n\tfunction wav2Decode( j, buffer, nx, ox, ny, oy, mx ) {\r\n\r\n\t\tvar n = ( nx > ny ) ? ny : nx;\r\n\t\tvar p = 1;\r\n\t\tvar p2;\r\n\r\n\t\twhile ( p <= n ) { p <<= 1; }\r\n\r\n\t\tp >>= 1;\r\n\t\tp2 = p;\r\n\t\tp >>= 1;\r\n\r\n\t\twhile ( p >= 1 ) {\r\n\r\n\t\t\tvar py = 0;\r\n\t\t\tvar ey = py + oy * ( ny - p2 );\r\n\t\t\tvar oy1 = oy * p;\r\n\t\t\tvar oy2 = oy * p2;\r\n\t\t\tvar ox1 = ox * p;\r\n\t\t\tvar ox2 = ox * p2;\r\n\t\t\tvar i00, i01, i10, i11;\r\n\r\n\t\t\tfor ( ; py <= ey; py += oy2 ) {\r\n\r\n\t\t\t\tvar px = py;\r\n\t\t\t\tvar ex = py + ox * ( nx - p2 );\r\n\r\n\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\r\n\r\n\t\t\t\t\tvar p01 = px + ox1;\r\n\t\t\t\t\tvar p10 = px + oy1;\r\n\t\t\t\t\tvar p11 = p10 + ox1;\r\n\r\n\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\r\n\r\n\t\t\t\t\ti00 = wdec14Return.a;\r\n\t\t\t\t\ti10 = wdec14Return.b;\r\n\r\n\t\t\t\t\twdec14( buffer[ p01 + j ], buffer[ p11 + j ] );\r\n\r\n\t\t\t\t\ti01 = wdec14Return.a;\r\n\t\t\t\t\ti11 = wdec14Return.b;\r\n\r\n\t\t\t\t\twdec14( i00, i01 );\r\n\r\n\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\r\n\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\r\n\r\n\t\t\t\t\twdec14( i10, i11 );\r\n\r\n\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\r\n\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nx & p ) {\r\n\r\n\t\t\t\t\tvar p10 = px + oy1;\r\n\r\n\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\r\n\r\n\t\t\t\t\ti00 = wdec14Return.a;\r\n\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.b;\r\n\r\n\t\t\t\t\tbuffer[ px + j ] = i00;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ny & p ) {\r\n\r\n\t\t\t\tvar px = py;\r\n\t\t\t\tvar ex = py + ox * ( nx - p2 );\r\n\r\n\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\r\n\r\n\t\t\t\t\tvar p01 = px + ox1;\r\n\r\n\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p01 + j ] );\r\n\r\n\t\t\t\t\ti00 = wdec14Return.a;\r\n\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\r\n\r\n\t\t\t\t\tbuffer[ px + j ] = i00;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp2 = p;\r\n\t\t\tp >>= 1;\r\n\r\n\t\t}\r\n\r\n\t\treturn py;\r\n\r\n\t}\r\n\r\n\tfunction hufDecode( encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset ) {\r\n\r\n\t\tvar c = 0;\r\n\t\tvar lc = 0;\r\n\t\tvar outBufferEndOffset = no;\r\n\t\tvar inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );\r\n\r\n\t\twhile ( inOffset.value < inOffsetEnd ) {\r\n\r\n\t\t\tgetChar( c, lc, uInt8Array, inOffset );\r\n\r\n\t\t\tc = getCharReturn.c;\r\n\t\t\tlc = getCharReturn.lc;\r\n\r\n\t\t\twhile ( lc >= HUF_DECBITS ) {\r\n\r\n\t\t\t\tvar index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;\r\n\t\t\t\tvar pl = decodingTable[ index ];\r\n\r\n\t\t\t\tif ( pl.len ) {\r\n\r\n\t\t\t\t\tlc -= pl.len;\r\n\r\n\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\r\n\r\n\t\t\t\t\tc = getCodeReturn.c;\r\n\t\t\t\t\tlc = getCodeReturn.lc;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( ! pl.p ) {\r\n\r\n\t\t\t\t\t\tthrow 'hufDecode issues';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar j;\r\n\r\n\t\t\t\t\tfor ( j = 0; j < pl.lit; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar l = hufLength( encodingTable[ pl.p[ j ] ] );\r\n\r\n\t\t\t\t\t\twhile ( lc < l && inOffset.value < inOffsetEnd ) {\r\n\r\n\t\t\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\r\n\r\n\t\t\t\t\t\t\tc = getCharReturn.c;\r\n\t\t\t\t\t\t\tlc = getCharReturn.lc;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( lc >= l ) {\r\n\r\n\t\t\t\t\t\t\tif ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {\r\n\r\n\t\t\t\t\t\t\t\tlc -= l;\r\n\r\n\t\t\t\t\t\t\t\tgetCode( pl.p[ j ], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\r\n\r\n\t\t\t\t\t\t\t\tc = getCodeReturn.c;\r\n\t\t\t\t\t\t\t\tlc = getCodeReturn.lc;\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( j == pl.lit ) {\r\n\r\n\t\t\t\t\t\tthrow 'hufDecode issues';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar i = ( 8 - ni ) & 7;\r\n\r\n\t\tc >>= i;\r\n\t\tlc -= i;\r\n\r\n\t\twhile ( lc > 0 ) {\r\n\r\n\t\t\tvar pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];\r\n\r\n\t\t\tif ( pl.len ) {\r\n\r\n\t\t\t\tlc -= pl.len;\r\n\r\n\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\r\n\r\n\t\t\t\tc = getCodeReturn.c;\r\n\t\t\t\tlc = getCodeReturn.lc;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow 'hufDecode issues';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfunction hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, outOffset, nRaw ) {\r\n\r\n\t\tvar initialInOffset = inOffset.value;\r\n\r\n\t\tvar im = parseUint32( inDataView, inOffset );\r\n\t\tvar iM = parseUint32( inDataView, inOffset );\r\n\r\n\t\tinOffset.value += 4;\r\n\r\n\t\tvar nBits = parseUint32( inDataView, inOffset );\r\n\r\n\t\tinOffset.value += 4;\r\n\r\n\t\tif ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {\r\n\r\n\t\t\tthrow 'Something wrong with HUF_ENCSIZE';\r\n\r\n\t\t}\r\n\r\n\t\tvar freq = new Array( HUF_ENCSIZE );\r\n\t\tvar hdec = new Array( HUF_DECSIZE );\r\n\r\n\t\thufClearDecTable( hdec );\r\n\r\n\t\tvar ni = nCompressed - ( inOffset.value - initialInOffset );\r\n\r\n\t\thufUnpackEncTable( uInt8Array, inDataView, inOffset, ni, im, iM, freq );\r\n\r\n\t\tif ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {\r\n\r\n\t\t\tthrow 'Something wrong with hufUncompress';\r\n\r\n\t\t}\r\n\r\n\t\thufBuildDecTable( freq, im, iM, hdec );\r\n\r\n\t\thufDecode( freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset );\r\n\r\n\t}\r\n\r\n\tfunction applyLut( lut, data, nData ) {\r\n\r\n\t\tfor ( var i = 0; i < nData; ++ i ) {\r\n\r\n\t\t\tdata[ i ] = lut[ data[ i ] ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction decompressPIZ( outBuffer, outOffset, uInt8Array, inDataView, inOffset, tmpBufSize, num_channels, exrChannelInfos, dataWidth, num_lines ) {\r\n\r\n\t\tvar bitmap = new Uint8Array( BITMAP_SIZE );\r\n\r\n\t\tvar minNonZero = parseUint16( inDataView, inOffset );\r\n\t\tvar maxNonZero = parseUint16( inDataView, inOffset );\r\n\r\n\t\tif ( maxNonZero >= BITMAP_SIZE ) {\r\n\r\n\t\t\tthrow 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\r\n\r\n\t\t}\r\n\r\n\t\tif ( minNonZero <= maxNonZero ) {\r\n\r\n\t\t\tfor ( var i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {\r\n\r\n\t\t\t\tbitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar lut = new Uint16Array( USHORT_RANGE );\r\n\t\tvar maxValue = reverseLutFromBitmap( bitmap, lut );\r\n\r\n\t\tvar length = parseUint32( inDataView, inOffset );\r\n\r\n\t\thufUncompress( uInt8Array, inDataView, inOffset, length, outBuffer, outOffset, tmpBufSize );\r\n\r\n\t\tvar pizChannelData = new Array( num_channels );\r\n\r\n\t\tvar outBufferEnd = 0;\r\n\r\n\t\tfor ( var i = 0; i < num_channels; i ++ ) {\r\n\r\n\t\t\tvar exrChannelInfo = exrChannelInfos[ i ];\r\n\r\n\t\t\tpizChannelData[ i ] = {};\r\n\t\t\tpizChannelData[ i ][ 'start' ] = outBufferEnd;\r\n\t\t\tpizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];\r\n\t\t\tpizChannelData[ i ][ 'nx' ] = dataWidth;\r\n\t\t\tpizChannelData[ i ][ 'ny' ] = num_lines;\r\n\t\t\tpizChannelData[ i ][ 'size' ] = 1;\r\n\r\n\t\t\toutBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;\r\n\r\n\t\t}\r\n\r\n\t\tvar fooOffset = 0;\r\n\r\n\t\tfor ( var i = 0; i < num_channels; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < pizChannelData[ i ].size; ++ j ) {\r\n\r\n\t\t\t\tfooOffset += wav2Decode(\r\n\t\t\t\t\tj + fooOffset,\r\n\t\t\t\t\toutBuffer,\r\n\t\t\t\t\tpizChannelData[ i ].nx,\r\n\t\t\t\t\tpizChannelData[ i ].size,\r\n\t\t\t\t\tpizChannelData[ i ].ny,\r\n\t\t\t\t\tpizChannelData[ i ].nx * pizChannelData[ i ].size,\r\n\t\t\t\t\tmaxValue\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tapplyLut( lut, outBuffer, outBufferEnd );\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfunction parseNullTerminatedString( buffer, offset ) {\r\n\r\n\t\tvar uintBuffer = new Uint8Array( buffer );\r\n\t\tvar endOffset = 0;\r\n\r\n\t\twhile ( uintBuffer[ offset.value + endOffset ] != 0 ) {\r\n\r\n\t\t\tendOffset += 1;\r\n\r\n\t\t}\r\n\r\n\t\tvar stringValue = new TextDecoder().decode(\r\n\t\t\tuintBuffer.slice( offset.value, offset.value + endOffset )\r\n\t\t);\r\n\r\n\t\toffset.value = offset.value + endOffset + 1;\r\n\r\n\t\treturn stringValue;\r\n\r\n\t}\r\n\r\n\tfunction parseFixedLengthString( buffer, offset, size ) {\r\n\r\n\t\tvar stringValue = new TextDecoder().decode(\r\n\t\t\tnew Uint8Array( buffer ).slice( offset.value, offset.value + size )\r\n\t\t);\r\n\r\n\t\toffset.value = offset.value + size;\r\n\r\n\t\treturn stringValue;\r\n\r\n\t}\r\n\r\n\tfunction parseUlong( dataView, offset ) {\r\n\r\n\t\tvar uLong = dataView.getUint32( 0, true );\r\n\r\n\t\toffset.value = offset.value + ULONG_SIZE;\r\n\r\n\t\treturn uLong;\r\n\r\n\t}\r\n\r\n\tfunction parseUint32( dataView, offset ) {\r\n\r\n\t\tvar Uint32 = dataView.getUint32(offset.value, true);\r\n\r\n\t\toffset.value = offset.value + INT32_SIZE;\r\n\r\n\t\treturn Uint32;\r\n\r\n\t}\r\n\r\n\tfunction parseUint8Array( uInt8Array, offset ) {\r\n\r\n\t\tvar Uint8 = uInt8Array[offset.value];\r\n\r\n\t\toffset.value = offset.value + INT8_SIZE;\r\n\r\n\t\treturn Uint8;\r\n\r\n\t}\r\n\r\n\tfunction parseUint8( dataView, offset ) {\r\n\r\n\t\tvar Uint8 = dataView.getUint8(offset.value);\r\n\r\n\t\toffset.value = offset.value + INT8_SIZE;\r\n\r\n\t\treturn Uint8;\r\n\r\n\t}\r\n\r\n\tfunction parseFloat32( dataView, offset ) {\r\n\r\n\t\tvar float = dataView.getFloat32(offset.value, true);\r\n\r\n\t\toffset.value += FLOAT32_SIZE;\r\n\r\n\t\treturn float;\r\n\r\n\t}\r\n\r\n\t// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\r\n\tfunction decodeFloat16( binary ) {\r\n\r\n\t\tvar exponent = ( binary & 0x7C00 ) >> 10,\r\n\t\t\tfraction = binary & 0x03FF;\r\n\r\n\t\treturn ( binary >> 15 ? - 1 : 1 ) * (\r\n\t\t\texponent ?\r\n\t\t\t\t(\r\n\t\t\t\t\texponent === 0x1F ?\r\n\t\t\t\t\t\tfraction ? NaN : Infinity :\r\n\t\t\t\t\t\tMath.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )\r\n\t\t\t\t) :\r\n\t\t\t\t6.103515625e-5 * ( fraction / 0x400 )\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tfunction parseUint16( dataView, offset ) {\r\n\r\n\t\tvar Uint16 = dataView.getUint16( offset.value, true );\r\n\r\n\t\toffset.value += INT16_SIZE;\r\n\r\n\t\treturn Uint16;\r\n\r\n\t}\r\n\r\n\tfunction parseFloat16( buffer, offset ) {\r\n\r\n\t\treturn decodeFloat16( parseUint16( buffer, offset) );\r\n\r\n\t}\r\n\r\n\tfunction parseChlist( dataView, buffer, offset, size ) {\r\n\r\n\t\tvar startOffset = offset.value;\r\n\t\tvar channels = [];\r\n\r\n\t\twhile ( offset.value < ( startOffset + size - 1 ) ) {\r\n\r\n\t\t\tvar name = parseNullTerminatedString( buffer, offset );\r\n\t\t\tvar pixelType = parseUint32( dataView, offset ); // TODO: Cast this to UINT, HALF or FLOAT\r\n\t\t\tvar pLinear = parseUint8( dataView, offset );\r\n\t\t\toffset.value += 3; // reserved, three chars\r\n\t\t\tvar xSampling = parseUint32( dataView, offset );\r\n\t\t\tvar ySampling = parseUint32( dataView, offset );\r\n\r\n\t\t\tchannels.push( {\r\n\t\t\t\tname: name,\r\n\t\t\t\tpixelType: pixelType,\r\n\t\t\t\tpLinear: pLinear,\r\n\t\t\t\txSampling: xSampling,\r\n\t\t\t\tySampling: ySampling\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\toffset.value += 1;\r\n\r\n\t\treturn channels;\r\n\r\n\t}\r\n\r\n\tfunction parseChromaticities( dataView, offset ) {\r\n\r\n\t\tvar redX = parseFloat32( dataView, offset );\r\n\t\tvar redY = parseFloat32( dataView, offset );\r\n\t\tvar greenX = parseFloat32( dataView, offset );\r\n\t\tvar greenY = parseFloat32( dataView, offset );\r\n\t\tvar blueX = parseFloat32( dataView, offset );\r\n\t\tvar blueY = parseFloat32( dataView, offset );\r\n\t\tvar whiteX = parseFloat32( dataView, offset );\r\n\t\tvar whiteY = parseFloat32( dataView, offset );\r\n\r\n\t\treturn { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\r\n\r\n\t}\r\n\r\n\tfunction parseCompression( dataView, offset ) {\r\n\r\n\t\tvar compressionCodes = [\r\n\t\t\t'NO_COMPRESSION',\r\n\t\t\t'RLE_COMPRESSION',\r\n\t\t\t'ZIPS_COMPRESSION',\r\n\t\t\t'ZIP_COMPRESSION',\r\n\t\t\t'PIZ_COMPRESSION'\r\n\t\t];\r\n\r\n\t\tvar compression = parseUint8( dataView, offset );\r\n\r\n\t\treturn compressionCodes[ compression ];\r\n\r\n\t}\r\n\r\n\tfunction parseBox2i( dataView, offset ) {\r\n\r\n\t\tvar xMin = parseUint32( dataView, offset );\r\n\t\tvar yMin = parseUint32( dataView, offset );\r\n\t\tvar xMax = parseUint32( dataView, offset );\r\n\t\tvar yMax = parseUint32( dataView, offset );\r\n\r\n\t\treturn { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\r\n\r\n\t}\r\n\r\n\tfunction parseLineOrder( dataView, offset ) {\r\n\r\n\t\tvar lineOrders = [\r\n\t\t\t'INCREASING_Y'\r\n\t\t];\r\n\r\n\t\tvar lineOrder = parseUint8( dataView, offset );\r\n\r\n\t\treturn lineOrders[ lineOrder ];\r\n\r\n\t}\r\n\r\n\tfunction parseV2f( dataView, offset ) {\r\n\r\n\t\tvar x = parseFloat32( dataView, offset );\r\n\t\tvar y = parseFloat32( dataView, offset );\r\n\r\n\t\treturn [ x, y ];\r\n\r\n\t}\r\n\r\n\tfunction parseValue( dataView, buffer, offset, type, size ) {\r\n\r\n\t\tif ( type === 'string' || type === 'iccProfile' ) {\r\n\r\n\t\t\treturn parseFixedLengthString( buffer, offset, size );\r\n\r\n\t\t} else if ( type === 'chlist' ) {\r\n\r\n\t\t\treturn parseChlist( dataView, buffer, offset, size );\r\n\r\n\t\t} else if ( type === 'chromaticities' ) {\r\n\r\n\t\t\treturn parseChromaticities( dataView, offset );\r\n\r\n\t\t} else if ( type === 'compression' ) {\r\n\r\n\t\t\treturn parseCompression( dataView, offset );\r\n\r\n\t\t} else if ( type === 'box2i' ) {\r\n\r\n\t\t\treturn parseBox2i( dataView, offset );\r\n\r\n\t\t} else if ( type === 'lineOrder' ) {\r\n\r\n\t\t\treturn parseLineOrder( dataView, offset );\r\n\r\n\t\t} else if ( type === 'float' ) {\r\n\r\n\t\t\treturn parseFloat32( dataView, offset );\r\n\r\n\t\t} else if ( type === 'v2f' ) {\r\n\r\n\t\t\treturn parseV2f( dataView, offset );\r\n\r\n\t\t} else if ( type === 'int' ) {\r\n\r\n\t\t\treturn parseUint32( dataView, offset );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthrow 'Cannot parse value for unsupported type: ' + type;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar bufferDataView = new DataView(buffer);\r\n\tvar uInt8Array = new Uint8Array(buffer);\r\n\r\n\tvar EXRHeader = {};\r\n\r\n\tvar magic = bufferDataView.getUint32( 0, true );\r\n\tvar versionByteZero = bufferDataView.getUint8( 4, true );\r\n\tvar fullMask = bufferDataView.getUint8( 5, true );\r\n\r\n\t// start of header\r\n\r\n\tvar offset = { value: 8 }; // start at 8, after magic stuff\r\n\r\n\tvar keepReading = true;\r\n\r\n\twhile ( keepReading ) {\r\n\r\n\t\tvar attributeName = parseNullTerminatedString( buffer, offset );\r\n\r\n\t\tif ( attributeName == 0 ) {\r\n\r\n\t\t\tkeepReading = false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar attributeType = parseNullTerminatedString( buffer, offset );\r\n\t\t\tvar attributeSize = parseUint32( bufferDataView, offset );\r\n\t\t\tvar attributeValue = parseValue( bufferDataView, buffer, offset, attributeType, attributeSize );\r\n\r\n\t\t\tEXRHeader[ attributeName ] = attributeValue;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// offsets\r\n\r\n\tvar dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\r\n\tvar scanlineBlockSize = 1; // 1 for NO_COMPRESSION\r\n\r\n\tif ( EXRHeader.compression === 'PIZ_COMPRESSION' ) {\r\n\r\n\t\tscanlineBlockSize = 32;\r\n\r\n\t}\r\n\r\n\tvar numBlocks = dataWindowHeight / scanlineBlockSize;\r\n\r\n\tfor ( var i = 0; i < numBlocks; i ++ ) {\r\n\r\n\t\tvar scanlineOffset = parseUlong( bufferDataView, offset );\r\n\r\n\t}\r\n\r\n\t// we should be passed the scanline offset table, start reading pixel data\r\n\r\n\tvar width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\r\n\tvar height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1;\r\n\tvar numChannels = EXRHeader.channels.length;\r\n\r\n\tvar byteArray = new Float32Array( width * height * numChannels );\r\n\r\n\tvar channelOffsets = {\r\n\t\tR: 0,\r\n\t\tG: 1,\r\n\t\tB: 2,\r\n\t\tA: 3\r\n\t};\r\n\r\n\tif ( EXRHeader.compression === 'NO_COMPRESSION' ) {\r\n\r\n\t\tfor ( var y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tvar y_scanline = parseUint32( bufferDataView, offset );\r\n\t\t\tvar dataSize = parseUint32( bufferDataView, offset );\r\n\r\n\t\t\tfor ( var channelID = 0; channelID < EXRHeader.channels.length; channelID ++ ) {\r\n\r\n\t\t\t\tvar cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];\r\n\r\n\t\t\t\tif ( EXRHeader.channels[ channelID ].pixelType === 1 ) {\r\n\r\n\t\t\t\t\t// HALF\r\n\t\t\t\t\tfor ( var x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\t\t\tvar val = parseFloat16( bufferDataView, offset );\r\n\r\n\t\t\t\t\t\tbyteArray[ ( ( ( height - y_scanline ) * ( width * numChannels ) ) + ( x * numChannels ) ) + cOff ] = val;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow 'Only supported pixel format is HALF';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else if ( EXRHeader.compression === 'PIZ_COMPRESSION' ) {\r\n\r\n\t\tfor ( var scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx ++ ) {\r\n\r\n\t\t\tvar line_no = parseUint32( bufferDataView, offset );\r\n\t\t\tvar data_len = parseUint32( bufferDataView, offset );\r\n\r\n\t\t\tvar tmpBufferSize = width * scanlineBlockSize * ( EXRHeader.channels.length * BYTES_PER_HALF );\r\n\t\t\tvar tmpBuffer = new Uint16Array( tmpBufferSize );\r\n\t\t\tvar tmpOffset = { value: 0 };\r\n\r\n\t\t\tdecompressPIZ( tmpBuffer, tmpOffset, uInt8Array, bufferDataView, offset, tmpBufferSize, numChannels, EXRHeader.channels, width, scanlineBlockSize );\r\n\r\n\t\t\tfor ( var line_y = 0; line_y < scanlineBlockSize; line_y ++ ) {\r\n\r\n\t\t\t\tfor ( var channelID = 0; channelID < EXRHeader.channels.length; channelID ++ ) {\r\n\r\n\t\t\t\t\tvar cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];\r\n\r\n\t\t\t\t\tif ( EXRHeader.channels[ channelID ].pixelType === 1 ) {\r\n\r\n\t\t\t\t\t\t// HALF\r\n\t\t\t\t\t\tfor ( var x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar val = decodeFloat16( tmpBuffer[ ( channelID * ( scanlineBlockSize * width ) ) + ( line_y * width ) + x ] );\r\n\r\n\t\t\t\t\t\t\tvar true_y = line_y + ( scanlineBlockIdx * scanlineBlockSize );\r\n\r\n\t\t\t\t\t\t\tbyteArray[ ( ( ( height - true_y ) * ( width * numChannels ) ) + ( x * numChannels ) ) + cOff ] = val;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthrow 'Only supported pixel format is HALF';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tthrow 'Cannot decompress unsupported compression';\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\theader: EXRHeader,\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdata: byteArray,\r\n\t\tformat: EXRHeader.channels.length == 4 ? RGBAFormat : RGBFormat,\r\n\t\ttype: FloatType\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar FBXLoader = ( function () {\r\n\r\n\tvar fbxTree;\r\n\tvar connections;\r\n\tvar sceneGraph;\r\n\r\n\tfunction FBXLoader( manager ) {\r\n\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\t}\r\n\r\n\tFBXLoader.prototype = {\r\n\r\n\t\tconstructor: FBXLoader,\r\n\r\n\t\tcrossOrigin: 'anonymous',\r\n\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tvar resourceDirectory = LoaderUtils.extractUrlBase( url );\r\n\r\n\t\t\tvar loader = new FileLoader( this.manager );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tvar scene = self.parse( buffer, resourceDirectory );\r\n\t\t\t\t\tonLoad( scene );\r\n\r\n\t\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\t\t\tif ( onError ) { onError( error ); }\r\n\r\n\t\t\t\t\t\tself.manager.itemError( url );\r\n\r\n\t\t\t\t\t}, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, onError );\r\n\t\t},\r\n\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\t\tthis.crossOrigin = value;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( FBXBuffer, resourceDirectory ) {\r\n\r\n\t\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\r\n\r\n\t\t\t\tfbxTree = new BinaryParser().parse( FBXBuffer );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar FBXText = convertArrayBufferToString( FBXBuffer );\r\n\r\n\t\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'FBXLoader: Unknown format.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfbxTree = new TextParser().parse( FBXText );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log( FBXTree );\r\n\r\n\t\t\tvar textureLoader = new TextureLoader( this.manager ).setPath( resourceDirectory ).setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\treturn new FBXTreeParser( textureLoader ).parse( fbxTree );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\r\n\tfunction FBXTreeParser( textureLoader ) {\r\n\r\n\t\tthis.textureLoader = textureLoader;\r\n\r\n\t}\r\n\r\n\tFBXTreeParser.prototype = {\r\n\r\n\t\tconstructor: FBXTreeParser,\r\n\r\n\t\tparse: function () {\r\n\r\n\t\t\tconnections = this.parseConnections();\r\n\r\n\t\t\tvar images = this.parseImages();\r\n\t\t\tvar textures = this.parseTextures( images );\r\n\t\t\tvar materials = this.parseMaterials( textures );\r\n\t\t\tvar deformers = this.parseDeformers();\r\n\t\t\tvar geometryMap = new GeometryParser().parse( deformers );\r\n\r\n\t\t\tthis.parseScene( deformers, geometryMap, materials );\r\n\r\n\t\t\treturn sceneGraph;\r\n\r\n\t\t},\r\n\r\n\t\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\r\n\t\t// and details the connection type\r\n\t\tparseConnections: function () {\r\n\r\n\t\t\tvar connectionMap = new Map();\r\n\r\n\t\t\tif ( 'Connections' in fbxTree ) {\r\n\r\n\t\t\t\tvar rawConnections = fbxTree.Connections.connections;\r\n\r\n\t\t\t\trawConnections.forEach( function ( rawConnection ) {\r\n\r\n\t\t\t\t\tvar fromID = rawConnection[ 0 ];\r\n\t\t\t\t\tvar toID = rawConnection[ 1 ];\r\n\t\t\t\t\tvar relationship = rawConnection[ 2 ];\r\n\r\n\t\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\r\n\r\n\t\t\t\t\t\tconnectionMap.set( fromID, {\r\n\t\t\t\t\t\t\tparents: [],\r\n\t\t\t\t\t\t\tchildren: []\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\r\n\t\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\r\n\r\n\t\t\t\t\tif ( ! connectionMap.has( toID ) ) {\r\n\r\n\t\t\t\t\t\tconnectionMap.set( toID, {\r\n\t\t\t\t\t\t\tparents: [],\r\n\t\t\t\t\t\t\tchildren: []\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\r\n\t\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn connectionMap;\r\n\r\n\t\t},\r\n\r\n\t\t// Parse FBXTree.Objects.Video for embedded image data\r\n\t\t// These images are connected to textures in FBXTree.Objects.Textures\r\n\t\t// via FBXTree.Connections.\r\n\t\tparseImages: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar images = {};\r\n\t\t\tvar blobs = {};\r\n\r\n\t\t\tif ( 'Video' in fbxTree.Objects ) {\r\n\r\n\t\t\t\tvar videoNodes = fbxTree.Objects.Video;\r\n\r\n\t\t\t\tfor ( var nodeID in videoNodes ) {\r\n\r\n\t\t\t\t\tvar videoNode = videoNodes[ nodeID ];\r\n\r\n\t\t\t\t\tvar id = parseInt( nodeID );\r\n\r\n\t\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\r\n\r\n\t\t\t\t\t// raw image data is in videoNode.Content\r\n\t\t\t\t\tif ( 'Content' in videoNode ) {\r\n\r\n\t\t\t\t\t\tvar arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\r\n\t\t\t\t\t\tvar base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\r\n\r\n\t\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\r\n\r\n\t\t\t\t\t\t\tvar image = this$1.parseImage( videoNodes[ nodeID ] );\r\n\r\n\t\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var id in images ) {\r\n\r\n\t\t\t\tvar filename = images[ id ];\r\n\r\n\t\t\t\tif ( blobs[ filename ] !== undefined ) { images[ id ] = blobs[ filename ]; }\r\n\t\t\t\telse { images[ id ] = images[ id ].split( '\\\\' ).pop(); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn images;\r\n\r\n\t\t},\r\n\r\n\t\t// Parse embedded image data in FBXTree.Video.Content\r\n\t\tparseImage: function ( videoNode ) {\r\n\r\n\t\t\tvar content = videoNode.Content;\r\n\t\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\r\n\t\t\tvar extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\r\n\r\n\t\t\tvar type;\r\n\r\n\t\t\tswitch ( extension ) {\r\n\r\n\t\t\t\tcase 'bmp':\r\n\r\n\t\t\t\t\ttype = 'image/bmp';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'jpg':\r\n\t\t\t\tcase 'jpeg':\r\n\r\n\t\t\t\t\ttype = 'image/jpeg';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'png':\r\n\r\n\t\t\t\t\ttype = 'image/png';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'tif':\r\n\r\n\t\t\t\t\ttype = 'image/tiff';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'tga':\r\n\r\n\t\t\t\t\tif ( typeof TGALoader !== 'function' ) {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: TGALoader is required to load TGA textures' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( Loader.Handlers.get( '.tga' ) === null ) {\r\n\r\n\t\t\t\t\t\t\tLoader.Handlers.add( /\\.tga$/i, new TGALoader() );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttype = 'image/tga';\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( typeof content === 'string' ) { // ASCII format\r\n\r\n\t\t\t\treturn 'data:' + type + ';base64,' + content;\r\n\r\n\t\t\t} else { // Binary Format\r\n\r\n\t\t\t\tvar array = new Uint8Array( content );\r\n\t\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// Parse nodes in FBXTree.Objects.Texture\r\n\t\t// These contain details such as UV scaling, cropping, rotation etc and are connected\r\n\t\t// to images in FBXTree.Objects.Video\r\n\t\tparseTextures: function ( images ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar textureMap = new Map();\r\n\r\n\t\t\tif ( 'Texture' in fbxTree.Objects ) {\r\n\r\n\t\t\t\tvar textureNodes = fbxTree.Objects.Texture;\r\n\t\t\t\tfor ( var nodeID in textureNodes ) {\r\n\r\n\t\t\t\t\tvar texture = this$1.parseTexture( textureNodes[ nodeID ], images );\r\n\t\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn textureMap;\r\n\r\n\t\t},\r\n\r\n\t\t// Parse individual node in FBXTree.Objects.Texture\r\n\t\tparseTexture: function ( textureNode, images ) {\r\n\r\n\t\t\tvar texture = this.loadTexture( textureNode, images );\r\n\r\n\t\t\ttexture.ID = textureNode.id;\r\n\r\n\t\t\ttexture.name = textureNode.attrName;\r\n\r\n\t\t\tvar wrapModeU = textureNode.WrapModeU;\r\n\t\t\tvar wrapModeV = textureNode.WrapModeV;\r\n\r\n\t\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\r\n\t\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\r\n\r\n\t\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\r\n\t\t\t// 0: repeat(default), 1: clamp\r\n\r\n\t\t\ttexture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;\r\n\t\t\ttexture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;\r\n\r\n\t\t\tif ( 'Scaling' in textureNode ) {\r\n\r\n\t\t\t\tvar values = textureNode.Scaling.value;\r\n\r\n\t\t\t\ttexture.repeat.x = values[ 0 ];\r\n\t\t\t\ttexture.repeat.y = values[ 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t},\r\n\r\n\t\t// load a texture specified as a blob or data URI, or via an external URL using TextureLoader\r\n\t\tloadTexture: function ( textureNode, images ) {\r\n\r\n\t\t\tvar fileName;\r\n\r\n\t\t\tvar currentPath = this.textureLoader.path;\r\n\r\n\t\t\tvar children = connections.get( textureNode.id ).children;\r\n\r\n\t\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\r\n\r\n\t\t\t\tfileName = images[ children[ 0 ].ID ];\r\n\r\n\t\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\r\n\r\n\t\t\t\t\tthis.textureLoader.setPath( undefined );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar texture;\r\n\r\n\t\t\tvar extension = textureNode.FileName.slice( - 3 ).toLowerCase();\r\n\r\n\t\t\tif ( extension === 'tga' ) {\r\n\r\n\t\t\t\tvar loader = Loader.Handlers.get( '.tga' );\r\n\r\n\t\t\t\tif ( loader === null ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'FBXLoader: TGALoader not found, creating empty placeholder texture for', fileName );\r\n\t\t\t\t\ttexture = new Texture();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture = loader.load( fileName );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( extension === 'psd' ) {\r\n\r\n\t\t\t\tconsole.warn( 'FBXLoader: PSD textures are not supported, creating empty placeholder texture for', fileName );\r\n\t\t\t\ttexture = new Texture();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttexture = this.textureLoader.load( fileName );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.textureLoader.setPath( currentPath );\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t},\r\n\r\n\t\t// Parse nodes in FBXTree.Objects.Material\r\n\t\tparseMaterials: function ( textureMap ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar materialMap = new Map();\r\n\r\n\t\t\tif ( 'Material' in fbxTree.Objects ) {\r\n\r\n\t\t\t\tvar materialNodes = fbxTree.Objects.Material;\r\n\r\n\t\t\t\tfor ( var nodeID in materialNodes ) {\r\n\r\n\t\t\t\t\tvar material = this$1.parseMaterial( materialNodes[ nodeID ], textureMap );\r\n\r\n\t\t\t\t\tif ( material !== null ) { materialMap.set( parseInt( nodeID ), material ); }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn materialMap;\r\n\r\n\t\t},\r\n\r\n\t\t// Parse single node in FBXTree.Objects.Material\r\n\t\t// Materials are connected to texture maps in FBXTree.Objects.Textures\r\n\t\t// FBX format currently only supports Lambert and Phong shading models\r\n\t\tparseMaterial: function ( materialNode, textureMap ) {\r\n\r\n\t\t\tvar ID = materialNode.id;\r\n\t\t\tvar name = materialNode.attrName;\r\n\t\t\tvar type = materialNode.ShadingModel;\r\n\r\n\t\t\t// Case where FBX wraps shading model in property object.\r\n\t\t\tif ( typeof type === 'object' ) {\r\n\r\n\t\t\t\ttype = type.value;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Ignore unused materials which don't have any connections.\r\n\t\t\tif ( ! connections.has( ID ) ) { return null; }\r\n\r\n\t\t\tvar parameters = this.parseParameters( materialNode, textureMap, ID );\r\n\r\n\t\t\tvar material;\r\n\r\n\t\t\tswitch ( type.toLowerCase() ) {\r\n\r\n\t\t\t\tcase 'phong':\r\n\t\t\t\t\tmaterial = new MeshPhongMaterial();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'lambert':\r\n\t\t\t\t\tmaterial = new MeshLambertMaterial();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tconsole.warn( 'FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\r\n\t\t\t\t\tmaterial = new MeshPhongMaterial( { color: 0x3300ff } );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.setValues( parameters );\r\n\t\t\tmaterial.name = name;\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t},\r\n\r\n\t\t// Parse FBX material and return parameters suitable for a three.js material\r\n\t\t// Also parse the texture map and return any textures associated with the material\r\n\t\tparseParameters: function ( materialNode, textureMap, ID ) {\r\n\r\n\t\t\tvar parameters = {};\r\n\r\n\t\t\tif ( materialNode.BumpFactor ) {\r\n\r\n\t\t\t\tparameters.bumpScale = materialNode.BumpFactor.value;\r\n\r\n\t\t\t}\r\n\t\t\tif ( materialNode.Diffuse ) {\r\n\r\n\t\t\t\tparameters.color = new Color().fromArray( materialNode.Diffuse.value );\r\n\r\n\t\t\t} else if ( materialNode.DiffuseColor && materialNode.DiffuseColor.type === 'Color' ) {\r\n\r\n\t\t\t\t// The blender exporter exports diffuse here instead of in materialNode.Diffuse\r\n\t\t\t\tparameters.color = new Color().fromArray( materialNode.DiffuseColor.value );\r\n\r\n\t\t\t}\r\n\t\t\tif ( materialNode.DisplacementFactor ) {\r\n\r\n\t\t\t\tparameters.displacementScale = materialNode.DisplacementFactor.value;\r\n\r\n\t\t\t}\r\n\t\t\tif ( materialNode.Emissive ) {\r\n\r\n\t\t\t\tparameters.emissive = new Color().fromArray( materialNode.Emissive.value );\r\n\r\n\t\t\t} else if ( materialNode.EmissiveColor && materialNode.EmissiveColor.type === 'Color' ) {\r\n\r\n\t\t\t\t// The blender exporter exports emissive color here instead of in materialNode.Emissive\r\n\t\t\t\tparameters.emissive = new Color().fromArray( materialNode.EmissiveColor.value );\r\n\r\n\t\t\t}\r\n\t\t\tif ( materialNode.EmissiveFactor ) {\r\n\r\n\t\t\t\tparameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );\r\n\r\n\t\t\t}\r\n\t\t\tif ( materialNode.Opacity ) {\r\n\r\n\t\t\t\tparameters.opacity = parseFloat( materialNode.Opacity.value );\r\n\r\n\t\t\t}\r\n\t\t\tif ( parameters.opacity < 1.0 ) {\r\n\r\n\t\t\t\tparameters.transparent = true;\r\n\r\n\t\t\t}\r\n\t\t\tif ( materialNode.ReflectionFactor ) {\r\n\r\n\t\t\t\tparameters.reflectivity = materialNode.ReflectionFactor.value;\r\n\r\n\t\t\t}\r\n\t\t\tif ( materialNode.Shininess ) {\r\n\r\n\t\t\t\tparameters.shininess = materialNode.Shininess.value;\r\n\r\n\t\t\t}\r\n\t\t\tif ( materialNode.Specular ) {\r\n\r\n\t\t\t\tparameters.specular = new Color().fromArray( materialNode.Specular.value );\r\n\r\n\t\t\t} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {\r\n\r\n\t\t\t\t// The blender exporter exports specular color here instead of in materialNode.Specular\r\n\t\t\t\tparameters.specular = new Color().fromArray( materialNode.SpecularColor.value );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tconnections.get( ID ).children.forEach( function ( child ) {\r\n\r\n\t\t\t\tvar type = child.relationship;\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\tcase 'Bump':\r\n\t\t\t\t\t\tparameters.bumpMap = self.getTexture( textureMap, child.ID );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'DiffuseColor':\r\n\t\t\t\t\t\tparameters.map = self.getTexture( textureMap, child.ID );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'DisplacementColor':\r\n\t\t\t\t\t\tparameters.displacementMap = self.getTexture( textureMap, child.ID );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'EmissiveColor':\r\n\t\t\t\t\t\tparameters.emissiveMap = self.getTexture( textureMap, child.ID );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'NormalMap':\r\n\t\t\t\t\t\tparameters.normalMap = self.getTexture( textureMap, child.ID );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'ReflectionColor':\r\n\t\t\t\t\t\tparameters.envMap = self.getTexture( textureMap, child.ID );\r\n\t\t\t\t\t\tparameters.envMap.mapping = EquirectangularReflectionMapping;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'SpecularColor':\r\n\t\t\t\t\t\tparameters.specularMap = self.getTexture( textureMap, child.ID );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TransparentColor':\r\n\t\t\t\t\t\tparameters.alphaMap = self.getTexture( textureMap, child.ID );\r\n\t\t\t\t\t\tparameters.transparent = true;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'AmbientColor':\r\n\t\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\r\n\t\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\r\n\t\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: %s map is not supported in three.js, skipping texture.', type );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn parameters;\r\n\r\n\t\t},\r\n\r\n\t\t// get a texture from the textureMap for use by a material.\r\n\t\tgetTexture: function ( textureMap, id ) {\r\n\r\n\t\t\t// if the texture is a layered texture, just use the first layer and issue a warning\r\n\t\t\tif ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {\r\n\r\n\t\t\t\tconsole.warn( 'FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\r\n\t\t\t\tid = connections.get( id ).children[ 0 ].ID;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn textureMap.get( id );\r\n\r\n\t\t},\r\n\r\n\t\t// Parse nodes in FBXTree.Objects.Deformer\r\n\t\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\r\n\t\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\r\n\t\tparseDeformers: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar skeletons = {};\r\n\t\t\tvar morphTargets = {};\r\n\r\n\t\t\tif ( 'Deformer' in fbxTree.Objects ) {\r\n\r\n\t\t\t\tvar DeformerNodes = fbxTree.Objects.Deformer;\r\n\r\n\t\t\t\tfor ( var nodeID in DeformerNodes ) {\r\n\r\n\t\t\t\t\tvar deformerNode = DeformerNodes[ nodeID ];\r\n\r\n\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\r\n\r\n\t\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\r\n\r\n\t\t\t\t\t\tvar skeleton = this$1.parseSkeleton( relationships, DeformerNodes );\r\n\t\t\t\t\t\tskeleton.ID = nodeID;\r\n\r\n\t\t\t\t\t\tif ( relationships.parents.length > 1 ) { console.warn( 'FBXLoader: skeleton attached to more than one geometry is not supported.' ); }\r\n\t\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\r\n\r\n\t\t\t\t\t\tskeletons[ nodeID ] = skeleton;\r\n\r\n\t\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\r\n\r\n\t\t\t\t\t\tvar morphTarget = {\r\n\t\t\t\t\t\t\tid: nodeID,\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tmorphTarget.rawTargets = this$1.parseMorphTargets( relationships, DeformerNodes );\r\n\t\t\t\t\t\tmorphTarget.id = nodeID;\r\n\r\n\t\t\t\t\t\tif ( relationships.parents.length > 1 ) { console.warn( 'FBXLoader: morph target attached to more than one geometry is not supported.' ); }\r\n\r\n\t\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\r\n\t\t\t\tskeletons: skeletons,\r\n\t\t\t\tmorphTargets: morphTargets,\r\n\r\n\t\t\t};\r\n\r\n\t\t},\r\n\r\n\t\t// Parse single nodes in FBXTree.Objects.Deformer\r\n\t\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\r\n\t\t// Each skin node represents a skeleton and each cluster node represents a bone\r\n\t\tparseSkeleton: function ( relationships, deformerNodes ) {\r\n\r\n\t\t\tvar rawBones = [];\r\n\r\n\t\t\trelationships.children.forEach( function ( child ) {\r\n\r\n\t\t\t\tvar boneNode = deformerNodes[ child.ID ];\r\n\r\n\t\t\t\tif ( boneNode.attrType !== 'Cluster' ) { return; }\r\n\r\n\t\t\t\tvar rawBone = {\r\n\r\n\t\t\t\t\tID: child.ID,\r\n\t\t\t\t\tindices: [],\r\n\t\t\t\t\tweights: [],\r\n\t\t\t\t\ttransform: new Matrix4().fromArray( boneNode.Transform.a ),\r\n\t\t\t\t\ttransformLink: new Matrix4().fromArray( boneNode.TransformLink.a ),\r\n\t\t\t\t\tlinkMode: boneNode.Mode,\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( 'Indexes' in boneNode ) {\r\n\r\n\t\t\t\t\trawBone.indices = boneNode.Indexes.a;\r\n\t\t\t\t\trawBone.weights = boneNode.Weights.a;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\trawBones.push( rawBone );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn {\r\n\r\n\t\t\t\trawBones: rawBones,\r\n\t\t\t\tbones: []\r\n\r\n\t\t\t};\r\n\r\n\t\t},\r\n\r\n\t\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\r\n\t\tparseMorphTargets: function ( relationships, deformerNodes ) {\r\n\r\n\t\t\tvar rawMorphTargets = [];\r\n\r\n\t\t\tfor ( var i = 0; i < relationships.children.length; i ++ ) {\r\n\r\n\t\t\t\tif ( i === 8 ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.' );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar child = relationships.children[ i ];\r\n\r\n\t\t\t\tvar morphTargetNode = deformerNodes[ child.ID ];\r\n\r\n\t\t\t\tvar rawMorphTarget = {\r\n\r\n\t\t\t\t\tname: morphTargetNode.attrName,\r\n\t\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\r\n\t\t\t\t\tid: morphTargetNode.id,\r\n\t\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) { return; }\r\n\r\n\t\t\t\tvar targetRelationships = connections.get( parseInt( child.ID ) );\r\n\r\n\t\t\t\ttargetRelationships.children.forEach( function ( child ) {\r\n\r\n\t\t\t\t\tif ( child.relationship === undefined ) { rawMorphTarget.geoID = child.ID; }\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\trawMorphTargets.push( rawMorphTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn rawMorphTargets;\r\n\r\n\t\t},\r\n\r\n\t\t// create the main Group() to be returned by the loader\r\n\t\tparseScene: function ( deformers, geometryMap, materialMap ) {\r\n\r\n\t\t\tsceneGraph = new Group();\r\n\r\n\t\t\tvar modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );\r\n\r\n\t\t\tvar modelNodes = fbxTree.Objects.Model;\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tmodelMap.forEach( function ( model ) {\r\n\r\n\t\t\t\tvar modelNode = modelNodes[ model.ID ];\r\n\t\t\t\tself.setLookAtProperties( model, modelNode );\r\n\r\n\t\t\t\tvar parentConnections = connections.get( model.ID ).parents;\r\n\r\n\t\t\t\tparentConnections.forEach( function ( connection ) {\r\n\r\n\t\t\t\t\tvar parent = modelMap.get( connection.ID );\r\n\t\t\t\t\tif ( parent !== undefined ) { parent.add( model ); }\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tif ( model.parent === null ) {\r\n\r\n\t\t\t\t\tsceneGraph.add( model );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tthis.bindSkeleton( deformers.skeletons, geometryMap, modelMap );\r\n\r\n\t\t\tthis.createAmbientLight();\r\n\r\n\t\t\tthis.setupMorphMaterials();\r\n\r\n\t\t\tvar animations = new AnimationParser().parse();\r\n\r\n\t\t\t// if all the models where already combined in a single group, just return that\r\n\t\t\tif ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {\r\n\r\n\t\t\t\tsceneGraph.children[ 0 ].animations = animations;\r\n\t\t\t\tsceneGraph = sceneGraph.children[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsceneGraph.animations = animations;\r\n\r\n\t\t},\r\n\r\n\t\t// parse nodes in FBXTree.Objects.Model\r\n\t\tparseModels: function ( skeletons, geometryMap, materialMap ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar modelMap = new Map();\r\n\t\t\tvar modelNodes = fbxTree.Objects.Model;\r\n\r\n\t\t\tfor ( var nodeID in modelNodes ) {\r\n\r\n\t\t\t\tvar id = parseInt( nodeID );\r\n\t\t\t\tvar node = modelNodes[ nodeID ];\r\n\t\t\t\tvar relationships = connections.get( id );\r\n\r\n\t\t\t\tvar model = this$1.buildSkeleton( relationships, skeletons, id, node.attrName );\r\n\r\n\t\t\t\tif ( ! model ) {\r\n\r\n\t\t\t\t\tswitch ( node.attrType ) {\r\n\r\n\t\t\t\t\t\tcase 'Camera':\r\n\t\t\t\t\t\t\tmodel = this$1.createCamera( relationships );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'Light':\r\n\t\t\t\t\t\t\tmodel = this$1.createLight( relationships );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'Mesh':\r\n\t\t\t\t\t\t\tmodel = this$1.createMesh( relationships, geometryMap, materialMap );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'NurbsCurve':\r\n\t\t\t\t\t\t\tmodel = this$1.createCurve( relationships, geometryMap );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'LimbNode': // usually associated with a Bone, however if a Bone was not created we'll make a Group instead\r\n\t\t\t\t\t\tcase 'Null':\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tmodel = new Group();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmodel.name = PropertyBinding.sanitizeNodeName( node.attrName );\r\n\t\t\t\t\tmodel.ID = id;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis$1.setModelTransforms( model, node );\r\n\t\t\t\tmodelMap.set( id, model );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn modelMap;\r\n\r\n\t\t},\r\n\r\n\t\tbuildSkeleton: function ( relationships, skeletons, id, name ) {\r\n\r\n\t\t\tvar bone = null;\r\n\r\n\t\t\trelationships.parents.forEach( function ( parent ) {\r\n\r\n\t\t\t\tfor ( var ID in skeletons ) {\r\n\r\n\t\t\t\t\tvar skeleton = skeletons[ ID ];\r\n\r\n\t\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\r\n\r\n\t\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\r\n\r\n\t\t\t\t\t\t\tvar subBone = bone;\r\n\t\t\t\t\t\t\tbone = new Bone();\r\n\t\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\r\n\r\n\t\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\r\n\t\t\t\t\t\t\tbone.name = PropertyBinding.sanitizeNodeName( name );\r\n\t\t\t\t\t\t\tbone.ID = id;\r\n\r\n\t\t\t\t\t\t\tskeleton.bones[ i ] = bone;\r\n\r\n\t\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\r\n\t\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\r\n\t\t\t\t\t\t\tif ( subBone !== null ) {\r\n\r\n\t\t\t\t\t\t\t\tbone.add( subBone );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn bone;\r\n\r\n\t\t},\r\n\r\n\t\t// create a PerspectiveCamera or OrthographicCamera\r\n\t\tcreateCamera: function ( relationships ) {\r\n\r\n\t\t\tvar model;\r\n\t\t\tvar cameraAttribute;\r\n\r\n\t\t\trelationships.children.forEach( function ( child ) {\r\n\r\n\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\r\n\r\n\t\t\t\tif ( attr !== undefined ) {\r\n\r\n\t\t\t\t\tcameraAttribute = attr;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tif ( cameraAttribute === undefined ) {\r\n\r\n\t\t\t\tmodel = new Object3D();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar type = 0;\r\n\t\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\r\n\r\n\t\t\t\t\ttype = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar nearClippingPlane = 1;\r\n\t\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\r\n\r\n\t\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar farClippingPlane = 1000;\r\n\t\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\r\n\r\n\t\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar width = window.innerWidth;\r\n\t\t\t\tvar height = window.innerHeight;\r\n\r\n\t\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\r\n\r\n\t\t\t\t\twidth = cameraAttribute.AspectWidth.value;\r\n\t\t\t\t\theight = cameraAttribute.AspectHeight.value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar aspect = width / height;\r\n\r\n\t\t\t\tvar fov = 45;\r\n\t\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\r\n\r\n\t\t\t\t\tfov = cameraAttribute.FieldOfView.value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\tcase 0: // Perspective\r\n\t\t\t\t\t\tmodel = new PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );\r\n\t\t\t\t\t\tif ( focalLength !== null ) { model.setFocalLength( focalLength ); }\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 1: // Orthographic\r\n\t\t\t\t\t\tmodel = new OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: Unknown camera type ' + type + '.' );\r\n\t\t\t\t\t\tmodel = new Object3D();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn model;\r\n\r\n\t\t},\r\n\r\n\t\t// Create a DirectionalLight, PointLight or SpotLight\r\n\t\tcreateLight: function ( relationships ) {\r\n\r\n\t\t\tvar model;\r\n\t\t\tvar lightAttribute;\r\n\r\n\t\t\trelationships.children.forEach( function ( child ) {\r\n\r\n\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\r\n\r\n\t\t\t\tif ( attr !== undefined ) {\r\n\r\n\t\t\t\t\tlightAttribute = attr;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tif ( lightAttribute === undefined ) {\r\n\r\n\t\t\t\tmodel = new Object3D();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar type;\r\n\r\n\t\t\t\t// LightType can be undefined for Point lights\r\n\t\t\t\tif ( lightAttribute.LightType === undefined ) {\r\n\r\n\t\t\t\t\ttype = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttype = lightAttribute.LightType.value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar color = 0xffffff;\r\n\r\n\t\t\t\tif ( lightAttribute.Color !== undefined ) {\r\n\r\n\t\t\t\t\tcolor = new Color().fromArray( lightAttribute.Color.value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\r\n\r\n\t\t\t\t// light disabled\r\n\t\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\r\n\r\n\t\t\t\t\tintensity = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar distance = 0;\r\n\t\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\r\n\r\n\t\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\r\n\r\n\t\t\t\t\t\tdistance = 0;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\r\n\t\t\t\tvar decay = 1;\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\tcase 0: // Point\r\n\t\t\t\t\t\tmodel = new PointLight( color, intensity, distance, decay );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 1: // Directional\r\n\t\t\t\t\t\tmodel = new DirectionalLight( color, intensity );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 2: // Spot\r\n\t\t\t\t\t\tvar angle = Math.PI / 3;\r\n\r\n\t\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tangle = _Math.degToRad( lightAttribute.InnerAngle.value );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar penumbra = 0;\r\n\t\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\r\n\r\n\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\r\n\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\r\n\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\r\n\t\t\t\t\t\t\tpenumbra = _Math.degToRad( lightAttribute.OuterAngle.value );\r\n\t\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmodel = new SpotLight( color, intensity, distance, angle, penumbra, decay );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );\r\n\t\t\t\t\t\tmodel = new PointLight( color, intensity );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\r\n\r\n\t\t\t\t\tmodel.castShadow = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn model;\r\n\r\n\t\t},\r\n\r\n\t\tcreateMesh: function ( relationships, geometryMap, materialMap ) {\r\n\r\n\t\t\tvar model;\r\n\t\t\tvar geometry = null;\r\n\t\t\tvar material = null;\r\n\t\t\tvar materials = [];\r\n\r\n\t\t\t// get geometry and materials(s) from connections\r\n\t\t\trelationships.children.forEach( function ( child ) {\r\n\r\n\t\t\t\tif ( geometryMap.has( child.ID ) ) {\r\n\r\n\t\t\t\t\tgeometry = geometryMap.get( child.ID );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( materialMap.has( child.ID ) ) {\r\n\r\n\t\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tif ( materials.length > 1 ) {\r\n\r\n\t\t\t\tmaterial = materials;\r\n\r\n\t\t\t} else if ( materials.length > 0 ) {\r\n\r\n\t\t\t\tmaterial = materials[ 0 ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial = new MeshPhongMaterial( { color: 0xcccccc } );\r\n\t\t\t\tmaterials.push( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( 'color' in geometry.attributes ) {\r\n\r\n\t\t\t\tmaterials.forEach( function ( material ) {\r\n\r\n\t\t\t\t\tmaterial.vertexColors = VertexColors;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.FBX_Deformer ) {\r\n\r\n\t\t\t\tmaterials.forEach( function ( material ) {\r\n\r\n\t\t\t\t\tmaterial.skinning = true;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tmodel = new SkinnedMesh( geometry, material );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmodel = new Mesh( geometry, material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn model;\r\n\r\n\t\t},\r\n\r\n\t\tcreateCurve: function ( relationships, geometryMap ) {\r\n\r\n\t\t\tvar geometry = relationships.children.reduce( function ( geo, child ) {\r\n\r\n\t\t\t\tif ( geometryMap.has( child.ID ) ) { geo = geometryMap.get( child.ID ); }\r\n\r\n\t\t\t\treturn geo;\r\n\r\n\t\t\t}, null );\r\n\r\n\t\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\r\n\t\t\tvar material = new LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );\r\n\t\t\treturn new Line( geometry, material );\r\n\r\n\t\t},\r\n\r\n\t\t// parse the model node for transform details and apply them to the model\r\n\t\tsetModelTransforms: function ( model, modelNode ) {\r\n\r\n\t\t\tvar transformData = {};\r\n\r\n\t\t\tif ( 'RotationOrder' in modelNode ) { transformData.eulerOrder = parseInt( modelNode.RotationOrder.value ); }\r\n\t\t\tif ( 'Lcl_Translation' in modelNode ) { transformData.translation = modelNode.Lcl_Translation.value; }\r\n\t\t\tif ( 'RotationOffset' in modelNode ) { transformData.rotationOffset = modelNode.RotationOffset.value; }\r\n\t\t\tif ( 'Lcl_Rotation' in modelNode ) { transformData.rotation = modelNode.Lcl_Rotation.value; }\r\n\t\t\tif ( 'PreRotation' in modelNode ) { transformData.preRotation = modelNode.PreRotation.value; }\r\n\t\t\tif ( 'PostRotation' in modelNode ) { transformData.postRotation = modelNode.PostRotation.value; }\r\n\t\t\tif ( 'Lcl_Scaling' in modelNode ) { transformData.scale = modelNode.Lcl_Scaling.value; }\r\n\r\n\t\t\tvar transform = generateTransform( transformData );\r\n\r\n\t\t\tmodel.applyMatrix( transform );\r\n\r\n\t\t},\r\n\r\n\t\tsetLookAtProperties: function ( model, modelNode ) {\r\n\r\n\t\t\tif ( 'LookAtProperty' in modelNode ) {\r\n\r\n\t\t\t\tvar children = connections.get( model.ID ).children;\r\n\r\n\t\t\t\tchildren.forEach( function ( child ) {\r\n\r\n\t\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\r\n\r\n\t\t\t\t\t\tvar lookAtTarget = fbxTree.Objects.Model[ child.ID ];\r\n\r\n\t\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\r\n\r\n\t\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\r\n\r\n\t\t\t\t\t\t\t// DirectionalLight, SpotLight\r\n\t\t\t\t\t\t\tif ( model.target !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\r\n\t\t\t\t\t\t\t\tsceneGraph.add( model.target );\r\n\r\n\t\t\t\t\t\t\t} else { // Cameras and other Object3Ds\r\n\r\n\t\t\t\t\t\t\t\tmodel.lookAt( new Vector3().fromArray( pos ) );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tbindSkeleton: function ( skeletons, geometryMap, modelMap ) {\r\n\r\n\t\t\tvar bindMatrices = this.parsePoseNodes();\r\n\r\n\t\t\tfor ( var ID in skeletons ) {\r\n\r\n\t\t\t\tvar skeleton = skeletons[ ID ];\r\n\r\n\t\t\t\tvar parents = connections.get( parseInt( skeleton.ID ) ).parents;\r\n\r\n\t\t\t\tparents.forEach( function ( parent ) {\r\n\r\n\t\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\r\n\r\n\t\t\t\t\t\tvar geoID = parent.ID;\r\n\t\t\t\t\t\tvar geoRelationships = connections.get( geoID );\r\n\r\n\t\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\r\n\r\n\t\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\r\n\r\n\t\t\t\t\t\t\t\tvar model = modelMap.get( geoConnParent.ID );\r\n\r\n\t\t\t\t\t\t\t\tmodel.bind( new Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tparsePoseNodes: function () {\r\n\r\n\t\t\tvar bindMatrices = {};\r\n\r\n\t\t\tif ( 'Pose' in fbxTree.Objects ) {\r\n\r\n\t\t\t\tvar BindPoseNode = fbxTree.Objects.Pose;\r\n\r\n\t\t\t\tfor ( var nodeID in BindPoseNode ) {\r\n\r\n\t\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {\r\n\r\n\t\t\t\t\t\tvar poseNodes = BindPoseNode[ nodeID ].PoseNode;\r\n\r\n\t\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\r\n\r\n\t\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\r\n\r\n\t\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new Matrix4().fromArray( poseNode.Matrix.a );\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new Matrix4().fromArray( poseNodes.Matrix.a );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn bindMatrices;\r\n\r\n\t\t},\r\n\r\n\t\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\r\n\t\tcreateAmbientLight: function () {\r\n\r\n\t\t\tif ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {\r\n\r\n\t\t\t\tvar ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\r\n\t\t\t\tvar r = ambientColor[ 0 ];\r\n\t\t\t\tvar g = ambientColor[ 1 ];\r\n\t\t\t\tvar b = ambientColor[ 2 ];\r\n\r\n\t\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\r\n\r\n\t\t\t\t\tvar color = new Color( r, g, b );\r\n\t\t\t\t\tsceneGraph.add( new AmbientLight( color, 1 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tsetupMorphMaterials: function () {\r\n\r\n\t\t\tsceneGraph.traverse( function ( child ) {\r\n\r\n\t\t\t\tif ( child.isMesh ) {\r\n\r\n\t\t\t\t\tif ( child.geometry.morphAttributes.position || child.geometry.morphAttributes.normal ) {\r\n\r\n\t\t\t\t\t\tvar uuid = child.uuid;\r\n\t\t\t\t\t\tvar matUuid = child.material.uuid;\r\n\r\n\t\t\t\t\t\t// if a geometry has morph targets, it cannot share the material with other geometries\r\n\t\t\t\t\t\tvar sharedMat = false;\r\n\r\n\t\t\t\t\t\tsceneGraph.traverse( function ( child ) {\r\n\r\n\t\t\t\t\t\t\tif ( child.isMesh ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( child.material.uuid === matUuid && child.uuid !== uuid ) { sharedMat = true; }\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\tif ( sharedMat === true ) { child.material = child.material.clone(); }\r\n\r\n\t\t\t\t\t\tchild.material.morphTargets = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t},\r\n\r\n\t};\r\n\r\n\t// parse Geometry data from FBXTree and return map of BufferGeometries\r\n\tfunction GeometryParser() {}\r\n\r\n\tGeometryParser.prototype = {\r\n\r\n\t\tconstructor: GeometryParser,\r\n\r\n\t\t// Parse nodes in FBXTree.Objects.Geometry\r\n\t\tparse: function ( deformers ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar geometryMap = new Map();\r\n\r\n\t\t\tif ( 'Geometry' in fbxTree.Objects ) {\r\n\r\n\t\t\t\tvar geoNodes = fbxTree.Objects.Geometry;\r\n\r\n\t\t\t\tfor ( var nodeID in geoNodes ) {\r\n\r\n\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\r\n\t\t\t\t\tvar geo = this$1.parseGeometry( relationships, geoNodes[ nodeID ], deformers );\r\n\r\n\t\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometryMap;\r\n\r\n\t\t},\r\n\r\n\t\t// Parse single node in FBXTree.Objects.Geometry\r\n\t\tparseGeometry: function ( relationships, geoNode, deformers ) {\r\n\r\n\t\t\tswitch ( geoNode.attrType ) {\r\n\r\n\t\t\t\tcase 'Mesh':\r\n\t\t\t\t\treturn this.parseMeshGeometry( relationships, geoNode, deformers );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'NurbsCurve':\r\n\t\t\t\t\treturn this.parseNurbsGeometry( geoNode );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\r\n\t\tparseMeshGeometry: function ( relationships, geoNode, deformers ) {\r\n\r\n\t\t\tvar skeletons = deformers.skeletons;\r\n\t\t\tvar morphTargets = deformers.morphTargets;\r\n\r\n\t\t\tvar modelNodes = relationships.parents.map( function ( parent ) {\r\n\r\n\t\t\t\treturn fbxTree.Objects.Model[ parent.ID ];\r\n\r\n\t\t\t} );\r\n\r\n\t\t\t// don't create geometry if it is not associated with any models\r\n\t\t\tif ( modelNodes.length === 0 ) { return; }\r\n\r\n\t\t\tvar skeleton = relationships.children.reduce( function ( skeleton, child ) {\r\n\r\n\t\t\t\tif ( skeletons[ child.ID ] !== undefined ) { skeleton = skeletons[ child.ID ]; }\r\n\r\n\t\t\t\treturn skeleton;\r\n\r\n\t\t\t}, null );\r\n\r\n\t\t\tvar morphTarget = relationships.children.reduce( function ( morphTarget, child ) {\r\n\r\n\t\t\t\tif ( morphTargets[ child.ID ] !== undefined ) { morphTarget = morphTargets[ child.ID ]; }\r\n\r\n\t\t\t\treturn morphTarget;\r\n\r\n\t\t\t}, null );\r\n\r\n\t\t\t// TODO: if there is more than one model associated with the geometry, AND the models have\r\n\t\t\t// different geometric transforms, then this will cause problems\r\n\t\t\t// if ( modelNodes.length > 1 ) { }\r\n\r\n\t\t\t// For now just assume one model and get the preRotations from that\r\n\t\t\tvar modelNode = modelNodes[ 0 ];\r\n\r\n\t\t\tvar transformData = {};\r\n\r\n\t\t\tif ( 'RotationOrder' in modelNode ) { transformData.eulerOrder = modelNode.RotationOrder.value; }\r\n\t\t\tif ( 'GeometricTranslation' in modelNode ) { transformData.translation = modelNode.GeometricTranslation.value; }\r\n\t\t\tif ( 'GeometricRotation' in modelNode ) { transformData.rotation = modelNode.GeometricRotation.value; }\r\n\t\t\tif ( 'GeometricScaling' in modelNode ) { transformData.scale = modelNode.GeometricScaling.value; }\r\n\r\n\t\t\tvar transform = generateTransform( transformData );\r\n\r\n\t\t\treturn this.genGeometry( geoNode, skeleton, morphTarget, transform );\r\n\r\n\t\t},\r\n\r\n\t\t// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\r\n\t\tgenGeometry: function ( geoNode, skeleton, morphTarget, preTransform ) {\r\n\r\n\t\t\tvar geo = new BufferGeometry();\r\n\t\t\tif ( geoNode.attrName ) { geo.name = geoNode.attrName; }\r\n\r\n\t\t\tvar geoInfo = this.parseGeoNode( geoNode, skeleton );\r\n\t\t\tvar buffers = this.genBuffers( geoInfo );\r\n\r\n\t\t\tvar positionAttribute = new Float32BufferAttribute( buffers.vertex, 3 );\r\n\r\n\t\t\tpreTransform.applyToBufferAttribute( positionAttribute );\r\n\r\n\t\t\tgeo.addAttribute( 'position', positionAttribute );\r\n\r\n\t\t\tif ( buffers.colors.length > 0 ) {\r\n\r\n\t\t\t\tgeo.addAttribute( 'color', new Float32BufferAttribute( buffers.colors, 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( skeleton ) {\r\n\r\n\t\t\t\tgeo.addAttribute( 'skinIndex', new Uint16BufferAttribute( buffers.weightsIndices, 4 ) );\r\n\r\n\t\t\t\tgeo.addAttribute( 'skinWeight', new Float32BufferAttribute( buffers.vertexWeights, 4 ) );\r\n\r\n\t\t\t\t// used later to bind the skeleton to the model\r\n\t\t\t\tgeo.FBX_Deformer = skeleton;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( buffers.normal.length > 0 ) {\r\n\r\n\t\t\t\tvar normalAttribute = new Float32BufferAttribute( buffers.normal, 3 );\r\n\r\n\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( preTransform );\r\n\t\t\t\tnormalMatrix.applyToBufferAttribute( normalAttribute );\r\n\r\n\t\t\t\tgeo.addAttribute( 'normal', normalAttribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\r\n\r\n\t\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\r\n\t\t\t\tvar name = 'uv' + ( i + 1 ).toString();\r\n\r\n\t\t\t\t// the first uv buffer is just called 'uv'\r\n\t\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\t\tname = 'uv';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeo.addAttribute( name, new Float32BufferAttribute( buffers.uvs[ i ], 2 ) );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\r\n\r\n\t\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\r\n\t\t\t\tvar prevMaterialIndex = buffers.materialIndex[ 0 ];\r\n\t\t\t\tvar startIndex = 0;\r\n\r\n\t\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\r\n\r\n\t\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\r\n\r\n\t\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\r\n\r\n\t\t\t\t\t\tprevMaterialIndex = currentIndex;\r\n\t\t\t\t\t\tstartIndex = i;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\t// the loop above doesn't add the last group, do that here.\r\n\t\t\t\tif ( geo.groups.length > 0 ) {\r\n\r\n\t\t\t\t\tvar lastGroup = geo.groups[ geo.groups.length - 1 ];\r\n\t\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\r\n\r\n\t\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\r\n\r\n\t\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// case where there are multiple materials but the whole geometry is only\r\n\t\t\t\t// using one of them\r\n\t\t\t\tif ( geo.groups.length === 0 ) {\r\n\r\n\t\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.addMorphTargets( geo, geoNode, morphTarget, preTransform );\r\n\r\n\t\t\treturn geo;\r\n\r\n\t\t},\r\n\r\n\t\tparseGeoNode: function ( geoNode, skeleton ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar geoInfo = {};\r\n\r\n\t\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\r\n\t\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\r\n\r\n\t\t\tif ( geoNode.LayerElementColor ) {\r\n\r\n\t\t\t\tgeoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geoNode.LayerElementMaterial ) {\r\n\r\n\t\t\t\tgeoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geoNode.LayerElementNormal ) {\r\n\r\n\t\t\t\tgeoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geoNode.LayerElementUV ) {\r\n\r\n\t\t\t\tgeoInfo.uv = [];\r\n\r\n\t\t\t\tvar i = 0;\r\n\t\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\r\n\r\n\t\t\t\t\tgeoInfo.uv.push( this$1.parseUVs( geoNode.LayerElementUV[ i ] ) );\r\n\t\t\t\t\ti ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeoInfo.weightTable = {};\r\n\r\n\t\t\tif ( skeleton !== null ) {\r\n\r\n\t\t\t\tgeoInfo.skeleton = skeleton;\r\n\r\n\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\r\n\r\n\t\t\t\t\t// loop over the bone's vertex indices and weights\r\n\t\t\t\t\trawBone.indices.forEach( function ( index, j ) {\r\n\r\n\t\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) { geoInfo.weightTable[ index ] = []; }\r\n\r\n\t\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\r\n\r\n\t\t\t\t\t\t\tid: i,\r\n\t\t\t\t\t\t\tweight: rawBone.weights[ j ],\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geoInfo;\r\n\r\n\t\t},\r\n\r\n\t\tgenBuffers: function ( geoInfo ) {\r\n\r\n\t\t\tvar buffers = {\r\n\t\t\t\tvertex: [],\r\n\t\t\t\tnormal: [],\r\n\t\t\t\tcolors: [],\r\n\t\t\t\tuvs: [],\r\n\t\t\t\tmaterialIndex: [],\r\n\t\t\t\tvertexWeights: [],\r\n\t\t\t\tweightsIndices: [],\r\n\t\t\t};\r\n\r\n\t\t\tvar polygonIndex = 0;\r\n\t\t\tvar faceLength = 0;\r\n\t\t\tvar displayedWeightsWarning = false;\r\n\r\n\t\t\t// these will hold data for a single face\r\n\t\t\tvar facePositionIndexes = [];\r\n\t\t\tvar faceNormals = [];\r\n\t\t\tvar faceColors = [];\r\n\t\t\tvar faceUVs = [];\r\n\t\t\tvar faceWeights = [];\r\n\t\t\tvar faceWeightIndices = [];\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\r\n\r\n\t\t\t\tvar endOfFace = false;\r\n\r\n\t\t\t\t// Face index and vertex index arrays are combined in a single array\r\n\t\t\t\t// A cube with quad faces looks like this:\r\n\t\t\t\t// PolygonVertexIndex: *24 {\r\n\t\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\r\n\t\t\t\t//  }\r\n\t\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\r\n\t\t\t\t// to find index of last vertex bit shift the index: ^ - 1\r\n\t\t\t\tif ( vertexIndex < 0 ) {\r\n\r\n\t\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\r\n\t\t\t\t\tendOfFace = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar weightIndices = [];\r\n\t\t\t\tvar weights = [];\r\n\r\n\t\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\r\n\r\n\t\t\t\tif ( geoInfo.color ) {\r\n\r\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\r\n\r\n\t\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geoInfo.skeleton ) {\r\n\r\n\t\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\r\n\r\n\t\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\r\n\r\n\t\t\t\t\t\t\tweights.push( wt.weight );\r\n\t\t\t\t\t\t\tweightIndices.push( wt.id );\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( weights.length > 4 ) {\r\n\r\n\t\t\t\t\t\tif ( ! displayedWeightsWarning ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( 'FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\r\n\t\t\t\t\t\t\tdisplayedWeightsWarning = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar wIndex = [ 0, 0, 0, 0 ];\r\n\t\t\t\t\t\tvar Weight = [ 0, 0, 0, 0 ];\r\n\r\n\t\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\r\n\r\n\t\t\t\t\t\t\tvar currentWeight = weight;\r\n\t\t\t\t\t\t\tvar currentIndex = weightIndices[ weightIndex ];\r\n\r\n\t\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\r\n\t\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\r\n\r\n\t\t\t\t\t\t\t\t\tvar tmp = wIndex[ comparedWeightIndex ];\r\n\t\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\r\n\t\t\t\t\t\t\t\t\tcurrentIndex = tmp;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\tweightIndices = wIndex;\r\n\t\t\t\t\t\tweights = Weight;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// if the weight array is shorter than 4 pad with 0s\r\n\t\t\t\t\twhile ( weights.length < 4 ) {\r\n\r\n\t\t\t\t\t\tweights.push( 0 );\r\n\t\t\t\t\t\tweightIndices.push( 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\r\n\r\n\t\t\t\t\t\tfaceWeights.push( weights[ i ] );\r\n\t\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geoInfo.normal ) {\r\n\r\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\r\n\r\n\t\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\r\n\r\n\t\t\t\t\tvar materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geoInfo.uv ) {\r\n\r\n\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\r\n\r\n\t\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\r\n\r\n\t\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\tfaceUVs[ i ] = [];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\r\n\t\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceLength ++;\r\n\r\n\t\t\t\tif ( endOfFace ) {\r\n\r\n\t\t\t\t\tself.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\r\n\r\n\t\t\t\t\tpolygonIndex ++;\r\n\t\t\t\t\tfaceLength = 0;\r\n\r\n\t\t\t\t\t// reset arrays for the next face\r\n\t\t\t\t\tfacePositionIndexes = [];\r\n\t\t\t\t\tfaceNormals = [];\r\n\t\t\t\t\tfaceColors = [];\r\n\t\t\t\t\tfaceUVs = [];\r\n\t\t\t\t\tfaceWeights = [];\r\n\t\t\t\t\tfaceWeightIndices = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn buffers;\r\n\r\n\t\t},\r\n\r\n\t\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\r\n\t\tgenFace: function ( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\r\n\r\n\t\t\tfor ( var i = 2; i < faceLength; i ++ ) {\r\n\r\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\r\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\r\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\r\n\r\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\r\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\r\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\r\n\r\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\r\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\r\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\r\n\r\n\t\t\t\tif ( geoInfo.skeleton ) {\r\n\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\r\n\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\r\n\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\r\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\r\n\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\r\n\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\r\n\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\r\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geoInfo.color ) {\r\n\r\n\t\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\r\n\t\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\r\n\t\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\r\n\r\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\r\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\r\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\r\n\r\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\r\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\r\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\r\n\r\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\r\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\r\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geoInfo.normal ) {\r\n\r\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\r\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\r\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\r\n\r\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\r\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\r\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\r\n\r\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\r\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\r\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geoInfo.uv ) {\r\n\r\n\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\r\n\r\n\t\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) { buffers.uvs[ j ] = []; }\r\n\r\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\r\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\r\n\r\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\r\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\r\n\r\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\r\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\taddMorphTargets: function ( parentGeo, parentGeoNode, morphTarget, preTransform ) {\r\n\r\n\t\t\tif ( morphTarget === null ) { return; }\r\n\r\n\t\t\tparentGeo.morphAttributes.position = [];\r\n\t\t\tparentGeo.morphAttributes.normal = [];\r\n\r\n\t\t\tvar self = this;\r\n\t\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\r\n\r\n\t\t\t\tvar morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];\r\n\r\n\t\t\t\tif ( morphGeoNode !== undefined ) {\r\n\r\n\t\t\t\t\tself.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t},\r\n\r\n\t\t// a morph geometry node is similar to a standard  node, and the node is also contained\r\n\t\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\r\n\t\t// and a special attribute Index defining which vertices of the original geometry are affected\r\n\t\t// Normal and position attributes only have data for the vertices that are affected by the morph\r\n\t\tgenMorphGeometry: function ( parentGeo, parentGeoNode, morphGeoNode, preTransform ) {\r\n\r\n\t\t\tvar morphGeo = new BufferGeometry();\r\n\t\t\tif ( morphGeoNode.attrName ) { morphGeo.name = morphGeoNode.attrName; }\r\n\r\n\t\t\tvar vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\r\n\r\n\t\t\t// make a copy of the parent's vertex positions\r\n\t\t\tvar vertexPositions = ( parentGeoNode.Vertices !== undefined ) ? parentGeoNode.Vertices.a.slice() : [];\r\n\r\n\t\t\tvar morphPositions = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\r\n\t\t\tvar indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\r\n\r\n\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\r\n\r\n\t\t\t\tvar morphIndex = indices[ i ] * 3;\r\n\r\n\t\t\t\t// FBX format uses blend shapes rather than morph targets. This can be converted\r\n\t\t\t\t// by additively combining the blend shape positions with the original geometry's positions\r\n\t\t\t\tvertexPositions[ morphIndex ] += morphPositions[ i * 3 ];\r\n\t\t\t\tvertexPositions[ morphIndex + 1 ] += morphPositions[ i * 3 + 1 ];\r\n\t\t\t\tvertexPositions[ morphIndex + 2 ] += morphPositions[ i * 3 + 2 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: add morph normal support\r\n\t\t\tvar morphGeoInfo = {\r\n\t\t\t\tvertexIndices: vertexIndices,\r\n\t\t\t\tvertexPositions: vertexPositions,\r\n\t\t\t};\r\n\r\n\t\t\tvar morphBuffers = this.genBuffers( morphGeoInfo );\r\n\r\n\t\t\tvar positionAttribute = new Float32BufferAttribute( morphBuffers.vertex, 3 );\r\n\t\t\tpositionAttribute.name = morphGeoNode.attrName;\r\n\r\n\t\t\tpreTransform.applyToBufferAttribute( positionAttribute );\r\n\r\n\t\t\tparentGeo.morphAttributes.position.push( positionAttribute );\r\n\r\n\t\t},\r\n\r\n\t\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\r\n\t\tparseNormals: function ( NormalNode ) {\r\n\r\n\t\t\tvar mappingType = NormalNode.MappingInformationType;\r\n\t\t\tvar referenceType = NormalNode.ReferenceInformationType;\r\n\t\t\tvar buffer = NormalNode.Normals.a;\r\n\t\t\tvar indexBuffer = [];\r\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\r\n\r\n\t\t\t\tif ( 'NormalIndex' in NormalNode ) {\r\n\r\n\t\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\r\n\r\n\t\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\r\n\r\n\t\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tdataSize: 3,\r\n\t\t\t\tbuffer: buffer,\r\n\t\t\t\tindices: indexBuffer,\r\n\t\t\t\tmappingType: mappingType,\r\n\t\t\t\treferenceType: referenceType\r\n\t\t\t};\r\n\r\n\t\t},\r\n\r\n\t\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\r\n\t\tparseUVs: function ( UVNode ) {\r\n\r\n\t\t\tvar mappingType = UVNode.MappingInformationType;\r\n\t\t\tvar referenceType = UVNode.ReferenceInformationType;\r\n\t\t\tvar buffer = UVNode.UV.a;\r\n\t\t\tvar indexBuffer = [];\r\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\r\n\r\n\t\t\t\tindexBuffer = UVNode.UVIndex.a;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tdataSize: 2,\r\n\t\t\t\tbuffer: buffer,\r\n\t\t\t\tindices: indexBuffer,\r\n\t\t\t\tmappingType: mappingType,\r\n\t\t\t\treferenceType: referenceType\r\n\t\t\t};\r\n\r\n\t\t},\r\n\r\n\t\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\r\n\t\tparseVertexColors: function ( ColorNode ) {\r\n\r\n\t\t\tvar mappingType = ColorNode.MappingInformationType;\r\n\t\t\tvar referenceType = ColorNode.ReferenceInformationType;\r\n\t\t\tvar buffer = ColorNode.Colors.a;\r\n\t\t\tvar indexBuffer = [];\r\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\r\n\r\n\t\t\t\tindexBuffer = ColorNode.ColorIndex.a;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tdataSize: 4,\r\n\t\t\t\tbuffer: buffer,\r\n\t\t\t\tindices: indexBuffer,\r\n\t\t\t\tmappingType: mappingType,\r\n\t\t\t\treferenceType: referenceType\r\n\t\t\t};\r\n\r\n\t\t},\r\n\r\n\t\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\r\n\t\tparseMaterialIndices: function ( MaterialNode ) {\r\n\r\n\t\t\tvar mappingType = MaterialNode.MappingInformationType;\r\n\t\t\tvar referenceType = MaterialNode.ReferenceInformationType;\r\n\r\n\t\t\tif ( mappingType === 'NoMappingInformation' ) {\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tdataSize: 1,\r\n\t\t\t\t\tbuffer: [ 0 ],\r\n\t\t\t\t\tindices: [ 0 ],\r\n\t\t\t\t\tmappingType: 'AllSame',\r\n\t\t\t\t\treferenceType: referenceType\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\r\n\r\n\t\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\r\n\t\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\r\n\t\t\t// for conforming with the other functions we've written for other data.\r\n\t\t\tvar materialIndices = [];\r\n\r\n\t\t\tfor ( var i = 0; i < materialIndexBuffer.length; ++ i ) {\r\n\r\n\t\t\t\tmaterialIndices.push( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tdataSize: 1,\r\n\t\t\t\tbuffer: materialIndexBuffer,\r\n\t\t\t\tindices: materialIndices,\r\n\t\t\t\tmappingType: mappingType,\r\n\t\t\t\treferenceType: referenceType\r\n\t\t\t};\r\n\r\n\t\t},\r\n\r\n\t\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\r\n\t\tparseNurbsGeometry: function ( geoNode ) {\r\n\r\n\t\t\tif ( NURBSCurve === undefined ) {\r\n\r\n\t\t\t\tconsole.error( 'FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );\r\n\t\t\t\treturn new BufferGeometry();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar order = parseInt( geoNode.Order );\r\n\r\n\t\t\tif ( isNaN( order ) ) {\r\n\r\n\t\t\t\tconsole.error( 'FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\r\n\t\t\t\treturn new BufferGeometry();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar degree = order - 1;\r\n\r\n\t\t\tvar knots = geoNode.KnotVector.a;\r\n\t\t\tvar controlPoints = [];\r\n\t\t\tvar pointsValues = geoNode.Points.a;\r\n\r\n\t\t\tfor ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {\r\n\r\n\t\t\t\tcontrolPoints.push( new Vector4().fromArray( pointsValues, i ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar startKnot, endKnot;\r\n\r\n\t\t\tif ( geoNode.Form === 'Closed' ) {\r\n\r\n\t\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\r\n\r\n\t\t\t} else if ( geoNode.Form === 'Periodic' ) {\r\n\r\n\t\t\t\tstartKnot = degree;\r\n\t\t\t\tendKnot = knots.length - 1 - startKnot;\r\n\r\n\t\t\t\tfor ( var i = 0; i < degree; ++ i ) {\r\n\r\n\t\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\r\n\t\t\tvar vertices = curve.getPoints( controlPoints.length * 7 );\r\n\r\n\t\t\tvar positions = new Float32Array( vertices.length * 3 );\r\n\r\n\t\t\tvertices.forEach( function ( vertex, i ) {\r\n\r\n\t\t\t\tvertex.toArray( positions, i * 3 );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t},\r\n\r\n\t};\r\n\r\n\t// parse animation data from FBXTree\r\n\tfunction AnimationParser() {}\r\n\r\n\tAnimationParser.prototype = {\r\n\r\n\t\tconstructor: AnimationParser,\r\n\r\n\t\t// take raw animation clips and turn them into three.js animation clips\r\n\t\tparse: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar animationClips = [];\r\n\r\n\t\t\tvar rawClips = this.parseClips();\r\n\r\n\t\t\tif ( rawClips === undefined ) { return; }\r\n\r\n\t\t\tfor ( var key in rawClips ) {\r\n\r\n\t\t\t\tvar rawClip = rawClips[ key ];\r\n\r\n\t\t\t\tvar clip = this$1.addClip( rawClip );\r\n\r\n\t\t\t\tanimationClips.push( clip );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn animationClips;\r\n\r\n\t\t},\r\n\r\n\t\tparseClips: function () {\r\n\r\n\t\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\r\n\t\t\t// if this is undefined we can safely assume there are no animations\r\n\t\t\tif ( fbxTree.Objects.AnimationCurve === undefined ) { return undefined; }\r\n\r\n\t\t\tvar curveNodesMap = this.parseAnimationCurveNodes();\r\n\r\n\t\t\tthis.parseAnimationCurves( curveNodesMap );\r\n\r\n\t\t\tvar layersMap = this.parseAnimationLayers( curveNodesMap );\r\n\t\t\tvar rawClips = this.parseAnimStacks( layersMap );\r\n\r\n\t\t\treturn rawClips;\r\n\r\n\t\t},\r\n\r\n\t\t// parse nodes in FBXTree.Objects.AnimationCurveNode\r\n\t\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\r\n\t\t// and is referenced by an AnimationLayer\r\n\t\tparseAnimationCurveNodes: function () {\r\n\r\n\t\t\tvar rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\r\n\r\n\t\t\tvar curveNodesMap = new Map();\r\n\r\n\t\t\tfor ( var nodeID in rawCurveNodes ) {\r\n\r\n\t\t\t\tvar rawCurveNode = rawCurveNodes[ nodeID ];\r\n\r\n\t\t\t\tif ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {\r\n\r\n\t\t\t\t\tvar curveNode = {\r\n\r\n\t\t\t\t\t\tid: rawCurveNode.id,\r\n\t\t\t\t\t\tattr: rawCurveNode.attrName,\r\n\t\t\t\t\t\tcurves: {},\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn curveNodesMap;\r\n\r\n\t\t},\r\n\r\n\t\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\r\n\t\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\r\n\t\t// axis ( e.g. times and values of x rotation)\r\n\t\tparseAnimationCurves: function ( curveNodesMap ) {\r\n\r\n\t\t\tvar rawCurves = fbxTree.Objects.AnimationCurve;\r\n\r\n\t\t\t// TODO: Many values are identical up to roundoff error, but won't be optimised\r\n\t\t\t// e.g. position times: [0, 0.4, 0. 8]\r\n\t\t\t// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\r\n\t\t\t// clearly, this should be optimised to\r\n\t\t\t// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\r\n\t\t\t// this shows up in nearly every FBX file, and generally time array is length > 100\r\n\r\n\t\t\tfor ( var nodeID in rawCurves ) {\r\n\r\n\t\t\t\tvar animationCurve = {\r\n\r\n\t\t\t\t\tid: rawCurves[ nodeID ].id,\r\n\t\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\r\n\t\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tvar relationships = connections.get( animationCurve.id );\r\n\r\n\t\t\t\tif ( relationships !== undefined ) {\r\n\r\n\t\t\t\t\tvar animationCurveID = relationships.parents[ 0 ].ID;\r\n\t\t\t\t\tvar animationCurveRelationship = relationships.parents[ 0 ].relationship;\r\n\r\n\t\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\r\n\r\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\r\n\r\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\r\n\r\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\r\n\r\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\r\n\r\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\r\n\r\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /d|DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {\r\n\r\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\r\n\t\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\r\n\t\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\r\n\t\tparseAnimationLayers: function ( curveNodesMap ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar rawLayers = fbxTree.Objects.AnimationLayer;\r\n\r\n\t\t\tvar layersMap = new Map();\r\n\r\n\t\t\tfor ( var nodeID in rawLayers ) {\r\n\r\n\t\t\t\tvar layerCurveNodes = [];\r\n\r\n\t\t\t\tvar connection = connections.get( parseInt( nodeID ) );\r\n\r\n\t\t\t\tif ( connection !== undefined ) {\r\n\r\n\t\t\t\t\t// all the animationCurveNodes used in the layer\r\n\t\t\t\t\tvar children = connection.children;\r\n\r\n\t\t\t\t\tvar self = this$1;\r\n\t\t\t\t\tchildren.forEach( function ( child, i ) {\r\n\r\n\t\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\r\n\r\n\t\t\t\t\t\t\tvar curveNode = curveNodesMap.get( child.ID );\r\n\r\n\t\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\r\n\t\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar modelID;\r\n\r\n\t\t\t\t\t\t\t\t\tconnections.get( child.ID ).parents.forEach( function ( parent ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( parent.relationship !== undefined ) { modelID = parent.ID; }\r\n\r\n\t\t\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID.toString() ];\r\n\r\n\t\t\t\t\t\t\t\t\tvar node = {\r\n\r\n\t\t\t\t\t\t\t\t\t\tmodelName: PropertyBinding.sanitizeNodeName( rawModel.attrName ),\r\n\t\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\r\n\t\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\r\n\t\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\r\n\t\t\t\t\t\t\t\t\t\ttransform: self.getModelAnimTransform( rawModel ),\r\n\r\n\t\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\r\n\t\t\t\t\t\t\t\t\t// animation value as well\r\n\t\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) { node.preRotations = rawModel.PreRotation.value; }\r\n\t\t\t\t\t\t\t\t\tif ( 'PostRotation' in rawModel ) { node.postRotations = rawModel.PostRotation.value; }\r\n\r\n\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\r\n\r\n\t\t\t\t\t\t\t} else if ( curveNode.curves.morph !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar deformerID;\r\n\r\n\t\t\t\t\t\t\t\t\tconnections.get( child.ID ).parents.forEach( function ( parent ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( parent.relationship !== undefined ) { deformerID = parent.ID; }\r\n\r\n\t\t\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t\t\t\tvar morpherID = connections.get( deformerID ).parents[ 0 ].ID;\r\n\t\t\t\t\t\t\t\t\tvar geoID = connections.get( morpherID ).parents[ 0 ].ID;\r\n\r\n\t\t\t\t\t\t\t\t\t// assuming geometry is not used in more than one model\r\n\t\t\t\t\t\t\t\t\tvar modelID = connections.get( geoID ).parents[ 0 ].ID;\r\n\r\n\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID ];\r\n\r\n\t\t\t\t\t\t\t\t\tvar node = {\r\n\r\n\t\t\t\t\t\t\t\t\t\tmodelName: PropertyBinding.sanitizeNodeName( rawModel.attrName ),\r\n\t\t\t\t\t\t\t\t\t\tmorphName: fbxTree.Objects.Deformer[ deformerID ].attrName,\r\n\r\n\t\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn layersMap;\r\n\r\n\t\t},\r\n\r\n\t\tgetModelAnimTransform: function ( modelNode ) {\r\n\r\n\t\t\tvar transformData = {};\r\n\r\n\t\t\tif ( 'RotationOrder' in modelNode ) { transformData.eulerOrder = parseInt( modelNode.RotationOrder.value ); }\r\n\r\n\t\t\tif ( 'Lcl_Translation' in modelNode ) { transformData.translation = modelNode.Lcl_Translation.value; }\r\n\t\t\tif ( 'RotationOffset' in modelNode ) { transformData.rotationOffset = modelNode.RotationOffset.value; }\r\n\r\n\t\t\tif ( 'Lcl_Rotation' in modelNode ) { transformData.rotation = modelNode.Lcl_Rotation.value; }\r\n\t\t\tif ( 'PreRotation' in modelNode ) { transformData.preRotation = modelNode.PreRotation.value; }\r\n\r\n\t\t\tif ( 'PostRotation' in modelNode ) { transformData.postRotation = modelNode.PostRotation.value; }\r\n\r\n\t\t\tif ( 'Lcl_Scaling' in modelNode ) { transformData.scale = modelNode.Lcl_Scaling.value; }\r\n\r\n\t\t\treturn generateTransform( transformData );\r\n\r\n\t\t},\r\n\r\n\t\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\r\n\t\t// hierarchy. Each Stack node will be used to create a AnimationClip\r\n\t\tparseAnimStacks: function ( layersMap ) {\r\n\r\n\t\t\tvar rawStacks = fbxTree.Objects.AnimationStack;\r\n\r\n\t\t\t// connect the stacks (clips) up to the layers\r\n\t\t\tvar rawClips = {};\r\n\r\n\t\t\tfor ( var nodeID in rawStacks ) {\r\n\r\n\t\t\t\tvar children = connections.get( parseInt( nodeID ) ).children;\r\n\r\n\t\t\t\tif ( children.length > 1 ) {\r\n\r\n\t\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\r\n\t\t\t\t\t// where there are multiple layers per stack, we'll display a warning\r\n\t\t\t\t\tconsole.warn( 'FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar layer = layersMap.get( children[ 0 ].ID );\r\n\r\n\t\t\t\trawClips[ nodeID ] = {\r\n\r\n\t\t\t\t\tname: rawStacks[ nodeID ].attrName,\r\n\t\t\t\t\tlayer: layer,\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn rawClips;\r\n\r\n\t\t},\r\n\r\n\t\taddClip: function ( rawClip ) {\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\tvar self = this;\r\n\t\t\trawClip.layer.forEach( function ( rawTracks ) {\r\n\r\n\t\t\t\ttracks = tracks.concat( self.generateTracks( rawTracks ) );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn new AnimationClip( rawClip.name, - 1, tracks );\r\n\r\n\t\t},\r\n\r\n\t\tgenerateTracks: function ( rawTracks ) {\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\tvar initialPosition = new Vector3();\r\n\t\t\tvar initialRotation = new Quaternion();\r\n\t\t\tvar initialScale = new Vector3();\r\n\r\n\t\t\tif ( rawTracks.transform ) { rawTracks.transform.decompose( initialPosition, initialRotation, initialScale ); }\r\n\r\n\t\t\tinitialPosition = initialPosition.toArray();\r\n\t\t\tinitialRotation = new Euler().setFromQuaternion( initialRotation ).toArray(); // todo: euler order\r\n\t\t\tinitialScale = initialScale.toArray();\r\n\r\n\t\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\r\n\r\n\t\t\t\tvar positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );\r\n\t\t\t\tif ( positionTrack !== undefined ) { tracks.push( positionTrack ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\r\n\r\n\t\t\t\tvar rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotations, rawTracks.postRotations );\r\n\t\t\t\tif ( rotationTrack !== undefined ) { tracks.push( rotationTrack ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\r\n\r\n\t\t\t\tvar scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );\r\n\t\t\t\tif ( scaleTrack !== undefined ) { tracks.push( scaleTrack ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( rawTracks.DeformPercent !== undefined ) {\r\n\r\n\t\t\t\tvar morphTrack = this.generateMorphTrack( rawTracks );\r\n\t\t\t\tif ( morphTrack !== undefined ) { tracks.push( morphTrack ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn tracks;\r\n\r\n\t\t},\r\n\r\n\t\tgenerateVectorTrack: function ( modelName, curves, initialValue, type ) {\r\n\r\n\t\t\tvar times = this.getTimesForAllAxes( curves );\r\n\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\r\n\r\n\t\t\treturn new VectorKeyframeTrack$1( modelName + '.' + type, times, values );\r\n\r\n\t\t},\r\n\r\n\t\tgenerateRotationTrack: function ( modelName, curves, initialValue, preRotations, postRotations ) {\r\n\r\n\t\t\tif ( curves.x !== undefined ) {\r\n\r\n\t\t\t\tthis.interpolateRotations( curves.x );\r\n\t\t\t\tcurves.x.values = curves.x.values.map( _Math.degToRad );\r\n\r\n\t\t\t}\r\n\t\t\tif ( curves.y !== undefined ) {\r\n\r\n\t\t\t\tthis.interpolateRotations( curves.y );\r\n\t\t\t\tcurves.y.values = curves.y.values.map( _Math.degToRad );\r\n\r\n\t\t\t}\r\n\t\t\tif ( curves.z !== undefined ) {\r\n\r\n\t\t\t\tthis.interpolateRotations( curves.z );\r\n\t\t\t\tcurves.z.values = curves.z.values.map( _Math.degToRad );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar times = this.getTimesForAllAxes( curves );\r\n\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\r\n\r\n\t\t\tif ( preRotations !== undefined ) {\r\n\r\n\t\t\t\tpreRotations = preRotations.map( _Math.degToRad );\r\n\t\t\t\tpreRotations.push( 'ZYX' );\r\n\r\n\t\t\t\tpreRotations = new Euler().fromArray( preRotations );\r\n\t\t\t\tpreRotations = new Quaternion().setFromEuler( preRotations );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( postRotations !== undefined ) {\r\n\r\n\t\t\t\tpostRotations = postRotations.map( _Math.degToRad );\r\n\t\t\t\tpostRotations.push( 'ZYX' );\r\n\r\n\t\t\t\tpostRotations = new Euler().fromArray( postRotations );\r\n\t\t\t\tpostRotations = new Quaternion().setFromEuler( postRotations ).inverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar quaternion = new Quaternion();\r\n\t\t\tvar euler = new Euler();\r\n\r\n\t\t\tvar quaternionValues = [];\r\n\r\n\t\t\tfor ( var i = 0; i < values.length; i += 3 ) {\r\n\r\n\t\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], 'ZYX' );\r\n\r\n\t\t\t\tquaternion.setFromEuler( euler );\r\n\r\n\t\t\t\tif ( preRotations !== undefined ) { quaternion.premultiply( preRotations ); }\r\n\t\t\t\tif ( postRotations !== undefined ) { quaternion.multiply( postRotations ); }\r\n\r\n\t\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new QuaternionKeyframeTrack$1( modelName + '.quaternion', times, quaternionValues );\r\n\r\n\t\t},\r\n\r\n\t\tgenerateMorphTrack: function ( rawTracks ) {\r\n\r\n\t\t\tvar curves = rawTracks.DeformPercent.curves.morph;\r\n\t\t\tvar values = curves.values.map( function ( val ) {\r\n\r\n\t\t\t\treturn val / 100;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tvar morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];\r\n\r\n\t\t\treturn new NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );\r\n\r\n\t\t},\r\n\r\n\t\t// For all animated objects, times are defined separately for each axis\r\n\t\t// Here we'll combine the times into one sorted array without duplicates\r\n\t\tgetTimesForAllAxes: function ( curves ) {\r\n\r\n\t\t\tvar times = [];\r\n\r\n\t\t\t// first join together the times for each axis, if defined\r\n\t\t\tif ( curves.x !== undefined ) { times = times.concat( curves.x.times ); }\r\n\t\t\tif ( curves.y !== undefined ) { times = times.concat( curves.y.times ); }\r\n\t\t\tif ( curves.z !== undefined ) { times = times.concat( curves.z.times ); }\r\n\r\n\t\t\t// then sort them and remove duplicates\r\n\t\t\ttimes = times.sort( function ( a, b ) {\r\n\r\n\t\t\t\treturn a - b;\r\n\r\n\t\t\t} ).filter( function ( elem, index, array ) {\r\n\r\n\t\t\t\treturn array.indexOf( elem ) == index;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn times;\r\n\r\n\t\t},\r\n\r\n\t\tgetKeyframeTrackValues: function ( times, curves, initialValue ) {\r\n\r\n\t\t\tvar prevValue = initialValue;\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tvar xIndex = - 1;\r\n\t\t\tvar yIndex = - 1;\r\n\t\t\tvar zIndex = - 1;\r\n\r\n\t\t\ttimes.forEach( function ( time ) {\r\n\r\n\t\t\t\tif ( curves.x ) { xIndex = curves.x.times.indexOf( time ); }\r\n\t\t\t\tif ( curves.y ) { yIndex = curves.y.times.indexOf( time ); }\r\n\t\t\t\tif ( curves.z ) { zIndex = curves.z.times.indexOf( time ); }\r\n\r\n\t\t\t\t// if there is an x value defined for this frame, use that\r\n\t\t\t\tif ( xIndex !== - 1 ) {\r\n\r\n\t\t\t\t\tvar xValue = curves.x.values[ xIndex ];\r\n\t\t\t\t\tvalues.push( xValue );\r\n\t\t\t\t\tprevValue[ 0 ] = xValue;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// otherwise use the x value from the previous frame\r\n\t\t\t\t\tvalues.push( prevValue[ 0 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( yIndex !== - 1 ) {\r\n\r\n\t\t\t\t\tvar yValue = curves.y.values[ yIndex ];\r\n\t\t\t\t\tvalues.push( yValue );\r\n\t\t\t\t\tprevValue[ 1 ] = yValue;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvalues.push( prevValue[ 1 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( zIndex !== - 1 ) {\r\n\r\n\t\t\t\t\tvar zValue = curves.z.values[ zIndex ];\r\n\t\t\t\t\tvalues.push( zValue );\r\n\t\t\t\t\tprevValue[ 2 ] = zValue;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvalues.push( prevValue[ 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn values;\r\n\r\n\t\t},\r\n\r\n\t\t// Rotations are defined as Euler angles which can have values  of any size\r\n\t\t// These will be converted to quaternions which don't support values greater than\r\n\t\t// PI, so we'll interpolate large rotations\r\n\t\tinterpolateRotations: function ( curve ) {\r\n\r\n\t\t\tfor ( var i = 1; i < curve.values.length; i ++ ) {\r\n\r\n\t\t\t\tvar initialValue = curve.values[ i - 1 ];\r\n\t\t\t\tvar valuesSpan = curve.values[ i ] - initialValue;\r\n\r\n\t\t\t\tvar absoluteSpan = Math.abs( valuesSpan );\r\n\r\n\t\t\t\tif ( absoluteSpan >= 180 ) {\r\n\r\n\t\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\r\n\r\n\t\t\t\t\tvar step = valuesSpan / numSubIntervals;\r\n\t\t\t\t\tvar nextValue = initialValue + step;\r\n\r\n\t\t\t\t\tvar initialTime = curve.times[ i - 1 ];\r\n\t\t\t\t\tvar timeSpan = curve.times[ i ] - initialTime;\r\n\t\t\t\t\tvar interval = timeSpan / numSubIntervals;\r\n\t\t\t\t\tvar nextTime = initialTime + interval;\r\n\r\n\t\t\t\t\tvar interpolatedTimes = [];\r\n\t\t\t\t\tvar interpolatedValues = [];\r\n\r\n\t\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\r\n\r\n\t\t\t\t\t\tinterpolatedTimes.push( nextTime );\r\n\t\t\t\t\t\tnextTime += interval;\r\n\r\n\t\t\t\t\t\tinterpolatedValues.push( nextValue );\r\n\t\t\t\t\t\tnextValue += step;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\r\n\t\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t};\r\n\r\n\t// parse an FBX file in ASCII format\r\n\tfunction TextParser() {}\r\n\r\n\tTextParser.prototype = {\r\n\r\n\t\tconstructor: TextParser,\r\n\r\n\t\tgetPrevNode: function () {\r\n\r\n\t\t\treturn this.nodeStack[ this.currentIndent - 2 ];\r\n\r\n\t\t},\r\n\r\n\t\tgetCurrentNode: function () {\r\n\r\n\t\t\treturn this.nodeStack[ this.currentIndent - 1 ];\r\n\r\n\t\t},\r\n\r\n\t\tgetCurrentProp: function () {\r\n\r\n\t\t\treturn this.currentProp;\r\n\r\n\t\t},\r\n\r\n\t\tpushStack: function ( node ) {\r\n\r\n\t\t\tthis.nodeStack.push( node );\r\n\t\t\tthis.currentIndent += 1;\r\n\r\n\t\t},\r\n\r\n\t\tpopStack: function () {\r\n\r\n\t\t\tthis.nodeStack.pop();\r\n\t\t\tthis.currentIndent -= 1;\r\n\r\n\t\t},\r\n\r\n\t\tsetCurrentProp: function ( val, name ) {\r\n\r\n\t\t\tthis.currentProp = val;\r\n\t\t\tthis.currentPropName = name;\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( text ) {\r\n\r\n\t\t\tthis.currentIndent = 0;\r\n\t\t\tconsole.log(\"FBXTree: \", FBXTree);\r\n\t\t\tthis.allNodes = new FBXTree();\r\n\t\t\tthis.nodeStack = [];\r\n\t\t\tthis.currentProp = [];\r\n\t\t\tthis.currentPropName = '';\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tvar split = text.split( /[\\r\\n]+/ );\r\n\r\n\t\t\tsplit.forEach( function ( line, i ) {\r\n\r\n\t\t\t\tvar matchComment = line.match( /^[\\s\\t]*;/ );\r\n\t\t\t\tvar matchEmpty = line.match( /^[\\s\\t]*$/ );\r\n\r\n\t\t\t\tif ( matchComment || matchEmpty ) { return; }\r\n\r\n\t\t\t\tvar matchBeginning = line.match( '^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '' );\r\n\t\t\t\tvar matchProperty = line.match( '^\\\\t{' + ( self.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\r\n\t\t\t\tvar matchEnd = line.match( '^\\\\t{' + ( self.currentIndent - 1 ) + '}}' );\r\n\r\n\t\t\t\tif ( matchBeginning ) {\r\n\r\n\t\t\t\t\tself.parseNodeBegin( line, matchBeginning );\r\n\r\n\t\t\t\t} else if ( matchProperty ) {\r\n\r\n\t\t\t\t\tself.parseNodeProperty( line, matchProperty, split[ ++ i ] );\r\n\r\n\t\t\t\t} else if ( matchEnd ) {\r\n\r\n\t\t\t\t\tself.popStack();\r\n\r\n\t\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\r\n\r\n\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\r\n\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\r\n\t\t\t\t\tself.parseNodePropertyContinued( line );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this.allNodes;\r\n\r\n\t\t},\r\n\r\n\t\tparseNodeBegin: function ( line, property ) {\r\n\r\n\t\t\tvar nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\r\n\r\n\t\t\tvar nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\r\n\r\n\t\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tvar node = { name: nodeName };\r\n\t\t\tvar attrs = this.parseNodeAttr( nodeAttrs );\r\n\r\n\t\t\tvar currentNode = this.getCurrentNode();\r\n\r\n\t\t\t// a top node\r\n\t\t\tif ( this.currentIndent === 0 ) {\r\n\r\n\t\t\t\tthis.allNodes.add( nodeName, node );\r\n\r\n\t\t\t} else { // a subnode\r\n\r\n\t\t\t\t// if the subnode already exists, append it\r\n\t\t\t\tif ( nodeName in currentNode ) {\r\n\r\n\t\t\t\t// special case Pose needs PoseNodes as an array\r\n\t\t\t\t\tif ( nodeName === 'PoseNode' ) {\r\n\r\n\t\t\t\t\t\tcurrentNode.PoseNode.push( node );\r\n\r\n\t\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\r\n\r\n\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\r\n\t\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attrs.id !== '' ) { currentNode[ nodeName ][ attrs.id ] = node; }\r\n\r\n\t\t\t\t} else if ( typeof attrs.id === 'number' ) {\r\n\r\n\t\t\t\t\tcurrentNode[ nodeName ] = {};\r\n\t\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\r\n\r\n\t\t\t\t} else if ( nodeName !== 'Properties70' ) {\r\n\r\n\t\t\t\t\tif ( nodeName === 'PoseNode' )\t{ currentNode[ nodeName ] = [ node ]; }\r\n\t\t\t\t\telse { currentNode[ nodeName ] = node; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( typeof attrs.id === 'number' ) { node.id = attrs.id; }\r\n\t\t\tif ( attrs.name !== '' ) { node.attrName = attrs.name; }\r\n\t\t\tif ( attrs.type !== '' ) { node.attrType = attrs.type; }\r\n\r\n\t\t\tthis.pushStack( node );\r\n\r\n\t\t},\r\n\r\n\t\tparseNodeAttr: function ( attrs ) {\r\n\r\n\t\t\tvar id = attrs[ 0 ];\r\n\r\n\t\t\tif ( attrs[ 0 ] !== '' ) {\r\n\r\n\t\t\t\tid = parseInt( attrs[ 0 ] );\r\n\r\n\t\t\t\tif ( isNaN( id ) ) {\r\n\r\n\t\t\t\t\tid = attrs[ 0 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar name = '', type = '';\r\n\r\n\t\t\tif ( attrs.length > 1 ) {\r\n\r\n\t\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\r\n\t\t\t\ttype = attrs[ 2 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { id: id, name: name, type: type };\r\n\r\n\t\t},\r\n\r\n\t\tparseNodeProperty: function ( line, property, contentLine ) {\r\n\r\n\t\t\tvar propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\r\n\t\t\tvar propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\r\n\r\n\t\t\t// for special case: base64 image data follows \"Content: ,\" line\r\n\t\t\t//\tContent: ,\r\n\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\r\n\t\t\tif ( propName === 'Content' && propValue === ',' ) {\r\n\r\n\t\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar currentNode = this.getCurrentNode();\r\n\t\t\tvar parentName = currentNode.name;\r\n\r\n\t\t\tif ( parentName === 'Properties70' ) {\r\n\r\n\t\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Connections\r\n\t\t\tif ( propName === 'C' ) {\r\n\r\n\t\t\t\tvar connProps = propValue.split( ',' ).slice( 1 );\r\n\t\t\t\tvar from = parseInt( connProps[ 0 ] );\r\n\t\t\t\tvar to = parseInt( connProps[ 1 ] );\r\n\r\n\t\t\t\tvar rest = propValue.split( ',' ).slice( 3 );\r\n\r\n\t\t\t\trest = rest.map( function ( elem ) {\r\n\r\n\t\t\t\t\treturn elem.trim().replace( /^\"/, '' );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tpropName = 'connections';\r\n\t\t\t\tpropValue = [ from, to ];\r\n\t\t\t\tappend( propValue, rest );\r\n\r\n\t\t\t\tif ( currentNode[ propName ] === undefined ) {\r\n\r\n\t\t\t\t\tcurrentNode[ propName ] = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Node\r\n\t\t\tif ( propName === 'Node' ) { currentNode.id = propValue; }\r\n\r\n\t\t\t// connections\r\n\t\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\r\n\r\n\t\t\t\tcurrentNode[ propName ].push( propValue );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( propName !== 'a' ) { currentNode[ propName ] = propValue; }\r\n\t\t\t\telse { currentNode.a = propValue; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.setCurrentProp( currentNode, propName );\r\n\r\n\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\r\n\t\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\r\n\r\n\t\t\t\tcurrentNode.a = parseNumberArray( propValue );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tparseNodePropertyContinued: function ( line ) {\r\n\r\n\t\t\tvar currentNode = this.getCurrentNode();\r\n\r\n\t\t\tcurrentNode.a += line;\r\n\r\n\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\r\n\t\t\t// so convert the string to an array\r\n\t\t\tif ( line.slice( - 1 ) !== ',' ) {\r\n\r\n\t\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// parse \"Property70\"\r\n\t\tparseNodeSpecialProperty: function ( line, propName, propValue ) {\r\n\r\n\t\t\t// split this\r\n\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\r\n\t\t\t// into array like below\r\n\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\r\n\t\t\tvar props = propValue.split( '\",' ).map( function ( prop ) {\r\n\r\n\t\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tvar innerPropName = props[ 0 ];\r\n\t\t\tvar innerPropType1 = props[ 1 ];\r\n\t\t\tvar innerPropType2 = props[ 2 ];\r\n\t\t\tvar innerPropFlag = props[ 3 ];\r\n\t\t\tvar innerPropValue = props[ 4 ];\r\n\r\n\t\t\t// cast values where needed, otherwise leave as strings\r\n\t\t\tswitch ( innerPropType1 ) {\r\n\r\n\t\t\t\tcase 'int':\r\n\t\t\t\tcase 'enum':\r\n\t\t\t\tcase 'bool':\r\n\t\t\t\tcase 'ULongLong':\r\n\t\t\t\tcase 'double':\r\n\t\t\t\tcase 'Number':\r\n\t\t\t\tcase 'FieldOfView':\r\n\t\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Color':\r\n\t\t\t\tcase 'ColorRGB':\r\n\t\t\t\tcase 'Vector3D':\r\n\t\t\t\tcase 'Lcl_Translation':\r\n\t\t\t\tcase 'Lcl_Rotation':\r\n\t\t\t\tcase 'Lcl_Scaling':\r\n\t\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// CAUTION: these props must append to parent's parent\r\n\t\t\tthis.getPrevNode()[ innerPropName ] = {\r\n\r\n\t\t\t\t'type': innerPropType1,\r\n\t\t\t\t'type2': innerPropType2,\r\n\t\t\t\t'flag': innerPropFlag,\r\n\t\t\t\t'value': innerPropValue\r\n\r\n\t\t\t};\r\n\r\n\t\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\r\n\r\n\t\t},\r\n\r\n\t};\r\n\r\n\t// Parse an FBX file in Binary format\r\n\tfunction BinaryParser() {}\r\n\r\n\tBinaryParser.prototype = {\r\n\r\n\t\tconstructor: BinaryParser,\r\n\r\n\t\tparse: function ( buffer ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar reader = new BinaryReader( buffer );\r\n\t\t\treader.skip( 23 ); // skip magic 23 bytes\r\n\r\n\t\t\tvar version = reader.getUint32();\r\n\r\n\t\t\tconsole.log( 'FBXLoader: FBX binary version: ' + version );\r\n\r\n\t\t\tvar allNodes = new FBXTree();\r\n\r\n\t\t\twhile ( ! this.endOfContent( reader ) ) {\r\n\r\n\t\t\t\tvar node = this$1.parseNode( reader, version );\r\n\t\t\t\tif ( node !== null ) { allNodes.add( node.name, node ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn allNodes;\r\n\r\n\t\t},\r\n\r\n\t\t// Check if reader has reached the end of content.\r\n\t\tendOfContent: function ( reader ) {\r\n\r\n\t\t\t// footer size: 160bytes + 16-byte alignment padding\r\n\t\t\t// - 16bytes: magic\r\n\t\t\t// - padding til 16-byte alignment (at least 1byte?)\r\n\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\r\n\t\t\t// - 4bytes: magic\r\n\t\t\t// - 4bytes: version\r\n\t\t\t// - 120bytes: zero\r\n\t\t\t// - 16bytes: magic\r\n\t\t\tif ( reader.size() % 16 === 0 ) {\r\n\r\n\t\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// recursively parse nodes until the end of the file is reached\r\n\t\tparseNode: function ( reader, version ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar node = {};\r\n\r\n\t\t\t// The first three data sizes depends on version.\r\n\t\t\tvar endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\r\n\t\t\tvar numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\r\n\r\n\t\t\t// note: do not remove this even if you get a linter warning as it moves the buffer forward\r\n\t\t\tvar propertyListLen = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\r\n\r\n\t\t\tvar nameLen = reader.getUint8();\r\n\t\t\tvar name = reader.getString( nameLen );\r\n\r\n\t\t\t// Regards this node as NULL-record if endOffset is zero\r\n\t\t\tif ( endOffset === 0 ) { return null; }\r\n\r\n\t\t\tvar propertyList = [];\r\n\r\n\t\t\tfor ( var i = 0; i < numProperties; i ++ ) {\r\n\r\n\t\t\t\tpropertyList.push( this$1.parseProperty( reader ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\r\n\t\t\tvar id = propertyList.length > 0 ? propertyList[ 0 ] : '';\r\n\t\t\tvar attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\r\n\t\t\tvar attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\r\n\r\n\t\t\t// check if this node represents just a single property\r\n\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\r\n\t\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\r\n\r\n\t\t\twhile ( endOffset > reader.getOffset() ) {\r\n\r\n\t\t\t\tvar subNode = this$1.parseNode( reader, version );\r\n\r\n\t\t\t\tif ( subNode !== null ) { this$1.parseSubNode( name, node, subNode ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnode.propertyList = propertyList; // raw property list used by parent\r\n\r\n\t\t\tif ( typeof id === 'number' ) { node.id = id; }\r\n\t\t\tif ( attrName !== '' ) { node.attrName = attrName; }\r\n\t\t\tif ( attrType !== '' ) { node.attrType = attrType; }\r\n\t\t\tif ( name !== '' ) { node.name = name; }\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t},\r\n\r\n\t\tparseSubNode: function ( name, node, subNode ) {\r\n\r\n\t\t\t// special case: child node is single property\r\n\t\t\tif ( subNode.singleProperty === true ) {\r\n\r\n\t\t\t\tvar value = subNode.propertyList[ 0 ];\r\n\r\n\t\t\t\tif ( Array.isArray( value ) ) {\r\n\r\n\t\t\t\t\tnode[ subNode.name ] = subNode;\r\n\r\n\t\t\t\t\tsubNode.a = value;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnode[ subNode.name ] = value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\r\n\r\n\t\t\t\tvar array = [];\r\n\r\n\t\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\r\n\r\n\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\r\n\t\t\t\t\tif ( i !== 0 ) { array.push( property ); }\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tif ( node.connections === undefined ) {\r\n\r\n\t\t\t\t\tnode.connections = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.connections.push( array );\r\n\r\n\t\t\t} else if ( subNode.name === 'Properties70' ) {\r\n\r\n\t\t\t\tvar keys = Object.keys( subNode );\r\n\r\n\t\t\t\tkeys.forEach( function ( key ) {\r\n\r\n\t\t\t\t\tnode[ key ] = subNode[ key ];\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\r\n\r\n\t\t\t\tvar innerPropName = subNode.propertyList[ 0 ];\r\n\t\t\t\tvar innerPropType1 = subNode.propertyList[ 1 ];\r\n\t\t\t\tvar innerPropType2 = subNode.propertyList[ 2 ];\r\n\t\t\t\tvar innerPropFlag = subNode.propertyList[ 3 ];\r\n\t\t\t\tvar innerPropValue;\r\n\r\n\t\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) { innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' ); }\r\n\t\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) { innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' ); }\r\n\r\n\t\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\r\n\r\n\t\t\t\t\tinnerPropValue = [\r\n\t\t\t\t\t\tsubNode.propertyList[ 4 ],\r\n\t\t\t\t\t\tsubNode.propertyList[ 5 ],\r\n\t\t\t\t\t\tsubNode.propertyList[ 6 ]\r\n\t\t\t\t\t];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// this will be copied to parent, see above\r\n\t\t\t\tnode[ innerPropName ] = {\r\n\r\n\t\t\t\t\t'type': innerPropType1,\r\n\t\t\t\t\t'type2': innerPropType2,\r\n\t\t\t\t\t'flag': innerPropFlag,\r\n\t\t\t\t\t'value': innerPropValue\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else if ( node[ subNode.name ] === undefined ) {\r\n\r\n\t\t\t\tif ( typeof subNode.id === 'number' ) {\r\n\r\n\t\t\t\t\tnode[ subNode.name ] = {};\r\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnode[ subNode.name ] = subNode;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( subNode.name === 'PoseNode' ) {\r\n\r\n\t\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\r\n\r\n\t\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode[ subNode.name ].push( subNode );\r\n\r\n\t\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\r\n\r\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tparseProperty: function ( reader ) {\r\n\r\n\t\t\tvar type = reader.getString( 1 );\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 'C':\r\n\t\t\t\t\treturn reader.getBoolean();\r\n\r\n\t\t\t\tcase 'D':\r\n\t\t\t\t\treturn reader.getFloat64();\r\n\r\n\t\t\t\tcase 'F':\r\n\t\t\t\t\treturn reader.getFloat32();\r\n\r\n\t\t\t\tcase 'I':\r\n\t\t\t\t\treturn reader.getInt32();\r\n\r\n\t\t\t\tcase 'L':\r\n\t\t\t\t\treturn reader.getInt64();\r\n\r\n\t\t\t\tcase 'R':\r\n\t\t\t\t\tvar length = reader.getUint32();\r\n\t\t\t\t\treturn reader.getArrayBuffer( length );\r\n\r\n\t\t\t\tcase 'S':\r\n\t\t\t\t\tvar length = reader.getUint32();\r\n\t\t\t\t\treturn reader.getString( length );\r\n\r\n\t\t\t\tcase 'Y':\r\n\t\t\t\t\treturn reader.getInt16();\r\n\r\n\t\t\t\tcase 'b':\r\n\t\t\t\tcase 'c':\r\n\t\t\t\tcase 'd':\r\n\t\t\t\tcase 'f':\r\n\t\t\t\tcase 'i':\r\n\t\t\t\tcase 'l':\r\n\r\n\t\t\t\t\tvar arrayLength = reader.getUint32();\r\n\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\r\n\t\t\t\t\tvar compressedLength = reader.getUint32();\r\n\r\n\t\t\t\t\tif ( encoding === 0 ) {\r\n\r\n\t\t\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\t\t\tcase 'b':\r\n\t\t\t\t\t\t\tcase 'c':\r\n\t\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\r\n\r\n\t\t\t\t\t\t\tcase 'd':\r\n\t\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\r\n\r\n\t\t\t\t\t\t\tcase 'f':\r\n\t\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\r\n\r\n\t\t\t\t\t\t\tcase 'i':\r\n\t\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\r\n\r\n\t\t\t\t\t\t\tcase 'l':\r\n\t\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( typeof Zlib === 'undefined' ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar inflate = new Zlib.Inflate( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef\r\n\t\t\t\t\tvar reader2 = new BinaryReader( inflate.decompress().buffer );\r\n\r\n\t\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\t\tcase 'b':\r\n\t\t\t\t\t\tcase 'c':\r\n\t\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\r\n\r\n\t\t\t\t\t\tcase 'd':\r\n\t\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\r\n\r\n\t\t\t\t\t\tcase 'f':\r\n\t\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\r\n\r\n\t\t\t\t\t\tcase 'i':\r\n\t\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\r\n\r\n\t\t\t\t\t\tcase 'l':\r\n\t\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'FBXLoader: Unknown property type ' + type );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction BinaryReader( buffer, littleEndian ) {\r\n\r\n\t\tthis.dv = new DataView( buffer );\r\n\t\tthis.offset = 0;\r\n\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\r\n\r\n\t}\r\n\r\n\tBinaryReader.prototype = {\r\n\r\n\t\tconstructor: BinaryReader,\r\n\r\n\t\tgetOffset: function () {\r\n\r\n\t\t\treturn this.offset;\r\n\r\n\t\t},\r\n\r\n\t\tsize: function () {\r\n\r\n\t\t\treturn this.dv.buffer.byteLength;\r\n\r\n\t\t},\r\n\r\n\t\tskip: function ( length ) {\r\n\r\n\t\t\tthis.offset += length;\r\n\r\n\t\t},\r\n\r\n\t\t// seems like true/false representation depends on exporter.\r\n\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\r\n\t\t// then sees LSB.\r\n\t\tgetBoolean: function () {\r\n\r\n\t\t\treturn ( this.getUint8() & 1 ) === 1;\r\n\r\n\t\t},\r\n\r\n\t\tgetBooleanArray: function ( size ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar a = [];\r\n\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\t\ta.push( this$1.getBoolean() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\r\n\t\tgetUint8: function () {\r\n\r\n\t\t\tvar value = this.dv.getUint8( this.offset );\r\n\t\t\tthis.offset += 1;\r\n\t\t\treturn value;\r\n\r\n\t\t},\r\n\r\n\t\tgetInt16: function () {\r\n\r\n\t\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\r\n\t\t\tthis.offset += 2;\r\n\t\t\treturn value;\r\n\r\n\t\t},\r\n\r\n\t\tgetInt32: function () {\r\n\r\n\t\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\r\n\t\t\tthis.offset += 4;\r\n\t\t\treturn value;\r\n\r\n\t\t},\r\n\r\n\t\tgetInt32Array: function ( size ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar a = [];\r\n\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\t\ta.push( this$1.getInt32() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\r\n\t\tgetUint32: function () {\r\n\r\n\t\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\r\n\t\t\tthis.offset += 4;\r\n\t\t\treturn value;\r\n\r\n\t\t},\r\n\r\n\t\t// JavaScript doesn't support 64-bit integer so calculate this here\r\n\t\t// 1 << 32 will return 1 so using multiply operation instead here.\r\n\t\t// There's a possibility that this method returns wrong value if the value\r\n\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\r\n\t\t// TODO: safely handle 64-bit integer\r\n\t\tgetInt64: function () {\r\n\r\n\t\t\tvar low, high;\r\n\r\n\t\t\tif ( this.littleEndian ) {\r\n\r\n\t\t\t\tlow = this.getUint32();\r\n\t\t\t\thigh = this.getUint32();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thigh = this.getUint32();\r\n\t\t\t\tlow = this.getUint32();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// calculate negative value\r\n\t\t\tif ( high & 0x80000000 ) {\r\n\r\n\t\t\t\thigh = ~ high & 0xFFFFFFFF;\r\n\t\t\t\tlow = ~ low & 0xFFFFFFFF;\r\n\r\n\t\t\t\tif ( low === 0xFFFFFFFF ) { high = ( high + 1 ) & 0xFFFFFFFF; }\r\n\r\n\t\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\r\n\r\n\t\t\t\treturn - ( high * 0x100000000 + low );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn high * 0x100000000 + low;\r\n\r\n\t\t},\r\n\r\n\t\tgetInt64Array: function ( size ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar a = [];\r\n\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\t\ta.push( this$1.getInt64() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\r\n\t\t// Note: see getInt64() comment\r\n\t\tgetUint64: function () {\r\n\r\n\t\t\tvar low, high;\r\n\r\n\t\t\tif ( this.littleEndian ) {\r\n\r\n\t\t\t\tlow = this.getUint32();\r\n\t\t\t\thigh = this.getUint32();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thigh = this.getUint32();\r\n\t\t\t\tlow = this.getUint32();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn high * 0x100000000 + low;\r\n\r\n\t\t},\r\n\r\n\t\tgetFloat32: function () {\r\n\r\n\t\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\r\n\t\t\tthis.offset += 4;\r\n\t\t\treturn value;\r\n\r\n\t\t},\r\n\r\n\t\tgetFloat32Array: function ( size ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar a = [];\r\n\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\t\ta.push( this$1.getFloat32() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\r\n\t\tgetFloat64: function () {\r\n\r\n\t\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\r\n\t\t\tthis.offset += 8;\r\n\t\t\treturn value;\r\n\r\n\t\t},\r\n\r\n\t\tgetFloat64Array: function ( size ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar a = [];\r\n\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\t\ta.push( this$1.getFloat64() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t},\r\n\r\n\t\tgetArrayBuffer: function ( size ) {\r\n\r\n\t\t\tvar value = this.dv.buffer.slice( this.offset, this.offset + size );\r\n\t\t\tthis.offset += size;\r\n\t\t\treturn value;\r\n\r\n\t\t},\r\n\r\n\t\tgetString: function ( size ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\r\n\t\t\tvar a = [];\r\n\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\t\ta[ i ] = this$1.getUint8();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar nullByte = a.indexOf( 0 );\r\n\t\t\tif ( nullByte >= 0 ) { a = a.slice( 0, nullByte ); }\r\n\r\n\t\t\treturn LoaderUtils.decodeText( new Uint8Array( a ) );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\r\n\t// and BinaryParser( FBX Binary format)\r\n\tfunction FBXTree() {}\r\n\r\n\tFBXTree.prototype = {\r\n\r\n\t\tconstructor: FBXTree,\r\n\r\n\t\tadd: function ( key, val ) {\r\n\r\n\t\t\tthis[ key ] = val;\r\n\r\n\t\t},\r\n\r\n\t};\r\n\r\n\t// ************** UTILITY FUNCTIONS **************\r\n\r\n\tfunction isFbxFormatBinary( buffer ) {\r\n\r\n\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\r\n\r\n\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\r\n\r\n\t}\r\n\r\n\tfunction isFbxFormatASCII( text ) {\r\n\r\n\t\tvar CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\r\n\r\n\t\tvar cursor = 0;\r\n\r\n\t\tfunction read( offset ) {\r\n\r\n\t\t\tvar result = text[ offset - 1 ];\r\n\t\t\ttext = text.slice( cursor + offset );\r\n\t\t\tcursor ++;\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < CORRECT.length; ++ i ) {\r\n\r\n\t\t\tvar num = read( 1 );\r\n\t\t\tif ( num === CORRECT[ i ] ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfunction getFbxVersion( text ) {\r\n\r\n\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\r\n\t\tvar match = text.match( versionRegExp );\r\n\t\tif ( match ) {\r\n\r\n\t\t\tvar version = parseInt( match[ 1 ] );\r\n\t\t\treturn version;\r\n\r\n\t\t}\r\n\t\tthrow new Error( 'FBXLoader: Cannot find the version number for the file given.' );\r\n\r\n\t}\r\n\r\n\t// Converts FBX ticks into real time seconds.\r\n\tfunction convertFBXTimeToSeconds( time ) {\r\n\r\n\t\treturn time / 46186158000;\r\n\r\n\t}\r\n\r\n\tvar dataArray = [];\r\n\r\n\t// extracts the data from the correct position in the FBX array based on indexing type\r\n\tfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\r\n\r\n\t\tvar index;\r\n\r\n\t\tswitch ( infoObject.mappingType ) {\r\n\r\n\t\t\tcase 'ByPolygonVertex' :\r\n\t\t\t\tindex = polygonVertexIndex;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'ByPolygon' :\r\n\t\t\t\tindex = polygonIndex;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'ByVertice' :\r\n\t\t\t\tindex = vertexIndex;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'AllSame' :\r\n\t\t\t\tindex = infoObject.indices[ 0 ];\r\n\t\t\t\tbreak;\r\n\t\t\tdefault :\r\n\t\t\t\tconsole.warn( 'FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\r\n\r\n\t\t}\r\n\r\n\t\tif ( infoObject.referenceType === 'IndexToDirect' ) { index = infoObject.indices[ index ]; }\r\n\r\n\t\tvar from = index * infoObject.dataSize;\r\n\t\tvar to = from + infoObject.dataSize;\r\n\r\n\t\treturn slice( dataArray, infoObject.buffer, from, to );\r\n\r\n\t}\r\n\r\n\tvar tempMat = new Matrix4();\r\n\tvar tempEuler = new Euler();\r\n\tvar tempVec = new Vector3();\r\n\tvar translation = new Vector3();\r\n\tvar rotation = new Matrix4();\r\n\r\n\t// generate transformation from FBX transform data\r\n\t// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\r\n\t// transformData = {\r\n\t//\t eulerOrder: int,\r\n\t//\t translation: [],\r\n\t//   rotationOffset: [],\r\n\t//\t preRotation\r\n\t//\t rotation\r\n\t//\t postRotation\r\n\t//   scale\r\n\t// }\r\n\t// all entries are optional\r\n\tfunction generateTransform( transformData ) {\r\n\r\n\t\tvar transform = new Matrix4();\r\n\t\ttranslation.set( 0, 0, 0 );\r\n\t\trotation.identity();\r\n\r\n\t\tvar order = ( transformData.eulerOrder ) ? getEulerOrder( transformData.eulerOrder ) : getEulerOrder( 0 );\r\n\r\n\t\tif ( transformData.translation ) { translation.fromArray( transformData.translation ); }\r\n\t\tif ( transformData.rotationOffset ) { translation.add( tempVec.fromArray( transformData.rotationOffset ) ); }\r\n\r\n\t\tif ( transformData.rotation ) {\r\n\r\n\t\t\tvar array = transformData.rotation.map( _Math.degToRad );\r\n\t\t\tarray.push( order );\r\n\t\t\trotation.makeRotationFromEuler( tempEuler.fromArray( array ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( transformData.preRotation ) {\r\n\r\n\t\t\tvar array = transformData.preRotation.map( _Math.degToRad );\r\n\t\t\tarray.push( order );\r\n\t\t\ttempMat.makeRotationFromEuler( tempEuler.fromArray( array ) );\r\n\r\n\t\t\trotation.premultiply( tempMat );\r\n\r\n\t\t}\r\n\r\n\t\tif ( transformData.postRotation ) {\r\n\r\n\t\t\tvar array = transformData.postRotation.map( _Math.degToRad );\r\n\t\t\tarray.push( order );\r\n\t\t\ttempMat.makeRotationFromEuler( tempEuler.fromArray( array ) );\r\n\r\n\t\t\ttempMat.getInverse( tempMat );\r\n\r\n\t\t\trotation.multiply( tempMat );\r\n\r\n\t\t}\r\n\r\n\t\tif ( transformData.scale ) { transform.scale( tempVec.fromArray( transformData.scale ) ); }\r\n\r\n\t\ttransform.setPosition( translation );\r\n\t\ttransform.multiply( rotation );\r\n\r\n\t\treturn transform;\r\n\r\n\t}\r\n\r\n\t// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\r\n\t// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\r\n\tfunction getEulerOrder( order ) {\r\n\r\n\t\tvar enums = [\r\n\t\t\t'ZYX', // -> XYZ extrinsic\r\n\t\t\t'YZX', // -> XZY extrinsic\r\n\t\t\t'XZY', // -> YZX extrinsic\r\n\t\t\t'ZXY', // -> YXZ extrinsic\r\n\t\t\t'YXZ', // -> ZXY extrinsic\r\n\t\t\t'XYZ' ];\r\n\r\n\t\tif ( order === 6 ) {\r\n\r\n\t\t\tconsole.warn( 'FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\r\n\t\t\treturn enums[ 0 ];\r\n\r\n\t\t}\r\n\r\n\t\treturn enums[ order ];\r\n\r\n\t}\r\n\r\n\t// Parses comma separated list of numbers and returns them an array.\r\n\t// Used internally by the TextParser\r\n\tfunction parseNumberArray( value ) {\r\n\r\n\t\tvar array = value.split( ',' ).map( function ( val ) {\r\n\r\n\t\t\treturn parseFloat( val );\r\n\r\n\t\t} );\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\tfunction convertArrayBufferToString( buffer, from, to ) {\r\n\r\n\t\tif ( from === undefined ) { from = 0; }\r\n\t\tif ( to === undefined ) { to = buffer.byteLength; }\r\n\r\n\t\treturn LoaderUtils.decodeText( new Uint8Array( buffer, from, to ) );\r\n\r\n\t}\r\n\r\n\tfunction append( a, b ) {\r\n\r\n\t\tfor ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\r\n\r\n\t\t\ta[ j ] = b[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction slice( a, b, from, to ) {\r\n\r\n\t\tfor ( var i = from, j = 0; i < to; i ++, j ++ ) {\r\n\r\n\t\t\ta[ j ] = b[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t}\r\n\r\n\t// inject array a2 into array a1 at index\r\n\tfunction inject( a1, index, a2 ) {\r\n\r\n\t\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\r\n\r\n\t}\r\n\r\n\treturn FBXLoader;\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar GCodeLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\tthis.splitLayer = false;\r\n\r\n};\r\n\r\nGCodeLoader.prototype.load = function ( url, onLoad, onProgress, onError ) {\r\n\r\n\tvar self = this;\r\n\r\n\tvar loader = new FileLoader( self.manager );\r\n\tloader.load( url, function ( text ) {\r\n\r\n\t\tonLoad( self.parse( text ) );\r\n\r\n\t}, onProgress, onError );\r\n\r\n};\r\n\r\nGCodeLoader.prototype.parse = function ( data ) {\r\n\r\n\tvar state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };\r\n\tvar layers = [];\r\n\r\n\tvar currentLayer = undefined;\r\n\r\n\tvar pathMaterial = new LineBasicMaterial( { color: 0xFF0000 } );\r\n\tpathMaterial.name = 'path';\r\n\r\n\tvar extrudingMaterial = new LineBasicMaterial( { color: 0x00FF00 } );\r\n\textrudingMaterial.name = 'extruded';\r\n\r\n\tfunction newLayer( line ) {\r\n\r\n\t\tcurrentLayer = { vertex: [], pathVertex: [], z: line.z };\r\n\t\tlayers.push( currentLayer );\r\n\r\n\t}\r\n\r\n\t//Create lie segment between p1 and p2\r\n\tfunction addSegment( p1, p2 ) {\r\n\r\n\t\tif ( currentLayer === undefined ) {\r\n\r\n\t\t\tnewLayer( p1 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( line.extruding ) {\r\n\r\n\t\t\tcurrentLayer.vertex.push( p1.x, p1.y, p1.z );\r\n\t\t\tcurrentLayer.vertex.push( p2.x, p2.y, p2.z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcurrentLayer.pathVertex.push( p1.x, p1.y, p1.z );\r\n\t\t\tcurrentLayer.pathVertex.push( p2.x, p2.y, p2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction delta( v1, v2 ) {\r\n\r\n\t\treturn state.relative ? v2 : v2 - v1;\r\n\r\n\t}\r\n\r\n\tfunction absolute( v1, v2 ) {\r\n\r\n\t\treturn state.relative ? v1 + v2 : v2;\r\n\r\n\t}\r\n\r\n\tvar lines = data.replace( /;.+/g, '' ).split( '\\n' );\r\n\r\n\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\tvar tokens = lines[ i ].split( ' ' );\r\n\t\tvar cmd = tokens[ 0 ].toUpperCase();\r\n\r\n\t\t//Argumments\r\n\t\tvar args = {};\r\n\t\ttokens.splice( 1 ).forEach( function ( token ) {\r\n\r\n\t\t\tif ( token[ 0 ] !== undefined ) {\r\n\r\n\t\t\t\tvar key = token[ 0 ].toLowerCase();\r\n\t\t\t\tvar value = parseFloat( token.substring( 1 ) );\r\n\t\t\t\targs[ key ] = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\t//Process commands\r\n\t\t//G0/G1 – Linear Movement\r\n\t\tif ( cmd === 'G0' || cmd === 'G1' ) {\r\n\r\n\t\t\tvar line = {\r\n\t\t\t\tx: args.x !== undefined ? absolute( state.x, args.x ) : state.x,\r\n\t\t\t\ty: args.y !== undefined ? absolute( state.y, args.y ) : state.y,\r\n\t\t\t\tz: args.z !== undefined ? absolute( state.z, args.z ) : state.z,\r\n\t\t\t\te: args.e !== undefined ? absolute( state.e, args.e ) : state.e,\r\n\t\t\t\tf: args.f !== undefined ? absolute( state.f, args.f ) : state.f,\r\n\t\t\t};\r\n\r\n\t\t\t//Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\r\n\t\t\tif ( delta( state.e, line.e ) > 0 ) {\r\n\r\n\t\t\t\tline.extruding = delta( state.e, line.e ) > 0;\r\n\r\n\t\t\t\tif ( currentLayer == undefined || line.z != currentLayer.z ) {\r\n\r\n\t\t\t\t\tnewLayer( line );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\taddSegment( state, line );\r\n\t\t\tstate = line;\r\n\r\n\t\t} else if ( cmd === 'G2' || cmd === 'G3' ) {\r\n\r\n\t\t\t//G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )\r\n\t\t\tconsole.warn( 'GCodeLoader: Arc command not supported' );\r\n\r\n\t\t} else if ( cmd === 'G90' ) {\r\n\r\n\t\t\t//G90: Set to Absolute Positioning\r\n\t\t\tstate.relative = false;\r\n\r\n\t\t} else if ( cmd === 'G91' ) {\r\n\r\n\t\t\t//G91: Set to state.relative Positioning\r\n\t\t\tstate.relative = true;\r\n\r\n\t\t} else if ( cmd === 'G92' ) {\r\n\r\n\t\t\t//G92: Set Position\r\n\t\t\tvar line = state;\r\n\t\t\tline.x = args.x !== undefined ? args.x : line.x;\r\n\t\t\tline.y = args.y !== undefined ? args.y : line.y;\r\n\t\t\tline.z = args.z !== undefined ? args.z : line.z;\r\n\t\t\tline.e = args.e !== undefined ? args.e : line.e;\r\n\t\t\tstate = line;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'GCodeLoader: Command not supported:' + cmd );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction addObject( vertex, extruding ) {\r\n\r\n\t\tvar geometry = new BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertex, 3 ) );\r\n\r\n\t\tvar segments = new LineSegments( geometry, extruding ? extrudingMaterial : pathMaterial );\r\n\t\tsegments.name = 'layer' + i;\r\n\t\tobject.add( segments );\r\n\r\n\t}\r\n\r\n\tvar object = new Group();\r\n\tobject.name = 'gcode';\r\n\r\n\tif ( this.splitLayer ) {\r\n\r\n\t\tfor ( var i = 0; i < layers.length; i ++ ) {\r\n\r\n\t\t\tvar layer = layers[ i ];\r\n\t\t\taddObject( layer.vertex, true );\r\n\t\t\taddObject( layer.pathVertex, false );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tvar vertex = [], pathVertex = [];\r\n\r\n\t\tfor ( var i = 0; i < layers.length; i ++ ) {\r\n\r\n\t\t\tvar layer = layers[ i ];\r\n\r\n\t\t\tvertex = vertex.concat( layer.vertex );\r\n\t\t\tpathVertex = pathVertex.concat( layer.pathVertex );\r\n\r\n\t\t}\r\n\r\n\t\taddObject( vertex, true );\r\n\t\taddObject( pathVertex, false );\r\n\r\n\t}\r\n\r\n\tobject.quaternion.setFromEuler( new Euler( - Math.PI / 2, 0, 0 ) );\r\n\r\n\treturn object;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BufferGeometryUtils = {\r\n\r\n\tcomputeTangents: function ( geometry ) {\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// (per vertex tangents)\r\n\r\n\t\tif ( index === null ||\r\n\t\t\t attributes.position === undefined ||\r\n\t\t\t attributes.normal === undefined ||\r\n\t\t\t attributes.uv === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar indices = index.array;\r\n\t\tvar positions = attributes.position.array;\r\n\t\tvar normals = attributes.normal.array;\r\n\t\tvar uvs = attributes.uv.array;\r\n\r\n\t\tvar nVertices = positions.length / 3;\r\n\r\n\t\tif ( attributes.tangent === undefined ) {\r\n\r\n\t\t\tgeometry.addAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar tangents = attributes.tangent.array;\r\n\r\n\t\tvar tan1 = [], tan2 = [];\r\n\r\n\t\tfor ( var i = 0; i < nVertices; i ++ ) {\r\n\r\n\t\t\ttan1[ i ] = new Vector3();\r\n\t\t\ttan2[ i ] = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar vA = new Vector3(),\r\n\t\t\tvB = new Vector3(),\r\n\t\t\tvC = new Vector3(),\r\n\r\n\t\t\tuvA = new Vector2(),\r\n\t\t\tuvB = new Vector2(),\r\n\t\t\tuvC = new Vector2(),\r\n\r\n\t\t\tsdir = new Vector3(),\r\n\t\t\ttdir = new Vector3();\r\n\r\n\t\tfunction handleTriangle( a, b, c ) {\r\n\r\n\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\tvC.fromArray( positions, c * 3 );\r\n\r\n\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\r\n\t\t\tvar x1 = vB.x - vA.x;\r\n\t\t\tvar x2 = vC.x - vA.x;\r\n\r\n\t\t\tvar y1 = vB.y - vA.y;\r\n\t\t\tvar y2 = vC.y - vA.y;\r\n\r\n\t\t\tvar z1 = vB.z - vA.z;\r\n\t\t\tvar z2 = vC.z - vA.z;\r\n\r\n\t\t\tvar s1 = uvB.x - uvA.x;\r\n\t\t\tvar s2 = uvC.x - uvA.x;\r\n\r\n\t\t\tvar t1 = uvB.y - uvA.y;\r\n\t\t\tvar t2 = uvC.y - uvA.y;\r\n\r\n\t\t\tvar r = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\r\n\t\t\tsdir.set(\r\n\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t( t2 * z1 - t1 * z2 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttdir.set(\r\n\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t( s1 * z2 - s2 * z1 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = geometry.groups;\r\n\r\n\t\tif ( groups.length === 0 ) {\r\n\r\n\t\t\tgroups = [ {\r\n\t\t\t\tstart: 0,\r\n\t\t\t\tcount: indices.length\r\n\t\t\t} ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\tvar start = group.start;\r\n\t\t\tvar count = group.count;\r\n\r\n\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\thandleTriangle(\r\n\t\t\t\t\tindices[ j + 0 ],\r\n\t\t\t\t\tindices[ j + 1 ],\r\n\t\t\t\t\tindices[ j + 2 ]\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar tmp = new Vector3(), tmp2 = new Vector3();\r\n\t\tvar n = new Vector3(), n2 = new Vector3();\r\n\t\tvar w, t, test;\r\n\r\n\t\tfunction handleVertex( v ) {\r\n\r\n\t\t\tn.fromArray( normals, v * 3 );\r\n\t\t\tn2.copy( n );\r\n\r\n\t\t\tt = tan1[ v ];\r\n\r\n\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\ttmp.copy( t );\r\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t// Calculate handedness\r\n\r\n\t\t\ttmp2.crossVectors( n2, t );\r\n\t\t\ttest = tmp2.dot( tan2[ v ] );\r\n\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\r\n\t\t\ttangents[ v * 4 ] = tmp.x;\r\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\r\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\r\n\t\t\ttangents[ v * 4 + 3 ] = w;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\tvar start = group.start;\r\n\t\t\tvar count = group.count;\r\n\r\n\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\thandleVertex( indices[ j + 0 ] );\r\n\t\t\t\thandleVertex( indices[ j + 1 ] );\r\n\t\t\t\thandleVertex( indices[ j + 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\t\r\n\tmergeBufferGeometries: function ( geometries, useGroups ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar isIndexed = geometries[ 0 ].index !== null;\r\n\r\n\t\tvar attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\r\n\t\tvar morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\r\n\r\n\t\tvar attributes = {};\r\n\t\tvar morphAttributes = {};\r\n\r\n\t\tvar mergedGeometry = new BufferGeometry();\r\n\r\n\t\tvar offset = 0;\r\n\r\n\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\tvar geometry = geometries[ i ];\r\n\r\n\t\t\t// ensure that all geometries are indexed, or none\r\n\r\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) { return null; }\r\n\r\n\t\t\t// gather attributes, exit early if they're different\r\n\r\n\t\t\tfor ( var name in geometry.attributes ) {\r\n\r\n\t\t\t\tif ( ! attributesUsed.has( name ) ) { return null; }\r\n\r\n\t\t\t\tif ( attributes[ name ] === undefined ) { attributes[ name ] = []; }\r\n\r\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// gather morph attributes, exit early if they're different\r\n\r\n\t\t\tfor ( var name in geometry.morphAttributes ) {\r\n\r\n\t\t\t\tif ( ! morphAttributesUsed.has( name ) ) { return null; }\r\n\r\n\t\t\t\tif ( morphAttributes[ name ] === undefined ) { morphAttributes[ name ] = []; }\r\n\r\n\t\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// gather .userData\r\n\r\n\t\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\r\n\t\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\r\n\r\n\t\t\tif ( useGroups ) {\r\n\r\n\t\t\t\tvar count;\r\n\r\n\t\t\t\tif ( isIndexed ) {\r\n\r\n\t\t\t\t\tcount = geometry.index.count;\r\n\r\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\r\n\r\n\t\t\t\t\tcount = geometry.attributes.position.count;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmergedGeometry.addGroup( offset, count, i );\r\n\r\n\t\t\t\toffset += count;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// merge indices\r\n\r\n\t\tif ( isIndexed ) {\r\n\r\n\t\t\tvar indexOffset = 0;\r\n\t\t\tvar mergedIndex = [];\r\n\r\n\t\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\t\tvar index = geometries[ i ].index;\r\n\r\n\t\t\t\tfor ( var j = 0; j < index.count; ++ j ) {\r\n\r\n\t\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindexOffset += geometries[ i ].attributes.position.count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmergedGeometry.setIndex( mergedIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// merge attributes\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tvar mergedAttribute = this$1.mergeBufferAttributes( attributes[ name ] );\r\n\r\n\t\t\tif ( ! mergedAttribute ) { return null; }\r\n\r\n\t\t\tmergedGeometry.addAttribute( name, mergedAttribute );\r\n\r\n\t\t}\r\n\r\n\t\t// merge morph attributes\r\n\r\n\t\tfor ( var name in morphAttributes ) {\r\n\r\n\t\t\tvar numMorphTargets = morphAttributes[ name ][ 0 ].length;\r\n\r\n\t\t\tif ( numMorphTargets === 0 ) { break; }\r\n\r\n\t\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\r\n\t\t\tmergedGeometry.morphAttributes[ name ] = [];\r\n\r\n\t\t\tfor ( var i = 0; i < numMorphTargets; ++ i ) {\r\n\r\n\t\t\t\tvar morphAttributesToMerge = [];\r\n\r\n\t\t\t\tfor ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {\r\n\r\n\t\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar mergedMorphAttribute = this$1.mergeBufferAttributes( morphAttributesToMerge );\r\n\r\n\t\t\t\tif ( ! mergedMorphAttribute ) { return null; }\r\n\r\n\t\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn mergedGeometry;\r\n\r\n\t},\r\n\t\r\n\tmergeBufferAttributes: function ( attributes ) {\r\n\r\n\t\tvar TypedArray;\r\n\t\tvar itemSize;\r\n\t\tvar normalized;\r\n\t\tvar arrayLength = 0;\r\n\r\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\r\n\r\n\t\t\tvar attribute = attributes[ i ];\r\n\r\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) { return null; }\r\n\r\n\t\t\tif ( TypedArray === undefined ) { TypedArray = attribute.array.constructor; }\r\n\t\t\tif ( TypedArray !== attribute.array.constructor ) { return null; }\r\n\r\n\t\t\tif ( itemSize === undefined ) { itemSize = attribute.itemSize; }\r\n\t\t\tif ( itemSize !== attribute.itemSize ) { return null; }\r\n\r\n\t\t\tif ( normalized === undefined ) { normalized = attribute.normalized; }\r\n\t\t\tif ( normalized !== attribute.normalized ) { return null; }\r\n\r\n\t\t\tarrayLength += attribute.array.length;\r\n\r\n\t\t}\r\n\r\n\t\tvar array = new TypedArray( arrayLength );\r\n\t\tvar offset = 0;\r\n\r\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\r\n\r\n\t\t\tarray.set( attributes[ i ].array, offset );\r\n\r\n\t\t\toffset += attributes[ i ].array.length;\r\n\r\n\t\t}\r\n\r\n\t\treturn new BufferAttribute( array, itemSize, normalized );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar GLTFLoader = ( function () {\r\n\r\n\tfunction GLTFLoader( manager ) {\r\n\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\t\tthis.dracoLoader = null;\r\n\r\n\t}\r\n\r\n\tGLTFLoader.prototype = {\r\n\r\n\t\tconstructor: GLTFLoader,\r\n\r\n\t\tcrossOrigin: 'anonymous',\r\n\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tvar path = this.path !== undefined ? this.path : LoaderUtils.extractUrlBase( url );\r\n\r\n\t\t\t// Tells the LoadingManager to track an extra item, which resolves after\r\n\t\t\t// the model is fully loaded. This means the count of items loaded will\r\n\t\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\tvar _onError = function ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar loader = new FileLoader( scope.manager );\r\n\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\t\tloader.load( url, function ( data ) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tscope.parse( data, path, function ( gltf ) {\r\n\r\n\t\t\t\t\t\tonLoad( gltf );\r\n\r\n\t\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t\t}, _onError );\r\n\r\n\t\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t\t_onError( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, _onError );\r\n\r\n\t\t},\r\n\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\t\tthis.crossOrigin = value;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetPath: function ( value ) {\r\n\r\n\t\t\tthis.path = value;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetDRACOLoader: function ( dracoLoader ) {\r\n\r\n\t\t\tthis.dracoLoader = dracoLoader;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( data, path, onLoad, onError ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar content;\r\n\t\t\tvar extensions = {};\r\n\r\n\t\t\tif ( typeof data === 'string' ) {\r\n\r\n\t\t\t\tcontent = data;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\r\n\r\n\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\r\n\r\n\t\t\t\t\ttry {\r\n\r\n\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\r\n\r\n\t\t\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\t\t\tif ( onError ) { onError( error ); }\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcontent = LoaderUtils.decodeText( new Uint8Array( data ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar json = JSON.parse( content );\r\n\r\n\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\r\n\r\n\t\t\t\tif ( onError ) { onError( new Error( 'GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.' ) ); }\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.extensionsUsed ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < json.extensionsUsed.length; ++ i ) {\r\n\r\n\t\t\t\t\tvar extensionName = json.extensionsUsed[ i ];\r\n\t\t\t\t\tvar extensionsRequired = json.extensionsRequired || [];\r\n\r\n\t\t\t\t\tswitch ( extensionName ) {\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFLightsExtension( json );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension( json );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\r\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this$1.dracoLoader );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase EXTENSIONS.MSFT_TEXTURE_DDS:\r\n\t\t\t\t\t\t\textensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] = new GLTFTextureDDSExtension();\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'GLTFLoader: Unknown extension \"' + extensionName + '\".' );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parser = new GLTFParser( json, extensions, {\r\n\r\n\t\t\t\tpath: path || this.path || '',\r\n\t\t\t\tcrossOrigin: this.crossOrigin,\r\n\t\t\t\tmanager: this.manager\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tparser.parse( function ( scene, scenes, cameras, animations, json ) {\r\n\r\n\t\t\t\tvar glTF = {\r\n\t\t\t\t\tscene: scene,\r\n\t\t\t\t\tscenes: scenes,\r\n\t\t\t\t\tcameras: cameras,\r\n\t\t\t\t\tanimations: animations,\r\n\t\t\t\t\tasset: json.asset,\r\n\t\t\t\t\tparser: parser,\r\n\t\t\t\t\tuserData: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\taddUnknownExtensionsToUserData( extensions, glTF, json );\r\n\r\n\t\t\t\tonLoad( glTF );\r\n\r\n\t\t\t}, onError );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction GLTFRegistry() {\r\n\r\n\t\tvar objects = {};\r\n\r\n\t\treturn\t{\r\n\r\n\t\t\tget: function ( key ) {\r\n\r\n\t\t\t\treturn objects[ key ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tadd: function ( key, object ) {\r\n\r\n\t\t\t\tobjects[ key ] = object;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tremove: function ( key ) {\r\n\r\n\t\t\t\tdelete objects[ key ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tremoveAll: function () {\r\n\r\n\t\t\t\tobjects = {};\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tvar EXTENSIONS = {\r\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\r\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\r\n\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\r\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\r\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\r\n\t\tMSFT_TEXTURE_DDS: 'MSFT_texture_dds'\r\n\t};\r\n\t\r\n\tfunction GLTFTextureDDSExtension() {\r\n\r\n\t\tif ( ! DDSLoader ) {\r\n\r\n\t\t\tthrow new Error( 'GLTFLoader: Attempting to load .dds texture without importing DDSLoader' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.name = EXTENSIONS.MSFT_TEXTURE_DDS;\r\n\t\tthis.ddsLoader = new DDSLoader();\r\n\r\n\t}\r\n\t\r\n\tfunction GLTFLightsExtension( json ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\r\n\r\n\t\tthis.lights = [];\r\n\r\n\t\tvar extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] ) || {};\r\n\t\tvar lightDefs = extension.lights || [];\r\n\r\n\t\tfor ( var i = 0; i < lightDefs.length; i ++ ) {\r\n\r\n\t\t\tvar lightDef = lightDefs[ i ];\r\n\t\t\tvar lightNode;\r\n\r\n\t\t\tvar color = new Color( 0xffffff );\r\n\t\t\tif ( lightDef.color !== undefined ) { color.fromArray( lightDef.color ); }\r\n\r\n\t\t\tvar range = lightDef.range !== undefined ? lightDef.range : 0;\r\n\r\n\t\t\tswitch ( lightDef.type ) {\r\n\r\n\t\t\t\tcase 'directional':\r\n\t\t\t\t\tlightNode = new DirectionalLight( color );\r\n\t\t\t\t\tlightNode.target.position.set( 0, 0, 1 );\r\n\t\t\t\t\tlightNode.add( lightNode.target );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'point':\r\n\t\t\t\t\tlightNode = new PointLight( color );\r\n\t\t\t\t\tlightNode.distance = range;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'spot':\r\n\t\t\t\t\tlightNode = new SpotLight( color );\r\n\t\t\t\t\tlightNode.distance = range;\r\n\t\t\t\t\t// Handle spotlight properties.\r\n\t\t\t\t\tlightDef.spot = lightDef.spot || {};\r\n\t\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\r\n\t\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\r\n\t\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\r\n\t\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\r\n\t\t\t\t\tlightNode.target.position.set( 0, 0, 1 );\r\n\t\t\t\t\tlightNode.add( lightNode.target );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlightNode.decay = 2;\r\n\r\n\t\t\tif ( lightDef.intensity !== undefined ) { lightNode.intensity = lightDef.intensity; }\r\n\r\n\t\t\tlightNode.name = lightDef.name || ( 'light_' + i );\r\n\r\n\t\t\tthis$1.lights.push( lightNode );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tfunction GLTFMaterialsUnlitExtension( json ) {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\r\n\r\n\t}\r\n\r\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function ( material ) {\r\n\r\n\t\treturn MeshBasicMaterial;\r\n\r\n\t};\r\n\r\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, material, parser ) {\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\r\n\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\tvar metallicRoughness = material.pbrMetallicRoughness;\r\n\r\n\t\tif ( metallicRoughness ) {\r\n\r\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\r\n\r\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\r\n\r\n\t\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture.index ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t};\r\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\r\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\r\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\r\n\r\n\tfunction GLTFBinaryExtension( data ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\r\n\t\tthis.content = null;\r\n\t\tthis.body = null;\r\n\r\n\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\r\n\r\n\t\tthis.header = {\r\n\t\t\tmagic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\r\n\t\t\tversion: headerView.getUint32( 4, true ),\r\n\t\t\tlength: headerView.getUint32( 8, true )\r\n\t\t};\r\n\r\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\r\n\r\n\t\t\tthrow new Error( 'GLTFLoader: Unsupported glTF-Binary header.' );\r\n\r\n\t\t} else if ( this.header.version < 2.0 ) {\r\n\r\n\t\t\tthrow new Error( 'GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\r\n\t\tvar chunkIndex = 0;\r\n\r\n\t\twhile ( chunkIndex < chunkView.byteLength ) {\r\n\r\n\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\r\n\t\t\tchunkIndex += 4;\r\n\r\n\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\r\n\t\t\tchunkIndex += 4;\r\n\r\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\r\n\r\n\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\r\n\t\t\t\tthis$1.content = LoaderUtils.decodeText( contentArray );\r\n\r\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\r\n\r\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\r\n\t\t\t\tthis$1.body = data.slice( byteOffset, byteOffset + chunkLength );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Clients must ignore chunks with unknown types.\r\n\r\n\t\t\tchunkIndex += chunkLength;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.content === null ) {\r\n\r\n\t\t\tthrow new Error( 'GLTFLoader: JSON content not found.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tfunction GLTFDracoMeshCompressionExtension( json, dracoLoader ) {\r\n\r\n\t\tif ( ! dracoLoader ) {\r\n\r\n\t\t\tthrow new Error( 'GLTFLoader: No DRACOLoader instance provided.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\r\n\t\tthis.json = json;\r\n\t\tthis.dracoLoader = dracoLoader;\r\n\r\n\t}\r\n\r\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar dracoLoader = this.dracoLoader;\r\n\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\r\n\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\r\n\t\tvar threeAttributeMap = {};\r\n\t\tvar attributeNormalizedMap = {};\r\n\t\tvar attributeTypeMap = {};\r\n\r\n\t\tfor ( var attributeName in gltfAttributeMap ) {\r\n\r\n\t\t\tif ( ! ( attributeName in ATTRIBUTES ) ) { continue; }\r\n\r\n\t\t\tthreeAttributeMap[ ATTRIBUTES[ attributeName ] ] = gltfAttributeMap[ attributeName ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( attributeName in primitive.attributes ) {\r\n\r\n\t\t\tif ( ATTRIBUTES[ attributeName ] !== undefined && gltfAttributeMap[ attributeName ] !== undefined ) {\r\n\r\n\t\t\t\tvar accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\r\n\t\t\t\tvar componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\r\n\t\t\t\tattributeTypeMap[ ATTRIBUTES[ attributeName ] ] = componentType;\r\n\t\t\t\tattributeNormalizedMap[ ATTRIBUTES[ attributeName ] ] = accessorDef.normalized === true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\r\n\r\n\t\t\treturn new Promise( function ( resolve ) {\r\n\r\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\r\n\r\n\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\r\n\r\n\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\r\n\t\t\t\t\t\tvar normalized = attributeNormalizedMap[ attributeName ];\r\n\r\n\t\t\t\t\t\tif ( normalized !== undefined ) { attribute.normalized = normalized; }\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresolve( geometry );\r\n\r\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\r\n\r\n\t\treturn {\r\n\r\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\r\n\r\n\t\t\tspecularGlossinessParams: [\r\n\t\t\t\t'color',\r\n\t\t\t\t'map',\r\n\t\t\t\t'lightMap',\r\n\t\t\t\t'lightMapIntensity',\r\n\t\t\t\t'aoMap',\r\n\t\t\t\t'aoMapIntensity',\r\n\t\t\t\t'emissive',\r\n\t\t\t\t'emissiveIntensity',\r\n\t\t\t\t'emissiveMap',\r\n\t\t\t\t'bumpMap',\r\n\t\t\t\t'bumpScale',\r\n\t\t\t\t'normalMap',\r\n\t\t\t\t'displacementMap',\r\n\t\t\t\t'displacementScale',\r\n\t\t\t\t'displacementBias',\r\n\t\t\t\t'specularMap',\r\n\t\t\t\t'specular',\r\n\t\t\t\t'glossinessMap',\r\n\t\t\t\t'glossiness',\r\n\t\t\t\t'alphaMap',\r\n\t\t\t\t'envMap',\r\n\t\t\t\t'envMapIntensity',\r\n\t\t\t\t'refractionRatio' ],\r\n\r\n\t\t\tgetMaterialType: function () {\r\n\r\n\t\t\t\treturn ShaderMaterial;\r\n\r\n\t\t\t},\r\n\r\n\t\t\textendParams: function ( params, material, parser ) {\r\n\r\n\t\t\t\tvar pbrSpecularGlossiness = material.extensions[ this.name ];\r\n\r\n\t\t\t\tvar shader = ShaderLib[ 'standard' ];\r\n\r\n\t\t\t\tvar uniforms = UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\t\t\tvar specularMapParsFragmentChunk = [\r\n\t\t\t\t\t'#ifdef USE_SPECULARMAP',\r\n\t\t\t\t\t'\tuniform sampler2D specularMap;',\r\n\t\t\t\t\t'#endif'\r\n\t\t\t\t].join( '\\n' );\r\n\r\n\t\t\t\tvar glossinessMapParsFragmentChunk = [\r\n\t\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\r\n\t\t\t\t\t'\tuniform sampler2D glossinessMap;',\r\n\t\t\t\t\t'#endif'\r\n\t\t\t\t].join( '\\n' );\r\n\r\n\t\t\t\tvar specularMapFragmentChunk = [\r\n\t\t\t\t\t'vec3 specularFactor = specular;',\r\n\t\t\t\t\t'#ifdef USE_SPECULARMAP',\r\n\t\t\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\r\n\t\t\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\r\n\t\t\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\r\n\t\t\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\r\n\t\t\t\t\t'#endif'\r\n\t\t\t\t].join( '\\n' );\r\n\r\n\t\t\t\tvar glossinessMapFragmentChunk = [\r\n\t\t\t\t\t'float glossinessFactor = glossiness;',\r\n\t\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\r\n\t\t\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\r\n\t\t\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\r\n\t\t\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\r\n\t\t\t\t\t'#endif'\r\n\t\t\t\t].join( '\\n' );\r\n\r\n\t\t\t\tvar lightPhysicalFragmentChunk = [\r\n\t\t\t\t\t'PhysicalMaterial material;',\r\n\t\t\t\t\t'material.diffuseColor = diffuseColor.rgb;',\r\n\t\t\t\t\t'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );',\r\n\t\t\t\t\t'material.specularColor = specularFactor.rgb;' ].join( '\\n' );\r\n\r\n\t\t\t\tvar fragmentShader = shader.fragmentShader\r\n\t\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\r\n\t\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\r\n\t\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\r\n\t\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\r\n\t\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\r\n\t\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\r\n\t\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\r\n\r\n\t\t\t\tdelete uniforms.roughness;\r\n\t\t\t\tdelete uniforms.metalness;\r\n\t\t\t\tdelete uniforms.roughnessMap;\r\n\t\t\t\tdelete uniforms.metalnessMap;\r\n\r\n\t\t\t\tuniforms.specular = { value: new Color().setHex( 0x111111 ) };\r\n\t\t\t\tuniforms.glossiness = { value: 0.5 };\r\n\t\t\t\tuniforms.specularMap = { value: null };\r\n\t\t\t\tuniforms.glossinessMap = { value: null };\r\n\r\n\t\t\t\tparams.vertexShader = shader.vertexShader;\r\n\t\t\t\tparams.fragmentShader = fragmentShader;\r\n\t\t\t\tparams.uniforms = uniforms;\r\n\t\t\t\tparams.defines = { 'STANDARD': '' };\r\n\r\n\t\t\t\tparams.color = new Color( 1.0, 1.0, 1.0 );\r\n\t\t\t\tparams.opacity = 1.0;\r\n\r\n\t\t\t\tvar pending = [];\r\n\r\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\r\n\r\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\r\n\r\n\t\t\t\t\tparams.color.fromArray( array );\r\n\t\t\t\t\tparams.opacity = array[ 3 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\r\n\r\n\t\t\t\t\tpending.push( parser.assignTexture( params, 'map', pbrSpecularGlossiness.diffuseTexture.index ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparams.emissive = new Color( 0.0, 0.0, 0.0 );\r\n\t\t\t\tparams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\r\n\t\t\t\tparams.specular = new Color( 1.0, 1.0, 1.0 );\r\n\r\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\r\n\r\n\t\t\t\t\tparams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\r\n\r\n\t\t\t\t\tvar specGlossIndex = pbrSpecularGlossiness.specularGlossinessTexture.index;\r\n\t\t\t\t\tpending.push( parser.assignTexture( params, 'glossinessMap', specGlossIndex ) );\r\n\t\t\t\t\tpending.push( parser.assignTexture( params, 'specularMap', specGlossIndex ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Promise.all( pending );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tcreateMaterial: function ( params ) {\r\n\r\n\t\t\t\t// setup material properties based on MeshStandardMaterial for Specular-Glossiness\r\n\r\n\t\t\t\tvar material = new ShaderMaterial( {\r\n\t\t\t\t\tdefines: params.defines,\r\n\t\t\t\t\tvertexShader: params.vertexShader,\r\n\t\t\t\t\tfragmentShader: params.fragmentShader,\r\n\t\t\t\t\tuniforms: params.uniforms,\r\n\t\t\t\t\tfog: true,\r\n\t\t\t\t\tlights: true,\r\n\t\t\t\t\topacity: params.opacity,\r\n\t\t\t\t\ttransparent: params.transparent\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tmaterial.isGLTFSpecularGlossinessMaterial = true;\r\n\r\n\t\t\t\tmaterial.color = params.color;\r\n\r\n\t\t\t\tmaterial.map = params.map === undefined ? null : params.map;\r\n\r\n\t\t\t\tmaterial.lightMap = null;\r\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\r\n\r\n\t\t\t\tmaterial.aoMap = params.aoMap === undefined ? null : params.aoMap;\r\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\r\n\r\n\t\t\t\tmaterial.emissive = params.emissive;\r\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\r\n\t\t\t\tmaterial.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\r\n\r\n\t\t\t\tmaterial.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\r\n\t\t\t\tmaterial.bumpScale = 1;\r\n\r\n\t\t\t\tmaterial.normalMap = params.normalMap === undefined ? null : params.normalMap;\r\n\t\t\t\tif ( params.normalScale ) { material.normalScale = params.normalScale; }\r\n\r\n\t\t\t\tmaterial.displacementMap = null;\r\n\t\t\t\tmaterial.displacementScale = 1;\r\n\t\t\t\tmaterial.displacementBias = 0;\r\n\r\n\t\t\t\tmaterial.specularMap = params.specularMap === undefined ? null : params.specularMap;\r\n\t\t\t\tmaterial.specular = params.specular;\r\n\r\n\t\t\t\tmaterial.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\r\n\t\t\t\tmaterial.glossiness = params.glossiness;\r\n\r\n\t\t\t\tmaterial.alphaMap = null;\r\n\r\n\t\t\t\tmaterial.envMap = params.envMap === undefined ? null : params.envMap;\r\n\t\t\t\tmaterial.envMapIntensity = 1.0;\r\n\r\n\t\t\t\tmaterial.refractionRatio = 0.98;\r\n\r\n\t\t\t\tmaterial.extensions.derivatives = true;\r\n\r\n\t\t\t\treturn material;\r\n\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\tcloneMaterial: function ( source ) {\r\n\r\n\t\t\t\tvar target = source.clone();\r\n\r\n\t\t\t\ttarget.isGLTFSpecularGlossinessMaterial = true;\r\n\r\n\t\t\t\tvar params = this.specularGlossinessParams;\r\n\r\n\t\t\t\tfor ( var i = 0, il = params.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\ttarget[ params[ i ] ] = source[ params[ i ] ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn target;\r\n\r\n\t\t\t},\r\n\r\n\t\t\t// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\r\n\t\t\trefreshUniforms: function ( renderer, scene, camera, geometry, material, group ) {\r\n\r\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial !== true ) {\r\n\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar uniforms = material.uniforms;\r\n\t\t\t\tvar defines = material.defines;\r\n\r\n\t\t\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t\tuniforms.diffuse.value.copy( material.color );\r\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\r\n\r\n\t\t\t\tuniforms.map.value = material.map;\r\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\r\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\r\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n\r\n\t\t\t\t// uv repeat and offset setting priorities\r\n\t\t\t\t// 1. color map\r\n\t\t\t\t// 2. specular map\r\n\t\t\t\t// 3. normal map\r\n\t\t\t\t// 4. bump map\r\n\t\t\t\t// 5. alpha map\r\n\t\t\t\t// 6. emissive map\r\n\r\n\t\t\t\tvar uvScaleMap;\r\n\r\n\t\t\t\tif ( material.map ) {\r\n\r\n\t\t\t\t\tuvScaleMap = material.map;\r\n\r\n\t\t\t\t} else if ( material.specularMap ) {\r\n\r\n\t\t\t\t\tuvScaleMap = material.specularMap;\r\n\r\n\t\t\t\t} else if ( material.displacementMap ) {\r\n\r\n\t\t\t\t\tuvScaleMap = material.displacementMap;\r\n\r\n\t\t\t\t} else if ( material.normalMap ) {\r\n\r\n\t\t\t\t\tuvScaleMap = material.normalMap;\r\n\r\n\t\t\t\t} else if ( material.bumpMap ) {\r\n\r\n\t\t\t\t\tuvScaleMap = material.bumpMap;\r\n\r\n\t\t\t\t} else if ( material.glossinessMap ) {\r\n\r\n\t\t\t\t\tuvScaleMap = material.glossinessMap;\r\n\r\n\t\t\t\t} else if ( material.alphaMap ) {\r\n\r\n\t\t\t\t\tuvScaleMap = material.alphaMap;\r\n\r\n\t\t\t\t} else if ( material.emissiveMap ) {\r\n\r\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( uvScaleMap !== undefined ) {\r\n\r\n\t\t\t\t\t// backwards compatibility\r\n\t\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\r\n\r\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\r\n\r\n\t\t\t\t\t\tuvScaleMap.updateMatrix();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tuniforms.envMap.value = material.envMap;\r\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\r\n\t\t\t\tuniforms.flipEnvMap.value = ( material.envMap && material.envMap.isCubeTexture ) ? - 1 : 1;\r\n\r\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\r\n\t\t\t\tuniforms.specular.value.copy( material.specular );\r\n\t\t\t\tuniforms.glossiness.value = material.glossiness;\r\n\r\n\t\t\t\tuniforms.glossinessMap.value = material.glossinessMap;\r\n\r\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\r\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t\t\tif ( uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined ) {\r\n\r\n\t\t\t\t\tdefines.USE_GLOSSINESSMAP = '';\r\n\t\t\t\t\t// set USE_ROUGHNESSMAP to enable vUv\r\n\t\t\t\t\tdefines.USE_ROUGHNESSMAP = '';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined ) {\r\n\r\n\t\t\t\t\tdelete defines.USE_GLOSSINESSMAP;\r\n\t\t\t\t\tdelete defines.USE_ROUGHNESSMAP;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t// Spline Interpolation\r\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\r\n\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\t\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n\t}\r\n\r\n\tGLTFCubicSplineInterpolant.prototype = Object.create( Interpolant.prototype );\r\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {\r\n\r\n\t\t// Copies a sample value to the result buffer. See description of glTF\r\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tvalueSize = this.valueSize,\r\n\t\t\toffset = index * valueSize * 3 + valueSize;\r\n\r\n\t\tfor ( var i = 0; i !== valueSize; i ++ ) {\r\n\r\n\t\t\tresult[ i ] = values[ offset + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer;\r\n\t\tvar values = this.sampleValues;\r\n\t\tvar stride = this.valueSize;\r\n\r\n\t\tvar stride2 = stride * 2;\r\n\t\tvar stride3 = stride * 3;\r\n\r\n\t\tvar td = t1 - t0;\r\n\r\n\t\tvar p = ( t - t0 ) / td;\r\n\t\tvar pp = p * p;\r\n\t\tvar ppp = pp * p;\r\n\r\n\t\tvar offset1 = i1 * stride3;\r\n\t\tvar offset0 = offset1 - stride3;\r\n\r\n\t\tvar s0 = 2 * ppp - 3 * pp + 1;\r\n\t\tvar s1 = ppp - 2 * pp + p;\r\n\t\tvar s2 = - 2 * ppp + 3 * pp;\r\n\t\tvar s3 = ppp - pp;\r\n\r\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\r\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\r\n\t\tfor ( var i = 0; i !== stride; i ++ ) {\r\n\r\n\t\t\tvar p0 = values[ offset0 + i + stride ]; // splineVertex_k\r\n\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\r\n\t\t\tvar p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\r\n\t\t\tvar m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\r\n\r\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\tvar WEBGL_CONSTANTS = {\r\n\t\tFLOAT: 5126,\r\n\t\t//FLOAT_MAT2: 35674,\r\n\t\tFLOAT_MAT3: 35675,\r\n\t\tFLOAT_MAT4: 35676,\r\n\t\tFLOAT_VEC2: 35664,\r\n\t\tFLOAT_VEC3: 35665,\r\n\t\tFLOAT_VEC4: 35666,\r\n\t\tLINEAR: 9729,\r\n\t\tREPEAT: 10497,\r\n\t\tSAMPLER_2D: 35678,\r\n\t\tPOINTS: 0,\r\n\t\tLINES: 1,\r\n\t\tLINE_LOOP: 2,\r\n\t\tLINE_STRIP: 3,\r\n\t\tTRIANGLES: 4,\r\n\t\tTRIANGLE_STRIP: 5,\r\n\t\tTRIANGLE_FAN: 6,\r\n\t\tUNSIGNED_BYTE: 5121,\r\n\t\tUNSIGNED_SHORT: 5123\r\n\t};\r\n\r\n\tvar WEBGL_COMPONENT_TYPES = {\r\n\t\t5120: Int8Array,\r\n\t\t5121: Uint8Array,\r\n\t\t5122: Int16Array,\r\n\t\t5123: Uint16Array,\r\n\t\t5125: Uint32Array,\r\n\t\t5126: Float32Array\r\n\t};\r\n\r\n\tvar WEBGL_FILTERS = {\r\n\t\t9728: NearestFilter,\r\n\t\t9729: LinearFilter,\r\n\t\t9984: NearestMipMapNearestFilter,\r\n\t\t9985: LinearMipMapNearestFilter,\r\n\t\t9986: NearestMipMapLinearFilter,\r\n\t\t9987: LinearMipMapLinearFilter\r\n\t};\r\n\r\n\tvar WEBGL_WRAPPINGS = {\r\n\t\t33071: ClampToEdgeWrapping,\r\n\t\t33648: MirroredRepeatWrapping,\r\n\t\t10497: RepeatWrapping\r\n\t};\r\n\r\n\tvar WEBGL_TYPE_SIZES = {\r\n\t\t'SCALAR': 1,\r\n\t\t'VEC2': 2,\r\n\t\t'VEC3': 3,\r\n\t\t'VEC4': 4,\r\n\t\t'MAT2': 4,\r\n\t\t'MAT3': 9,\r\n\t\t'MAT4': 16\r\n\t};\r\n\r\n\tvar ATTRIBUTES = {\r\n\t\tPOSITION: 'position',\r\n\t\tNORMAL: 'normal',\r\n\t\tTEXCOORD_0: 'uv',\r\n\t\tTEXCOORD0: 'uv', // deprecated\r\n\t\tTEXCOORD: 'uv', // deprecated\r\n\t\tTEXCOORD_1: 'uv2',\r\n\t\tCOLOR_0: 'color',\r\n\t\tCOLOR0: 'color', // deprecated\r\n\t\tCOLOR: 'color', // deprecated\r\n\t\tWEIGHTS_0: 'skinWeight',\r\n\t\tWEIGHT: 'skinWeight', // deprecated\r\n\t\tJOINTS_0: 'skinIndex',\r\n\t\tJOINT: 'skinIndex' // deprecated\r\n\t};\r\n\r\n\tvar PATH_PROPERTIES = {\r\n\t\tscale: 'scale',\r\n\t\ttranslation: 'position',\r\n\t\trotation: 'quaternion',\r\n\t\tweights: 'morphTargetInfluences'\r\n\t};\r\n\r\n\tvar INTERPOLATION = {\r\n\t\tCUBICSPLINE: InterpolateSmooth, // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE.\r\n\t\t                                      // KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,\r\n\t\t                                      // using InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.\r\n\t\t                                      // See KeyframeTrack.optimize() for the detail.\r\n\t\tLINEAR: InterpolateLinear,\r\n\t\tSTEP: InterpolateDiscrete\r\n\t};\r\n\r\n\tvar ALPHA_MODES = {\r\n\t\tOPAQUE: 'OPAQUE',\r\n\t\tMASK: 'MASK',\r\n\t\tBLEND: 'BLEND'\r\n\t};\r\n\r\n\tvar MIME_TYPE_FORMATS = {\r\n\t\t'image/png': RGBAFormat,\r\n\t\t'image/jpeg': RGBFormat\r\n\t};\r\n\r\n\tfunction resolveURL( url, path ) {\r\n\r\n\t\t// Invalid URL\r\n\t\tif ( typeof url !== 'string' || url === '' ) { return ''; }\r\n\r\n\t\t// Absolute URL http://,https://,//\r\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) { return url; }\r\n\r\n\t\t// Data URI\r\n\t\tif ( /^data:.*,.*$/i.test( url ) ) { return url; }\r\n\r\n\t\t// Blob URL\r\n\t\tif ( /^blob:.*$/i.test( url ) ) { return url; }\r\n\r\n\t\t// Relative URL\r\n\t\treturn path + url;\r\n\r\n\t}\r\n\t\r\n\tfunction createDefaultMaterial() {\r\n\r\n\t\treturn new MeshStandardMaterial( {\r\n\t\t\tcolor: 0xFFFFFF,\r\n\t\t\temissive: 0x000000,\r\n\t\t\tmetalness: 1,\r\n\t\t\troughness: 1,\r\n\t\t\ttransparent: false,\r\n\t\t\tdepthTest: true,\r\n\t\t\tside: FrontSide\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\r\n\r\n\t\t// Add unknown glTF extensions to an object's userData.\r\n\r\n\t\tfor ( var name in objectDef.extensions ) {\r\n\r\n\t\t\tif ( knownExtensions[ name ] === undefined ) {\r\n\r\n\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\r\n\t\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tfunction assignExtrasToUserData( object, gltfDef ) {\r\n\r\n\t\tif ( gltfDef.extras !== undefined ) {\r\n\r\n\t\t\tif ( typeof gltfDef.extras === 'object' ) {\r\n\r\n\t\t\t\tobject.userData = gltfDef.extras;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tfunction addMorphTargets( geometry, targets, accessors ) {\r\n\r\n\t\tvar hasMorphPosition = false;\r\n\t\tvar hasMorphNormal = false;\r\n\r\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar target = targets[ i ];\r\n\r\n\t\t\tif ( target.POSITION !== undefined ) { hasMorphPosition = true; }\r\n\t\t\tif ( target.NORMAL !== undefined ) { hasMorphNormal = true; }\r\n\r\n\t\t\tif ( hasMorphPosition && hasMorphNormal ) { break; }\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) { return; }\r\n\r\n\t\tvar morphPositions = [];\r\n\t\tvar morphNormals = [];\r\n\r\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar target = targets[ i ];\r\n\t\t\tvar attributeName = 'morphTarget' + i;\r\n\r\n\t\t\tif ( hasMorphPosition ) {\r\n\r\n\t\t\t\t// Three.js morph position is absolute value. The formula is\r\n\t\t\t\t//   basePosition\r\n\t\t\t\t//     + weight0 * ( morphPosition0 - basePosition )\r\n\t\t\t\t//     + weight1 * ( morphPosition1 - basePosition )\r\n\t\t\t\t//     ...\r\n\t\t\t\t// while the glTF one is relative\r\n\t\t\t\t//   basePosition\r\n\t\t\t\t//     + weight0 * glTFmorphPosition0\r\n\t\t\t\t//     + weight1 * glTFmorphPosition1\r\n\t\t\t\t//     ...\r\n\t\t\t\t// then we need to convert from relative to absolute here.\r\n\r\n\t\t\t\tif ( target.POSITION !== undefined ) {\r\n\r\n\t\t\t\t\t// Cloning not to pollute original accessor\r\n\t\t\t\t\tvar positionAttribute = cloneBufferAttribute( accessors[ target.POSITION ] );\r\n\t\t\t\t\tpositionAttribute.name = attributeName;\r\n\r\n\t\t\t\t\tvar position = geometry.attributes.position;\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = positionAttribute.count; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tpositionAttribute.setXYZ(\r\n\t\t\t\t\t\t\tj,\r\n\t\t\t\t\t\t\tpositionAttribute.getX( j ) + position.getX( j ),\r\n\t\t\t\t\t\t\tpositionAttribute.getY( j ) + position.getY( j ),\r\n\t\t\t\t\t\t\tpositionAttribute.getZ( j ) + position.getZ( j )\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpositionAttribute = geometry.attributes.position;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmorphPositions.push( positionAttribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasMorphNormal ) {\r\n\r\n\t\t\t\t// see target.POSITION's comment\r\n\r\n\t\t\t\tvar normalAttribute;\r\n\r\n\t\t\t\tif ( target.NORMAL !== undefined ) {\r\n\r\n\t\t\t\t\tvar normalAttribute = cloneBufferAttribute( accessors[ target.NORMAL ] );\r\n\t\t\t\t\tnormalAttribute.name = attributeName;\r\n\r\n\t\t\t\t\tvar normal = geometry.attributes.normal;\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = normalAttribute.count; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tnormalAttribute.setXYZ(\r\n\t\t\t\t\t\t\tj,\r\n\t\t\t\t\t\t\tnormalAttribute.getX( j ) + normal.getX( j ),\r\n\t\t\t\t\t\t\tnormalAttribute.getY( j ) + normal.getY( j ),\r\n\t\t\t\t\t\t\tnormalAttribute.getZ( j ) + normal.getZ( j )\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnormalAttribute = geometry.attributes.normal;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmorphNormals.push( normalAttribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( hasMorphPosition ) { geometry.morphAttributes.position = morphPositions; }\r\n\t\tif ( hasMorphNormal ) { geometry.morphAttributes.normal = morphNormals; }\r\n\r\n\t}\r\n\t\r\n\tfunction updateMorphTargets( mesh, meshDef ) {\r\n\r\n\t\tmesh.updateMorphTargets();\r\n\r\n\t\tif ( meshDef.weights !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\r\n\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\r\n\r\n\t\t\tvar targetNames = meshDef.extras.targetNames;\r\n\r\n\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\r\n\r\n\t\t\t\tmesh.morphTargetDictionary = {};\r\n\r\n\t\t\t\tfor ( var i = 0, il = targetNames.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction isPrimitiveEqual( a, b ) {\r\n\r\n\t\tif ( a.indices !== b.indices ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn isObjectEqual( a.attributes, b.attributes );\r\n\r\n\t}\r\n\r\n\tfunction isObjectEqual( a, b ) {\r\n\r\n\t\tif ( Object.keys( a ).length !== Object.keys( b ).length ) { return false; }\r\n\r\n\t\tfor ( var key in a ) {\r\n\r\n\t\t\tif ( a[ key ] !== b[ key ] ) { return false; }\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfunction isArrayEqual( a, b ) {\r\n\r\n\t\tif ( a.length !== b.length ) { return false; }\r\n\r\n\t\tfor ( var i = 0, il = a.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( a[ i ] !== b[ i ] ) { return false; }\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfunction getCachedGeometry( cache, newPrimitive ) {\r\n\r\n\t\tfor ( var i = 0, il = cache.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar cached = cache[ i ];\r\n\r\n\t\t\tif ( isPrimitiveEqual( cached.primitive, newPrimitive ) ) { return cached.promise; }\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tfunction getCachedCombinedGeometry( cache, geometries ) {\r\n\r\n\t\tfor ( var i = 0, il = cache.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar cached = cache[ i ];\r\n\r\n\t\t\tif ( isArrayEqual( geometries, cached.baseGeometries ) ) { return cached.geometry; }\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tfunction getCachedMultiPassGeometry( cache, geometry, primitives ) {\r\n\r\n\t\tfor ( var i = 0, il = cache.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar cached = cache[ i ];\r\n\r\n\t\t\tif ( geometry === cached.baseGeometry && isArrayEqual( primitives, cached.primitives ) ) { return cached.geometry; }\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tfunction cloneBufferAttribute( attribute ) {\r\n\r\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tvar count = attribute.count;\r\n\t\t\tvar itemSize = attribute.itemSize;\r\n\t\t\tvar array = attribute.array.slice( 0, count * itemSize );\r\n\r\n\t\t\tfor ( var i = 0; i < count; ++ i ) {\r\n\r\n\t\t\t\tarray[ i ] = attribute.getX( i );\r\n\t\t\t\tif ( itemSize >= 2 ) { array[ i + 1 ] = attribute.getY( i ); }\r\n\t\t\t\tif ( itemSize >= 3 ) { array[ i + 2 ] = attribute.getZ( i ); }\r\n\t\t\t\tif ( itemSize >= 4 ) { array[ i + 3 ] = attribute.getW( i ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new BufferAttribute( array, itemSize, attribute.normalized );\r\n\r\n\t\t}\r\n\r\n\t\treturn attribute.clone();\r\n\r\n\t}\r\n\t\r\n\tfunction isMultiPassGeometry( primitives ) {\r\n\r\n\t\tif ( primitives.length < 2 ) { return false; }\r\n\r\n\t\tvar primitive0 = primitives[ 0 ];\r\n\t\tvar targets0 = primitive0.targets || [];\r\n\r\n\t\tif ( primitive0.indices === undefined ) { return false; }\r\n\r\n\t\tfor ( var i = 1, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar primitive = primitives[ i ];\r\n\r\n\t\t\tif ( primitive0.mode !== primitive.mode ) { return false; }\r\n\t\t\tif ( primitive.indices === undefined ) { return false; }\r\n\t\t\tif ( ! isObjectEqual( primitive0.attributes, primitive.attributes ) ) { return false; }\r\n\r\n\t\t\tvar targets = primitive.targets || [];\r\n\r\n\t\t\tif ( targets0.length !== targets.length ) { return false; }\r\n\r\n\t\t\tfor ( var j = 0, jl = targets0.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tif ( ! isObjectEqual( targets0[ j ], targets[ j ] ) ) { return false; }\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfunction GLTFParser( json, extensions, options ) {\r\n\r\n\t\tthis.json = json || {};\r\n\t\tthis.extensions = extensions || {};\r\n\t\tthis.options = options || {};\r\n\r\n\t\t// loader object cache\r\n\t\tthis.cache = new GLTFRegistry();\r\n\r\n\t\t// BufferGeometry caching\r\n\t\tthis.primitiveCache = [];\r\n\t\tthis.multiplePrimitivesCache = [];\r\n\t\tthis.multiPassGeometryCache = [];\r\n\r\n\t\tthis.textureLoader = new TextureLoader( this.options.manager );\r\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\r\n\r\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\r\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\r\n\r\n\t}\r\n\r\n\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\t// Clear the loader cache\r\n\t\tthis.cache.removeAll();\r\n\r\n\t\t// Mark the special nodes/meshes in json for efficient parse\r\n\t\tthis.markDefs();\r\n\r\n\t\t// Fire the callback on complete\r\n\t\tthis.getMultiDependencies( [\r\n\r\n\t\t\t'scene',\r\n\t\t\t'animation',\r\n\t\t\t'camera'\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tvar scenes = dependencies.scenes || [];\r\n\t\t\tvar scene = scenes[ json.scene || 0 ];\r\n\t\t\tvar animations = dependencies.animations || [];\r\n\t\t\tvar cameras = dependencies.cameras || [];\r\n\r\n\t\t\tonLoad( scene, scenes, cameras, animations, json );\r\n\r\n\t\t} ).catch( onError );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.markDefs = function () {\r\n\r\n\t\tvar nodeDefs = this.json.nodes || [];\r\n\t\tvar skinDefs = this.json.skins || [];\r\n\t\tvar meshDefs = this.json.meshes || [];\r\n\r\n\t\tvar meshReferences = {};\r\n\t\tvar meshUses = {};\r\n\r\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\r\n\t\t// Object3D. Use the skins' joint references to mark bones.\r\n\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\r\n\r\n\t\t\tvar joints = skinDefs[ skinIndex ].joints;\r\n\r\n\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Meshes can (and should) be reused by multiple nodes in a glTF asset. To\r\n\t\t// avoid having more than one Mesh with the same name, count\r\n\t\t// references and rename instances below.\r\n\t\t//\r\n\t\t// Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\r\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\r\n\r\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\r\n\r\n\t\t\tif ( nodeDef.mesh !== undefined ) {\r\n\r\n\t\t\t\tif ( meshReferences[ nodeDef.mesh ] === undefined ) {\r\n\r\n\t\t\t\t\tmeshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmeshReferences[ nodeDef.mesh ] ++;\r\n\r\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\r\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\r\n\t\t\t\t// to mark SkinnedMesh if node has skin.\r\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\r\n\r\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.json.meshReferences = meshReferences;\r\n\t\tthis.json.meshUses = meshUses;\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.getDependency = function ( type, index ) {\r\n\r\n\t\tvar cacheKey = type + ':' + index;\r\n\t\tvar dependency = this.cache.get( cacheKey );\r\n\r\n\t\tif ( ! dependency ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 'scene':\r\n\t\t\t\t\tdependency = this.loadScene( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'node':\r\n\t\t\t\t\tdependency = this.loadNode( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'mesh':\r\n\t\t\t\t\tdependency = this.loadMesh( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'accessor':\r\n\t\t\t\t\tdependency = this.loadAccessor( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'bufferView':\r\n\t\t\t\t\tdependency = this.loadBufferView( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'buffer':\r\n\t\t\t\t\tdependency = this.loadBuffer( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'material':\r\n\t\t\t\t\tdependency = this.loadMaterial( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'texture':\r\n\t\t\t\t\tdependency = this.loadTexture( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'skin':\r\n\t\t\t\t\tdependency = this.loadSkin( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'animation':\r\n\t\t\t\t\tdependency = this.loadAnimation( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'camera':\r\n\t\t\t\t\tdependency = this.loadCamera( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.cache.add( cacheKey, dependency );\r\n\r\n\t\t}\r\n\r\n\t\treturn dependency;\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.getDependencies = function ( type ) {\r\n\r\n\t\tvar dependencies = this.cache.get( type );\r\n\r\n\t\tif ( ! dependencies ) {\r\n\r\n\t\t\tvar parser = this;\r\n\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\r\n\r\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\r\n\r\n\t\t\t\treturn parser.getDependency( type, index );\r\n\r\n\t\t\t} ) );\r\n\r\n\t\t\tthis.cache.add( type, dependencies );\r\n\r\n\t\t}\r\n\r\n\t\treturn dependencies;\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.getMultiDependencies = function ( types ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar results = {};\r\n\t\tvar pendings = [];\r\n\r\n\t\tfor ( var i = 0, il = types.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar type = types[ i ];\r\n\t\t\tvar value = this$1.getDependencies( type );\r\n\r\n\t\t\tvalue = value.then( function ( key, value ) {\r\n\r\n\t\t\t\tresults[ key ] = value;\r\n\r\n\t\t\t}.bind( this$1, type + ( type === 'mesh' ? 'es' : 's' ) ) );\r\n\r\n\t\t\tpendings.push( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pendings ).then( function () {\r\n\r\n\t\t\treturn results;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\r\n\r\n\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\r\n\t\tvar loader = this.fileLoader;\r\n\r\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\r\n\r\n\t\t\tthrow new Error( 'GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\t// If present, GLB container is required to be the first buffer.\r\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\r\n\r\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\r\n\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\r\n\r\n\t\t\t\treject( new Error( 'GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\r\n\r\n\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\r\n\r\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\r\n\r\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\r\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\r\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\r\n\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\r\n\r\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\r\n\r\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\r\n\t\t\t// information about attributes coming from another source (e.g. Draco\r\n\t\t\t// compression extension).\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar pendingBufferViews = [];\r\n\r\n\t\tif ( accessorDef.bufferView !== undefined ) {\r\n\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tpendingBufferViews.push( null );\r\n\r\n\t\t}\r\n\r\n\t\tif ( accessorDef.sparse !== undefined ) {\r\n\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\r\n\r\n\t\t\tvar bufferView = bufferViews[ 0 ];\r\n\r\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\r\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\r\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\r\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\r\n\t\t\tvar itemBytes = elementBytes * itemSize;\r\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\r\n\t\t\tvar byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\r\n\t\t\tvar normalized = accessorDef.normalized === true;\r\n\t\t\tvar array, bufferAttribute;\r\n\r\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\r\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\r\n\r\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;\r\n\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\r\n\r\n\t\t\t\tif ( ! ib ) {\r\n\r\n\t\t\t\t\t// Use the full buffer if it's interleaved.\r\n\t\t\t\t\tarray = new TypedArray( bufferView );\r\n\r\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\r\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\r\n\r\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, byteOffset / elementBytes, normalized );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( bufferView === null ) {\r\n\r\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\r\n\t\t\tif ( accessorDef.sparse !== undefined ) {\r\n\r\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\r\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\r\n\r\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\r\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\r\n\r\n\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\r\n\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\r\n\r\n\t\t\t\tif ( bufferView !== null ) {\r\n\r\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\r\n\t\t\t\t\tbufferAttribute.setArray( bufferAttribute.array.slice() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar index = sparseIndices[ i ];\r\n\r\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\r\n\t\t\t\t\tif ( itemSize >= 2 ) { bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] ); }\r\n\t\t\t\t\tif ( itemSize >= 3 ) { bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] ); }\r\n\t\t\t\t\tif ( itemSize >= 4 ) { bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] ); }\r\n\t\t\t\t\tif ( itemSize >= 5 ) { throw new Error( 'GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' ); }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn bufferAttribute;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadTexture = function ( textureIndex ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar options = this.options;\r\n\t\tvar textureLoader = this.textureLoader;\r\n\r\n\t\tvar URL = window.URL || window.webkitURL;\r\n\r\n\t\tvar textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tvar textureExtensions = textureDef.extensions || {};\r\n\r\n\t\tvar source;\r\n\r\n\t\tif ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {\r\n\r\n\t\t\tsource = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsource = json.images[ textureDef.source ];\r\n\r\n\t\t}\r\n\r\n\t\tvar sourceURI = source.uri;\r\n\t\tvar isObjectURL = false;\r\n\r\n\t\tif ( source.bufferView !== undefined ) {\r\n\r\n\t\t\t// Load binary image data from bufferView, if provided.\r\n\r\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\r\n\r\n\t\t\t\tisObjectURL = true;\r\n\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\r\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\r\n\t\t\t\treturn sourceURI;\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\r\n\r\n\t\t\t// Load Texture resource.\r\n\r\n\t\t\tvar loader = Loader$1.Handlers.get( sourceURI );\r\n\r\n\t\t\tif ( ! loader ) {\r\n\r\n\t\t\t\tloader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ]\r\n\t\t\t\t\t? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader\r\n\t\t\t\t\t: textureLoader;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} ).then( function ( texture ) {\r\n\r\n\t\t\t// Clean up resources and configure Texture.\r\n\r\n\t\t\tif ( isObjectURL === true ) {\r\n\r\n\t\t\t\tURL.revokeObjectURL( sourceURI );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.flipY = false;\r\n\r\n\t\t\tif ( textureDef.name !== undefined ) { texture.name = textureDef.name; }\r\n\r\n\t\t\t// Ignore unknown mime types, like DDS files.\r\n\t\t\tif ( source.mimeType in MIME_TYPE_FORMATS ) {\r\n\r\n\t\t\t\ttexture.format = MIME_TYPE_FORMATS[ source.mimeType ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar samplers = json.samplers || {};\r\n\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\r\n\r\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\r\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipMapLinearFilter;\r\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\r\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.assignTexture = function ( materialParams, textureName, textureIndex ) {\r\n\r\n\t\treturn this.getDependency( 'texture', textureIndex ).then( function ( texture ) {\r\n\r\n\t\t\tmaterialParams[ textureName ] = texture;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar materialDef = json.materials[ materialIndex ];\r\n\r\n\t\tvar materialType;\r\n\t\tvar materialParams = {};\r\n\t\tvar materialExtensions = materialDef.extensions || {};\r\n\r\n\t\tvar pending = [];\r\n\r\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\r\n\r\n\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\r\n\t\t\tmaterialType = sgExtension.getMaterialType( materialDef );\r\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\r\n\r\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\r\n\r\n\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\r\n\t\t\tmaterialType = kmuExtension.getMaterialType( materialDef );\r\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Specification:\r\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\r\n\r\n\t\t\tmaterialType = MeshStandardMaterial;\r\n\r\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\r\n\r\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\r\n\t\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\r\n\r\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\r\n\r\n\t\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture.index ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\r\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\r\n\r\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\r\n\r\n\t\t\t\tvar textureIndex = metallicRoughness.metallicRoughnessTexture.index;\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', textureIndex ) );\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', textureIndex ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.doubleSided === true ) {\r\n\r\n\t\t\tmaterialParams.side = DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\r\n\r\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\r\n\r\n\t\t\tmaterialParams.transparent = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterialParams.transparent = false;\r\n\r\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\r\n\r\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture.index ) );\r\n\r\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\r\n\r\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\r\n\r\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture.index ) );\r\n\r\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\r\n\r\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tmaterialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture.index ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\t\tvar material;\r\n\r\n\t\t\tif ( materialType === ShaderMaterial ) {\r\n\r\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial = new materialType( materialParams );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( materialDef.name !== undefined ) { material.name = materialDef.name; }\r\n\r\n\t\t\t// Normal map textures use OpenGL conventions:\r\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture\r\n\t\t\tif ( material.normalScale ) {\r\n\r\n\t\t\t\tmaterial.normalScale.y = - material.normalScale.y;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\r\n\t\t\tif ( material.map ) { material.map.encoding = sRGBEncoding; }\r\n\t\t\tif ( material.emissiveMap ) { material.emissiveMap.encoding = sRGBEncoding; }\r\n\t\t\tif ( material.specularMap ) { material.specularMap.encoding = sRGBEncoding; }\r\n\r\n\t\t\tassignExtrasToUserData( material, materialDef );\r\n\r\n\t\t\tif ( materialDef.extensions ) { addUnknownExtensionsToUserData( extensions, material, materialDef ); }\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tfunction addPrimitiveAttributes( geometry, primitiveDef, accessors ) {\r\n\r\n\t\tvar attributes = primitiveDef.attributes;\r\n\r\n\t\tfor ( var gltfAttributeName in attributes ) {\r\n\r\n\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ];\r\n\t\t\tvar bufferAttribute = accessors[ attributes[ gltfAttributeName ] ];\r\n\r\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\r\n\t\t\tif ( ! threeAttributeName ) { continue; }\r\n\t\t\tif ( threeAttributeName in geometry.attributes ) { continue; }\r\n\r\n\t\t\tgeometry.addAttribute( threeAttributeName, bufferAttribute );\r\n\r\n\t\t}\r\n\r\n\t\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\r\n\r\n\t\t\tgeometry.setIndex( accessors[ primitiveDef.indices ] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( primitiveDef.targets !== undefined ) {\r\n\r\n\t\t\taddMorphTargets( geometry, primitiveDef.targets, accessors );\r\n\r\n\t\t}\r\n\r\n\t\tassignExtrasToUserData( geometry, primitiveDef );\r\n\r\n\t}\r\n\t\r\n\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\r\n\r\n\t\tvar parser = this;\r\n\t\tvar extensions = this.extensions;\r\n\t\tvar cache = this.primitiveCache;\r\n\r\n\t\tvar isMultiPass = isMultiPassGeometry( primitives );\r\n\t\tvar originalPrimitives;\r\n\r\n\t\tif ( isMultiPass ) {\r\n\r\n\t\t\toriginalPrimitives = primitives; // save original primitives and use later\r\n\r\n\t\t\t// We build a single BufferGeometry with .groups from multiple primitives\r\n\t\t\t// because all primitives share the same attributes/morph/mode and have indices.\r\n\r\n\t\t\tprimitives = [ primitives[ 0 ] ];\r\n\r\n\t\t\t// Sets .groups and combined indices to a geometry later in this method.\r\n\r\n\t\t}\r\n\r\n\t\treturn this.getDependencies( 'accessor' ).then( function ( accessors ) {\r\n\r\n\t\t\tvar pending = [];\r\n\r\n\t\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar primitive = primitives[ i ];\r\n\r\n\t\t\t\t// See if we've already created this geometry\r\n\t\t\t\tvar cached = getCachedGeometry( cache, primitive );\r\n\r\n\t\t\t\tif ( cached ) {\r\n\r\n\t\t\t\t\t// Use the cached geometry if it exists\r\n\t\t\t\t\tpending.push( cached );\r\n\r\n\t\t\t\t} else if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\r\n\r\n\t\t\t\t\t// Use DRACO geometry if available\r\n\t\t\t\t\tvar geometryPromise = extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\r\n\t\t\t\t\t\t.decodePrimitive( primitive, parser )\r\n\t\t\t\t\t\t.then( function ( geometry ) {\r\n\r\n\t\t\t\t\t\t\taddPrimitiveAttributes( geometry, primitive, accessors );\r\n\r\n\t\t\t\t\t\t\treturn geometry;\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tcache.push( { primitive: primitive, promise: geometryPromise } );\r\n\r\n\t\t\t\t\tpending.push( geometryPromise );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Otherwise create a new geometry\r\n\t\t\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\t\t\taddPrimitiveAttributes( geometry, primitive, accessors );\r\n\r\n\t\t\t\t\tvar geometryPromise = Promise.resolve( geometry );\r\n\r\n\t\t\t\t\t// Cache this geometry\r\n\t\t\t\t\tcache.push( { primitive: primitive, promise: geometryPromise } );\r\n\r\n\t\t\t\t\tpending.push( geometryPromise );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all( pending ).then( function ( geometries ) {\r\n\r\n\t\t\t\tif ( isMultiPass ) {\r\n\r\n\t\t\t\t\tvar baseGeometry = geometries[ 0 ];\r\n\r\n\t\t\t\t\t// See if we've already created this combined geometry\r\n\t\t\t\t\tvar cache = parser.multiPassGeometryCache;\r\n\t\t\t\t\tvar cached = getCachedMultiPassGeometry( cache, baseGeometry, originalPrimitives );\r\n\r\n\t\t\t\t\tif ( cached !== null ) { return [ cached.geometry ]; }\r\n\r\n\t\t\t\t\t// Cloning geometry because of index override.\r\n\t\t\t\t\t// Attributes can be reused so cloning by myself here.\r\n\t\t\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\t\t\tgeometry.name = baseGeometry.name;\r\n\t\t\t\t\tgeometry.userData = baseGeometry.userData;\r\n\r\n\t\t\t\t\tfor ( var key in baseGeometry.attributes ) { geometry.addAttribute( key, baseGeometry.attributes[ key ] ); }\r\n\t\t\t\t\tfor ( var key in baseGeometry.morphAttributes ) { geometry.morphAttributes[ key ] = baseGeometry.morphAttributes[ key ]; }\r\n\r\n\t\t\t\t\tvar indices = [];\r\n\t\t\t\t\tvar offset = 0;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = originalPrimitives.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar accessor = accessors[ originalPrimitives[ i ].indices ];\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = accessor.count; j < jl; j ++ ) { indices.push( accessor.array[ j ] ); }\r\n\r\n\t\t\t\t\t\tgeometry.addGroup( offset, accessor.count, i );\r\n\r\n\t\t\t\t\t\toffset += accessor.count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.setIndex( indices );\r\n\r\n\t\t\t\t\tcache.push( { geometry: geometry, baseGeometry: baseGeometry, primitives: originalPrimitives } );\r\n\r\n\t\t\t\t\treturn [ geometry ];\r\n\r\n\t\t\t\t} else if ( geometries.length > 1 && BufferGeometryUtils !== undefined ) {\r\n\r\n\t\t\t\t\t// Tries to merge geometries with BufferGeometryUtils if possible\r\n\r\n\t\t\t\t\tfor ( var i = 1, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t// can't merge if draw mode is different\r\n\t\t\t\t\t\tif ( primitives[ 0 ].mode !== primitives[ i ].mode ) { return geometries; }\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// See if we've already created this combined geometry\r\n\t\t\t\t\tvar cache = parser.multiplePrimitivesCache;\r\n\t\t\t\t\tvar cached = getCachedCombinedGeometry( cache, geometries );\r\n\r\n\t\t\t\t\tif ( cached ) {\r\n\r\n\t\t\t\t\t\tif ( cached.geometry !== null ) { return [ cached.geometry ]; }\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar geometry = BufferGeometryUtils.mergeBufferGeometries( geometries, true );\r\n\r\n\t\t\t\t\t\tcache.push( { geometry: geometry, baseGeometries: geometries } );\r\n\r\n\t\t\t\t\t\tif ( geometry !== null ) { return [ geometry ]; }\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn geometries;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\r\n\t\tvar meshDef = json.meshes[ meshIndex ];\r\n\r\n\t\treturn this.getMultiDependencies( [\r\n\r\n\t\t\t'accessor',\r\n\t\t\t'material'\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tvar primitives = meshDef.primitives;\r\n\t\t\tvar originalMaterials = [];\r\n\r\n\t\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\t\toriginalMaterials[ i ] = primitives[ i ].material === undefined\r\n\t\t\t\t\t? createDefaultMaterial()\r\n\t\t\t\t\t: dependencies.materials[ primitives[ i ].material ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn scope.loadGeometries( primitives ).then( function ( geometries ) {\r\n\r\n\t\t\t\tvar isMultiMaterial = geometries.length === 1 && geometries[ 0 ].groups.length > 0;\r\n\r\n\t\t\t\tvar meshes = [];\r\n\r\n\t\t\t\tfor ( var i = 0, il = geometries.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar geometry = geometries[ i ];\r\n\t\t\t\t\tvar primitive = primitives[ i ];\r\n\r\n\t\t\t\t\t// 1. create Mesh\r\n\r\n\t\t\t\t\tvar mesh;\r\n\r\n\t\t\t\t\tvar material = isMultiMaterial ? originalMaterials : originalMaterials[ i ];\r\n\r\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\r\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\r\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\r\n\t\t\t\t\t\tprimitive.mode === undefined ) {\r\n\r\n\t\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See .markDefs()\r\n\t\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\r\n\t\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\r\n\t\t\t\t\t\t\t: new Mesh( geometry, material );\r\n\r\n\t\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\r\n\r\n\t\t\t\t\t\t\tmesh.drawMode = TriangleStripDrawMode;\r\n\r\n\t\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\r\n\r\n\t\t\t\t\t\t\tmesh.drawMode = TriangleFanDrawMode;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\r\n\r\n\t\t\t\t\t\tmesh = new LineSegments( geometry, material );\r\n\r\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\r\n\r\n\t\t\t\t\t\tmesh = new Line( geometry, material );\r\n\r\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\r\n\r\n\t\t\t\t\t\tmesh = new LineLoop( geometry, material );\r\n\r\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\r\n\r\n\t\t\t\t\t\tmesh = new Points( geometry, material );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthrow new Error( 'GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\r\n\r\n\t\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmesh.name = meshDef.name || ( 'mesh_' + meshIndex );\r\n\r\n\t\t\t\t\tif ( geometries.length > 1 ) { mesh.name += '_' + i; }\r\n\r\n\t\t\t\t\tassignExtrasToUserData( mesh, meshDef );\r\n\r\n\t\t\t\t\tmeshes.push( mesh );\r\n\r\n\t\t\t\t\t// 2. update Material depending on Mesh and BufferGeometry\r\n\r\n\t\t\t\t\tvar materials = isMultiMaterial ? mesh.material : [ mesh.material ];\r\n\r\n\t\t\t\t\tvar useVertexColors = geometry.attributes.color !== undefined;\r\n\t\t\t\t\tvar useFlatShading = geometry.attributes.normal === undefined;\r\n\t\t\t\t\tvar useSkinning = mesh.isSkinnedMesh === true;\r\n\t\t\t\t\tvar useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\r\n\t\t\t\t\tvar useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = materials.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar material = materials[ j ];\r\n\r\n\t\t\t\t\t\tif ( mesh.isPoints ) {\r\n\r\n\t\t\t\t\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\r\n\r\n\t\t\t\t\t\t\tvar pointsMaterial = scope.cache.get( cacheKey );\r\n\r\n\t\t\t\t\t\t\tif ( ! pointsMaterial ) {\r\n\r\n\t\t\t\t\t\t\t\tpointsMaterial = new PointsMaterial();\r\n\t\t\t\t\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\r\n\t\t\t\t\t\t\t\tpointsMaterial.color.copy( material.color );\r\n\t\t\t\t\t\t\t\tpointsMaterial.map = material.map;\r\n\t\t\t\t\t\t\t\tpointsMaterial.lights = false; // PointsMaterial doesn't support lights yet\r\n\r\n\t\t\t\t\t\t\t\tscope.cache.add( cacheKey, pointsMaterial );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmaterial = pointsMaterial;\r\n\r\n\t\t\t\t\t\t} else if ( mesh.isLine ) {\r\n\r\n\t\t\t\t\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\r\n\r\n\t\t\t\t\t\t\tvar lineMaterial = scope.cache.get( cacheKey );\r\n\r\n\t\t\t\t\t\t\tif ( ! lineMaterial ) {\r\n\r\n\t\t\t\t\t\t\t\tlineMaterial = new LineBasicMaterial();\r\n\t\t\t\t\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\r\n\t\t\t\t\t\t\t\tlineMaterial.color.copy( material.color );\r\n\t\t\t\t\t\t\t\tlineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet\r\n\r\n\t\t\t\t\t\t\t\tscope.cache.add( cacheKey, lineMaterial );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmaterial = lineMaterial;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Clone the material if it will be modified\r\n\t\t\t\t\t\tif ( useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\r\n\r\n\t\t\t\t\t\t\tvar cacheKey = 'ClonedMaterial:' + material.uuid + ':';\r\n\r\n\t\t\t\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) { cacheKey += 'specular-glossiness:'; }\r\n\t\t\t\t\t\t\tif ( useSkinning ) { cacheKey += 'skinning:'; }\r\n\t\t\t\t\t\t\tif ( useVertexColors ) { cacheKey += 'vertex-colors:'; }\r\n\t\t\t\t\t\t\tif ( useFlatShading ) { cacheKey += 'flat-shading:'; }\r\n\t\t\t\t\t\t\tif ( useMorphTargets ) { cacheKey += 'morph-targets:'; }\r\n\t\t\t\t\t\t\tif ( useMorphNormals ) { cacheKey += 'morph-normals:'; }\r\n\r\n\t\t\t\t\t\t\tvar cachedMaterial = scope.cache.get( cacheKey );\r\n\r\n\t\t\t\t\t\t\tif ( ! cachedMaterial ) {\r\n\r\n\t\t\t\t\t\t\t\tcachedMaterial = material.isGLTFSpecularGlossinessMaterial\r\n\t\t\t\t\t\t\t\t\t? extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].cloneMaterial( material )\r\n\t\t\t\t\t\t\t\t\t: material.clone();\r\n\r\n\t\t\t\t\t\t\t\tif ( useSkinning ) { cachedMaterial.skinning = true; }\r\n\t\t\t\t\t\t\t\tif ( useVertexColors ) { cachedMaterial.vertexColors = VertexColors; }\r\n\t\t\t\t\t\t\t\tif ( useFlatShading ) { cachedMaterial.flatShading = true; }\r\n\t\t\t\t\t\t\t\tif ( useMorphTargets ) { cachedMaterial.morphTargets = true; }\r\n\t\t\t\t\t\t\t\tif ( useMorphNormals ) { cachedMaterial.morphNormals = true; }\r\n\r\n\t\t\t\t\t\t\t\tscope.cache.add( cacheKey, cachedMaterial );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmaterial = cachedMaterial;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmaterials[ j ] = material;\r\n\r\n\t\t\t\t\t\t// workarounds for mesh and geometry\r\n\r\n\t\t\t\t\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tconsole.log( 'GLTFLoader: Duplicating UVs to support aoMap.' );\r\n\t\t\t\t\t\t\tgeometry.addAttribute( 'uv2', new BufferAttribute( geometry.attributes.uv.array, 2 ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) {\r\n\r\n\t\t\t\t\t\t\t// for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update\r\n\t\t\t\t\t\t\tmesh.onBeforeRender = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].refreshUniforms;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmesh.material = isMultiMaterial ? materials : materials[ 0 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( meshes.length === 1 ) {\r\n\r\n\t\t\t\t\treturn meshes[ 0 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar group = new Group();\r\n\r\n\t\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tgroup.add( meshes[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn group;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\r\n\r\n\t\tvar camera;\r\n\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\r\n\t\tvar params = cameraDef[ cameraDef.type ];\r\n\r\n\t\tif ( ! params ) {\r\n\r\n\t\t\tconsole.warn( 'GLTFLoader: Missing camera parameters.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( cameraDef.type === 'perspective' ) {\r\n\r\n\t\t\tcamera = new PerspectiveCamera( _Math.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\r\n\r\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\r\n\r\n\t\t\tcamera = new OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cameraDef.name !== undefined ) { camera.name = cameraDef.name; }\r\n\r\n\t\tassignExtrasToUserData( camera, cameraDef );\r\n\r\n\t\treturn Promise.resolve( camera );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\r\n\r\n\t\tvar skinDef = this.json.skins[ skinIndex ];\r\n\r\n\t\tvar skinEntry = { joints: skinDef.joints };\r\n\r\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\r\n\r\n\t\t\treturn Promise.resolve( skinEntry );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\r\n\r\n\t\t\tskinEntry.inverseBindMatrices = accessor;\r\n\r\n\t\t\treturn skinEntry;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\r\n\r\n\t\tvar json = this.json;\r\n\r\n\t\tvar animationDef = json.animations[ animationIndex ];\r\n\r\n\t\treturn this.getMultiDependencies( [\r\n\r\n\t\t\t'accessor',\r\n\t\t\t'node'\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar channel = animationDef.channels[ i ];\r\n\t\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\r\n\r\n\t\t\t\tif ( sampler ) {\r\n\r\n\t\t\t\t\tvar target = channel.target;\r\n\t\t\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\r\n\t\t\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\r\n\t\t\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\r\n\r\n\t\t\t\t\tvar inputAccessor = dependencies.accessors[ input ];\r\n\t\t\t\t\tvar outputAccessor = dependencies.accessors[ output ];\r\n\r\n\t\t\t\t\tvar node = dependencies.nodes[ name ];\r\n\r\n\t\t\t\t\tif ( node ) {\r\n\r\n\t\t\t\t\t\tnode.updateMatrix();\r\n\t\t\t\t\t\tnode.matrixAutoUpdate = true;\r\n\r\n\t\t\t\t\t\tvar TypedKeyframeTrack;\r\n\r\n\t\t\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\r\n\r\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.weights:\r\n\r\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.rotation:\r\n\r\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack$1;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.position:\r\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.scale:\r\n\t\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack$1;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\r\n\r\n\t\t\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\r\n\r\n\t\t\t\t\t\tvar targetNames = [];\r\n\r\n\t\t\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\r\n\r\n\t\t\t\t\t\t\t// node can be Group here but\r\n\t\t\t\t\t\t\t// PATH_PROPERTIES.weights(morphTargetInfluences) should be\r\n\t\t\t\t\t\t\t// the property of a mesh object under group.\r\n\r\n\t\t\t\t\t\t\tnode.traverse( function ( object ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttargetNames.push( targetName );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// KeyframeTrack.optimize() will modify given 'times' and 'values'\r\n\t\t\t\t\t\t// buffers before creating a truncated copy to keep. Because buffers may\r\n\t\t\t\t\t\t// be reused by other tracks, make copies here.\r\n\t\t\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar track = new TypedKeyframeTrack(\r\n\t\t\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\r\n\t\t\t\t\t\t\t\tAnimationUtils.arraySlice( inputAccessor.array, 0 ),\r\n\t\t\t\t\t\t\t\tAnimationUtils.arraySlice( outputAccessor.array, 0 ),\r\n\t\t\t\t\t\t\t\tinterpolation\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t// Here is the trick to enable custom interpolation.\r\n\t\t\t\t\t\t\t// Overrides .createInterpolant in a factory method which creates custom interpolation.\r\n\t\t\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\r\n\r\n\t\t\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\r\n\r\n\t\t\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\r\n\t\t\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\r\n\t\t\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\r\n\r\n\t\t\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\r\n\r\n\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t// Workaround, provide an alternate way to know if the interpolant type is cubis spline to track.\r\n\t\t\t\t\t\t\t\t// track.getInterpolation() doesn't return valid value for custom interpolant.\r\n\t\t\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttracks.push( track );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\r\n\r\n\t\t\treturn new AnimationClip( name, undefined, tracks );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\r\n\r\n\t\tvar json = this.json;\r\n\t\tvar extensions = this.extensions;\r\n\r\n\t\tvar meshReferences = json.meshReferences;\r\n\t\tvar meshUses = json.meshUses;\r\n\r\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\r\n\r\n\t\treturn this.getMultiDependencies( [\r\n\r\n\t\t\t'mesh',\r\n\t\t\t'skin',\r\n\t\t\t'camera',\r\n\t\t\t'light'\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tvar node;\r\n\r\n\t\t\t// .isBone isn't in glTF spec. See .markDefs\r\n\t\t\tif ( nodeDef.isBone === true ) {\r\n\r\n\t\t\t\tnode = new Bone();\r\n\r\n\t\t\t} else if ( nodeDef.mesh !== undefined ) {\r\n\r\n\t\t\t\tvar mesh = dependencies.meshes[ nodeDef.mesh ];\r\n\r\n\t\t\t\tif ( meshReferences[ nodeDef.mesh ] > 1 ) {\r\n\r\n\t\t\t\t\tvar instanceNum = meshUses[ nodeDef.mesh ] ++;\r\n\r\n\t\t\t\t\tnode = mesh.clone();\r\n\t\t\t\t\tnode.name += '_instance_' + instanceNum;\r\n\r\n\t\t\t\t\t// onBeforeRender copy for Specular-Glossiness\r\n\t\t\t\t\tnode.onBeforeRender = mesh.onBeforeRender;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = node.children.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tnode.children[ i ].name += '_instance_' + instanceNum;\r\n\t\t\t\t\t\tnode.children[ i ].onBeforeRender = mesh.children[ i ].onBeforeRender;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnode = mesh;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( nodeDef.camera !== undefined ) {\r\n\r\n\t\t\t\tnode = dependencies.cameras[ nodeDef.camera ];\r\n\r\n\t\t\t} else if ( nodeDef.extensions\r\n\t\t\t\t\t && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ]\r\n\t\t\t\t\t && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light !== undefined ) {\r\n\r\n\t\t\t\tvar lights = extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].lights;\r\n\t\t\t\tnode = lights[ nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode = new Object3D();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.name !== undefined ) {\r\n\r\n\t\t\t\tnode.name = PropertyBinding.sanitizeNodeName( nodeDef.name );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tassignExtrasToUserData( node, nodeDef );\r\n\r\n\t\t\tif ( nodeDef.extensions ) { addUnknownExtensionsToUserData( extensions, node, nodeDef ); }\r\n\r\n\t\t\tif ( nodeDef.matrix !== undefined ) {\r\n\r\n\t\t\t\tvar matrix = new Matrix4();\r\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\r\n\t\t\t\tnode.applyMatrix( matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\r\n\r\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\r\n\r\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\r\n\r\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\t\r\n\tGLTFParser.prototype.loadScene = function () {\r\n\r\n\t\t// scene node hierachy builder\r\n\r\n\t\tfunction buildNodeHierachy( nodeId, parentObject, json, allNodes, skins ) {\r\n\r\n\t\t\tvar node = allNodes[ nodeId ];\r\n\t\t\tvar nodeDef = json.nodes[ nodeId ];\r\n\r\n\t\t\t// build skeleton here as well\r\n\r\n\t\t\tif ( nodeDef.skin !== undefined ) {\r\n\r\n\t\t\t\tvar meshes = node.isGroup === true ? node.children : [ node ];\r\n\r\n\t\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar mesh = meshes[ i ];\r\n\t\t\t\t\tvar skinEntry = skins[ nodeDef.skin ];\r\n\r\n\t\t\t\t\tvar bones = [];\r\n\t\t\t\t\tvar boneInverses = [];\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = skinEntry.joints.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar jointId = skinEntry.joints[ j ];\r\n\t\t\t\t\t\tvar jointNode = allNodes[ jointId ];\r\n\r\n\t\t\t\t\t\tif ( jointNode ) {\r\n\r\n\t\t\t\t\t\t\tbones.push( jointNode );\r\n\r\n\t\t\t\t\t\t\tvar mat = new Matrix4();\r\n\r\n\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tboneInverses.push( mat );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( 'GLTFLoader: Joint \"%s\" could not be found.', jointId );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// build node hierachy\r\n\r\n\t\t\tparentObject.add( node );\r\n\r\n\t\t\tif ( nodeDef.children ) {\r\n\r\n\t\t\t\tvar children = nodeDef.children;\r\n\r\n\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar child = children[ i ];\r\n\t\t\t\t\tbuildNodeHierachy( child, node, json, allNodes, skins );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn function loadScene( sceneIndex ) {\r\n\r\n\t\t\tvar json = this.json;\r\n\t\t\tvar extensions = this.extensions;\r\n\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\r\n\r\n\t\t\treturn this.getMultiDependencies( [\r\n\r\n\t\t\t\t'node',\r\n\t\t\t\t'skin'\r\n\r\n\t\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\t\tvar scene = new Scene();\r\n\t\t\t\tif ( sceneDef.name !== undefined ) { scene.name = sceneDef.name; }\r\n\r\n\t\t\t\tassignExtrasToUserData( scene, sceneDef );\r\n\r\n\t\t\t\tif ( sceneDef.extensions ) { addUnknownExtensionsToUserData( extensions, scene, sceneDef ); }\r\n\r\n\t\t\t\tvar nodeIds = sceneDef.nodes || [];\r\n\r\n\t\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tbuildNodeHierachy( nodeIds[ i ], scene, json, dependencies.nodes, dependencies.skins );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn scene;\r\n\r\n\t\t\t} );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\treturn GLTFLoader;\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// https://github.com/mrdoob/three.js/issues/5552\r\n// http://en.wikipedia.org/wiki/RGBE_image_format\r\n\r\nvar RGBELoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\n// extend DataTextureLoader\r\nRGBELoader.prototype = Object.create( DataTextureLoader.prototype );\r\n\r\n// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\r\nRGBELoader.prototype._parser = function ( buffer ) {\r\n\r\n\tvar \r\n\t\t\r\n\t\tRGBE_RETURN_FAILURE = - 1,\r\n\t\t\r\n\t\trgbe_read_error = 1,\r\n\t\trgbe_write_error = 2,\r\n\t\trgbe_format_error = 3,\r\n\t\trgbe_memory_error = 4,\r\n\t\trgbe_error = function ( rgbe_error_code, msg ) {\r\n\r\n\t\t\tswitch ( rgbe_error_code ) {\r\n\r\n\t\t\t\tcase rgbe_read_error: console.error( \"RGBELoader Read Error: \" + ( msg || '' ) );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase rgbe_write_error: console.error( \"RGBELoader Write Error: \" + ( msg || '' ) );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase rgbe_format_error: console.error( \"RGBELoader Bad File Format: \" + ( msg || '' ) );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\tcase rgbe_memory_error: console.error( \"RGBELoader: Error: \" + ( msg || '' ) );\r\n\r\n\t\t\t}\r\n\t\t\treturn RGBE_RETURN_FAILURE;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tRGBE_VALID_PROGRAMTYPE = 1,\r\n\t\tRGBE_VALID_FORMAT = 2,\r\n\t\tRGBE_VALID_DIMENSIONS = 4,\r\n\r\n\t\tNEWLINE = \"\\n\",\r\n\r\n\t\tfgets = function ( buffer, lineLimit, consume ) {\r\n\r\n\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\r\n\t\t\tvar p = buffer.pos,\r\n\t\t\t\ti = - 1, len = 0, s = '', chunkSize = 128,\r\n\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) )\r\n\t\t\t;\r\n\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\r\n\r\n\t\t\t\ts += chunk; len += chunk.length;\r\n\t\t\t\tp += chunkSize;\r\n\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( - 1 < i ) {\r\n\t\t\t\t\r\n\t\t\t\tif ( false !== consume ) { buffer.pos += len + i + 1; }\r\n\t\t\t\treturn s + chunk.slice( 0, i );\r\n\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tRGBE_ReadHeader = function ( buffer ) {\r\n\r\n\t\t\tvar line, match,\r\n\r\n\t\t\t\t// regexes to parse header info fields\r\n\t\t\t\tmagic_token_re = /^#\\?(\\S+)$/,\r\n\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\r\n\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\r\n\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\r\n\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\r\n\r\n\t\t\t\t// RGBE format header struct\r\n\t\t\t\theader = {\r\n\r\n\t\t\t\t\tvalid: 0, \r\n\r\n\t\t\t\t\tstring: '', \r\n\r\n\t\t\t\t\tcomments: '', \r\n\r\n\t\t\t\t\tprogramtype: 'RGBE', \r\n\r\n\t\t\t\t\tformat: '', \r\n\r\n\t\t\t\t\tgamma: 1.0, \r\n\r\n\t\t\t\t\texposure: 1.0, \r\n\r\n\t\t\t\t\twidth: 0, height: 0 \r\n\r\n\t\t\t\t};\r\n\r\n\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\r\n\r\n\t\t\t\treturn rgbe_error( rgbe_read_error, \"no header found\" );\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\r\n\r\n\t\t\t\treturn rgbe_error( rgbe_format_error, \"bad initial token\" );\r\n\r\n\t\t\t}\r\n\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\r\n\t\t\theader.programtype = match[ 1 ];\r\n\t\t\theader.string += line + \"\\n\";\r\n\r\n\t\t\twhile ( true ) {\r\n\r\n\t\t\t\tline = fgets( buffer );\r\n\t\t\t\tif ( false === line ) { break; }\r\n\t\t\t\theader.string += line + \"\\n\";\r\n\r\n\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\r\n\r\n\t\t\t\t\theader.comments += line + \"\\n\";\r\n\t\t\t\t\tcontinue; // comment line\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( match = line.match( gamma_re ) ) {\r\n\r\n\t\t\t\t\theader.gamma = parseFloat( match[ 1 ], 10 );\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( match = line.match( exposure_re ) ) {\r\n\r\n\t\t\t\t\theader.exposure = parseFloat( match[ 1 ], 10 );\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( match = line.match( format_re ) ) {\r\n\r\n\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\r\n\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( match = line.match( dimensions_re ) ) {\r\n\r\n\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\r\n\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\r\n\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) { break; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\r\n\r\n\t\t\t\treturn rgbe_error( rgbe_format_error, \"missing format specifier\" );\r\n\r\n\t\t\t}\r\n\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\r\n\r\n\t\t\t\treturn rgbe_error( rgbe_format_error, \"missing image size specifier\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn header;\r\n\r\n\t\t},\r\n\r\n\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\r\n\r\n\t\t\tvar data_rgba, offset, pos, count, byteValue,\r\n\t\t\t\tscanline_buffer, ptr, ptr_end, i, l, off, isEncodedRun,\r\n\t\t\t\tscanline_width = w, num_scanlines = h, rgbeStart\r\n\t\t\t;\r\n\r\n\t\t\tif (\r\n\t\t\t\t// run length encoding is not allowed so read flat\r\n\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\r\n\t\t\t\t// this file is not run length encoded\r\n\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\r\n\t\t\t) {\r\n\r\n\t\t\t\t// return the flat buffer\r\n\t\t\t\treturn new Uint8Array( buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\r\n\r\n\t\t\t\treturn rgbe_error( rgbe_format_error, \"wrong scanline width\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdata_rgba = new Uint8Array( 4 * w * h );\r\n\r\n\t\t\tif ( ! data_rgba || ! data_rgba.length ) {\r\n\r\n\t\t\t\treturn rgbe_error( rgbe_memory_error, \"unable to allocate buffer space\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset = 0; pos = 0; ptr_end = 4 * scanline_width;\r\n\t\t\trgbeStart = new Uint8Array( 4 );\r\n\t\t\tscanline_buffer = new Uint8Array( ptr_end );\r\n\r\n\t\t\t// read in each successive scanline\r\n\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\r\n\r\n\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\r\n\r\n\t\t\t\t\treturn rgbe_error( rgbe_read_error );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\r\n\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\r\n\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\r\n\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\r\n\r\n\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\r\n\r\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"bad rgbe scanline format\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// read each of the four channels for the scanline into the buffer\r\n\t\t\t\t// first red, then green, then blue, then exponent\r\n\t\t\t\tptr = 0;\r\n\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\r\n\r\n\t\t\t\t\tcount = buffer[ pos ++ ];\r\n\t\t\t\t\tisEncodedRun = count > 128;\r\n\t\t\t\t\tif ( isEncodedRun ) { count -= 128; }\r\n\r\n\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\r\n\r\n\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, \"bad scanline data\" );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( isEncodedRun ) {\r\n\r\n\t\t\t\t\t\t// a (encoded) run of the same value\r\n\t\t\t\t\t\tbyteValue = buffer[ pos ++ ];\r\n\t\t\t\t\t\tfor ( i = 0; i < count; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//ptr += count;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// a literal-run\r\n\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\r\n\t\t\t\t\t\tptr += count; pos += count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// now convert data from buffer into rgba\r\n\t\t\t\t// first red, then green, then blue, then exponent (alpha)\r\n\t\t\t\tl = scanline_width; //scanline_buffer.byteLength;\r\n\t\t\t\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\t\t\t\toff = 0;\r\n\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\r\n\t\t\t\t\toff += scanline_width; //1;\r\n\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\r\n\t\t\t\t\toff += scanline_width; //1;\r\n\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\r\n\t\t\t\t\toff += scanline_width; //1;\r\n\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\r\n\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnum_scanlines --;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data_rgba;\r\n\r\n\t\t}\r\n\t;\r\n\r\n\tvar byteArray = new Uint8Array( buffer );\r\r\n\tbyteArray.pos = 0;\r\n\tvar rgbe_header_info = RGBE_ReadHeader( byteArray );\r\n\r\n\tif ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {\r\n\r\n\t\tvar w = rgbe_header_info.width,\r\n\t\t\th = rgbe_header_info.height,\r\n\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h )\r\n\t\t;\r\n\t\tif ( RGBE_RETURN_FAILURE !== image_rgba_data ) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\twidth: w, height: h,\r\n\t\t\t\tdata: image_rgba_data,\r\n\t\t\t\theader: rgbe_header_info.string,\r\n\t\t\t\tgamma: rgbe_header_info.gamma,\r\n\t\t\t\texposure: rgbe_header_info.exposure,\r\n\t\t\t\tformat: RGBEFormat, // handled as RGBAFormat in shaders\r\n\t\t\t\ttype: UnsignedByteType\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t}\r\n\treturn null;\r\n\r\n};\r\nvar HDRLoader = RGBELoader;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\r\n\r\n\timages = images !== undefined ? images : [];\r\n\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\r\n\r\n\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\r\n\tthis.flipY = false;\r\n\r\n}\r\n\r\nCubeTexture.prototype = Object.create( Texture.prototype );\r\nCubeTexture.prototype.constructor = CubeTexture;\r\n\r\nCubeTexture.prototype.isCubeTexture = true;\r\n\r\nObject.defineProperty( CubeTexture.prototype, 'images', {\r\n\r\n\tget: function () {\r\n\r\n\t\treturn this.image;\r\n\r\n\t},\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tthis.image = value;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar HDRCubeTextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\t// override in sub classes\r\n\tthis.hdrLoader = new RGBELoader();\r\n\r\n};\r\n\r\nHDRCubeTextureLoader.prototype.load = function ( type, urls, onLoad, onProgress, onError ) {\r\n\r\n\tvar RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\r\n\r\n\t\tvar e = sourceArray[ sourceOffset + 3 ];\r\n\t\tvar scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\r\n\r\n\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\r\n\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\r\n\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\r\n\r\n\t};\r\n\r\n\tvar RGBEByteToRGBHalf = ( function () {\r\n\r\n\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\r\n\r\n\t\tvar floatView = new Float32Array( 1 );\r\n\t\tvar int32View = new Int32Array( floatView.buffer );\r\n\t\t\r\n\t\tfunction toHalf( val ) {\r\n\r\n\t\t\tfloatView[ 0 ] = val;\r\n\t\t\tvar x = int32View[ 0 ];\r\n\r\n\t\t\tvar bits = ( x >> 16 ) & 0x8000; \r\n\t\t\tvar m = ( x >> 12 ) & 0x07ff; \r\n\t\t\tvar e = ( x >> 23 ) & 0xff; \r\n\t\t\t\r\n\t\t\tif ( e < 103 ) { return bits; }\r\n\t\t\t\r\n\t\t\tif ( e > 142 ) {\r\n\r\n\t\t\t\tbits |= 0x7c00;\r\n\t\t\t\t\r\n\t\t\t\tbits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );\r\n\t\t\t\treturn bits;\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( e < 113 ) {\r\n\r\n\t\t\t\tm |= 0x0800;\r\n\t\t\t\t\r\n\t\t\t\tbits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );\r\n\t\t\t\treturn bits;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );\r\n\t\t\t\r\n\t\t\tbits += m & 1;\r\n\t\t\treturn bits;\r\n\r\n\t\t}\r\n\r\n\t\treturn function ( sourceArray, sourceOffset, destArray, destOffset ) {\r\n\r\n\t\t\tvar e = sourceArray[ sourceOffset + 3 ];\r\n\t\t\tvar scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\r\n\r\n\t\t\tdestArray[ destOffset + 0 ] = toHalf( sourceArray[ sourceOffset + 0 ] * scale );\r\n\t\t\tdestArray[ destOffset + 1 ] = toHalf( sourceArray[ sourceOffset + 1 ] * scale );\r\n\t\t\tdestArray[ destOffset + 2 ] = toHalf( sourceArray[ sourceOffset + 2 ] * scale );\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n\t//\r\n\r\n\tvar texture = new CubeTexture();\r\n\r\n\ttexture.type = type;\r\n\ttexture.encoding = ( type === UnsignedByteType ) ? RGBEEncoding : LinearEncoding;\r\n\ttexture.format = ( type === UnsignedByteType ) ? RGBAFormat : RGBFormat;\r\n\ttexture.minFilter = ( texture.encoding === RGBEEncoding ) ? NearestFilter : LinearFilter;\r\n\ttexture.magFilter = ( texture.encoding === RGBEEncoding ) ? NearestFilter : LinearFilter;\r\n\ttexture.generateMipmaps = ( texture.encoding !== RGBEEncoding );\r\n\ttexture.anisotropy = 0;\r\n\r\n\tvar scope = this.hdrLoader;\r\n\r\n\tvar loaded = 0;\r\n\r\n\tfunction loadHDRData( i, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( urls[ i ], function ( buffer ) {\r\n\r\n\t\t\tloaded ++;\r\n\r\n\t\t\tvar texData = scope._parser( buffer );\r\n\r\n\t\t\tif ( ! texData ) { return; }\r\n\r\n\t\t\tif ( type === FloatType ) {\r\n\r\n\t\t\t\tvar numElements = ( texData.data.length / 4 ) * 3;\r\n\t\t\t\tvar floatdata = new Float32Array( numElements );\r\n\r\n\t\t\t\tfor ( var j = 0; j < numElements; j ++ ) {\r\n\r\n\t\t\t\t\tRGBEByteToRGBFloat( texData.data, j * 4, floatdata, j * 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexData.data = floatdata;\r\n\r\n\t\t\t} else if ( type === HalfFloatType ) {\r\n\r\n\t\t\t\tvar numElements = ( texData.data.length / 4 ) * 3;\r\n\t\t\t\tvar halfdata = new Uint16Array( numElements );\r\n\r\n\t\t\t\tfor ( var j = 0; j < numElements; j ++ ) {\r\n\r\n\t\t\t\t\tRGBEByteToRGBHalf( texData.data, j * 4, halfdata, j * 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexData.data = halfdata;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( undefined !== texData.image ) {\r\n\r\n\t\t\t\ttexture[ i ].images = texData.image;\r\n\r\n\t\t\t} else if ( undefined !== texData.data ) {\r\n\r\n\t\t\t\tvar dataTexture = new DataTexture( texData.data, texData.width, texData.height );\r\n\t\t\t\tdataTexture.format = texture.format;\r\n\t\t\t\tdataTexture.type = texture.type;\r\n\t\t\t\tdataTexture.encoding = texture.encoding;\r\n\t\t\t\tdataTexture.minFilter = texture.minFilter;\r\n\t\t\t\tdataTexture.magFilter = texture.magFilter;\r\n\t\t\t\tdataTexture.generateMipmaps = texture.generateMipmaps;\r\n\r\n\t\t\t\ttexture.images[ i ] = dataTexture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\tif ( onLoad ) { onLoad( texture ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < urls.length; i ++ ) {\r\n\r\n\t\tloadHDRData( i, onLoad, onProgress, onError );\r\n\r\n\t}\r\n\r\n\treturn texture;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar KMZLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nKMZLoader.prototype = {\r\n\r\n\tconstructor: KMZLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( data ) {\r\n\r\n\t\tfunction findFile( url ) {\r\n\r\n\t\t\tfor ( var path in zip.files ) {\r\n\r\n\t\t\t\tif ( path.substr( - url.length ) === url ) {\r\n\r\n\t\t\t\t\treturn zip.files[ path ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar manager = new LoadingManager();\r\n\t\tmanager.setURLModifier( function ( url ) {\r\n\r\n\t\t\tvar image = findFile( url );\r\n\r\n\t\t\tif ( image ) {\r\n\r\n\t\t\t\tconsole.log( 'Loading', url );\r\n\r\n\t\t\t\tvar blob = new Blob( [ image.asArrayBuffer() ], { type: 'application/octet-stream' } );\r\n\t\t\t\treturn URL.createObjectURL( blob );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn url;\r\n\r\n\t\t} );\r\n\r\n\t\t//\r\n\r\n\t\tvar zip = new JSZip( data ); // eslint-disable-line no-undef\r\n\r\n\t\tif ( zip.files[ 'doc.kml' ] ) {\r\n\r\n\t\t\tvar xml = new DOMParser().parseFromString( zip.files[ 'doc.kml' ].asText(), 'application/xml' );\r\n\r\n\t\t\tvar model = xml.querySelector( 'Placemark Model Link href' );\r\n\r\n\t\t\tif ( model ) {\r\n\r\n\t\t\t\tvar loader = new ColladaLoader( manager );\r\n\t\t\t\treturn loader.parse( zip.files[ model.textContent ].asText() );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'KMZLoader: Missing doc.kml file.' );\r\n\r\n\t\t\tfor ( var path in zip.files ) {\r\n\r\n\t\t\t\tvar extension = path.split( '.' ).pop().toLowerCase();\r\n\r\n\t\t\t\tif ( extension === 'dae' ) {\r\n\r\n\t\t\t\t\tvar loader = new ColladaLoader( manager );\r\n\t\t\t\t\treturn loader.parse( zip.files[ path ].asText() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconsole.error( 'KMZLoader: Couldn\\'t find .dae file.' );\r\n\t\treturn { scene: new Group() };\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar KTXLoader = function ( manager ) {\r\n\r\n\tCompressedTextureLoader.call( this, manager );\r\n\r\n\tthis._parser = KTXLoader.parse;\r\n\r\n};\r\n\r\nKTXLoader.prototype = Object.create( CompressedTextureLoader.prototype );\r\nKTXLoader.prototype.constructor = KTXLoader;\r\n\r\nKTXLoader.parse = function ( buffer, loadMipmaps ) {\r\n\r\n\tvar ktx = new KhronosTextureContainer( buffer, 1 );\r\n\r\n\treturn {\r\n\t\tmipmaps: ktx.mipmaps( loadMipmaps ),\r\n\t\twidth: ktx.pixelWidth,\r\n\t\theight: ktx.pixelHeight,\r\n\t\tformat: ktx.glInternalFormat,\r\n\t\tisCubemap: ktx.numberOfFaces === 6,\r\n\t\tmipmapCount: ktx.numberOfMipmapLevels\r\n\t};\r\n\r\n};\r\n\r\nvar KhronosTextureContainer = ( function () {\r\n\t\r\n\tfunction KhronosTextureContainer( arrayBuffer, facesExpected, threeDExpected, textureArrayExpected ) {\r\n\r\n\t\tthis.arrayBuffer = arrayBuffer;\r\n\r\n\t\t// Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\r\n\t\t// '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\\r', '\\n', '\\x1A', '\\n'\r\n\t\t// 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\r\n\t\tvar identifier = new Uint8Array( this.arrayBuffer, 0, 12 );\r\n\t\tif ( identifier[ 0 ] !== 0xAB ||\r\n\t\t\tidentifier[ 1 ] !== 0x4B ||\r\n\t\t\tidentifier[ 2 ] !== 0x54 ||\r\n\t\t\tidentifier[ 3 ] !== 0x58 ||\r\n\t\t\tidentifier[ 4 ] !== 0x20 ||\r\n\t\t\tidentifier[ 5 ] !== 0x31 ||\r\n\t\t\tidentifier[ 6 ] !== 0x31 ||\r\n\t\t\tidentifier[ 7 ] !== 0xBB ||\r\n\t\t\tidentifier[ 8 ] !== 0x0D ||\r\n\t\t\tidentifier[ 9 ] !== 0x0A ||\r\n\t\t\tidentifier[ 10 ] !== 0x1A ||\r\n\t\t\tidentifier[ 11 ] !== 0x0A ) {\r\n\r\n\t\t\tconsole.error( 'texture missing KTX identifier' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// load the reset of the header in native 32 bit int\r\n\t\tvar header = new Int32Array( this.arrayBuffer, 12, 13 );\r\n\t\t// determine of the remaining header values are recorded in the opposite endianness & require conversion\r\n\t\tvar oppositeEndianess = header[ 0 ] === 0x01020304;\r\n\t\t// read all the header elements in order they exist in the file, without modification (sans endainness)\r\n\t\tthis.glType = oppositeEndianess ? this.switchEndainness( header[ 1 ] ) : header[ 1 ]; // must be 0 for compressed textures\r\n\t\tthis.glTypeSize = oppositeEndianess ? this.switchEndainness( header[ 2 ] ) : header[ 2 ]; // must be 1 for compressed textures\r\n\t\tthis.glFormat = oppositeEndianess ? this.switchEndainness( header[ 3 ] ) : header[ 3 ]; // must be 0 for compressed textures\r\n\t\tthis.glInternalFormat = oppositeEndianess ? this.switchEndainness( header[ 4 ] ) : header[ 4 ]; // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\r\n\t\tthis.glBaseInternalFormat = oppositeEndianess ? this.switchEndainness( header[ 5 ] ) : header[ 5 ]; // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\r\n\t\tthis.pixelWidth = oppositeEndianess ? this.switchEndainness( header[ 6 ] ) : header[ 6 ]; // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\r\n\t\tthis.pixelHeight = oppositeEndianess ? this.switchEndainness( header[ 7 ] ) : header[ 7 ]; // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\r\n\t\tthis.pixelDepth = oppositeEndianess ? this.switchEndainness( header[ 8 ] ) : header[ 8 ]; // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\r\n\t\tthis.numberOfArrayElements = oppositeEndianess ? this.switchEndainness( header[ 9 ] ) : header[ 9 ]; // used for texture arrays\r\n\t\tthis.numberOfFaces = oppositeEndianess ? this.switchEndainness( header[ 10 ] ) : header[ 10 ]; // used for cubemap textures, should either be 1 or 6\r\n\t\tthis.numberOfMipmapLevels = oppositeEndianess ? this.switchEndainness( header[ 11 ] ) : header[ 11 ]; // number of levels; disregard possibility of 0 for compressed textures\r\n\t\tthis.bytesOfKeyValueData = oppositeEndianess ? this.switchEndainness( header[ 12 ] ) : header[ 12 ]; // the amount of space after the header for meta-data\r\n\r\n\t\t// Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\r\n\t\tif ( this.glType !== 0 ) {\r\n\r\n\t\t\tconsole.warn( 'only compressed formats currently supported' );\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\r\n\t\t\tthis.numberOfMipmapLevels = Math.max( 1, this.numberOfMipmapLevels );\r\n\r\n\t\t}\r\n\t\tif ( this.pixelHeight === 0 || this.pixelDepth !== 0 ) {\r\n\r\n\t\t\tconsole.warn( 'only 2D textures currently supported' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\t\tif ( this.numberOfArrayElements !== 0 ) {\r\n\r\n\t\t\tconsole.warn( 'texture arrays not currently supported' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\t\tif ( this.numberOfFaces !== facesExpected ) {\r\n\r\n\t\t\tconsole.warn( 'number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\t\t// we now have a completely validated file, so could use existence of loadType as success\r\n\t\t// would need to make this more elaborate & adjust checks above to support more than one load type\r\n\t\tthis.loadType = KhronosTextureContainer.COMPRESSED_2D;\r\n\r\n\t}\r\n\r\n\t// not as fast hardware based, but will probably never need to use\r\n\tKhronosTextureContainer.prototype.switchEndainness = function ( val ) {\r\n\r\n\t\treturn ( ( val & 0xFF ) << 24 ) | ( ( val & 0xFF00 ) << 8 ) | ( ( val >> 8 ) & 0xFF00 ) | ( ( val >> 24 ) & 0xFF );\r\n\r\n\t};\r\n\r\n\t// return mipmaps for js\r\n\tKhronosTextureContainer.prototype.mipmaps = function ( loadMipmaps ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar mipmaps = [];\r\n\r\n\t\t// initialize width & height for level 1\r\n\t\tvar dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\r\n\t\tvar width = this.pixelWidth;\r\n\t\tvar height = this.pixelHeight;\r\n\t\tvar mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\r\n\r\n\t\tfor ( var level = 0; level < mipmapCount; level ++ ) {\r\n\r\n\t\t\tvar imageSize = new Int32Array( this$1.arrayBuffer, dataOffset, 1 )[ 0 ]; // size per face, since not supporting array cubemaps\r\n\t\t\tfor ( var face = 0; face < this.numberOfFaces; face ++ ) {\r\n\r\n\t\t\t\tvar byteArray = new Uint8Array( this$1.arrayBuffer, dataOffset + 4, imageSize );\r\n\r\n\t\t\t\tmipmaps.push( { \"data\": byteArray, \"width\": width, \"height\": height } );\r\n\r\n\t\t\t\tdataOffset += imageSize + 4; // size of the image + 4 for the imageSize field\r\n\t\t\t\tdataOffset += 3 - ( ( imageSize + 3 ) % 4 ); // add padding for odd sized image\r\n\r\n\t\t\t}\r\n\t\t\twidth = Math.max( 1.0, width * 0.5 );\r\n\t\t\theight = Math.max( 1.0, height * 0.5 );\r\n\r\n\t\t}\r\n\r\n\t\treturn mipmaps;\r\n\r\n\t};\r\n\r\n\tKhronosTextureContainer.HEADER_LEN = 12 + ( 13 * 4 ); // identifier + header elements (not including key value meta-data pairs)\r\n\t// load types\r\n\tKhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\r\n\tKhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\r\n\tKhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()\r\n\tKhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()\r\n\r\n\treturn KhronosTextureContainer;\r\n\r\n}() );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/*\r\nif ( var LoaderSupport === undefined ) {\r\n\r\n\tvar LoaderSupport = {};\r\n\r\n}\r\n\r\n*/\r\nvar LoaderSupport = {};\r\nLoaderSupport.Validator = {\r\n\t\r\n\tisValid: function( input ) {\r\n\t\treturn ( input !== null && input !== undefined );\r\n\t},\r\n\t\r\n\tverifyInput: function( input, defaultValue ) {\r\n\t\treturn ( input === null || input === undefined ) ? defaultValue : input;\r\n\t}\r\n};\r\n\r\nLoaderSupport.Callbacks = (function () {\r\n\r\n\tvar Validator = LoaderSupport.Validator;\r\n\r\n\tfunction Callbacks() {\r\n\t\tthis.onProgress = null;\r\n\t\tthis.onReportError = null;\r\n\t\tthis.onMeshAlter = null;\r\n\t\tthis.onLoad = null;\r\n\t\tthis.onLoadMaterials = null;\r\n\t}\r\n\t\r\n\tCallbacks.prototype.setCallbackOnProgress = function ( callbackOnProgress ) {\r\n\t\tthis.onProgress = Validator.verifyInput( callbackOnProgress, this.onProgress );\r\n\t};\r\n\t\r\n\tCallbacks.prototype.setCallbackOnReportError = function ( callbackOnReportError ) {\r\n\t\tthis.onReportError = Validator.verifyInput( callbackOnReportError, this.onReportError );\r\n\t};\r\n\t\r\n\tCallbacks.prototype.setCallbackOnMeshAlter = function ( callbackOnMeshAlter ) {\r\n\t\tthis.onMeshAlter = Validator.verifyInput( callbackOnMeshAlter, this.onMeshAlter );\r\n\t};\r\n\t\r\n\tCallbacks.prototype.setCallbackOnLoad = function ( callbackOnLoad ) {\r\n\t\tthis.onLoad = Validator.verifyInput( callbackOnLoad, this.onLoad );\r\n\t};\r\n\t\r\n\tCallbacks.prototype.setCallbackOnLoadMaterials = function ( callbackOnLoadMaterials ) {\r\n\t\tthis.onLoadMaterials = Validator.verifyInput( callbackOnLoadMaterials, this.onLoadMaterials );\r\n\t};\r\n\r\n\treturn Callbacks;\r\n})();\r\n\r\nLoaderSupport.LoadedMeshUserOverride = (function () {\r\n\r\n\tfunction LoadedMeshUserOverride( disregardMesh, alteredMesh ) {\r\n\t\tthis.disregardMesh = disregardMesh === true;\r\n\t\tthis.alteredMesh = alteredMesh === true;\r\n\t\tthis.meshes = [];\r\n\t}\r\n\t\r\n\tLoadedMeshUserOverride.prototype.addMesh = function ( mesh ) {\r\n\t\tthis.meshes.push( mesh );\r\n\t\tthis.alteredMesh = true;\r\n\t};\r\n\t\r\n\tLoadedMeshUserOverride.prototype.isDisregardMesh = function () {\r\n\t\treturn this.disregardMesh;\r\n\t};\r\n\t\r\n\tLoadedMeshUserOverride.prototype.providesAlteredMeshes = function () {\r\n\t\treturn this.alteredMesh;\r\n\t};\r\n\r\n\treturn LoadedMeshUserOverride;\r\n})();\r\n\r\nLoaderSupport.ResourceDescriptor = (function () {\r\n\r\n\tvar Validator = LoaderSupport.Validator;\r\n\r\n\tfunction ResourceDescriptor( url, extension ) {\r\n\t\tvar urlParts = url.split( '/' );\r\n\r\n\t\tif ( urlParts.length < 2 ) {\r\n\r\n\t\t\tthis.path = null;\r\n\t\t\tthis.name = url;\r\n\t\t\tthis.url = url;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.path = Validator.verifyInput( urlParts.slice( 0, urlParts.length - 1).join( '/' ) + '/', null );\r\n\t\t\tthis.name = urlParts[ urlParts.length - 1 ];\r\n\t\t\tthis.url = url;\r\n\r\n\t\t}\r\n\t\tthis.name = Validator.verifyInput( this.name, 'Unnamed_Resource' );\r\n\t\tthis.extension = Validator.verifyInput( extension, 'default' );\r\n\t\tthis.extension = this.extension.trim();\r\n\t\tthis.content = null;\r\n\t}\r\n\t\r\n\tResourceDescriptor.prototype.setContent = function ( content ) {\r\n\t\tthis.content = Validator.verifyInput( content, null );\r\n\t};\r\n\r\n\treturn ResourceDescriptor;\r\n})();\r\n\r\nLoaderSupport.PrepData = (function () {\r\n\r\n\tvar Validator = LoaderSupport.Validator;\r\n\r\n\tfunction PrepData( modelName ) {\r\n\t\tthis.logging = {\r\n\t\t\tenabled: true,\r\n\t\t\tdebug: false\r\n\t\t};\r\n\t\tthis.modelName = Validator.verifyInput( modelName, '' );\r\n\t\tthis.resources = [];\r\n\t\tthis.callbacks = new LoaderSupport.Callbacks();\r\n\t}\r\n\t\r\n\tPrepData.prototype.setLogging = function ( enabled, debug ) {\r\n\t\tthis.logging.enabled = enabled === true;\r\n\t\tthis.logging.debug = debug === true;\r\n\t};\r\n\t\r\n\tPrepData.prototype.getCallbacks = function () {\r\n\t\treturn this.callbacks;\r\n\t};\r\n\t\r\n\tPrepData.prototype.addResource = function ( resource ) {\r\n\t\tthis.resources.push( resource );\r\n\t};\r\n\t\r\n\tPrepData.prototype.clone = function () {\n\t\tvar this$1 = this;\n\r\n\t\tvar clone = new LoaderSupport.PrepData( this.modelName );\r\n\t\tclone.logging.enabled = this.logging.enabled;\r\n\t\tclone.logging.debug = this.logging.debug;\r\n\t\tclone.resources = this.resources;\r\n\t\tclone.callbacks = this.callbacks;\r\n\r\n\t\tvar property, value;\r\n\t\tfor ( property in this$1 ) {\r\n\r\n\t\t\tvalue = this$1[ property ];\r\n\t\t\tif ( ! clone.hasOwnProperty( property ) && typeof this$1[ property ] !== 'function' ) {\r\n\r\n\t\t\t\tclone[ property ] = value;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn clone;\r\n\t};\r\n\t\r\n\tPrepData.prototype.checkResourceDescriptorFiles = function ( resources, fileDesc ) {\r\n\t\tvar resource, triple, i, found;\r\n\t\tvar result = {};\r\n\r\n\t\tfor ( var index in resources ) {\r\n\r\n\t\t\tresource = resources[ index ];\r\n\t\t\tfound = false;\r\n\t\t\tif ( ! Validator.isValid( resource.name ) ) { continue; }\r\n\t\t\tif ( Validator.isValid( resource.content ) ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < fileDesc.length && !found; i++ ) {\r\n\r\n\t\t\t\t\ttriple = fileDesc[ i ];\r\n\t\t\t\t\tif ( resource.extension.toLowerCase() === triple.ext.toLowerCase() ) {\r\n\r\n\t\t\t\t\t\tif ( triple.ignore ) {\r\n\r\n\t\t\t\t\t\t\tfound = true;\r\n\r\n\t\t\t\t\t\t} else if ( triple.type === \"ArrayBuffer\" ) {\r\n\r\n\t\t\t\t\t\t\t// fast-fail on bad type\r\n\t\t\t\t\t\t\tif ( ! ( resource.content instanceof ArrayBuffer || resource.content instanceof Uint8Array ) ) { throw 'Provided content is not of type ArrayBuffer! Aborting...'; }\r\n\t\t\t\t\t\t\tresult[ triple.ext ] = resource;\r\n\t\t\t\t\t\t\tfound = true;\r\n\r\n\t\t\t\t\t\t} else if ( triple.type === \"String\" ) {\r\n\r\n\t\t\t\t\t\t\tif ( ! ( typeof( resource.content ) === 'string' || resource.content instanceof String) ) { throw 'Provided  content is not of type String! Aborting...'; }\r\n\t\t\t\t\t\t\tresult[ triple.ext ] = resource;\r\n\t\t\t\t\t\t\tfound = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( !found ) { throw 'Unidentified resource \"' + resource.name + '\": ' + resource.url; }\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// fast-fail on bad type\r\n\t\t\t\tif ( ! ( typeof( resource.name ) === 'string' || resource.name instanceof String ) ) { throw 'Provided file is not properly defined! Aborting...'; }\r\n\t\t\t\tfor ( i = 0; i < fileDesc.length && !found; i++ ) {\r\n\r\n\t\t\t\t\ttriple = fileDesc[ i ];\r\n\t\t\t\t\tif ( resource.extension.toLowerCase() === triple.ext.toLowerCase() ) {\r\n\r\n\t\t\t\t\t\tif ( ! triple.ignore ) { result[ triple.ext ] = resource; }\r\n\t\t\t\t\t\tfound = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( !found ) { throw 'Unidentified resource \"' + resource.name + '\": ' + resource.url; }\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t};\r\n\r\n\treturn PrepData;\r\n})();\r\n\r\nLoaderSupport.MeshBuilder = (function () {\r\n\r\n\tvar LOADER_MESH_BUILDER_VERSION = '1.2.2';\r\n\r\n\tvar Validator = LoaderSupport.Validator;\r\n\r\n\tfunction MeshBuilder() {\r\n\t\tconsole.info( 'Using LoaderSupport.MeshBuilder version: ' + LOADER_MESH_BUILDER_VERSION );\r\n\t\tthis.logging = {\r\n\t\t\tenabled: true,\r\n\t\t\tdebug: false\r\n\t\t};\r\n\r\n\t\tthis.callbacks = new LoaderSupport.Callbacks();\r\n\t\tthis.materials = [];\r\n\t}\r\n\t\r\n\tMeshBuilder.prototype.setLogging = function ( enabled, debug ) {\r\n\t\tthis.logging.enabled = enabled === true;\r\n\t\tthis.logging.debug = debug === true;\r\n\t};\r\n\t\r\n\tMeshBuilder.prototype.init = function () {\r\n\t\tvar defaultMaterial = new MeshStandardMaterial( { color: 0xDCF1FF } );\r\n\t\tdefaultMaterial.name = 'defaultMaterial';\r\n\r\n\t\tvar defaultVertexColorMaterial = new MeshStandardMaterial( { color: 0xDCF1FF } );\r\n\t\tdefaultVertexColorMaterial.name = 'defaultVertexColorMaterial';\r\n\t\tdefaultVertexColorMaterial.vertexColors = VertexColors;\r\n\r\n\t\tvar defaultLineMaterial = new LineBasicMaterial();\r\n\t\tdefaultLineMaterial.name = 'defaultLineMaterial';\r\n\r\n\t\tvar defaultPointMaterial = new PointsMaterial( { size: 1 } );\r\n\t\tdefaultPointMaterial.name = 'defaultPointMaterial';\r\n\r\n\t\tvar runtimeMaterials = {};\r\n\t\truntimeMaterials[ defaultMaterial.name ] = defaultMaterial;\r\n\t\truntimeMaterials[ defaultVertexColorMaterial.name ] = defaultVertexColorMaterial;\r\n\t\truntimeMaterials[ defaultLineMaterial.name ] = defaultLineMaterial;\r\n\t\truntimeMaterials[ defaultPointMaterial.name ] = defaultPointMaterial;\r\n\r\n\t\tthis.updateMaterials(\r\n\t\t\t{\r\n\t\t\t\tcmd: 'materialData',\r\n\t\t\t\tmaterials: {\r\n\t\t\t\t\tmaterialCloneInstructions: null,\r\n\t\t\t\t\tserializedMaterials: null,\r\n\t\t\t\t\truntimeMaterials: runtimeMaterials\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t};\r\n\t\r\n\tMeshBuilder.prototype.setMaterials = function ( materials ) {\r\n\t\tvar payload = {\r\n\t\t\tcmd: 'materialData',\r\n\t\t\tmaterials: {\r\n\t\t\t\tmaterialCloneInstructions: null,\r\n\t\t\t\tserializedMaterials: null,\r\n\t\t\t\truntimeMaterials: Validator.isValid( this.callbacks.onLoadMaterials ) ? this.callbacks.onLoadMaterials( materials ) : materials\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.updateMaterials( payload );\r\n\t};\r\n\r\n\tMeshBuilder.prototype._setCallbacks = function ( callbacks ) {\r\n\t\tif ( Validator.isValid( callbacks.onProgress ) ) { this.callbacks.setCallbackOnProgress( callbacks.onProgress ); }\r\n\t\tif ( Validator.isValid( callbacks.onReportError ) ) { this.callbacks.setCallbackOnReportError( callbacks.onReportError ); }\r\n\t\tif ( Validator.isValid( callbacks.onMeshAlter ) ) { this.callbacks.setCallbackOnMeshAlter( callbacks.onMeshAlter ); }\r\n\t\tif ( Validator.isValid( callbacks.onLoad ) ) { this.callbacks.setCallbackOnLoad( callbacks.onLoad ); }\r\n\t\tif ( Validator.isValid( callbacks.onLoadMaterials ) ) { this.callbacks.setCallbackOnLoadMaterials( callbacks.onLoadMaterials ); }\r\n\t};\r\n\t\r\n\tMeshBuilder.prototype.processPayload = function ( payload ) {\r\n\t\tif ( payload.cmd === 'meshData' ) {\r\n\r\n\t\t\treturn this.buildMeshes( payload );\r\n\r\n\t\t} else if ( payload.cmd === 'materialData' ) {\r\n\r\n\t\t\tthis.updateMaterials( payload );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\tMeshBuilder.prototype.buildMeshes = function ( meshPayload ) {\n\t\tvar this$1 = this;\n\r\n\t\tvar meshName = meshPayload.params.meshName;\r\n\r\n\t\tvar bufferGeometry = new BufferGeometry();\r\n\t\tbufferGeometry.addAttribute( 'position', new BufferAttribute( new Float32Array( meshPayload.buffers.vertices ), 3 ) );\r\n\t\tif ( Validator.isValid( meshPayload.buffers.indices ) ) {\r\n\r\n\t\t\tbufferGeometry.setIndex( new BufferAttribute( new Uint32Array( meshPayload.buffers.indices ), 1 ));\r\n\r\n\t\t}\r\n\t\tvar haveVertexColors = Validator.isValid( meshPayload.buffers.colors );\r\n\t\tif ( haveVertexColors ) {\r\n\r\n\t\t\tbufferGeometry.addAttribute( 'color', new BufferAttribute( new Float32Array( meshPayload.buffers.colors ), 3 ) );\r\n\r\n\t\t}\r\n\t\tif ( Validator.isValid( meshPayload.buffers.normals ) ) {\r\n\r\n\t\t\tbufferGeometry.addAttribute( 'normal', new BufferAttribute( new Float32Array( meshPayload.buffers.normals ), 3 ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tbufferGeometry.computeVertexNormals();\r\n\r\n\t\t}\r\n\t\tif ( Validator.isValid( meshPayload.buffers.uvs ) ) {\r\n\r\n\t\t\tbufferGeometry.addAttribute( 'uv', new BufferAttribute( new Float32Array( meshPayload.buffers.uvs ), 2 ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar material, materialName, key;\r\n\t\tvar materialNames = meshPayload.materials.materialNames;\r\n\t\tvar createMultiMaterial = meshPayload.materials.multiMaterial;\r\n\t\tvar multiMaterials = [];\r\n\t\tfor ( key in materialNames ) {\r\n\r\n\t\t\tmaterialName = materialNames[ key ];\r\n\t\t\tmaterial = this$1.materials[ materialName ];\r\n\t\t\tif ( createMultiMaterial ) { multiMaterials.push( material ); }\r\n\r\n\t\t}\r\n\t\tif ( createMultiMaterial ) {\r\n\r\n\t\t\tmaterial = multiMaterials;\r\n\t\t\tvar materialGroups = meshPayload.materials.materialGroups;\r\n\t\t\tvar materialGroup;\r\n\t\t\tfor ( key in materialGroups ) {\r\n\r\n\t\t\t\tmaterialGroup = materialGroups[ key ];\r\n\t\t\t\tbufferGeometry.addGroup( materialGroup.start, materialGroup.count, materialGroup.index );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar meshes = [];\r\n\t\tvar mesh;\r\n\t\tvar callbackOnMeshAlter = this.callbacks.onMeshAlter;\r\n\t\tvar callbackOnMeshAlterResult;\r\n\t\tvar useOrgMesh = true;\r\n\t\tvar geometryType = Validator.verifyInput( meshPayload.geometryType, 0 );\r\n\t\tif ( Validator.isValid( callbackOnMeshAlter ) ) {\r\n\r\n\t\t\tcallbackOnMeshAlterResult = callbackOnMeshAlter(\r\n\t\t\t\t{\r\n\t\t\t\t\tdetail: {\r\n\t\t\t\t\t\tmeshName: meshName,\r\n\t\t\t\t\t\tbufferGeometry: bufferGeometry,\r\n\t\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\t\tgeometryType: geometryType\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\tif ( Validator.isValid( callbackOnMeshAlterResult ) ) {\r\n\r\n\t\t\t\tif ( callbackOnMeshAlterResult.isDisregardMesh() ) {\r\n\r\n\t\t\t\t\tuseOrgMesh = false;\r\n\r\n\t\t\t\t} else if ( callbackOnMeshAlterResult.providesAlteredMeshes() ) {\r\n\r\n\t\t\t\t\tfor ( var i in callbackOnMeshAlterResult.meshes ) {\r\n\r\n\t\t\t\t\t\tmeshes.push( callbackOnMeshAlterResult.meshes[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tuseOrgMesh = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tif ( useOrgMesh ) {\r\n\r\n\t\t\tif ( meshPayload.computeBoundingSphere ) { bufferGeometry.computeBoundingSphere(); }\r\n\t\t\tif ( geometryType === 0 ) {\r\n\r\n\t\t\t\tmesh = new Mesh( bufferGeometry, material );\r\n\r\n\t\t\t} else if ( geometryType === 1) {\r\n\r\n\t\t\t\tmesh = new LineSegments( bufferGeometry, material );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmesh = new Points( bufferGeometry, material );\r\n\r\n\t\t\t}\r\n\t\t\tmesh.name = meshName;\r\n\t\t\tmeshes.push( mesh );\r\n\r\n\t\t}\r\n\r\n\t\tvar progressMessage;\r\n\t\tif ( Validator.isValid( meshes ) && meshes.length > 0 ) {\r\n\r\n\t\t\tvar meshNames = [];\r\n\t\t\tfor ( var i in meshes ) {\r\n\r\n\t\t\t\tmesh = meshes[ i ];\r\n\t\t\t\tmeshNames[ i ] = mesh.name;\r\n\r\n\t\t\t}\r\n\t\t\tprogressMessage = 'Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\r\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tprogressMessage = 'Not adding mesh: ' + meshName;\r\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\r\n\r\n\t\t}\r\n\t\tvar callbackOnProgress = this.callbacks.onProgress;\r\n\t\tif ( Validator.isValid( callbackOnProgress ) ) {\r\n\r\n\t\t\tvar event = new CustomEvent( 'MeshBuilderEvent', {\r\n\t\t\t\tdetail: {\r\n\t\t\t\t\ttype: 'progress',\r\n\t\t\t\t\tmodelName: meshPayload.params.meshName,\r\n\t\t\t\t\ttext: progressMessage,\r\n\t\t\t\t\tnumericalValue: meshPayload.progress.numericalValue\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t\tcallbackOnProgress( event );\r\n\r\n\t\t}\r\n\r\n\t\treturn meshes;\r\n\t};\r\n\t\r\n\tMeshBuilder.prototype.updateMaterials = function ( materialPayload ) {\n\t\tvar this$1 = this;\n\r\n\t\tvar material, materialName;\r\n\t\tvar materialCloneInstructions = materialPayload.materials.materialCloneInstructions;\r\n\t\tif ( Validator.isValid( materialCloneInstructions ) ) {\r\n\r\n\t\t\tvar materialNameOrg = materialCloneInstructions.materialNameOrg;\r\n\t\t\tvar materialOrg = this.materials[ materialNameOrg ];\r\n\r\n\t\t\tif ( Validator.isValid( materialNameOrg ) ) {\r\n\r\n\t\t\t\tmaterial = materialOrg.clone();\r\n\r\n\t\t\t\tmaterialName = materialCloneInstructions.materialName;\r\n\t\t\t\tmaterial.name = materialName;\r\n\r\n\t\t\t\tvar materialProperties = materialCloneInstructions.materialProperties;\r\n\t\t\t\tfor ( var key in materialProperties ) {\r\n\r\n\t\t\t\t\tif ( material.hasOwnProperty( key ) && materialProperties.hasOwnProperty( key ) ) { material[ key ] = materialProperties[ key ]; }\r\n\r\n\t\t\t\t}\r\n\t\t\t\tthis.materials[ materialName ] = material;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'Requested material \"' + materialNameOrg + '\" is not available!' );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar materials = materialPayload.materials.serializedMaterials;\r\n\t\tif ( Validator.isValid( materials ) && Object.keys( materials ).length > 0 ) {\r\n\r\n\t\t\tvar loader = new MaterialLoader();\r\n\t\t\tvar materialJson;\r\n\t\t\tfor ( materialName in materials ) {\r\n\r\n\t\t\t\tmaterialJson = materials[ materialName ];\r\n\t\t\t\tif ( Validator.isValid( materialJson ) ) {\r\n\r\n\t\t\t\t\tmaterial = loader.parse( materialJson );\r\n\t\t\t\t\tif ( this$1.logging.enabled ) { console.info( 'De-serialized material with name \"' + materialName + '\" will be added.' ); }\r\n\t\t\t\t\tthis$1.materials[ materialName ] = material;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmaterials = materialPayload.materials.runtimeMaterials;\r\n\t\tif ( Validator.isValid( materials ) && Object.keys( materials ).length > 0 ) {\r\n\r\n\t\t\tfor ( materialName in materials ) {\r\n\r\n\t\t\t\tmaterial = materials[ materialName ];\r\n\t\t\t\tif ( this$1.logging.enabled ) { console.info( 'Material with name \"' + materialName + '\" will be added.' ); }\r\n\t\t\t\tthis$1.materials[ materialName ] = material;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\tMeshBuilder.prototype.getMaterialsJSON = function () {\n\t\tvar this$1 = this;\n\r\n\t\tvar materialsJSON = {};\r\n\t\tvar material;\r\n\t\tfor ( var materialName in this$1.materials ) {\r\n\r\n\t\t\tmaterial = this$1.materials[ materialName ];\r\n\t\t\tmaterialsJSON[ materialName ] = material.toJSON();\r\n\t\t}\r\n\r\n\t\treturn materialsJSON;\r\n\t};\r\n\t\r\n\tMeshBuilder.prototype.getMaterials = function () {\r\n\t\treturn this.materials;\r\n\t};\r\n\r\n\treturn MeshBuilder;\r\n})();\r\n\r\nLoaderSupport.WorkerRunnerRefImpl = (function () {\r\n\r\n\tfunction WorkerRunnerRefImpl() {\r\n\t\tvar scope = this;\r\n\t\tvar scopedRunner = function( event ) {\r\n\t\t\tscope.processMessage( event.data );\r\n\t\t};\r\n\t\tself.addEventListener( 'message', scopedRunner, false );\r\n\t}\r\n\t\r\n\tWorkerRunnerRefImpl.prototype.applyProperties = function ( parser, params ) {\r\n\t\tvar property, funcName, values;\r\n\t\tfor ( property in params ) {\r\n\t\t\tfuncName = 'set' + property.substring( 0, 1 ).toLocaleUpperCase() + property.substring( 1 );\r\n\t\t\tvalues = params[ property ];\r\n\r\n\t\t\tif ( typeof parser[ funcName ] === 'function' ) {\r\n\r\n\t\t\t\tparser[ funcName ]( values );\r\n\r\n\t\t\t} else if ( parser.hasOwnProperty( property ) ) {\r\n\r\n\t\t\t\tparser[ property ] = values;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\tWorkerRunnerRefImpl.prototype.processMessage = function ( payload ) {\r\n\t\tif ( payload.cmd === 'run' ) {\r\n\r\n\t\t\tvar callbacks = {\r\n\t\t\t\tcallbackMeshBuilder: function ( payload ) {\r\n\t\t\t\t\tself.postMessage( payload );\r\n\t\t\t\t},\r\n\t\t\t\tcallbackProgress: function ( text ) {\r\n\t\t\t\t\tif ( payload.logging.enabled && payload.logging.debug ) { console.debug( 'WorkerRunner: progress: ' + text ); }\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Parser is expected to be named as such\r\n\t\t\tvar parser = new Parser();\r\n\t\t\tif ( typeof parser[ 'setLogging' ] === 'function' ) { parser.setLogging( payload.logging.enabled, payload.logging.debug ); }\r\n\t\t\tthis.applyProperties( parser, payload.params );\r\n\t\t\tthis.applyProperties( parser, payload.materials );\r\n\t\t\tthis.applyProperties( parser, callbacks );\r\n\t\t\tparser.workerScope = self;\r\n\t\t\tparser.parse( payload.data.input, payload.data.options );\r\n\r\n\t\t\tif ( payload.logging.enabled ) { console.log( 'WorkerRunner: Run complete!' ); }\r\n\r\n\t\t\tcallbacks.callbackMeshBuilder( {\r\n\t\t\t\tcmd: 'complete',\r\n\t\t\t\tmsg: 'WorkerRunner completed run.'\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( 'WorkerRunner: Received unknown command: ' + payload.cmd );\r\n\r\n\t\t}\r\n\t};\r\n\r\n\treturn WorkerRunnerRefImpl;\r\n})();\r\n\r\nLoaderSupport.WorkerSupport = (function () {\r\n\r\n\tvar WORKER_SUPPORT_VERSION = '2.2.1';\r\n\r\n\tvar Validator = LoaderSupport.Validator;\r\n\r\n\tvar LoaderWorker = (function () {\r\n\r\n\t\tfunction LoaderWorker() {\r\n\t\t\tthis._reset();\r\n\t\t}\r\n\r\n\t\tLoaderWorker.prototype._reset = function () {\r\n\t\t\tthis.logging = {\r\n\t\t\t\tenabled: true,\r\n\t\t\t\tdebug: false\r\n\t\t\t};\r\n\t\t\tthis.worker = null;\r\n\t\t\tthis.runnerImplName = null;\r\n\t\t\tthis.callbacks = {\r\n\t\t\t\tmeshBuilder: null,\r\n\t\t\t\tonLoad: null\r\n\t\t\t};\r\n\t\t\tthis.terminateRequested = false;\r\n\t\t\tthis.queuedMessage = null;\r\n\t\t\tthis.started = false;\r\n\t\t\tthis.forceCopy = false;\r\n\t\t};\r\n\r\n\t\tLoaderWorker.prototype.setLogging = function ( enabled, debug ) {\r\n\t\t\tthis.logging.enabled = enabled === true;\r\n\t\t\tthis.logging.debug = debug === true;\r\n\t\t};\r\n\r\n\t\tLoaderWorker.prototype.setForceCopy = function ( forceCopy ) {\r\n\t\t\tthis.forceCopy = forceCopy === true;\r\n\t\t};\r\n\r\n\t\tLoaderWorker.prototype.initWorker = function ( code, runnerImplName ) {\r\n\t\t\tthis.runnerImplName = runnerImplName;\r\n\t\t\tvar blob = new Blob( [ code ], { type: 'application/javascript' } );\r\n\t\t\tthis.worker = new Worker( window.URL.createObjectURL( blob ) );\r\n\t\t\tthis.worker.onmessage = this._receiveWorkerMessage;\r\n\r\n\t\t\t// set referemce to this, then processing in worker scope within \"_receiveWorkerMessage\" can access members\r\n\t\t\tthis.worker.runtimeRef = this;\r\n\r\n\t\t\t// process stored queuedMessage\r\n\t\t\tthis._postMessage();\r\n\t\t};\r\n\t\t\r\n\t\tLoaderWorker.prototype._receiveWorkerMessage = function ( e ) {\r\n\t\t\tvar payload = e.data;\r\n\t\t\tswitch ( payload.cmd ) {\r\n\t\t\t\tcase 'meshData':\r\n\t\t\t\tcase 'materialData':\r\n\t\t\t\tcase 'imageData':\r\n\t\t\t\t\tthis.runtimeRef.callbacks.meshBuilder( payload );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'complete':\r\n\t\t\t\t\tthis.runtimeRef.queuedMessage = null;\r\n\t\t\t\t\tthis.started = false;\r\n\t\t\t\t\tthis.runtimeRef.callbacks.onLoad( payload.msg );\r\n\r\n\t\t\t\t\tif ( this.runtimeRef.terminateRequested ) {\r\n\r\n\t\t\t\t\t\tif ( this.runtimeRef.logging.enabled ) { console.info( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run is complete. Terminating application on request!' ); }\r\n\t\t\t\t\t\tthis.runtimeRef._terminate();\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'error':\r\n\t\t\t\t\tconsole.error( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Reported error: ' + payload.msg );\r\n\t\t\t\t\tthis.runtimeRef.queuedMessage = null;\r\n\t\t\t\t\tthis.started = false;\r\n\t\t\t\t\tthis.runtimeRef.callbacks.onLoad( payload.msg );\r\n\r\n\t\t\t\t\tif ( this.runtimeRef.terminateRequested ) {\r\n\r\n\t\t\t\t\t\tif ( this.runtimeRef.logging.enabled ) { console.info( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run reported error. Terminating application on request!' ); }\r\n\t\t\t\t\t\tthis.runtimeRef._terminate();\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tconsole.error( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Received unknown command: ' + payload.cmd );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tLoaderWorker.prototype.setCallbacks = function ( meshBuilder, onLoad ) {\r\n\t\t\tthis.callbacks.meshBuilder = Validator.verifyInput( meshBuilder, this.callbacks.meshBuilder );\r\n\t\t\tthis.callbacks.onLoad = Validator.verifyInput( onLoad, this.callbacks.onLoad );\r\n\t\t};\r\n\r\n\t\tLoaderWorker.prototype.run = function( payload ) {\r\n\t\t\tif ( Validator.isValid( this.queuedMessage ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'Already processing message. Rejecting new run instruction' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.queuedMessage = payload;\r\n\t\t\t\tthis.started = true;\r\n\r\n\t\t\t}\r\n\t\t\tif ( ! Validator.isValid( this.callbacks.meshBuilder ) ) { throw 'Unable to run as no \"MeshBuilder\" callback is set.'; }\r\n\t\t\tif ( ! Validator.isValid( this.callbacks.onLoad ) ) { throw 'Unable to run as no \"onLoad\" callback is set.'; }\r\n\t\t\tif ( payload.cmd !== 'run' ) { payload.cmd = 'run'; }\r\n\t\t\tif ( Validator.isValid( payload.logging ) ) {\r\n\r\n\t\t\t\tpayload.logging.enabled = payload.logging.enabled === true;\r\n\t\t\t\tpayload.logging.debug = payload.logging.debug === true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tpayload.logging = {\r\n\t\t\t\t\tenabled: true,\r\n\t\t\t\t\tdebug: false\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\t\t\tthis._postMessage();\r\n\t\t};\r\n\r\n\t\tLoaderWorker.prototype._postMessage = function () {\r\n\t\t\tif ( Validator.isValid( this.queuedMessage ) && Validator.isValid( this.worker ) ) {\r\n\r\n\t\t\t\tif ( this.queuedMessage.data.input instanceof ArrayBuffer ) {\r\n\r\n\t\t\t\t\tvar content;\r\n\t\t\t\t\tif ( this.forceCopy ) {\r\n\r\n\t\t\t\t\t\tcontent = this.queuedMessage.data.input.slice( 0 );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcontent = this.queuedMessage.data.input;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.worker.postMessage( this.queuedMessage, [ content ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.worker.postMessage( this.queuedMessage );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tLoaderWorker.prototype.setTerminateRequested = function ( terminateRequested ) {\r\n\t\t\tthis.terminateRequested = terminateRequested === true;\r\n\t\t\tif ( this.terminateRequested && Validator.isValid( this.worker ) && ! Validator.isValid( this.queuedMessage ) && this.started ) {\r\n\r\n\t\t\t\tif ( this.logging.enabled ) { console.info( 'Worker is terminated immediately as it is not running!' ); }\r\n\t\t\t\tthis._terminate();\r\n\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tLoaderWorker.prototype._terminate = function () {\r\n\t\t\tthis.worker.terminate();\r\n\t\t\tthis._reset();\r\n\t\t};\r\n\r\n\t\treturn LoaderWorker;\r\n\r\n\t})();\r\n\r\n\tfunction WorkerSupport() {\r\n\t\tconsole.info( 'Using LoaderSupport.WorkerSupport version: ' + WORKER_SUPPORT_VERSION );\r\n\t\tthis.logging = {\r\n\t\t\tenabled: true,\r\n\t\t\tdebug: false\r\n\t\t};\r\n\r\n\t\t// check worker support first\r\n\t\tif ( window.Worker === undefined ) { throw \"This browser does not support web workers!\"; }\r\n\t\tif ( window.Blob === undefined  ) { throw \"This browser does not support Blob!\"; }\r\n\t\tif ( typeof window.URL.createObjectURL !== 'function'  ) { throw \"This browser does not support Object creation from URL!\"; }\r\n\r\n\t\tthis.loaderWorker = new LoaderWorker();\r\n\t}\r\n\t\r\n\tWorkerSupport.prototype.setLogging = function ( enabled, debug ) {\r\n\t\tthis.logging.enabled = enabled === true;\r\n\t\tthis.logging.debug = debug === true;\r\n\t\tthis.loaderWorker.setLogging( this.logging.enabled, this.logging.debug );\r\n\t};\r\n\t\r\n\tWorkerSupport.prototype.setForceWorkerDataCopy = function ( forceWorkerDataCopy ) {\r\n\t\tthis.loaderWorker.setForceCopy( forceWorkerDataCopy );\r\n\t};\r\n\t\r\n\tWorkerSupport.prototype.validate = function ( functionCodeBuilder, parserName, libLocations, libPath, runnerImpl ) {\r\n\t\tif ( Validator.isValid( this.loaderWorker.worker ) ) { return; }\r\n\r\n\t\tif ( this.logging.enabled ) {\r\n\r\n\t\t\tconsole.info( 'WorkerSupport: Building worker code...' );\r\n\t\t\tconsole.time( 'buildWebWorkerCode' );\r\n\r\n\t\t}\r\n\t\tif ( Validator.isValid( runnerImpl ) ) {\r\n\r\n\t\t\tif ( this.logging.enabled ) { console.info( 'WorkerSupport: Using \"' + runnerImpl.name + '\" as Runner class for worker.' ); }\r\n\r\n\t\t} else {\r\n\r\n\t\t\trunnerImpl = LoaderSupport.WorkerRunnerRefImpl;\r\n\t\t\tif ( this.logging.enabled ) { console.info( 'WorkerSupport: Using DEFAULT \"LoaderSupport.WorkerRunnerRefImpl\" as Runner class for worker.' ); }\r\n\r\n\t\t}\r\n\r\n\t\tvar userWorkerCode = functionCodeBuilder( buildObject, buildSingleton );\r\n\t\tuserWorkerCode += 'var Parser = '+ parserName +  ';\\n\\n';\r\n\t\tuserWorkerCode += buildSingleton( runnerImpl.name, runnerImpl );\r\n\t\tuserWorkerCode += 'new ' + runnerImpl.name + '();\\n\\n';\r\n\r\n\t\tvar scope = this;\r\n\t\tif ( Validator.isValid( libLocations ) && libLocations.length > 0 ) {\r\n\r\n\t\t\tvar libsContent = '';\r\n\t\t\tvar loadAllLibraries = function ( path, locations ) {\r\n\t\t\t\tif ( locations.length === 0 ) {\r\n\r\n\t\t\t\t\tscope.loaderWorker.initWorker( libsContent + userWorkerCode, runnerImpl.name );\r\n\t\t\t\t\tif ( scope.logging.enabled ) { console.timeEnd( 'buildWebWorkerCode' ); }\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvar loadedLib = function ( contentAsString ) {\r\n\t\t\t\t\t\tlibsContent += contentAsString;\r\n\t\t\t\t\t\tloadAllLibraries( path, locations );\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvar fileLoader = new FileLoader();\r\n\t\t\t\t\tfileLoader.setPath( path );\r\n\t\t\t\t\tfileLoader.setResponseType( 'text' );\r\n\t\t\t\t\tfileLoader.load( locations[ 0 ], loadedLib );\r\n\t\t\t\t\tlocations.shift();\r\n\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tloadAllLibraries( libPath, libLocations );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.loaderWorker.initWorker( userWorkerCode, runnerImpl.name );\r\n\t\t\tif ( this.logging.enabled ) { console.timeEnd( 'buildWebWorkerCode' ); }\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\tWorkerSupport.prototype.setCallbacks = function ( meshBuilder, onLoad ) {\r\n\t\tthis.loaderWorker.setCallbacks( meshBuilder, onLoad );\r\n\t};\r\n\t\r\n\tWorkerSupport.prototype.run = function ( payload ) {\r\n\t\tthis.loaderWorker.run( payload );\r\n\t};\r\n\t\r\n\tWorkerSupport.prototype.setTerminateRequested = function ( terminateRequested ) {\r\n\t\tthis.loaderWorker.setTerminateRequested( terminateRequested );\r\n\t};\r\n\r\n\tvar buildObject = function ( fullName, object ) {\r\n\t\tvar objectString = fullName + ' = {\\n';\r\n\t\tvar part;\r\n\t\tfor ( var name in object ) {\r\n\r\n\t\t\tpart = object[ name ];\r\n\t\t\tif ( typeof( part ) === 'string' || part instanceof String ) {\r\n\r\n\t\t\t\tpart = part.replace( '\\n', '\\\\n' );\r\n\t\t\t\tpart = part.replace( '\\r', '\\\\r' );\r\n\t\t\t\tobjectString += '\\t' + name + ': \"' + part + '\",\\n';\r\n\r\n\t\t\t} else if ( part instanceof Array ) {\r\n\r\n\t\t\t\tobjectString += '\\t' + name + ': [' + part + '],\\n';\r\n\r\n\t\t\t} else if ( Number.isInteger( part ) ) {\r\n\r\n\t\t\t\tobjectString += '\\t' + name + ': ' + part + ',\\n';\r\n\r\n\t\t\t} else if ( typeof part === 'function' ) {\r\n\r\n\t\t\t\tobjectString += '\\t' + name + ': ' + part + ',\\n';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tobjectString += '}\\n\\n';\r\n\r\n\t\treturn objectString;\r\n\t};\r\n\r\n\tvar buildSingleton = function ( fullName, object, internalName, basePrototypeName, ignoreFunctions ) {\r\n\t\tvar objectString = '';\r\n\t\tvar objectName = ( Validator.isValid( internalName ) ) ? internalName : object.name;\r\n\r\n\t\tvar funcString, objectPart, constructorString;\r\n\t\tignoreFunctions = Validator.verifyInput( ignoreFunctions, [] );\r\n\t\tfor ( var name in object.prototype ) {\r\n\r\n\t\t\tobjectPart = object.prototype[ name ];\r\n\t\t\tif ( name === 'constructor' ) {\r\n\r\n\t\t\t\tfuncString = objectPart.toString();\r\n\t\t\t\tfuncString = funcString.replace( 'function', '' );\r\n\t\t\t\tconstructorString = '\\tfunction ' + objectName + funcString + ';\\n\\n';\r\n\r\n\t\t\t} else if ( typeof objectPart === 'function' ) {\r\n\r\n\t\t\t\tif ( ignoreFunctions.indexOf( name ) < 0 ) {\r\n\r\n\t\t\t\t\tfuncString = objectPart.toString();\r\n\t\t\t\t\tobjectString += '\\t' + objectName + '.prototype.' + name + ' = ' + funcString + ';\\n\\n';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tobjectString += '\\treturn ' + objectName + ';\\n';\r\n\t\tobjectString += '})();\\n\\n';\r\n\r\n\t\tvar inheritanceBlock = '';\r\n\t\tif ( Validator.isValid( basePrototypeName ) ) {\r\n\r\n\t\t\tinheritanceBlock += '\\n';\r\n\t\t\tinheritanceBlock += objectName + '.prototype = Object.create( ' + basePrototypeName + '.prototype );\\n';\r\n\t\t\tinheritanceBlock += objectName + '.constructor = ' + objectName + ';\\n';\r\n\t\t\tinheritanceBlock += '\\n';\r\n\t\t}\r\n\t\tif ( ! Validator.isValid( constructorString ) ) {\r\n\r\n\t\t\tconstructorString = fullName + ' = (function () {\\n\\n';\r\n\t\t\tconstructorString += inheritanceBlock + '\\t' + object.prototype.constructor.toString() + '\\n\\n';\r\n\t\t\tobjectString = constructorString + objectString;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobjectString = fullName + ' = (function () {\\n\\n' + inheritanceBlock + constructorString + objectString;\r\n\r\n\t\t}\r\n\r\n\t\treturn objectString;\r\n\t};\r\n\r\n\treturn WorkerSupport;\r\n\r\n})();\r\n\r\nLoaderSupport.WorkerDirector = (function () {\r\n\r\n\tvar LOADER_WORKER_DIRECTOR_VERSION = '2.2.2';\r\n\r\n\tvar Validator = LoaderSupport.Validator;\r\n\r\n\tvar MAX_WEB_WORKER = 16;\r\n\tvar MAX_QUEUE_SIZE = 8192;\r\n\r\n\tfunction WorkerDirector( classDef ) {\r\n\t\tconsole.info( 'Using LoaderSupport.WorkerDirector version: ' + LOADER_WORKER_DIRECTOR_VERSION );\r\n\t\tthis.logging = {\r\n\t\t\tenabled: true,\r\n\t\t\tdebug: false\r\n\t\t};\r\n\r\n\t\tthis.maxQueueSize = MAX_QUEUE_SIZE ;\r\n\t\tthis.maxWebWorkers = MAX_WEB_WORKER;\r\n\t\tthis.crossOrigin = null;\r\n\r\n\t\tif ( ! Validator.isValid( classDef ) ) { throw 'Provided invalid classDef: ' + classDef; }\r\n\r\n\t\tthis.workerDescription = {\r\n\t\t\tclassDef: classDef,\r\n\t\t\tglobalCallbacks: {},\r\n\t\t\tworkerSupports: {},\r\n\t\t\tforceWorkerDataCopy: true\r\n\t\t};\r\n\t\tthis.objectsCompleted = 0;\r\n\t\tthis.instructionQueue = [];\r\n\t\tthis.instructionQueuePointer = 0;\r\n\r\n\t\tthis.callbackOnFinishedProcessing = null;\r\n\t}\r\n\t\r\n\tWorkerDirector.prototype.setLogging = function ( enabled, debug ) {\r\n\t\tthis.logging.enabled = enabled === true;\r\n\t\tthis.logging.debug = debug === true;\r\n\t};\r\n\t\r\n\tWorkerDirector.prototype.getMaxQueueSize = function () {\r\n\t\treturn this.maxQueueSize;\r\n\t};\r\n\t\r\n\tWorkerDirector.prototype.getMaxWebWorkers = function () {\r\n\t\treturn this.maxWebWorkers;\r\n\t};\r\n\t\r\n\tWorkerDirector.prototype.setCrossOrigin = function ( crossOrigin ) {\r\n\t\tthis.crossOrigin = crossOrigin;\r\n\t};\r\n\t\r\n\tWorkerDirector.prototype.setForceWorkerDataCopy = function ( forceWorkerDataCopy ) {\r\n\t\tthis.workerDescription.forceWorkerDataCopy = forceWorkerDataCopy === true;\r\n\t};\r\n\t\r\n\tWorkerDirector.prototype.prepareWorkers = function ( globalCallbacks, maxQueueSize, maxWebWorkers ) {\n\t\tvar this$1 = this;\n\r\n\t\tif ( Validator.isValid( globalCallbacks ) ) { this.workerDescription.globalCallbacks = globalCallbacks; }\r\n\t\tthis.maxQueueSize = Math.min( maxQueueSize, MAX_QUEUE_SIZE );\r\n\t\tthis.maxWebWorkers = Math.min( maxWebWorkers, MAX_WEB_WORKER );\r\n\t\tthis.maxWebWorkers = Math.min( this.maxWebWorkers, this.maxQueueSize );\r\n\t\tthis.objectsCompleted = 0;\r\n\t\tthis.instructionQueue = [];\r\n\t\tthis.instructionQueuePointer = 0;\r\n\r\n\t\tfor ( var instanceNo = 0; instanceNo < this.maxWebWorkers; instanceNo++ ) {\r\n\r\n\t\t\tvar workerSupport = new LoaderSupport.WorkerSupport();\r\n\t\t\tworkerSupport.setLogging( this$1.logging.enabled, this$1.logging.debug );\r\n\t\t\tworkerSupport.setForceWorkerDataCopy( this$1.workerDescription.forceWorkerDataCopy );\r\n\t\t\tthis$1.workerDescription.workerSupports[ instanceNo ] = {\r\n\t\t\t\tinstanceNo: instanceNo,\r\n\t\t\t\tinUse: false,\r\n\t\t\t\tterminateRequested: false,\r\n\t\t\t\tworkerSupport: workerSupport,\r\n\t\t\t\tloader: null\r\n\t\t\t};\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\tWorkerDirector.prototype.enqueueForRun = function ( prepData ) {\r\n\t\tif ( this.instructionQueue.length < this.maxQueueSize ) {\r\n\t\t\tthis.instructionQueue.push( prepData );\r\n\t\t}\r\n\t};\r\n\t\r\n\tWorkerDirector.prototype.isRunning = function () {\r\n\t\tvar wsKeys = Object.keys( this.workerDescription.workerSupports );\r\n\t\treturn ( ( this.instructionQueue.length > 0 && this.instructionQueuePointer < this.instructionQueue.length ) || wsKeys.length > 0 );\r\n\t};\r\n\t\r\n\tWorkerDirector.prototype.processQueue = function () {\n\t\tvar this$1 = this;\n\r\n\t\tvar prepData, supportDesc;\r\n\t\tfor ( var instanceNo in this$1.workerDescription.workerSupports ) {\r\n\r\n\t\t\tsupportDesc = this$1.workerDescription.workerSupports[ instanceNo ];\r\n\t\t\tif ( ! supportDesc.inUse ) {\r\n\r\n\t\t\t\tif ( this$1.instructionQueuePointer < this$1.instructionQueue.length ) {\r\n\r\n\t\t\t\t\tprepData = this$1.instructionQueue[ this$1.instructionQueuePointer ];\r\n\t\t\t\t\tthis$1._kickWorkerRun( prepData, supportDesc );\r\n\t\t\t\t\tthis$1.instructionQueuePointer++;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis$1._deregister( supportDesc );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! this.isRunning() && this.callbackOnFinishedProcessing !== null ) {\r\n\r\n\t\t\tthis.callbackOnFinishedProcessing();\r\n\t\t\tthis.callbackOnFinishedProcessing = null;\r\n\r\n\t\t}\r\n\t};\r\n\r\n\tWorkerDirector.prototype._kickWorkerRun = function( prepData, supportDesc ) {\r\n\t\tsupportDesc.inUse = true;\r\n\t\tsupportDesc.workerSupport.setTerminateRequested( supportDesc.terminateRequested );\r\n\r\n\t\tif ( this.logging.enabled ) { console.info( '\\nAssigning next item from queue to worker (queue length: ' + this.instructionQueue.length + ')\\n\\n' ); }\r\n\r\n\t\tvar scope = this;\r\n\t\tvar prepDataCallbacks = prepData.getCallbacks();\r\n\t\tvar globalCallbacks = this.workerDescription.globalCallbacks;\r\n\t\tvar wrapperOnLoad = function ( event ) {\r\n\t\t\tif ( Validator.isValid( globalCallbacks.onLoad ) ) { globalCallbacks.onLoad( event ); }\r\n\t\t\tif ( Validator.isValid( prepDataCallbacks.onLoad ) ) { prepDataCallbacks.onLoad( event ); }\r\n\t\t\tscope.objectsCompleted++;\r\n\t\t\tsupportDesc.inUse = false;\r\n\r\n\t\t\tscope.processQueue();\r\n\t\t};\r\n\r\n\t\tvar wrapperOnProgress = function ( event ) {\r\n\t\t\tif ( Validator.isValid( globalCallbacks.onProgress ) ) { globalCallbacks.onProgress( event ); }\r\n\t\t\tif ( Validator.isValid( prepDataCallbacks.onProgress ) ) { prepDataCallbacks.onProgress( event ); }\r\n\t\t};\r\n\r\n\t\tvar wrapperOnMeshAlter = function ( event, override ) {\r\n\t\t\tif ( Validator.isValid( globalCallbacks.onMeshAlter ) ) { override = globalCallbacks.onMeshAlter( event, override ); }\r\n\t\t\tif ( Validator.isValid( prepDataCallbacks.onMeshAlter ) ) { override = globalCallbacks.onMeshAlter( event, override ); }\r\n\t\t\treturn override;\r\n\t\t};\r\n\r\n\t\tvar wrapperOnLoadMaterials = function ( materials ) {\r\n\t\t\tif ( Validator.isValid( globalCallbacks.onLoadMaterials ) ) { materials = globalCallbacks.onLoadMaterials( materials ); }\r\n\t\t\tif ( Validator.isValid( prepDataCallbacks.onLoadMaterials ) ) { materials = prepDataCallbacks.onLoadMaterials( materials ); }\r\n\t\t\treturn materials;\r\n\t\t};\r\n\r\n\t\tvar wrapperOnReportError = function ( errorMessage ) {\r\n\t\t\tvar continueProcessing = true;\r\n\t\t\tif ( Validator.isValid( globalCallbacks.onReportError ) ) { continueProcessing = globalCallbacks.onReportError( supportDesc, errorMessage ); }\r\n\t\t\tif ( Validator.isValid( prepDataCallbacks.onReportError ) )\t{ continueProcessing = prepDataCallbacks.onReportError( supportDesc, errorMessage ); }\r\n\r\n\t\t\tif ( ! Validator.isValid( globalCallbacks.onReportError ) && ! Validator.isValid( prepDataCallbacks.onReportError ) ) {\r\n\r\n\t\t\t\tconsole.error( 'Loader reported an error: ' );\r\n\t\t\t\tconsole.error( errorMessage );\r\n\r\n\t\t\t}\r\n\t\t\tif ( continueProcessing ) {\r\n\r\n\t\t\t\tsupportDesc.inUse = false;\r\n\t\t\t\tscope.processQueue();\r\n\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tsupportDesc.loader = this._buildLoader( supportDesc.instanceNo );\r\n\r\n\t\tvar updatedCallbacks = new LoaderSupport.Callbacks();\r\n\t\tupdatedCallbacks.setCallbackOnLoad( wrapperOnLoad );\r\n\t\tupdatedCallbacks.setCallbackOnProgress( wrapperOnProgress );\r\n\t\tupdatedCallbacks.setCallbackOnReportError( wrapperOnReportError );\r\n\t\tupdatedCallbacks.setCallbackOnMeshAlter( wrapperOnMeshAlter );\r\n\t\tupdatedCallbacks.setCallbackOnLoadMaterials( wrapperOnLoadMaterials );\r\n\t\tprepData.callbacks = updatedCallbacks;\r\n\r\n\t\tsupportDesc.loader.run( prepData, supportDesc.workerSupport );\r\n\t};\r\n\r\n\tWorkerDirector.prototype._buildLoader = function ( instanceNo ) {\r\n\t\tvar classDef = this.workerDescription.classDef;\r\n\t\tvar loader = Object.create( classDef.prototype );\r\n\t\tclassDef.call( loader, DefaultLoadingManager );\r\n\r\n\t\t// verify that all required functions are implemented\r\n\t\tif ( ! loader.hasOwnProperty( 'instanceNo' ) ) { throw classDef.name + ' has no property \"instanceNo\".'; }\r\n\t\tloader.instanceNo = instanceNo;\r\n\r\n\t\tif ( ! loader.hasOwnProperty( 'workerSupport' ) ) {\r\n\r\n\t\t\tthrow classDef.name + ' has no property \"workerSupport\".';\r\n\r\n\t\t}\r\n\t\tif ( typeof loader.run !== 'function'  ) { throw classDef.name + ' has no function \"run\".'; }\r\n\t\tif ( ! loader.hasOwnProperty( 'callbacks' ) || ! Validator.isValid( loader.callbacks ) ) {\r\n\r\n\t\t\tconsole.warn( classDef.name + ' has an invalid property \"callbacks\". Will change to \"LoaderSupport.Callbacks\"' );\r\n\t\t\tloader.callbacks = new LoaderSupport.Callbacks();\r\n\r\n\t\t}\r\n\r\n\t\treturn loader;\r\n\t};\r\n\r\n\tWorkerDirector.prototype._deregister = function ( supportDesc ) {\r\n\t\tif ( Validator.isValid( supportDesc ) ) {\r\n\r\n\t\t\tsupportDesc.workerSupport.setTerminateRequested( true );\r\n\t\t\tif ( this.logging.enabled ) { console.info( 'Requested termination of worker #' + supportDesc.instanceNo + '.' ); }\r\n\r\n\t\t\tvar loaderCallbacks = supportDesc.loader.callbacks;\r\n\t\t\tif ( Validator.isValid( loaderCallbacks.onProgress ) ) { loaderCallbacks.onProgress( { detail: { text: '' } } ); }\r\n\t\t\tdelete this.workerDescription.workerSupports[ supportDesc.instanceNo ];\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\tWorkerDirector.prototype.tearDown = function ( callbackOnFinishedProcessing ) {\n\t\tvar this$1 = this;\n\r\n\t\tif ( this.logging.enabled ) { console.info( 'WorkerDirector received the deregister call. Terminating all workers!' ); }\r\n\r\n\t\tthis.instructionQueuePointer = this.instructionQueue.length;\r\n\t\tthis.callbackOnFinishedProcessing = Validator.verifyInput( callbackOnFinishedProcessing, null );\r\n\r\n\t\tfor ( var name in this$1.workerDescription.workerSupports ) {\r\n\r\n\t\t\tthis$1.workerDescription.workerSupports[ name ].terminateRequested = true;\r\n\r\n\t\t}\r\n\t};\r\n\r\n\treturn WorkerDirector;\r\n\r\n})();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MD2Loader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nMD2Loader.prototype = {\r\n\r\n\tconstructor: MD2Loader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tonLoad( scope.parse( buffer ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: ( function () {\r\n\r\n\t\tvar normalData = [\r\n\t\t\t[ - 0.525731, 0.000000, 0.850651 ], [ - 0.442863, 0.238856, 0.864188 ],\r\n\t\t\t[ - 0.295242, 0.000000, 0.955423 ], [ - 0.309017, 0.500000, 0.809017 ],\r\n\t\t\t[ - 0.162460, 0.262866, 0.951056 ], [ 0.000000, 0.000000, 1.000000 ],\r\n\t\t\t[ 0.000000, 0.850651, 0.525731 ], [ - 0.147621, 0.716567, 0.681718 ],\r\n\t\t\t[ 0.147621, 0.716567, 0.681718 ], [ 0.000000, 0.525731, 0.850651 ],\r\n\t\t\t[ 0.309017, 0.500000, 0.809017 ], [ 0.525731, 0.000000, 0.850651 ],\r\n\t\t\t[ 0.295242, 0.000000, 0.955423 ], [ 0.442863, 0.238856, 0.864188 ],\r\n\t\t\t[ 0.162460, 0.262866, 0.951056 ], [ - 0.681718, 0.147621, 0.716567 ],\r\n\t\t\t[ - 0.809017, 0.309017, 0.500000 ], [ - 0.587785, 0.425325, 0.688191 ],\r\n\t\t\t[ - 0.850651, 0.525731, 0.000000 ], [ - 0.864188, 0.442863, 0.238856 ],\r\n\t\t\t[ - 0.716567, 0.681718, 0.147621 ], [ - 0.688191, 0.587785, 0.425325 ],\r\n\t\t\t[ - 0.500000, 0.809017, 0.309017 ], [ - 0.238856, 0.864188, 0.442863 ],\r\n\t\t\t[ - 0.425325, 0.688191, 0.587785 ], [ - 0.716567, 0.681718, - 0.147621 ],\r\n\t\t\t[ - 0.500000, 0.809017, - 0.309017 ], [ - 0.525731, 0.850651, 0.000000 ],\r\n\t\t\t[ 0.000000, 0.850651, - 0.525731 ], [ - 0.238856, 0.864188, - 0.442863 ],\r\n\t\t\t[ 0.000000, 0.955423, - 0.295242 ], [ - 0.262866, 0.951056, - 0.162460 ],\r\n\t\t\t[ 0.000000, 1.000000, 0.000000 ], [ 0.000000, 0.955423, 0.295242 ],\r\n\t\t\t[ - 0.262866, 0.951056, 0.162460 ], [ 0.238856, 0.864188, 0.442863 ],\r\n\t\t\t[ 0.262866, 0.951056, 0.162460 ], [ 0.500000, 0.809017, 0.309017 ],\r\n\t\t\t[ 0.238856, 0.864188, - 0.442863 ], [ 0.262866, 0.951056, - 0.162460 ],\r\n\t\t\t[ 0.500000, 0.809017, - 0.309017 ], [ 0.850651, 0.525731, 0.000000 ],\r\n\t\t\t[ 0.716567, 0.681718, 0.147621 ], [ 0.716567, 0.681718, - 0.147621 ],\r\n\t\t\t[ 0.525731, 0.850651, 0.000000 ], [ 0.425325, 0.688191, 0.587785 ],\r\n\t\t\t[ 0.864188, 0.442863, 0.238856 ], [ 0.688191, 0.587785, 0.425325 ],\r\n\t\t\t[ 0.809017, 0.309017, 0.500000 ], [ 0.681718, 0.147621, 0.716567 ],\r\n\t\t\t[ 0.587785, 0.425325, 0.688191 ], [ 0.955423, 0.295242, 0.000000 ],\r\n\t\t\t[ 1.000000, 0.000000, 0.000000 ], [ 0.951056, 0.162460, 0.262866 ],\r\n\t\t\t[ 0.850651, - 0.525731, 0.000000 ], [ 0.955423, - 0.295242, 0.000000 ],\r\n\t\t\t[ 0.864188, - 0.442863, 0.238856 ], [ 0.951056, - 0.162460, 0.262866 ],\r\n\t\t\t[ 0.809017, - 0.309017, 0.500000 ], [ 0.681718, - 0.147621, 0.716567 ],\r\n\t\t\t[ 0.850651, 0.000000, 0.525731 ], [ 0.864188, 0.442863, - 0.238856 ],\r\n\t\t\t[ 0.809017, 0.309017, - 0.500000 ], [ 0.951056, 0.162460, - 0.262866 ],\r\n\t\t\t[ 0.525731, 0.000000, - 0.850651 ], [ 0.681718, 0.147621, - 0.716567 ],\r\n\t\t\t[ 0.681718, - 0.147621, - 0.716567 ], [ 0.850651, 0.000000, - 0.525731 ],\r\n\t\t\t[ 0.809017, - 0.309017, - 0.500000 ], [ 0.864188, - 0.442863, - 0.238856 ],\r\n\t\t\t[ 0.951056, - 0.162460, - 0.262866 ], [ 0.147621, 0.716567, - 0.681718 ],\r\n\t\t\t[ 0.309017, 0.500000, - 0.809017 ], [ 0.425325, 0.688191, - 0.587785 ],\r\n\t\t\t[ 0.442863, 0.238856, - 0.864188 ], [ 0.587785, 0.425325, - 0.688191 ],\r\n\t\t\t[ 0.688191, 0.587785, - 0.425325 ], [ - 0.147621, 0.716567, - 0.681718 ],\r\n\t\t\t[ - 0.309017, 0.500000, - 0.809017 ], [ 0.000000, 0.525731, - 0.850651 ],\r\n\t\t\t[ - 0.525731, 0.000000, - 0.850651 ], [ - 0.442863, 0.238856, - 0.864188 ],\r\n\t\t\t[ - 0.295242, 0.000000, - 0.955423 ], [ - 0.162460, 0.262866, - 0.951056 ],\r\n\t\t\t[ 0.000000, 0.000000, - 1.000000 ], [ 0.295242, 0.000000, - 0.955423 ],\r\n\t\t\t[ 0.162460, 0.262866, - 0.951056 ], [ - 0.442863, - 0.238856, - 0.864188 ],\r\n\t\t\t[ - 0.309017, - 0.500000, - 0.809017 ], [ - 0.162460, - 0.262866, - 0.951056 ],\r\n\t\t\t[ 0.000000, - 0.850651, - 0.525731 ], [ - 0.147621, - 0.716567, - 0.681718 ],\r\n\t\t\t[ 0.147621, - 0.716567, - 0.681718 ], [ 0.000000, - 0.525731, - 0.850651 ],\r\n\t\t\t[ 0.309017, - 0.500000, - 0.809017 ], [ 0.442863, - 0.238856, - 0.864188 ],\r\n\t\t\t[ 0.162460, - 0.262866, - 0.951056 ], [ 0.238856, - 0.864188, - 0.442863 ],\r\n\t\t\t[ 0.500000, - 0.809017, - 0.309017 ], [ 0.425325, - 0.688191, - 0.587785 ],\r\n\t\t\t[ 0.716567, - 0.681718, - 0.147621 ], [ 0.688191, - 0.587785, - 0.425325 ],\r\n\t\t\t[ 0.587785, - 0.425325, - 0.688191 ], [ 0.000000, - 0.955423, - 0.295242 ],\r\n\t\t\t[ 0.000000, - 1.000000, 0.000000 ], [ 0.262866, - 0.951056, - 0.162460 ],\r\n\t\t\t[ 0.000000, - 0.850651, 0.525731 ], [ 0.000000, - 0.955423, 0.295242 ],\r\n\t\t\t[ 0.238856, - 0.864188, 0.442863 ], [ 0.262866, - 0.951056, 0.162460 ],\r\n\t\t\t[ 0.500000, - 0.809017, 0.309017 ], [ 0.716567, - 0.681718, 0.147621 ],\r\n\t\t\t[ 0.525731, - 0.850651, 0.000000 ], [ - 0.238856, - 0.864188, - 0.442863 ],\r\n\t\t\t[ - 0.500000, - 0.809017, - 0.309017 ], [ - 0.262866, - 0.951056, - 0.162460 ],\r\n\t\t\t[ - 0.850651, - 0.525731, 0.000000 ], [ - 0.716567, - 0.681718, - 0.147621 ],\r\n\t\t\t[ - 0.716567, - 0.681718, 0.147621 ], [ - 0.525731, - 0.850651, 0.000000 ],\r\n\t\t\t[ - 0.500000, - 0.809017, 0.309017 ], [ - 0.238856, - 0.864188, 0.442863 ],\r\n\t\t\t[ - 0.262866, - 0.951056, 0.162460 ], [ - 0.864188, - 0.442863, 0.238856 ],\r\n\t\t\t[ - 0.809017, - 0.309017, 0.500000 ], [ - 0.688191, - 0.587785, 0.425325 ],\r\n\t\t\t[ - 0.681718, - 0.147621, 0.716567 ], [ - 0.442863, - 0.238856, 0.864188 ],\r\n\t\t\t[ - 0.587785, - 0.425325, 0.688191 ], [ - 0.309017, - 0.500000, 0.809017 ],\r\n\t\t\t[ - 0.147621, - 0.716567, 0.681718 ], [ - 0.425325, - 0.688191, 0.587785 ],\r\n\t\t\t[ - 0.162460, - 0.262866, 0.951056 ], [ 0.442863, - 0.238856, 0.864188 ],\r\n\t\t\t[ 0.162460, - 0.262866, 0.951056 ], [ 0.309017, - 0.500000, 0.809017 ],\r\n\t\t\t[ 0.147621, - 0.716567, 0.681718 ], [ 0.000000, - 0.525731, 0.850651 ],\r\n\t\t\t[ 0.425325, - 0.688191, 0.587785 ], [ 0.587785, - 0.425325, 0.688191 ],\r\n\t\t\t[ 0.688191, - 0.587785, 0.425325 ], [ - 0.955423, 0.295242, 0.000000 ],\r\n\t\t\t[ - 0.951056, 0.162460, 0.262866 ], [ - 1.000000, 0.000000, 0.000000 ],\r\n\t\t\t[ - 0.850651, 0.000000, 0.525731 ], [ - 0.955423, - 0.295242, 0.000000 ],\r\n\t\t\t[ - 0.951056, - 0.162460, 0.262866 ], [ - 0.864188, 0.442863, - 0.238856 ],\r\n\t\t\t[ - 0.951056, 0.162460, - 0.262866 ], [ - 0.809017, 0.309017, - 0.500000 ],\r\n\t\t\t[ - 0.864188, - 0.442863, - 0.238856 ], [ - 0.951056, - 0.162460, - 0.262866 ],\r\n\t\t\t[ - 0.809017, - 0.309017, - 0.500000 ], [ - 0.681718, 0.147621, - 0.716567 ],\r\n\t\t\t[ - 0.681718, - 0.147621, - 0.716567 ], [ - 0.850651, 0.000000, - 0.525731 ],\r\n\t\t\t[ - 0.688191, 0.587785, - 0.425325 ], [ - 0.587785, 0.425325, - 0.688191 ],\r\n\t\t\t[ - 0.425325, 0.688191, - 0.587785 ], [ - 0.425325, - 0.688191, - 0.587785 ],\r\n\t\t\t[ - 0.587785, - 0.425325, - 0.688191 ], [ - 0.688191, - 0.587785, - 0.425325 ]\r\n\t\t];\r\n\r\n\t\treturn function ( buffer ) {\r\n\r\n\t\t\tconsole.time( 'MD2Loader' );\r\n\r\n\t\t\tvar data = new DataView( buffer );\r\n\r\n\t\t\t// http://tfc.duke.free.fr/coding/md2-specs-en.html\r\n\r\n\t\t\tvar header = {};\r\n\t\t\tvar headerNames = [\r\n\t\t\t\t'ident', 'version',\r\n\t\t\t\t'skinwidth', 'skinheight',\r\n\t\t\t\t'framesize',\r\n\t\t\t\t'num_skins', 'num_vertices', 'num_st', 'num_tris', 'num_glcmds', 'num_frames',\r\n\t\t\t\t'offset_skins', 'offset_st', 'offset_tris', 'offset_frames', 'offset_glcmds', 'offset_end'\r\n\t\t\t];\r\n\r\n\t\t\tfor ( var i = 0; i < headerNames.length; i ++ ) {\r\n\r\n\t\t\t\theader[ headerNames[ i ] ] = data.getInt32( i * 4, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( header.ident !== 844121161 || header.version !== 8 ) {\r\n\r\n\t\t\t\tconsole.error( 'Not a valid MD2 file' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( header.offset_end !== data.byteLength ) {\r\n\r\n\t\t\t\tconsole.error( 'Corrupted MD2 file' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\t// uvs\r\n\r\n\t\t\tvar uvsTemp = [];\r\n\t\t\tvar offset = header.offset_st;\r\n\r\n\t\t\tfor ( var i = 0, l = header.num_st; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar u = data.getInt16( offset + 0, true );\r\n\t\t\t\tvar v = data.getInt16( offset + 2, true );\r\n\r\n\t\t\t\tuvsTemp.push( u / header.skinwidth, 1 - ( v / header.skinheight ) );\r\n\r\n\t\t\t\toffset += 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// triangles\r\n\r\n\t\t\toffset = header.offset_tris;\r\n\r\n\t\t\tvar vertexIndices = [];\r\n\t\t\tvar uvIndices = [];\r\n\r\n\t\t\tfor ( var i = 0, l = header.num_tris; i < l; i ++ ) {\r\n\r\n\t\t\t\tvertexIndices.push(\r\n\t\t\t\t\tdata.getUint16( offset + 0, true ),\r\n\t\t\t\t\tdata.getUint16( offset + 2, true ),\r\n\t\t\t\t\tdata.getUint16( offset + 4, true )\r\n\t\t\t\t);\r\n\r\n\t\t\t\tuvIndices.push(\r\n\t\t\t\t\tdata.getUint16( offset + 6, true ),\r\n\t\t\t\t\tdata.getUint16( offset + 8, true ),\r\n\t\t\t\t\tdata.getUint16( offset + 10, true )\r\n\t\t\t\t);\r\n\r\n\t\t\t\toffset += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// frames\r\n\r\n\t\t\tvar translation = new Vector3();\r\n\t\t\tvar scale = new Vector3();\r\n\t\t\tvar string = [];\r\n\r\n\t\t\tvar frames = [];\r\n\r\n\t\t\toffset = header.offset_frames;\r\n\r\n\t\t\tfor ( var i = 0, l = header.num_frames; i < l; i ++ ) {\r\n\r\n\t\t\t\tscale.set(\r\n\t\t\t\t\tdata.getFloat32( offset + 0, true ),\r\n\t\t\t\t\tdata.getFloat32( offset + 4, true ),\r\n\t\t\t\t\tdata.getFloat32( offset + 8, true )\r\n\t\t\t\t);\r\n\r\n\t\t\t\ttranslation.set(\r\n\t\t\t\t\tdata.getFloat32( offset + 12, true ),\r\n\t\t\t\t\tdata.getFloat32( offset + 16, true ),\r\n\t\t\t\t\tdata.getFloat32( offset + 20, true )\r\n\t\t\t\t);\r\n\r\n\t\t\t\toffset += 24;\r\n\r\n\t\t\t\tfor ( var j = 0; j < 16; j ++ ) {\r\n\r\n\t\t\t\t\tvar character = data.getUint8( offset + j, true );\r\n\t\t\t\t\tif ( character === 0 ) { break; }\r\n\r\n\t\t\t\t\tstring[ j ] = character;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar frame = {\r\n\t\t\t\t\tname: String.fromCharCode.apply( null, string ),\r\n\t\t\t\t\tvertices: [],\r\n\t\t\t\t\tnormals: []\r\n\t\t\t\t};\r\n\r\n\t\t\t\toffset += 16;\r\n\r\n\t\t\t\tfor ( var j = 0; j < header.num_vertices; j ++ ) {\r\n\r\n\t\t\t\t\tvar x = data.getUint8( offset ++, true );\r\n\t\t\t\t\tvar y = data.getUint8( offset ++, true );\r\n\t\t\t\t\tvar z = data.getUint8( offset ++, true );\r\n\t\t\t\t\tvar n = normalData[ data.getUint8( offset ++, true ) ];\r\n\r\n\t\t\t\t\tx = x * scale.x + translation.x;\r\n\t\t\t\t\ty = y * scale.y + translation.y;\r\n\t\t\t\t\tz = z * scale.z + translation.z;\r\n\r\n\t\t\t\t\tframe.vertices.push( x, z, y ); // convert to Y-up\r\n\t\t\t\t\tframe.normals.push( n[ 0 ], n[ 2 ], n[ 1 ] ); // convert to Y-up\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tframes.push( frame );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// static\r\n\r\n\t\t\tvar positions = [];\r\n\t\t\tvar normals = [];\r\n\t\t\tvar uvs = [];\r\n\r\n\t\t\tvar verticesTemp = frames[ 0 ].vertices;\r\n\t\t\tvar normalsTemp = frames[ 0 ].normals;\r\n\r\n\t\t\tfor ( var i = 0, l = vertexIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar vertexIndex = vertexIndices[ i ];\r\n\t\t\t\tvar stride = vertexIndex * 3;\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\tvar x = verticesTemp[ stride ];\r\n\t\t\t\tvar y = verticesTemp[ stride + 1 ];\r\n\t\t\t\tvar z = verticesTemp[ stride + 2 ];\r\n\r\n\t\t\t\tpositions.push( x, y, z );\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\tvar nx = normalsTemp[ stride ];\r\n\t\t\t\tvar ny = normalsTemp[ stride + 1 ];\r\n\t\t\t\tvar nz = normalsTemp[ stride + 2 ];\r\n\r\n\t\t\t\tnormals.push( nx, ny, nz );\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\tvar uvIndex = uvIndices[ i ];\r\n\t\t\t\tstride = uvIndex * 2;\r\n\r\n\t\t\t\tvar u = uvsTemp[ stride ];\r\n\t\t\t\tvar v = uvsTemp[ stride + 1 ];\r\n\r\n\t\t\t\tuvs.push( u, v );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\r\n\t\t\tgeometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\t\tgeometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\t\t// animation\r\n\r\n\t\t\tvar morphPositions = [];\r\n\t\t\tvar morphNormals = [];\r\n\r\n\t\t\tfor ( var i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar frame = frames[ i ];\r\n\t\t\t\tvar attributeName = frame.name;\r\n\r\n\t\t\t\tif ( frame.vertices.length > 0 ) {\r\n\r\n\t\t\t\t\tvar positions = [];\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = vertexIndices.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar vertexIndex = vertexIndices[ j ];\r\n\t\t\t\t\t\tvar stride = vertexIndex * 3;\r\n\r\n\t\t\t\t\t\tvar x = frame.vertices[ stride ];\r\n\t\t\t\t\t\tvar y = frame.vertices[ stride + 1 ];\r\n\t\t\t\t\t\tvar z = frame.vertices[ stride + 2 ];\r\n\r\n\t\t\t\t\t\tpositions.push( x, y, z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar positionAttribute = new Float32BufferAttribute( positions, 3 );\r\n\t\t\t\t\tpositionAttribute.name = attributeName;\r\n\r\n\t\t\t\t\tmorphPositions.push( positionAttribute );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( frame.normals.length > 0 ) {\r\n\r\n\t\t\t\t\tvar normals = [];\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = vertexIndices.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar vertexIndex = vertexIndices[ j ];\r\n\t\t\t\t\t\tvar stride = vertexIndex * 3;\r\n\r\n\t\t\t\t\t\tvar nx = frame.normals[ stride ];\r\n\t\t\t\t\t\tvar ny = frame.normals[ stride + 1 ];\r\n\t\t\t\t\t\tvar nz = frame.normals[ stride + 2 ];\r\n\r\n\t\t\t\t\t\tnormals.push( nx, ny, nz );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar normalAttribute = new Float32BufferAttribute( normals, 3 );\r\n\t\t\t\t\tnormalAttribute.name = attributeName;\r\n\r\n\t\t\t\t\tmorphNormals.push( normalAttribute );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.morphAttributes.position = morphPositions;\r\n\t\t\tgeometry.morphAttributes.normal = morphNormals;\r\n\r\n\t\t\tgeometry.animations = AnimationClip.CreateClipsFromMorphTargetSequences( frames, 10 );\r\n\r\n\t\t\tconsole.timeEnd( 'MD2Loader' );\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MMDLoader = ( function () {\r\n\t\r\n\tfunction MMDLoader( manager ) {\r\n\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\t\tthis.loader = new FileLoader( this.manager );\r\n\r\n\t\tthis.parser = null; // lazy generation\r\n\t\tthis.meshBuilder = new MeshBuilder( this.manager );\r\n\t\tthis.animationBuilder = new AnimationBuilder();\r\n\r\n\t}\r\n\r\n\tMMDLoader.prototype = {\r\n\r\n\t\tconstructor: MMDLoader,\r\n\r\n\t\tcrossOrigin: 'anonymous',\r\n\t\t\r\n\t\tsetCrossOrigin: function ( crossOrigin ) {\r\n\r\n\t\t\tthis.crossOrigin = crossOrigin;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\t// Load MMD assets as Three.js Object\r\n\t\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar builder = this.meshBuilder.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\tvar texturePath = LoaderUtils.extractUrlBase( url );\r\n\t\t\tvar modelExtension = this._extractExtension( url ).toLowerCase();\r\n\r\n\t\t\t// Should I detect by seeing header?\r\n\t\t\tif ( modelExtension !== 'pmd' && modelExtension !== 'pmx' ) {\r\n\r\n\t\t\t\tif ( onError ) { onError( new Error( 'MMDLoader: Unknown model file extension .' + modelExtension + '.' ) ); }\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis[ modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX' ]( url, function ( data ) {\r\n\r\n\t\t\t\tonLoad(\tbuilder.build( data, texturePath, onProgress, onError )\t);\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\t\t\r\n\t\tloadAnimation: function ( url, object, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar builder = this.animationBuilder;\r\n\r\n\t\t\tthis.loadVMD( url, function ( vmd ) {\r\n\r\n\t\t\t\tonLoad( object.isCamera\r\n\t\t\t\t\t? builder.buildCameraAnimation( vmd )\r\n\t\t\t\t\t: builder.build( vmd, object ) );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\t\t\r\n\t\tloadWithAnimation: function ( modelUrl, vmdUrl, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tthis.load( modelUrl, function ( mesh ) {\r\n\r\n\t\t\t\tscope.loadAnimation( vmdUrl, mesh, function ( animation ) {\r\n\r\n\t\t\t\t\tonLoad( {\r\n\t\t\t\t\t\tmesh: mesh,\r\n\t\t\t\t\t\tanimation: animation\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}, onProgress, onError );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\r\n\t\t// Load MMD assets as Object data parsed by MMDParser\r\n\t\t\r\n\t\tloadPMD: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar parser = this._getParser();\r\n\r\n\t\t\tthis.loader\r\n\t\t\t\t.setMimeType( undefined )\r\n\t\t\t\t.setResponseType( 'arraybuffer' )\r\n\t\t\t\t.load( url, function ( buffer ) {\r\n\r\n\t\t\t\t\tonLoad( parser.parsePmd( buffer, true ) );\r\n\r\n\t\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\t\t\r\n\t\tloadPMX: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar parser = this._getParser();\r\n\r\n\t\t\tthis.loader\r\n\t\t\t\t.setMimeType( undefined )\r\n\t\t\t\t.setResponseType( 'arraybuffer' )\r\n\t\t\t\t.load( url, function ( buffer ) {\r\n\r\n\t\t\t\t\tonLoad( parser.parsePmx( buffer, true ) );\r\n\r\n\t\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\t\t\r\n\t\tloadVMD: function ( url, onLoad, onProgress, onError ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar urls = Array.isArray( url ) ? url : [ url ];\r\n\r\n\t\t\tvar vmds = [];\r\n\t\t\tvar vmdNum = urls.length;\r\n\r\n\t\t\tvar parser = this._getParser();\r\n\r\n\t\t\tthis.loader\r\n\t\t\t\t.setMimeType( undefined )\r\n\t\t\t\t.setResponseType( 'arraybuffer' );\r\n\r\n\t\t\tfor ( var i = 0, il = urls.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tthis$1.loader.load( urls[ i ], function ( buffer ) {\r\n\r\n\t\t\t\t\tvmds.push( parser.parseVmd( buffer, true ) );\r\n\r\n\t\t\t\t\tif ( vmds.length === vmdNum ) { onLoad( parser.mergeVmds( vmds ) ); }\r\n\r\n\t\t\t\t}, onProgress, onError );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\t\t\r\n\t\tloadVPD: function ( url, isUnicode, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar parser = this._getParser();\r\n\r\n\t\t\tthis.loader\r\n\t\t\t\t.setMimeType( isUnicode ? undefined : 'text/plain; charset=shift_jis' )\r\n\t\t\t\t.setResponseType( 'text' )\r\n\t\t\t\t.load( url, function ( text ) {\r\n\r\n\t\t\t\t\tonLoad( parser.parseVpd( text, true ) );\r\n\r\n\t\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\r\n\t\t// private methods\r\n\r\n\t\t_extractExtension: function ( url ) {\r\n\r\n\t\t\tvar index = url.lastIndexOf( '.' );\r\n\t\t\treturn index < 0 ? '' : url.slice( index + 1 );\r\n\r\n\t\t},\r\n\r\n\t\t_getParser: function () {\r\n\r\n\t\t\tif ( this.parser === null ) {\r\n\r\n\t\t\t\tif ( typeof MMDParser === 'undefined' ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'MMDLoader: Import MMDParser https://github.com/takahirox/mmd-parser' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.parser = new MMDParser.Parser();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.parser;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Utilities\r\n\t\r\n\tvar DEFAULT_TOON_TEXTURES = [\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==',\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC',\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==',\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==',\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=',\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=',\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\r\n\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII='\r\n\t];\r\n\r\n\t// Builders. They build Three.js object from Object data parsed by MMDParser.\r\n\t\r\n\tfunction MeshBuilder( manager ) {\r\n\r\n\t\tthis.geometryBuilder = new GeometryBuilder();\r\n\t\tthis.materialBuilder = new MaterialBuilder( manager );\r\n\r\n\t}\r\n\r\n\tMeshBuilder.prototype = {\r\n\r\n\t\tconstructor: MeshBuilder,\r\n\r\n\t\tcrossOrigin: 'anonymous',\r\n\t\t\r\n\t\tsetCrossOrigin: function ( crossOrigin ) {\r\n\r\n\t\t\tthis.crossOrigin = crossOrigin;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tbuild: function ( data, texturePath, onProgress, onError ) {\r\n\r\n\t\t\tvar geometry = this.geometryBuilder.build( data );\r\n\t\t\tvar material = this.materialBuilder\r\n\t\t\t\t.setCrossOrigin( this.crossOrigin )\r\n\t\t\t\t.setTexturePath( texturePath )\r\n\t\t\t\t.build( data, geometry, onProgress, onError );\r\n\r\n\t\t\tvar mesh = new SkinnedMesh( geometry, material );\r\n\r\n\t\t\t// console.log( mesh ); // for console debug\r\n\r\n\t\t\treturn mesh;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction GeometryBuilder() {\r\n\r\n\t}\r\n\r\n\tGeometryBuilder.prototype = {\r\n\r\n\t\tconstructor: GeometryBuilder,\r\n\t\t\r\n\t\tbuild: function ( data ) {\r\n\r\n\t\t\t// for geometry\r\n\t\t\tvar positions = [];\r\n\t\t\tvar uvs = [];\r\n\t\t\tvar normals = [];\r\n\r\n\t\t\tvar indices = [];\r\n\r\n\t\t\tvar groups = [];\r\n\r\n\t\t\tvar bones = [];\r\n\t\t\tvar skinIndices = [];\r\n\t\t\tvar skinWeights = [];\r\n\r\n\t\t\tvar morphTargets = [];\r\n\t\t\tvar morphPositions = [];\r\n\r\n\t\t\tvar iks = [];\r\n\t\t\tvar grants = [];\r\n\r\n\t\t\tvar rigidBodies = [];\r\n\t\t\tvar constraints = [];\r\n\r\n\t\t\t// for work\r\n\t\t\tvar offset = 0;\r\n\t\t\tvar boneTypeTable = {};\r\n\r\n\t\t\t// positions, normals, uvs, skinIndices, skinWeights\r\n\r\n\t\t\tfor ( var i = 0; i < data.metadata.vertexCount; i ++ ) {\r\n\r\n\t\t\t\tvar v = data.vertices[ i ];\r\n\r\n\t\t\t\tfor ( var j = 0, jl = v.position.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tpositions.push( v.position[ j ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 0, jl = v.normal.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tnormals.push( v.normal[ j ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 0, jl = v.uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tuvs.push( v.uv[ j ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\tskinIndices.push( v.skinIndices.length - 1 >= j ? v.skinIndices[ j ] : 0.0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\tskinWeights.push( v.skinWeights.length - 1 >= j ? v.skinWeights[ j ] : 0.0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// indices\r\n\r\n\t\t\tfor ( var i = 0; i < data.metadata.faceCount; i ++ ) {\r\n\r\n\t\t\t\tvar face = data.faces[ i ];\r\n\r\n\t\t\t\tfor ( var j = 0, jl = face.indices.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tindices.push( face.indices[ j ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// groups\r\n\r\n\t\t\tfor ( var i = 0; i < data.metadata.materialCount; i ++ ) {\r\n\r\n\t\t\t\tvar material = data.materials[ i ];\r\n\r\n\t\t\t\tgroups.push( {\r\n\t\t\t\t\toffset: offset * 3,\r\n\t\t\t\t\tcount: material.faceCount * 3\r\n\t\t\t\t} );\r\n\r\n\t\t\t\toffset += material.faceCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// bones\r\n\r\n\t\t\tfor ( var i = 0; i < data.metadata.rigidBodyCount; i ++ ) {\r\n\r\n\t\t\t\tvar body = data.rigidBodies[ i ];\r\n\t\t\t\tvar value = boneTypeTable[ body.boneIndex ];\r\n\r\n\t\t\t\t// keeps greater number if already value is set without any special reasons\r\n\t\t\t\tvalue = value === undefined ? body.type : Math.max( body.type, value );\r\n\r\n\t\t\t\tboneTypeTable[ body.boneIndex ] = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < data.metadata.boneCount; i ++ ) {\r\n\r\n\t\t\t\tvar boneData = data.bones[ i ];\r\n\r\n\t\t\t\tvar bone = {\r\n\t\t\t\t\tparent: boneData.parentIndex,\r\n\t\t\t\t\tname: boneData.name,\r\n\t\t\t\t\tpos: boneData.position.slice( 0, 3 ),\r\n\t\t\t\t\trotq: [ 0, 0, 0, 1 ],\r\n\t\t\t\t\tscl: [ 1, 1, 1 ],\r\n\t\t\t\t\trigidBodyType: boneTypeTable[ i ] !== undefined ? boneTypeTable[ i ] : - 1\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( bone.parent !== - 1 ) {\r\n\r\n\t\t\t\t\tbone.pos[ 0 ] -= data.bones[ bone.parent ].position[ 0 ];\r\n\t\t\t\t\tbone.pos[ 1 ] -= data.bones[ bone.parent ].position[ 1 ];\r\n\t\t\t\t\tbone.pos[ 2 ] -= data.bones[ bone.parent ].position[ 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbones.push( bone );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// iks\r\n\r\n\t\t\t// TODO: remove duplicated codes between PMD and PMX\r\n\t\t\tif ( data.metadata.format === 'pmd' ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < data.metadata.ikCount; i ++ ) {\r\n\r\n\t\t\t\t\tvar ik = data.iks[ i ];\r\n\r\n\t\t\t\t\tvar param = {\r\n\t\t\t\t\t\ttarget: ik.target,\r\n\t\t\t\t\t\teffector: ik.effector,\r\n\t\t\t\t\t\titeration: ik.iteration,\r\n\t\t\t\t\t\tmaxAngle: ik.maxAngle * 4,\r\n\t\t\t\t\t\tlinks: []\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar link = {};\r\n\t\t\t\t\t\tlink.index = ik.links[ j ].index;\r\n\t\t\t\t\t\tlink.enabled = true;\r\n\r\n\t\t\t\t\t\tif ( data.bones[ link.index ].name.indexOf( 'ひざ' ) >= 0 ) {\r\n\r\n\t\t\t\t\t\t\tlink.limitation = new Vector3( 1.0, 0.0, 0.0 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tparam.links.push( link );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tiks.push( param );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0; i < data.metadata.boneCount; i ++ ) {\r\n\r\n\t\t\t\t\tvar ik = data.bones[ i ].ik;\r\n\r\n\t\t\t\t\tif ( ik === undefined ) { continue; }\r\n\r\n\t\t\t\t\tvar param = {\r\n\t\t\t\t\t\ttarget: i,\r\n\t\t\t\t\t\teffector: ik.effector,\r\n\t\t\t\t\t\titeration: ik.iteration,\r\n\t\t\t\t\t\tmaxAngle: ik.maxAngle,\r\n\t\t\t\t\t\tlinks: []\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar link = {};\r\n\t\t\t\t\t\tlink.index = ik.links[ j ].index;\r\n\t\t\t\t\t\tlink.enabled = true;\r\n\r\n\t\t\t\t\t\tif ( ik.links[ j ].angleLimitation === 1 ) {\r\n\r\n\t\t\t\t\t\t\t// Revert if rotationMin/Max doesn't work well\r\n\t\t\t\t\t\t\t// link.limitation = new Vector3( 1.0, 0.0, 0.0 );\r\n\r\n\t\t\t\t\t\t\tvar rotationMin = ik.links[ j ].lowerLimitationAngle;\r\n\t\t\t\t\t\t\tvar rotationMax = ik.links[ j ].upperLimitationAngle;\r\n\r\n\t\t\t\t\t\t\t// Convert Left to Right coordinate by myself because\r\n\t\t\t\t\t\t\t// MMDParser doesn't convert. It's a MMDParser's bug\r\n\r\n\t\t\t\t\t\t\tvar tmp1 = - rotationMax[ 0 ];\r\n\t\t\t\t\t\t\tvar tmp2 = - rotationMax[ 1 ];\r\n\t\t\t\t\t\t\trotationMax[ 0 ] = - rotationMin[ 0 ];\r\n\t\t\t\t\t\t\trotationMax[ 1 ] = - rotationMin[ 1 ];\r\n\t\t\t\t\t\t\trotationMin[ 0 ] = tmp1;\r\n\t\t\t\t\t\t\trotationMin[ 1 ] = tmp2;\r\n\r\n\t\t\t\t\t\t\tlink.rotationMin = new Vector3().fromArray( rotationMin );\r\n\t\t\t\t\t\t\tlink.rotationMax = new Vector3().fromArray( rotationMax );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tparam.links.push( link );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tiks.push( param );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// grants\r\n\r\n\t\t\tif ( data.metadata.format === 'pmx' ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < data.metadata.boneCount; i ++ ) {\r\n\r\n\t\t\t\t\tvar boneData = data.bones[ i ];\r\n\t\t\t\t\tvar grant = boneData.grant;\r\n\r\n\t\t\t\t\tif ( grant === undefined ) { continue; }\r\n\r\n\t\t\t\t\tvar param = {\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tparentIndex: grant.parentIndex,\r\n\t\t\t\t\t\tratio: grant.ratio,\r\n\t\t\t\t\t\tisLocal: grant.isLocal,\r\n\t\t\t\t\t\taffectRotation: grant.affectRotation,\r\n\t\t\t\t\t\taffectPosition: grant.affectPosition,\r\n\t\t\t\t\t\ttransformationClass: boneData.transformationClass\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tgrants.push( param );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgrants.sort( function ( a, b ) {\r\n\r\n\t\t\t\t\treturn a.transformationClass - b.transformationClass;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// morph\r\n\r\n\t\t\tfunction updateAttributes( attribute, morph, ratio ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < morph.elementCount; i ++ ) {\r\n\r\n\t\t\t\t\tvar element = morph.elements[ i ];\r\n\r\n\t\t\t\t\tvar index;\r\n\r\n\t\t\t\t\tif ( data.metadata.format === 'pmd' ) {\r\n\r\n\t\t\t\t\t\tindex = data.morphs[ 0 ].elements[ element.index ].index;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tindex = element.index;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tattribute.array[ index * 3 + 0 ] += element.position[ 0 ] * ratio;\r\n\t\t\t\t\tattribute.array[ index * 3 + 1 ] += element.position[ 1 ] * ratio;\r\n\t\t\t\t\tattribute.array[ index * 3 + 2 ] += element.position[ 2 ] * ratio;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < data.metadata.morphCount; i ++ ) {\r\n\r\n\t\t\t\tvar morph = data.morphs[ i ];\r\n\t\t\t\tvar params = { name: morph.name };\r\n\r\n\t\t\t\tvar attribute = new Float32BufferAttribute( data.metadata.vertexCount * 3, 3 );\r\n\t\t\t\tattribute.name = morph.name;\r\n\r\n\t\t\t\tfor ( var j = 0; j < data.metadata.vertexCount * 3; j ++ ) {\r\n\r\n\t\t\t\t\tattribute.array[ j ] = positions[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.metadata.format === 'pmd' ) {\r\n\r\n\t\t\t\t\tif ( i !== 0 ) {\r\n\r\n\t\t\t\t\t\tupdateAttributes( attribute, morph, 1.0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( morph.type === 0 ) { // group\r\n\r\n\t\t\t\t\t\tfor ( var j = 0; j < morph.elementCount; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar morph2 = data.morphs[ morph.elements[ j ].index ];\r\n\t\t\t\t\t\t\tvar ratio = morph.elements[ j ].ratio;\r\n\r\n\t\t\t\t\t\t\tif ( morph2.type === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\tupdateAttributes( attribute, morph2, ratio );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( morph.type === 1 ) { // vertex\r\n\r\n\t\t\t\t\t\tupdateAttributes( attribute, morph, 1.0 );\r\n\r\n\t\t\t\t\t} else if ( morph.type === 2 ) ; else if ( morph.type === 3 ) ; else if ( morph.type === 4 ) ; else if ( morph.type === 5 ) ; else if ( morph.type === 6 ) ; else if ( morph.type === 7 ) ; else if ( morph.type === 8 ) ;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmorphTargets.push( params );\r\n\t\t\t\tmorphPositions.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// rigid bodies from rigidBodies field.\r\n\r\n\t\t\tfor ( var i = 0; i < data.metadata.rigidBodyCount; i ++ ) {\r\n\r\n\t\t\t\tvar rigidBody = data.rigidBodies[ i ];\r\n\t\t\t\tvar params = {};\r\n\r\n\t\t\t\tfor ( var key in rigidBody ) {\r\n\r\n\t\t\t\t\tparams[ key ] = rigidBody[ key ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif ( data.metadata.format === 'pmx' ) {\r\n\r\n\t\t\t\t\tif ( params.boneIndex !== - 1 ) {\r\n\r\n\t\t\t\t\t\tvar bone = data.bones[ params.boneIndex ];\r\n\t\t\t\t\t\tparams.position[ 0 ] -= bone.position[ 0 ];\r\n\t\t\t\t\t\tparams.position[ 1 ] -= bone.position[ 1 ];\r\n\t\t\t\t\t\tparams.position[ 2 ] -= bone.position[ 2 ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\trigidBodies.push( params );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// constraints from constraints field.\r\n\r\n\t\t\tfor ( var i = 0; i < data.metadata.constraintCount; i ++ ) {\r\n\r\n\t\t\t\tvar constraint = data.constraints[ i ];\r\n\t\t\t\tvar params = {};\r\n\r\n\t\t\t\tfor ( var key in constraint ) {\r\n\r\n\t\t\t\t\tparams[ key ] = constraint[ key ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar bodyA = rigidBodies[ params.rigidBodyIndex1 ];\r\n\t\t\t\tvar bodyB = rigidBodies[ params.rigidBodyIndex2 ];\r\n\r\n\t\t\t\t// Refer to http://www20.atpages.jp/katwat/wp/?p=4135\r\n\t\t\t\tif ( bodyA.type !== 0 && bodyB.type === 2 ) {\r\n\r\n\t\t\t\t\tif ( bodyA.boneIndex !== - 1 && bodyB.boneIndex !== - 1 &&\r\n\t\t\t\t\t     data.bones[ bodyB.boneIndex ].parentIndex === bodyA.boneIndex ) {\r\n\r\n\t\t\t\t\t\tbodyB.type = 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconstraints.push( params );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// build BufferGeometry.\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\r\n\t\t\tgeometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\t\tgeometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\t\t\tgeometry.addAttribute( 'skinIndex', new Uint16BufferAttribute( skinIndices, 4 ) );\r\n\t\t\tgeometry.addAttribute( 'skinWeight', new Float32BufferAttribute( skinWeights, 4 ) );\r\n\t\t\tgeometry.setIndex( indices );\r\n\r\n\t\t\tfor ( var i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgeometry.addGroup( groups[ i ].offset, groups[ i ].count, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.bones = bones;\r\n\r\n\t\t\tgeometry.morphTargets = morphTargets;\r\n\t\t\tgeometry.morphAttributes.position = morphPositions;\r\n\r\n\t\t\tgeometry.userData.MMD = {\r\n\t\t\t\tbones: bones,\r\n\t\t\t\tiks: iks,\r\n\t\t\t\tgrants: grants,\r\n\t\t\t\trigidBodies: rigidBodies,\r\n\t\t\t\tconstraints: constraints,\r\n\t\t\t\tformat: data.metadata.format\r\n\t\t\t};\r\n\r\n\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\t\r\n\tfunction MaterialBuilder( manager ) {\r\n\r\n\t\tthis.manager = manager;\r\n\r\n\t\tthis.textureLoader = new TextureLoader( this.manager );\r\n\t\tthis.tgaLoader = null; // lazy generation\r\n\r\n\t}\r\n\r\n\tMaterialBuilder.prototype = {\r\n\r\n\t\tconstructor: MaterialBuilder,\r\n\r\n\t\tcrossOrigin: 'anonymous',\r\n\r\n\t\ttexturePath: undefined,\r\n\t\t\r\n\t\tsetCrossOrigin: function ( crossOrigin ) {\r\n\r\n\t\t\tthis.crossOrigin = crossOrigin;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tsetTexturePath: function ( texturePath ) {\r\n\r\n\t\t\tthis.texturePath = texturePath;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\t\t\r\n\t\tbuild: function ( data, geometry, onProgress, onError ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar materials = [];\r\n\r\n\t\t\tvar textures = {};\r\n\r\n\t\t\tthis.textureLoader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\t// materials\r\n\r\n\t\t\tfor ( var i = 0; i < data.metadata.materialCount; i ++ ) {\r\n\r\n\t\t\t\tvar material = data.materials[ i ];\r\n\r\n\t\t\t\tvar params = { userData: {} };\r\n\r\n\t\t\t\tif ( material.name !== undefined ) { params.name = material.name; }\r\n\t\t\t\t\r\n\t\t\t\tparams.color = new Color().fromArray( material.diffuse );\r\n\t\t\t\tparams.opacity = material.diffuse[ 3 ];\r\n\t\t\t\tparams.specular = new Color().fromArray( material.specular );\r\n\t\t\t\tparams.emissive = new Color().fromArray( material.ambient );\r\n\t\t\t\tparams.shininess = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\r\n\t\t\t\tparams.transparent = params.opacity !== 1.0;\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\tparams.skinning = geometry.bones.length > 0 ? true : false;\r\n\t\t\t\tparams.morphTargets = geometry.morphTargets.length > 0 ? true : false;\r\n\t\t\t\tparams.lights = true;\r\n\t\t\t\tparams.fog = true;\r\n\r\n\t\t\t\t// blend\r\n\r\n\t\t\t\tparams.blending = CustomBlending;\r\n\t\t\t\tparams.blendSrc = SrcAlphaFactor;\r\n\t\t\t\tparams.blendDst = OneMinusSrcAlphaFactor;\r\n\t\t\t\tparams.blendSrcAlpha = SrcAlphaFactor;\r\n\t\t\t\tparams.blendDstAlpha = DstAlphaFactor;\r\n\r\n\t\t\t\t// side\r\n\r\n\t\t\t\tif ( data.metadata.format === 'pmx' && ( material.flag & 0x1 ) === 1 ) {\r\n\r\n\t\t\t\t\tparams.side = DoubleSide;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tparams.side = params.opacity === 1.0 ? FrontSide : DoubleSide;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.metadata.format === 'pmd' ) {\r\n\r\n\t\t\t\t\t// map, envMap\r\n\r\n\t\t\t\t\tif ( material.fileName ) {\r\n\r\n\t\t\t\t\t\tvar fileName = material.fileName;\r\n\t\t\t\t\t\tvar fileNames = fileName.split( '*' );\r\n\r\n\t\t\t\t\t\t// fileNames[ 0 ]: mapFileName\r\n\t\t\t\t\t\t// fileNames[ 1 ]: envMapFileName( optional )\r\n\r\n\t\t\t\t\t\tparams.map = this$1._loadTexture( fileNames[ 0 ], textures );\r\n\r\n\t\t\t\t\t\tif ( fileNames.length > 1 ) {\r\n\r\n\t\t\t\t\t\t\tvar extension = fileNames[ 1 ].slice( - 4 ).toLowerCase();\r\n\r\n\t\t\t\t\t\t\tparams.envMap = this$1._loadTexture(\r\n\t\t\t\t\t\t\t\tfileNames[ 1 ],\r\n\t\t\t\t\t\t\t\ttextures,\r\n\t\t\t\t\t\t\t\t{ sphericalReflectionMapping: true }\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tparams.combine = extension === '.sph'\r\n\t\t\t\t\t\t\t\t? MultiplyOperation\r\n\t\t\t\t\t\t\t\t: AddOperation;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// gradientMap\r\n\r\n\t\t\t\t\tvar toonFileName = ( material.toonIndex === - 1 )\r\n\t\t\t\t\t\t? 'toon00.bmp'\r\n\t\t\t\t\t\t: data.toonTextures[ material.toonIndex ].fileName;\r\n\r\n\t\t\t\t\tparams.gradientMap = this$1._loadTexture(\r\n\t\t\t\t\t\ttoonFileName,\r\n\t\t\t\t\t\ttextures,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisToonTexture: true,\r\n\t\t\t\t\t\t\tisDefaultToonTexture: this$1._isDefaultToonTexture( toonFileName )\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// parameters for OutlineEffect\r\n\r\n\t\t\t\t\tparams.userData.outlineParameters = {\r\n\t\t\t\t\t\tthickness: material.edgeFlag === 1 ? 0.003 : 0.0,\r\n\t\t\t\t\t\tcolor: [ 0, 0, 0 ],\r\n\t\t\t\t\t\talpha: 1.0,\r\n\t\t\t\t\t\tvisible: material.edgeFlag === 1\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// map\r\n\r\n\t\t\t\t\tif ( material.textureIndex !== - 1 ) {\r\n\r\n\t\t\t\t\t\tparams.map = this$1._loadTexture( data.textures[ material.textureIndex ], textures );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// envMap TODO: support m.envFlag === 3\r\n\r\n\t\t\t\t\tif ( material.envTextureIndex !== - 1 && ( material.envFlag === 1 || material.envFlag == 2 ) ) {\r\n\r\n\t\t\t\t\t\tparams.envMap = this$1._loadTexture(\r\n\t\t\t\t\t\t\tdata.textures[ material.envTextureIndex ],\r\n\t\t\t\t\t\t\ttextures, { sphericalReflectionMapping: true }\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tparams.combine = material.envFlag === 1\r\n\t\t\t\t\t\t\t? MultiplyOperation\r\n\t\t\t\t\t\t\t: AddOperation;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// gradientMap\r\n\r\n\t\t\t\t\tvar toonFileName, isDefaultToon;\r\n\r\n\t\t\t\t\tif ( material.toonIndex === - 1 || material.toonFlag !== 0 ) {\r\n\r\n\t\t\t\t\t\ttoonFileName = 'toon' + ( '0' + ( material.toonIndex + 1 ) ).slice( - 2 ) + '.bmp';\r\n\t\t\t\t\t\tisDefaultToon = true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttoonFileName = data.textures[ material.toonIndex ];\r\n\t\t\t\t\t\tisDefaultToon = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tparams.gradientMap = this$1._loadTexture(\r\n\t\t\t\t\t\ttoonFileName,\r\n\t\t\t\t\t\ttextures,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisToonTexture: true,\r\n\t\t\t\t\t\t\tisDefaultToonTexture: isDefaultToon\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// parameters for OutlineEffect\r\n\t\t\t\t\tparams.userData.outlineParameters = {\r\n\t\t\t\t\t\tthickness: material.edgeSize / 300, // TODO: better calculation?\r\n\t\t\t\t\t\tcolor: material.edgeColor.slice( 0, 3 ),\r\n\t\t\t\t\t\talpha: material.edgeColor[ 3 ],\r\n\t\t\t\t\t\tvisible: ( material.flag & 0x10 ) !== 0 && material.edgeSize > 0.0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( params.map !== undefined ) {\r\n\r\n\t\t\t\t\tif ( ! params.transparent ) {\r\n\r\n\t\t\t\t\t\tthis$1._checkImageTransparency( params.map, geometry, i );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tparams.emissive.multiplyScalar( 0.2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterials.push( new MeshToonMaterial( params ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.metadata.format === 'pmx' ) {\r\n\r\n\t\t\t\t// set transparent true if alpha morph is defined.\r\n\r\n\t\t\t\tfunction checkAlphaMorph( elements, materials ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = elements.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar element = elements[ i ];\r\n\r\n\t\t\t\t\t\tif ( element.index === - 1 ) { continue; }\r\n\r\n\t\t\t\t\t\tvar material = materials[ element.index ];\r\n\r\n\t\t\t\t\t\tif ( material.opacity !== element.diffuse[ 3 ] ) {\r\n\r\n\t\t\t\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0, il = data.morphs.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar morph = data.morphs[ i ];\r\n\t\t\t\t\tvar elements = morph.elements;\r\n\r\n\t\t\t\t\tif ( morph.type === 0 ) {\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = elements.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar morph2 = data.morphs[ elements[ j ].index ];\r\n\r\n\t\t\t\t\t\t\tif ( morph2.type !== 8 ) { continue; }\r\n\r\n\t\t\t\t\t\t\tcheckAlphaMorph( morph2.elements, materials );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( morph.type === 8 ) {\r\n\r\n\t\t\t\t\t\tcheckAlphaMorph( elements, materials );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn materials;\r\n\r\n\t\t},\r\n\r\n\t\t// private methods\r\n\r\n\t\t_getTGALoader: function () {\r\n\r\n\t\t\tif ( this.tgaLoader === null ) {\r\n\r\n\t\t\t\tif ( TGALoader === undefined ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'MMDLoader: Import TGALoader' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.tgaLoader = new TGALoader( this.manager );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.tgaLoader;\r\n\r\n\t\t},\r\n\r\n\t\t_isDefaultToonTexture: function ( name ) {\r\n\r\n\t\t\tif ( name.length !== 10 ) { return false; }\r\n\r\n\t\t\treturn /toon(10|0[0-9])\\.bmp/.test( name );\r\n\r\n\t\t},\r\n\r\n\t\t_loadTexture: function ( filePath, textures, params, onProgress, onError ) {\r\n\r\n\t\t\tparams = params || {};\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tvar fullPath;\r\n\r\n\t\t\tif ( params.isDefaultToonTexture === true ) {\r\n\r\n\t\t\t\tvar index;\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tindex = parseInt( filePath.match( 'toon([0-9]{2})\\.bmp$' )[ 1 ] );\r\n\r\n\t\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'MMDLoader: ' + filePath + ' seems like a '\r\n\t\t\t\t\t\t+ 'not right default texture path. Using toon00.bmp instead.' );\r\n\r\n\t\t\t\t\tindex = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfullPath = DEFAULT_TOON_TEXTURES[ index ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfullPath = this.texturePath + filePath;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( textures[ fullPath ] !== undefined ) { return textures[ fullPath ]; }\r\n\r\n\t\t\tvar loader = Loader.Handlers.get( fullPath );\r\n\r\n\t\t\tif ( loader === null ) {\r\n\r\n\t\t\t\tloader = ( filePath.slice( - 4 ).toLowerCase() === '.tga' )\r\n\t\t\t\t\t? this._getTGALoader()\r\n\t\t\t\t\t: this.textureLoader;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar texture = loader.load( fullPath, function ( t ) {\r\n\r\n\t\t\t\t// MMD toon texture is Axis-Y oriented\r\n\t\t\t\t// but Three.js gradient map is Axis-X oriented.\r\n\t\t\t\t// So here replaces the toon texture image with the rotated one.\r\n\t\t\t\tif ( params.isToonTexture === true ) {\r\n\r\n\t\t\t\t\tt.image = scope._getRotatedImage( t.image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt.flipY = false;\r\n\t\t\t\tt.wrapS = RepeatWrapping;\r\n\t\t\t\tt.wrapT = RepeatWrapping;\r\n\r\n\t\t\t\tfor ( var i = 0; i < texture.readyCallbacks.length; i ++ ) {\r\n\r\n\t\t\t\t\ttexture.readyCallbacks[ i ]( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete texture.readyCallbacks;\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t\tif ( params.sphericalReflectionMapping === true ) {\r\n\r\n\t\t\t\ttexture.mapping = SphericalReflectionMapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.readyCallbacks = [];\r\n\r\n\t\t\ttextures[ fullPath ] = texture;\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t},\r\n\r\n\t\t_getRotatedImage: function ( image ) {\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\r\n\t\t\tvar width = image.width;\r\n\t\t\tvar height = image.height;\r\n\r\n\t\t\tcanvas.width = width;\r\n\t\t\tcanvas.height = height;\r\n\r\n\t\t\tcontext.clearRect( 0, 0, width, height );\r\n\t\t\tcontext.translate( width / 2.0, height / 2.0 );\r\n\t\t\tcontext.rotate( 0.5 * Math.PI ); // 90.0 * Math.PI / 180.0\r\n\t\t\tcontext.translate( - width / 2.0, - height / 2.0 );\r\n\t\t\tcontext.drawImage( image, 0, 0 );\r\n\r\n\t\t\treturn context.getImageData( 0, 0, width, height );\r\n\r\n\t\t},\r\n\r\n\t\t// Check if the partial image area used by the texture is transparent.\r\n\t\t_checkImageTransparency: function ( map, geometry, groupIndex ) {\r\n\r\n\t\t\tmap.readyCallbacks.push( function ( texture ) {\r\n\r\n\t\t\t\t// Is there any efficient ways?\r\n\t\t\t\tfunction createImageData( image ) {\r\n\r\n\t\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\t\tcanvas.width = image.width;\r\n\t\t\t\t\tcanvas.height = image.height;\r\n\r\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\t\tcontext.drawImage( image, 0, 0 );\r\n\r\n\t\t\t\t\treturn context.getImageData( 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction detectImageTransparency( image, uvs, indices ) {\r\n\r\n\t\t\t\t\tvar width = image.width;\r\n\t\t\t\t\tvar height = image.height;\r\n\t\t\t\t\tvar data = image.data;\r\n\t\t\t\t\tvar threshold = 253;\r\n\r\n\t\t\t\t\tif ( data.length / ( width * height ) !== 4 ) { return false; }\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t\t\t\tvar centerUV = { x: 0.0, y: 0.0 };\r\n\r\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar index = indices[ i * 3 + j ];\r\n\t\t\t\t\t\t\tvar uv = { x: uvs[ index * 2 + 0 ], y: uvs[ index * 2 + 1 ] };\r\n\r\n\t\t\t\t\t\t\tif ( getAlphaByUv( image, uv ) < threshold ) { return true; }\r\n\r\n\t\t\t\t\t\t\tcenterUV.x += uv.x;\r\n\t\t\t\t\t\t\tcenterUV.y += uv.y;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcenterUV.x /= 3;\r\n\t\t\t\t\t\tcenterUV.y /= 3;\r\n\r\n\t\t\t\t\t\tif ( getAlphaByUv( image, centerUV ) < threshold ) { return true; }\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction getAlphaByUv( image, uv ) {\r\n\r\n\t\t\t\t\tvar width = image.width;\r\n\t\t\t\t\tvar height = image.height;\r\n\r\n\t\t\t\t\tvar x = Math.round( uv.x * width ) % width;\r\n\t\t\t\t\tvar y = Math.round( uv.y * height ) % height;\r\n\r\n\t\t\t\t\tif ( x < 0 ) { x += width; }\r\n\t\t\t\t\tif ( y < 0 ) { y += height; }\r\n\r\n\t\t\t\t\tvar index = y * width + x;\r\n\r\n\t\t\t\t\treturn image.data[ index * 4 + 3 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar imageData = texture.image.data !== undefined\r\n\t\t\t\t\t? texture.image\r\n\t\t\t\t\t: createImageData( texture.image );\r\n\r\n\t\t\t\tvar group = geometry.groups[ groupIndex ];\r\n\r\n\t\t\t\tif ( detectImageTransparency(\r\n\t\t\t\t\timageData,\r\n\t\t\t\t\tgeometry.attributes.uv.array,\r\n\t\t\t\t\tgeometry.index.array.slice( group.start, group.start + group.count ) ) ) {\r\n\r\n\t\t\t\t\tmap.transparent = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction AnimationBuilder() {\r\n\r\n\t}\r\n\r\n\tAnimationBuilder.prototype = {\r\n\r\n\t\tconstructor: AnimationBuilder,\r\n\t\t\r\n\t\tbuild: function ( vmd, mesh ) {\r\n\r\n\t\t\t// combine skeletal and morph animations\r\n\r\n\t\t\tvar tracks = this.buildSkeletalAnimation( vmd, mesh ).tracks;\r\n\t\t\tvar tracks2 = this.buildMorphAnimation( vmd, mesh ).tracks;\r\n\r\n\t\t\tfor ( var i = 0, il = tracks2.length; i < il; i ++ ) {\r\n\r\n\t\t\t\ttracks.push( tracks2[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new AnimationClip( '', - 1, tracks );\r\n\r\n\t\t},\r\n\t\t\r\n\t\tbuildSkeletalAnimation: function ( vmd, mesh ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tfunction pushInterpolation( array, interpolation, index ) {\r\n\r\n\t\t\t\tarray.push( interpolation[ index + 0 ] / 127 ); // x1\r\n\t\t\t\tarray.push( interpolation[ index + 8 ] / 127 ); // x2\r\n\t\t\t\tarray.push( interpolation[ index + 4 ] / 127 ); // y1\r\n\t\t\t\tarray.push( interpolation[ index + 12 ] / 127 ); // y2\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\tvar motions = {};\r\n\t\t\tvar bones = mesh.skeleton.bones;\r\n\t\t\tvar boneNameDictionary = {};\r\n\r\n\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tboneNameDictionary[ bones[ i ].name ] = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < vmd.metadata.motionCount; i ++ ) {\r\n\r\n\t\t\t\tvar motion = vmd.motions[ i ];\r\n\t\t\t\tvar boneName = motion.boneName;\r\n\r\n\t\t\t\tif ( boneNameDictionary[ boneName ] === undefined ) { continue; }\r\n\r\n\t\t\t\tmotions[ boneName ] = motions[ boneName ] || [];\r\n\t\t\t\tmotions[ boneName ].push( motion );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var key in motions ) {\r\n\r\n\t\t\t\tvar array = motions[ key ];\r\n\r\n\t\t\t\tarray.sort( function ( a, b ) {\r\n\r\n\t\t\t\t\treturn a.frameNum - b.frameNum;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tvar times = [];\r\n\t\t\t\tvar positions = [];\r\n\t\t\t\tvar rotations = [];\r\n\t\t\t\tvar pInterpolations = [];\r\n\t\t\t\tvar rInterpolations = [];\r\n\r\n\t\t\t\tvar basePosition = mesh.skeleton.getBoneByName( key ).position.toArray();\r\n\r\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar time = array[ i ].frameNum / 30;\r\n\t\t\t\t\tvar position = array[ i ].position;\r\n\t\t\t\t\tvar rotation = array[ i ].rotation;\r\n\t\t\t\t\tvar interpolation = array[ i ].interpolation;\r\n\r\n\t\t\t\t\ttimes.push( time );\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) { positions.push( basePosition[ j ] + position[ j ] ); }\r\n\t\t\t\t\tfor ( var j = 0; j < 4; j ++ ) { rotations.push( rotation[ j ] ); }\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) { pushInterpolation( pInterpolations, interpolation, j ); }\r\n\r\n\t\t\t\t\tpushInterpolation( rInterpolations, interpolation, 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar targetName = '.bones[' + key + ']';\r\n\r\n\t\t\t\ttracks.push( this$1._createTrack( targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations ) );\r\n\t\t\t\ttracks.push( this$1._createTrack( targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new AnimationClip( '', - 1, tracks );\r\n\r\n\t\t},\r\n\t\t\r\n\t\tbuildMorphAnimation: function ( vmd, mesh ) {\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\tvar morphs = {};\r\n\t\t\tvar morphTargetDictionary = mesh.morphTargetDictionary;\r\n\r\n\t\t\tfor ( var i = 0; i < vmd.metadata.morphCount; i ++ ) {\r\n\r\n\t\t\t\tvar morph = vmd.morphs[ i ];\r\n\t\t\t\tvar morphName = morph.morphName;\r\n\r\n\t\t\t\tif ( morphTargetDictionary[ morphName ] === undefined ) { continue; }\r\n\r\n\t\t\t\tmorphs[ morphName ] = morphs[ morphName ] || [];\r\n\t\t\t\tmorphs[ morphName ].push( morph );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var key in morphs ) {\r\n\r\n\t\t\t\tvar array = morphs[ key ];\r\n\r\n\t\t\t\tarray.sort( function ( a, b ) {\r\n\r\n\t\t\t\t\treturn a.frameNum - b.frameNum;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tvar times = [];\r\n\t\t\t\tvar values = [];\r\n\r\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\ttimes.push( array[ i ].frameNum / 30 );\r\n\t\t\t\t\tvalues.push( array[ i ].weight );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetDictionary[ key ] + ']', times, values ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new AnimationClip( '', - 1, tracks );\r\n\r\n\t\t},\r\n\t\t\r\n\t\tbuildCameraAnimation: function ( vmd ) {\r\n\r\n\t\t\tfunction pushVector3( array, vec ) {\r\n\r\n\t\t\t\tarray.push( vec.x );\r\n\t\t\t\tarray.push( vec.y );\r\n\t\t\t\tarray.push( vec.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction pushQuaternion( array, q ) {\r\n\r\n\t\t\t\tarray.push( q.x );\r\n\t\t\t\tarray.push( q.y );\r\n\t\t\t\tarray.push( q.z );\r\n\t\t\t\tarray.push( q.w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction pushInterpolation( array, interpolation, index ) {\r\n\r\n\t\t\t\tarray.push( interpolation[ index * 4 + 0 ] / 127 ); // x1\r\n\t\t\t\tarray.push( interpolation[ index * 4 + 1 ] / 127 ); // x2\r\n\t\t\t\tarray.push( interpolation[ index * 4 + 2 ] / 127 ); // y1\r\n\t\t\t\tarray.push( interpolation[ index * 4 + 3 ] / 127 ); // y2\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\tvar cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice();\r\n\r\n\t\t\tcameras.sort( function ( a, b ) {\r\n\r\n\t\t\t\treturn a.frameNum - b.frameNum;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tvar times = [];\r\n\t\t\tvar centers = [];\r\n\t\t\tvar quaternions = [];\r\n\t\t\tvar positions = [];\r\n\t\t\tvar fovs = [];\r\n\r\n\t\t\tvar cInterpolations = [];\r\n\t\t\tvar qInterpolations = [];\r\n\t\t\tvar pInterpolations = [];\r\n\t\t\tvar fInterpolations = [];\r\n\r\n\t\t\tvar quaternion = new Quaternion();\r\n\t\t\tvar euler = new Euler();\r\n\t\t\tvar position = new Vector3();\r\n\t\t\tvar center = new Vector3();\r\n\r\n\t\t\tfor ( var i = 0, il = cameras.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar motion = cameras[ i ];\r\n\r\n\t\t\t\tvar time = motion.frameNum / 30;\r\n\t\t\t\tvar pos = motion.position;\r\n\t\t\t\tvar rot = motion.rotation;\r\n\t\t\t\tvar distance = motion.distance;\r\n\t\t\t\tvar fov = motion.fov;\r\n\t\t\t\tvar interpolation = motion.interpolation;\r\n\r\n\t\t\t\ttimes.push( time );\r\n\r\n\t\t\t\tposition.set( 0, 0, - distance );\r\n\t\t\t\tcenter.set( pos[ 0 ], pos[ 1 ], pos[ 2 ] );\r\n\r\n\t\t\t\teuler.set( - rot[ 0 ], - rot[ 1 ], - rot[ 2 ] );\r\n\t\t\t\tquaternion.setFromEuler( euler );\r\n\r\n\t\t\t\tposition.add( center );\r\n\t\t\t\tposition.applyQuaternion( quaternion );\r\n\r\n\t\t\t\tpushVector3( centers, center );\r\n\t\t\t\tpushQuaternion( quaternions, quaternion );\r\n\t\t\t\tpushVector3( positions, position );\r\n\r\n\t\t\t\tfovs.push( fov );\r\n\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tpushInterpolation( cInterpolations, interpolation, j );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpushInterpolation( qInterpolations, interpolation, 3 );\r\n\r\n\t\t\t\t// use the same parameter for x, y, z axis.\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tpushInterpolation( pInterpolations, interpolation, 4 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpushInterpolation( fInterpolations, interpolation, 5 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar tracks = [];\r\n\r\n\t\t\t// I expect an object whose name 'target' exists under Camera\r\n\t\t\ttracks.push( this._createTrack( 'target.position', VectorKeyframeTrack, times, centers, cInterpolations ) );\r\n\r\n\t\t\ttracks.push( this._createTrack( '.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations ) );\r\n\t\t\ttracks.push( this._createTrack( '.position', VectorKeyframeTrack, times, positions, pInterpolations ) );\r\n\t\t\ttracks.push( this._createTrack( '.fov', NumberKeyframeTrack, times, fovs, fInterpolations ) );\r\n\r\n\t\t\treturn new AnimationClip( '', - 1, tracks );\r\n\r\n\t\t},\r\n\r\n\t\t// private method\r\n\r\n\t\t_createTrack: function ( node, typedKeyframeTrack, times, values, interpolations ) {\r\n\t\t\t\r\n\t\t\tif ( times.length > 2 ) {\r\n\r\n\t\t\t\ttimes = times.slice();\r\n\t\t\t\tvalues = values.slice();\r\n\t\t\t\tinterpolations = interpolations.slice();\r\n\r\n\t\t\t\tvar stride = values.length / times.length;\r\n\t\t\t\tvar interpolateStride = interpolations.length / times.length;\r\n\r\n\t\t\t\tvar index = 1;\r\n\r\n\t\t\t\tfor ( var aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex ++ ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < stride; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( values[ index * stride + i ] !== values[ ( index - 1 ) * stride + i ] ||\r\n\t\t\t\t\t\t\tvalues[ index * stride + i ] !== values[ aheadIndex * stride + i ] ) {\r\n\r\n\t\t\t\t\t\t\tindex ++;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( aheadIndex > index ) {\r\n\r\n\t\t\t\t\t\ttimes[ index ] = times[ aheadIndex ];\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < stride; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalues[ index * stride + i ] = values[ aheadIndex * stride + i ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < interpolateStride; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tinterpolations[ index * interpolateStride + i ] = interpolations[ aheadIndex * interpolateStride + i ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttimes.length = index + 1;\r\n\t\t\t\tvalues.length = ( index + 1 ) * stride;\r\n\t\t\t\tinterpolations.length = ( index + 1 ) * interpolateStride;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar track = new typedKeyframeTrack( node, times, values );\r\n\r\n\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodCubicBezier( result ) {\r\n\r\n\t\t\t\treturn new CubicBezierInterpolation( this.times, this.values, this.getValueSize(), result, new Float32Array( interpolations ) );\r\n\r\n\t\t\t};\r\n\r\n\t\t\treturn track;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// interpolation\r\n\r\n\tfunction CubicBezierInterpolation( parameterPositions, sampleValues, sampleSize, resultBuffer, params ) {\r\n\r\n\t\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n\t\tthis.interpolationParams = params;\r\n\r\n\t}\r\n\r\n\tCubicBezierInterpolation.prototype = Object.assign( Object.create( Interpolant.prototype ), {\r\n\r\n\t\tconstructor: CubicBezierInterpolation,\r\n\r\n\t\tinterpolate_: function ( i1, t0, t, t1 ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar result = this.resultBuffer;\r\n\t\t\tvar values = this.sampleValues;\r\n\t\t\tvar stride = this.valueSize;\r\n\t\t\tvar params = this.interpolationParams;\r\n\r\n\t\t\tvar offset1 = i1 * stride;\r\n\t\t\tvar offset0 = offset1 - stride;\r\n\r\n\t\t\t// No interpolation if next key frame is in one frame in 30fps.\r\n\t\t\t// This is from MMD animation spec.\r\n\t\t\t// '1.5' is for precision loss. times are Float32 in Three.js Animation system.\r\n\t\t\tvar weight1 = ( ( t1 - t0 ) < 1 / 30 * 1.5 ) ? 0.0 : ( t - t0 ) / ( t1 - t0 );\r\n\r\n\t\t\tif ( stride === 4 ) { // Quaternion\r\n\r\n\t\t\t\tvar x1 = params[ i1 * 4 + 0 ];\r\n\t\t\t\tvar x2 = params[ i1 * 4 + 1 ];\r\n\t\t\t\tvar y1 = params[ i1 * 4 + 2 ];\r\n\t\t\t\tvar y2 = params[ i1 * 4 + 3 ];\r\n\r\n\t\t\t\tvar ratio = this._calculate( x1, x2, y1, y2, weight1 );\r\n\r\n\t\t\t\tQuaternion.slerpFlat( result, 0, values, offset0, values, offset1, ratio );\r\n\r\n\t\t\t} else if ( stride === 3 ) { // Vector3\r\n\r\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\t\tvar x1 = params[ i1 * 12 + i * 4 + 0 ];\r\n\t\t\t\t\tvar x2 = params[ i1 * 12 + i * 4 + 1 ];\r\n\t\t\t\t\tvar y1 = params[ i1 * 12 + i * 4 + 2 ];\r\n\t\t\t\t\tvar y2 = params[ i1 * 12 + i * 4 + 3 ];\r\n\r\n\t\t\t\t\tvar ratio = this$1._calculate( x1, x2, y1, y2, weight1 );\r\n\r\n\t\t\t\t\tresult[ i ] = values[ offset0 + i ] * ( 1 - ratio ) + values[ offset1 + i ] * ratio;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else { // Number\r\n\r\n\t\t\t\tvar x1 = params[ i1 * 4 + 0 ];\r\n\t\t\t\tvar x2 = params[ i1 * 4 + 1 ];\r\n\t\t\t\tvar y1 = params[ i1 * 4 + 2 ];\r\n\t\t\t\tvar y2 = params[ i1 * 4 + 3 ];\r\n\r\n\t\t\t\tvar ratio = this._calculate( x1, x2, y1, y2, weight1 );\r\n\r\n\t\t\t\tresult[ 0 ] = values[ offset0 ] * ( 1 - ratio ) + values[ offset1 ] * ratio;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t},\r\n\r\n\t\t_calculate: function ( x1, x2, y1, y2, x ) {\r\n\r\n\t\t\tvar c = 0.5;\r\n\t\t\tvar t = c;\r\n\t\t\tvar s = 1.0 - t;\r\n\t\t\tvar loop = 15;\r\n\t\t\tvar eps = 1e-5;\r\n\t\t\tvar math = Math;\r\n\r\n\t\t\tvar sst3, stt3, ttt;\r\n\r\n\t\t\tfor ( var i = 0; i < loop; i ++ ) {\r\n\r\n\t\t\t\tsst3 = 3.0 * s * s * t;\r\n\t\t\t\tstt3 = 3.0 * s * t * t;\r\n\t\t\t\tttt = t * t * t;\r\n\r\n\t\t\t\tvar ft = ( sst3 * x1 ) + ( stt3 * x2 ) + ( ttt ) - x;\r\n\r\n\t\t\t\tif ( math.abs( ft ) < eps ) { break; }\r\n\r\n\t\t\t\tc /= 2.0;\r\n\r\n\t\t\t\tt += ( ft < 0 ) ? c : - c;\r\n\t\t\t\ts = 1.0 - t;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn ( sst3 * y1 ) + ( stt3 * y2 ) + ttt;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn MMDLoader;\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MTLLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nMTLLoader.prototype = {\r\n\r\n\tconstructor: MTLLoader,\r\n\t\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\t\r\n\tsetPath: function ( path ) {\r\n\r\n\t\tthis.path = path;\r\n\t\treturn this;\r\n\r\n\t},\r\n\t\r\n\tsetTexturePath: function ( path ) {\r\n\r\n\t\tthis.texturePath = path;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetBaseUrl: function ( path ) {\r\n\r\n\t\tconsole.warn( 'MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.' );\r\n\r\n\t\treturn this.setTexturePath( path );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetMaterialOptions: function ( value ) {\r\n\r\n\t\tthis.materialOptions = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\t\r\n\tparse: function ( text ) {\r\n\r\n\t\tvar lines = text.split( '\\n' );\r\n\t\tvar info = {};\r\n\t\tvar delimiter_pattern = /\\s+/;\r\n\t\tvar materialsInfo = {};\r\n\r\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\tvar line = lines[ i ];\r\n\t\t\tline = line.trim();\r\n\r\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\r\n\r\n\t\t\t\t// Blank line or comment ignore\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar pos = line.indexOf( ' ' );\r\n\r\n\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\r\n\t\t\tkey = key.toLowerCase();\r\n\r\n\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\r\n\t\t\tvalue = value.trim();\r\n\r\n\t\t\tif ( key === 'newmtl' ) {\r\n\r\n\t\t\t\t// New material\r\n\r\n\t\t\t\tinfo = { name: value };\r\n\t\t\t\tmaterialsInfo[ value ] = info;\r\n\r\n\t\t\t} else if ( info ) {\r\n\r\n\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' ) {\r\n\r\n\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\r\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tinfo[ key ] = value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar materialCreator = new MTLLoader.MaterialCreator( this.texturePath || this.path, this.materialOptions );\r\n\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\r\n\t\tmaterialCreator.setManager( this.manager );\r\n\t\tmaterialCreator.setMaterials( materialsInfo );\r\n\t\treturn materialCreator;\r\n\r\n\t}\r\n\r\n};\r\n\r\nMTLLoader.MaterialCreator = function ( baseUrl, options ) {\r\n\r\n\tthis.baseUrl = baseUrl || '';\r\n\tthis.options = options;\r\n\tthis.materialsInfo = {};\r\n\tthis.materials = {};\r\n\tthis.materialsArray = [];\r\n\tthis.nameLookup = {};\r\n\r\n\tthis.side = ( this.options && this.options.side ) ? this.options.side : FrontSide;\r\n\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : RepeatWrapping;\r\n\r\n};\r\n\r\nMTLLoader.MaterialCreator.prototype = {\r\n\r\n\tconstructor: MTLLoader.MaterialCreator,\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetManager: function ( value ) {\r\n\r\n\t\tthis.manager = value;\r\n\r\n\t},\r\n\r\n\tsetMaterials: function ( materialsInfo ) {\r\n\r\n\t\tthis.materialsInfo = this.convert( materialsInfo );\r\n\t\tthis.materials = {};\r\n\t\tthis.materialsArray = [];\r\n\t\tthis.nameLookup = {};\r\n\r\n\t},\r\n\r\n\tconvert: function ( materialsInfo ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( ! this.options ) { return materialsInfo; }\r\n\r\n\t\tvar converted = {};\r\n\r\n\t\tfor ( var mn in materialsInfo ) {\r\n\r\n\t\t\t// Convert materials info into normalized form based on options\r\n\r\n\t\t\tvar mat = materialsInfo[ mn ];\r\n\r\n\t\t\tvar covmat = {};\r\n\r\n\t\t\tconverted[ mn ] = covmat;\r\n\r\n\t\t\tfor ( var prop in mat ) {\r\n\r\n\t\t\t\tvar save = true;\r\n\t\t\t\tvar value = mat[ prop ];\r\n\t\t\t\tvar lprop = prop.toLowerCase();\r\n\r\n\t\t\t\tswitch ( lprop ) {\r\n\r\n\t\t\t\t\tcase 'kd':\r\n\t\t\t\t\tcase 'ka':\r\n\t\t\t\t\tcase 'ks':\r\n\r\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\r\n\r\n\t\t\t\t\t\tif ( this$1.options && this$1.options.normalizeRGB ) {\r\n\r\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( this$1.options && this$1.options.ignoreZeroRGBs ) {\r\n\r\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t// ignore\r\n\r\n\t\t\t\t\t\t\t\tsave = false;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( save ) {\r\n\r\n\t\t\t\t\tcovmat[ lprop ] = value;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn converted;\r\n\r\n\t},\r\n\r\n\tpreload: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var mn in this$1.materialsInfo ) {\r\n\r\n\t\t\tthis$1.create( mn );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetIndex: function ( materialName ) {\r\n\r\n\t\treturn this.nameLookup[ materialName ];\r\n\r\n\t},\r\n\r\n\tgetAsArray: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar index = 0;\r\n\r\n\t\tfor ( var mn in this$1.materialsInfo ) {\r\n\r\n\t\t\tthis$1.materialsArray[ index ] = this$1.create( mn );\r\n\t\t\tthis$1.nameLookup[ mn ] = index;\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.materialsArray;\r\n\r\n\t},\r\n\r\n\tcreate: function ( materialName ) {\r\n\r\n\t\tif ( this.materials[ materialName ] === undefined ) {\r\n\r\n\t\t\tthis.createMaterial_( materialName );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.materials[ materialName ];\r\n\r\n\t},\r\n\r\n\tcreateMaterial_: function ( materialName ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\t// Create material\r\n\r\n\t\tvar scope = this;\r\n\t\tvar mat = this.materialsInfo[ materialName ];\r\n\t\tvar params = {\r\n\r\n\t\t\tname: materialName,\r\n\t\t\tside: this.side\r\n\r\n\t\t};\r\n\r\n\t\tfunction resolveURL( baseUrl, url ) {\r\n\r\n\t\t\tif ( typeof url !== 'string' || url === '' )\r\n\t\t\t\t{ return ''; }\r\n\r\n\t\t\t// Absolute URL\r\n\t\t\tif ( /^https?:\\/\\//i.test( url ) ) { return url; }\r\n\r\n\t\t\treturn baseUrl + url;\r\n\r\n\t\t}\r\n\r\n\t\tfunction setMapForType( mapType, value ) {\r\n\r\n\t\t\tif ( params[ mapType ] ) { return; } // Keep the first encountered texture\r\n\r\n\t\t\tvar texParams = scope.getTextureParams( value, params );\r\n\t\t\tvar map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\r\n\r\n\t\t\tmap.repeat.copy( texParams.scale );\r\n\t\t\tmap.offset.copy( texParams.offset );\r\n\r\n\t\t\tmap.wrapS = scope.wrap;\r\n\t\t\tmap.wrapT = scope.wrap;\r\n\r\n\t\t\tparams[ mapType ] = map;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var prop in mat ) {\r\n\r\n\t\t\tvar value = mat[ prop ];\r\n\t\t\tvar n;\r\n\r\n\t\t\tif ( value === '' ) { continue; }\r\n\r\n\t\t\tswitch ( prop.toLowerCase() ) {\r\n\r\n\t\t\t\t// Ns is material specular exponent\r\n\r\n\t\t\t\tcase 'kd':\r\n\r\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\r\n\r\n\t\t\t\t\tparams.color = new Color().fromArray( value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ks':\r\n\r\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\r\n\t\t\t\t\tparams.specular = new Color().fromArray( value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_kd':\r\n\r\n\t\t\t\t\t// Diffuse texture map\r\n\r\n\t\t\t\t\tsetMapForType( \"map\", value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_ks':\r\n\r\n\t\t\t\t\t// Specular map\r\n\r\n\t\t\t\t\tsetMapForType( \"specularMap\", value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'norm':\r\n\r\n\t\t\t\t\tsetMapForType( \"normalMap\", value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'map_bump':\r\n\t\t\t\tcase 'bump':\r\n\r\n\t\t\t\t\t// Bump texture map\r\n\r\n\t\t\t\t\tsetMapForType( \"bumpMap\", value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ns':\r\n\r\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\r\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\r\n\r\n\t\t\t\t\tparams.shininess = parseFloat( value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'd':\r\n\t\t\t\t\tn = parseFloat( value );\r\n\r\n\t\t\t\t\tif ( n < 1 ) {\r\n\r\n\t\t\t\t\t\tparams.opacity = n;\r\n\t\t\t\t\t\tparams.transparent = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'tr':\r\n\t\t\t\t\tn = parseFloat( value );\r\n\r\n\t\t\t\t\tif ( this$1.options && this$1.options.invertTrProperty ) { n = 1 - n; }\r\n\r\n\t\t\t\t\tif ( n > 0 ) {\r\n\r\n\t\t\t\t\t\tparams.opacity = 1 - n;\r\n\t\t\t\t\t\tparams.transparent = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.materials[ materialName ] = new MeshPhongMaterial( params );\r\n\t\treturn this.materials[ materialName ];\r\n\r\n\t},\r\n\r\n\tgetTextureParams: function ( value, matParams ) {\r\n\r\n\t\tvar texParams = {\r\n\r\n\t\t\tscale: new Vector2( 1, 1 ),\r\n\t\t\toffset: new Vector2( 0, 0 )\r\n\r\n\t\t };\r\n\r\n\t\tvar items = value.split( /\\s+/ );\r\n\t\tvar pos;\r\n\r\n\t\tpos = items.indexOf( '-bm' );\r\n\r\n\t\tif ( pos >= 0 ) {\r\n\r\n\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\r\n\t\t\titems.splice( pos, 2 );\r\n\r\n\t\t}\r\n\r\n\t\tpos = items.indexOf( '-s' );\r\n\r\n\t\tif ( pos >= 0 ) {\r\n\r\n\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\r\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\r\n\r\n\t\t}\r\n\r\n\t\tpos = items.indexOf( '-o' );\r\n\r\n\t\tif ( pos >= 0 ) {\r\n\r\n\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\r\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\r\n\r\n\t\t}\r\n\r\n\t\ttexParams.url = items.join( ' ' ).trim();\r\n\t\treturn texParams;\r\n\r\n\t},\r\n\r\n\tloadTexture: function ( url, mapping, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar texture;\r\n\t\tvar loader = Loader$1.Handlers.get( url );\r\n\t\tvar manager = ( this.manager !== undefined ) ? this.manager : DefaultLoadingManager;\r\n\r\n\t\tif ( loader === null ) {\r\n\r\n\t\t\tloader = new TextureLoader( manager );\r\n\r\n\t\t}\r\n\r\n\t\tif ( loader.setCrossOrigin ) { loader.setCrossOrigin( this.crossOrigin ); }\r\n\t\ttexture = loader.load( url, onLoad, onProgress, onError );\r\n\r\n\t\tif ( mapping !== undefined ) { texture.mapping = mapping; }\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Node( type ) {\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.name = \"\";\r\n\r\n\tthis.type = type;\r\n\r\n\tthis.userData = {};\r\n\r\n}\r\n\r\nNode.prototype = {\r\n\r\n\tconstructor: Node,\r\n\r\n\tisNode: true,\r\n\r\n\tparse: function ( builder, settings ) {\r\n\r\n\t\tsettings = settings || {};\r\n\r\n\t\tbuilder.parsing = true;\r\n\r\n\t\tthis.build( builder.addFlow( settings.slot, settings.cache, settings.context ), 'v4' );\r\n\r\n\t\tbuilder.clearVertexNodeCode();\r\n\t\tbuilder.clearFragmentNodeCode();\r\n\r\n\t\tbuilder.removeFlow();\r\n\r\n\t\tbuilder.parsing = false;\r\n\r\n\t},\r\n\r\n\tparseAndBuildCode: function ( builder, output, settings ) {\r\n\r\n\t\tsettings = settings || {};\r\n\r\n\t\tthis.parse( builder, settings );\r\n\r\n\t\treturn this.buildCode( builder, output, settings );\r\n\r\n\t},\r\n\r\n\tbuildCode: function ( builder, output, settings ) {\r\n\r\n\t\tsettings = settings || {};\r\n\r\n\t\tvar data = { result: this.build( builder.addFlow( settings.slot, settings.cache, settings.context ), output ) };\r\n\r\n\t\tdata.code = builder.clearNodeCode();\r\n\r\n\t\tbuilder.removeFlow();\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tbuild: function ( builder, output, uuid ) {\r\n\r\n\t\toutput = output || this.getType( builder, output );\r\n\r\n\t\tvar data = builder.getNodeData( uuid || this );\r\n\r\n\t\tif ( builder.parsing ) {\r\n\r\n\t\t\tthis.appendDepsNode( builder, data, output );\r\n\r\n\t\t}\r\n\r\n\t\tif ( builder.nodes.indexOf( this ) === - 1 ) {\r\n\r\n\t\t\tbuilder.nodes.push( this );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.updateFrame !== undefined && builder.updaters.indexOf( this ) === - 1 ) {\r\n\r\n\t\t\tbuilder.updaters.push( this );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.generate( builder, output, uuid );\r\n\r\n\t},\r\n\r\n\tappendDepsNode: function ( builder, data, output ) {\r\n\r\n\t\tdata.deps = ( data.deps || 0 ) + 1;\r\n\r\n\t\tvar outputLen = builder.getTypeLength( output );\r\n\r\n\t\tif ( outputLen > ( data.outputMax || 0 ) || this.getType( builder, output ) ) {\r\n\r\n\t\t\tdata.outputMax = outputLen;\r\n\t\t\tdata.output = output;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetName: function ( name ) {\r\n\r\n\t\tthis.name = name;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetName: function ( builder ) {\r\n\r\n\t\treturn this.name;\r\n\r\n\t},\r\n\r\n\tgetType: function ( builder, output ) {\r\n\r\n\t\treturn output === 'sampler2D' || output === 'samplerCube' ? output : this.type;\r\n\r\n\t},\r\n\r\n\tgetJSONNode: function ( meta ) {\r\n\r\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\t\tif ( ! isRootObject && meta.nodes[ this.uuid ] !== undefined ) {\r\n\r\n\t\t\treturn meta.nodes[ this.uuid ];\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tif ( source.name !== undefined ) { this.name = source.name; }\r\n\r\n\t\tif ( source.userData !== undefined ) { this.userData = JSON.parse( JSON.stringify( source.userData ) ); }\r\n\r\n\t},\r\n\r\n\tcreateJSONNode: function ( meta ) {\r\n\r\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\t\tvar data = {};\r\n\r\n\t\tif ( typeof this.nodeType !== \"string\" ) { throw new Error( \"Node does not allow serialization.\" ); }\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.nodeType = this.nodeType;\r\n\r\n\t\tif ( this.name !== \"\" ) { data.name = this.name; }\r\n\r\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }\r\n\r\n\t\tif ( ! isRootObject ) {\r\n\r\n\t\t\tmeta.nodes[ this.uuid ] = data;\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\treturn this.getJSONNode( meta ) || this.createJSONNode( meta );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction TempNode( type, params ) {\r\n\r\n\tNode.call( this, type );\r\n\r\n\tparams = params || {};\r\n\r\n\tthis.shared = params.shared !== undefined ? params.shared : true;\r\n\tthis.unique = params.unique !== undefined ? params.unique : false;\r\n\r\n}\r\n\r\nTempNode.prototype = Object.create( Node.prototype );\r\nTempNode.prototype.constructor = TempNode;\r\n\r\nTempNode.prototype.build = function ( builder, output, uuid, ns ) {\r\n\r\n\toutput = output || this.getType( builder );\r\n\r\n\tif ( this.isShared( builder, output ) ) {\r\n\r\n\t\tvar isUnique = this.isUnique( builder, output );\r\n\r\n\t\tif ( isUnique && this.constructor.uuid === undefined ) {\r\n\r\n\t\t\tthis.constructor.uuid = _Math.generateUUID();\r\n\r\n\t\t}\r\n\r\n\t\tuuid = builder.getUuid( uuid || this.getUuid(), ! isUnique );\r\n\r\n\t\tvar data = builder.getNodeData( uuid ),\r\n\t\t\ttype = data.output || this.getType( builder );\r\n\r\n\t\tif ( builder.parsing ) {\r\n\r\n\t\t\tif ( ( data.deps || 0 ) > 0 ) {\r\n\r\n\t\t\t\tthis.appendDepsNode( builder, data, output );\r\n\r\n\t\t\t\treturn this.generate( builder, output, uuid );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Node.prototype.build.call( this, builder, output, uuid );\r\n\r\n\t\t} else if ( isUnique ) {\r\n\r\n\t\t\tdata.name = data.name || Node.prototype.build.call( this, builder, output, uuid );\r\n\r\n\t\t\treturn data.name;\r\n\r\n\t\t} else if ( ! this.isShared( builder, type ) || ( ! builder.optimize || data.deps == 1 ) ) {\r\n\r\n\t\t\treturn Node.prototype.build.call( this, builder, output, uuid );\r\n\r\n\t\t}\r\n\r\n\t\tuuid = this.getUuid( false );\r\n\r\n\t\tvar name = this.getTemp( builder, uuid );\r\n\r\n\t\tif ( name ) {\r\n\r\n\t\t\treturn builder.format( name, type, output );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tname = TempNode.prototype.generate.call( this, builder, output, uuid, data.output, ns );\r\n\r\n\t\t\tvar code = this.generate( builder, type, uuid );\r\n\r\n\t\t\tbuilder.addNodeCode( name + ' = ' + code + ';' );\r\n\r\n\t\t\treturn builder.format( name, type, output );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn Node.prototype.build.call( this, builder, output, uuid );\r\n\r\n};\r\n\r\nTempNode.prototype.isShared = function ( builder, output ) {\r\n\r\n\treturn output !== 'sampler2D' && output !== 'samplerCube' && this.shared;\r\n\r\n};\r\n\r\nTempNode.prototype.isUnique = function ( builder, output ) {\r\n\r\n\treturn this.unique;\r\n\r\n};\r\n\r\nTempNode.prototype.getUuid = function ( unique ) {\r\n\r\n\tvar uuid = unique || unique == undefined ? this.constructor.uuid || this.uuid : this.uuid;\r\n\r\n\tif ( typeof this.scope == \"string\" ) { uuid = this.scope + '-' + uuid; }\r\n\r\n\treturn uuid;\r\n\r\n};\r\n\r\nTempNode.prototype.getTemp = function ( builder, uuid ) {\r\n\r\n\tuuid = uuid || this.uuid;\r\n\r\n\tvar tempVar = builder.getVars()[ uuid ];\r\n\r\n\treturn tempVar ? tempVar.name : undefined;\r\n\r\n};\r\n\r\nTempNode.prototype.generate = function ( builder, output, uuid, type, ns ) {\r\n\r\n\tif ( ! this.isShared( builder, output ) ) { console.error( \"TempNode is not shared!\" ); }\r\n\r\n\tuuid = uuid || this.uuid;\r\n\r\n\treturn builder.getTempVar( uuid, type || this.getType( builder ), ns ).name;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar FunctionNode = function( src, includesOrType, extensionsOrIncludes, keywordsOrExtensions ) {\r\n\r\n\tsrc = src || '';\r\n\r\n\tthis.isMethod = typeof includesOrType !== \"string\";\r\n\tthis.useKeywords = true;\r\n\r\n\tTempNode.call( this, this.isMethod ? null : includesOrType );\r\n\r\n\tif ( this.isMethod ) { this.eval( src, includesOrType, extensionsOrIncludes, keywordsOrExtensions ); }\r\n\telse { this.eval( src, extensionsOrIncludes, keywordsOrExtensions ); }\r\n\r\n};\r\n\r\nFunctionNode.rDeclaration = /^([a-z_0-9]+)\\s([a-z_0-9]+)\\s?\\((.*?)\\)/i;\r\nFunctionNode.rProperties = /[a-z_0-9]+/ig;\r\n\r\nFunctionNode.prototype = Object.create( TempNode.prototype );\r\nFunctionNode.prototype.constructor = FunctionNode;\r\nFunctionNode.prototype.nodeType = \"Function\";\r\n\r\nFunctionNode.prototype.eval = function( src, includes, extensions, keywords ) {\n\tvar this$1 = this;\n\r\n\r\n\tsrc = ( src || '' ).trim();\r\n\r\n\tthis.includes = includes || [];\r\n\tthis.extensions = extensions || {};\r\n\tthis.keywords = keywords || {};\r\n\r\n\tif ( this.isMethod ) {\r\n\r\n\t\tvar match = src.match( FunctionNode.rDeclaration );\r\n\r\n\t\tthis.inputs = [];\r\n\r\n\t\tif ( match && match.length == 4 ) {\r\n\r\n\t\t\tthis.type = match[ 1 ];\r\n\t\t\tthis.name = match[ 2 ];\r\n\r\n\t\t\tvar inputs = match[ 3 ].match( FunctionNode.rProperties );\r\n\r\n\t\t\tif ( inputs ) {\r\n\r\n\t\t\t\tvar i = 0;\r\n\r\n\t\t\t\twhile ( i < inputs.length ) {\r\n\r\n\t\t\t\t\tvar qualifier = inputs[ i ++ ];\r\n\t\t\t\t\tvar type, name;\r\n\r\n\t\t\t\t\tif ( qualifier == 'in' || qualifier == 'out' || qualifier == 'inout' ) {\r\n\r\n\t\t\t\t\t\ttype = inputs[ i ++ ];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttype = qualifier;\r\n\t\t\t\t\t\tqualifier = '';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tname = inputs[ i ++ ];\r\n\r\n\t\t\t\t\tthis$1.inputs.push( {\r\n\t\t\t\t\t\tname : name,\r\n\t\t\t\t\t\ttype : type,\r\n\t\t\t\t\t\tqualifier : qualifier\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.type = '';\r\n\t\t\tthis.name = '';\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.value = src;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar NodeLib = {\r\n\r\n\tnodes: {},\r\n\tkeywords: {},\r\n\r\n\tadd: function( node ) {\r\n\r\n\t\tthis.nodes[ node.name ] = node;\r\n\r\n\t},\r\n\r\n\taddKeyword: function( name, callback, cache ) {\r\n\r\n\t\tcache = cache !== undefined ? cache : true;\r\n\r\n\t\tthis.keywords[ name ] = { callback : callback, cache : cache };\r\n\r\n\t},\r\n\r\n\tremove: function( node ) {\r\n\r\n\t\tdelete this.nodes[ node.name ];\r\n\r\n\t},\r\n\r\n\tremoveKeyword: function( name ) {\r\n\r\n\t\tdelete this.keywords[ name ];\r\n\r\n\t},\r\n\r\n\tget: function( name ) {\r\n\r\n\t\treturn this.nodes[ name ];\r\n\r\n\t},\r\n\r\n\tgetKeyword: function( name, material ) {\r\n\r\n\t\treturn this.keywords[ name ].callback.call( this, material );\r\n\r\n\t},\r\n\r\n\tgetKeywordData: function( name ) {\r\n\r\n\t\treturn this.keywords[ name ];\r\n\r\n\t},\r\n\r\n\tcontains: function( name ) {\r\n\r\n\t\treturn this.nodes[ name ] != undefined;\r\n\r\n\t},\r\n\r\n\tcontainsKeyword: function( name ) {\r\n\r\n\t\treturn this.keywords[ name ] != undefined;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar vertexDict = [ 'uv', 'uv2' ],\r\n\tfragmentDict = [ 'vUv', 'vUv2' ];\r\n\r\nfunction UVNode( index ) {\r\n\r\n\tTempNode.call( this, 'v2', { shared: false } );\r\n\r\n\tthis.index = index || 0;\r\n\r\n}\r\n\r\nUVNode.prototype = Object.create( TempNode.prototype );\r\nUVNode.prototype.constructor = UVNode;\r\nUVNode.prototype.nodeType = \"UV\";\r\n\r\nUVNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tbuilder.requires.uv[ this.index ] = true;\r\n\r\n\tvar result = builder.isShader( 'vertex' ) ? vertexDict[ this.index ] : fragmentDict[ this.index ];\r\n\r\n\treturn builder.format( result, this.getType( builder ), output );\r\n\r\n};\r\n\r\nUVNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.index = source.index;\r\n\r\n};\r\n\r\nUVNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.index = this.index;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nNodeLib.addKeyword( 'uv', function () {\r\n\r\n\treturn new UVNode();\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'uv2', function () {\r\n\r\n\treturn new UVNode( 1 );\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PositionNode( scope ) {\r\n\r\n\tTempNode.call( this, 'v3' );\r\n\r\n\tthis.scope = scope || PositionNode.LOCAL;\r\n\r\n}\r\n\r\nPositionNode.LOCAL = 'local';\r\nPositionNode.WORLD = 'world';\r\nPositionNode.VIEW = 'view';\r\nPositionNode.PROJECTION = 'projection';\r\n\r\nPositionNode.prototype = Object.create( TempNode.prototype );\r\nPositionNode.prototype.constructor = PositionNode;\r\nPositionNode.prototype.nodeType = \"Position\";\r\n\r\nPositionNode.prototype.getType = function ( ) {\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase PositionNode.PROJECTION:\r\n\r\n\t\t\treturn 'v4';\r\n\r\n\t}\r\n\r\n\treturn this.type;\r\n\r\n};\r\n\r\nPositionNode.prototype.isShared = function ( builder ) {\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase PositionNode.LOCAL:\r\n\t\tcase PositionNode.WORLD:\r\n\r\n\t\t\treturn false;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n};\r\n\r\nPositionNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar result;\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase PositionNode.LOCAL:\r\n\r\n\t\t\tbuilder.requires.position = true;\r\n\r\n\t\t\tresult = builder.isShader( 'vertex' ) ? 'transformed' : 'vPosition';\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase PositionNode.WORLD:\r\n\r\n\t\t\tbuilder.requires.worldPosition = true;\r\n\r\n\t\t\tresult = 'vWPosition';\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase PositionNode.VIEW:\r\n\r\n\t\t\tresult = builder.isShader( 'vertex' ) ? '-mvPosition.xyz' : 'vViewPosition';\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase PositionNode.PROJECTION:\r\n\r\n\t\t\tresult = builder.isShader( 'vertex' ) ? '( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )' : 'vec4( 0.0 )';\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n\treturn builder.format( result, this.getType( builder ), output );\r\n\r\n};\r\n\r\nPositionNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.scope = source.scope;\r\n\r\n};\r\n\r\nPositionNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.scope = this.scope;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nNodeLib.addKeyword( 'position', function () {\r\n\r\n\treturn new PositionNode();\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'worldPosition', function () {\r\n\r\n\treturn new PositionNode( PositionNode.WORLD );\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'viewPosition', function () {\r\n\r\n\treturn new PositionNode( NormalNode.VIEW );\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction NormalNode$1( scope ) {\r\n\r\n\tTempNode.call( this, 'v3' );\r\n\r\n\tthis.scope = scope || NormalNode$1.LOCAL;\r\n\r\n}\r\n\r\nNormalNode$1.LOCAL = 'local';\r\nNormalNode$1.WORLD = 'world';\r\nNormalNode$1.VIEW = 'view';\r\n\r\nNormalNode$1.prototype = Object.create( TempNode.prototype );\r\nNormalNode$1.prototype.constructor = NormalNode$1;\r\nNormalNode$1.prototype.nodeType = \"Normal\";\r\n\r\nNormalNode$1.prototype.isShared = function ( builder ) {\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase NormalNode$1.WORLD:\r\n\r\n\t\t\treturn true;\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n};\r\n\r\nNormalNode$1.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar result;\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase NormalNode$1.LOCAL:\r\n\r\n\t\t\tbuilder.requires.normal = true;\r\n\r\n\t\t\tresult = 'normal';\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase NormalNode$1.WORLD:\r\n\r\n\t\t\tbuilder.requires.worldNormal = true;\r\n\r\n\t\t\tresult = builder.isShader( 'vertex' ) ? '( modelMatrix * vec4( objectNormal, 0.0 ) ).xyz' : 'vWNormal';\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase NormalNode$1.VIEW:\r\n\r\n\t\t\tresult = 'vNormal';\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n\treturn builder.format( result, this.getType( builder ), output );\r\n\r\n};\r\n\r\nNormalNode$1.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.scope = source.scope;\r\n\r\n};\r\n\r\nNormalNode$1.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.scope = this.scope;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nNodeLib.addKeyword( 'normal', function () {\r\n\r\n\treturn new NormalNode$1();\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'worldNormal', function () {\r\n\r\n\treturn new NormalNode$1( NormalNode$1.WORLD );\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'viewNormal', function () {\r\n\r\n\treturn new NormalNode$1( NormalNode$1.VIEW );\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction InputNode$1( type, params ) {\r\n\r\n\tparams = params || {};\r\n\tparams.shared = params.shared !== undefined ? params.shared : false;\r\n\r\n\tTempNode.call( this, type, params );\r\n\r\n\tthis.readonly = false;\r\n\r\n}\r\n\r\nInputNode$1.prototype = Object.create( TempNode.prototype );\r\nInputNode$1.prototype.constructor = InputNode$1;\r\n\r\nInputNode$1.prototype.isReadonly = function ( builder ) {\r\n\r\n\treturn this.readonly;\r\n\r\n};\r\n\r\nInputNode$1.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tif ( source.readonly !== undefined ) { this.readonly = source.readonly; }\r\n\r\n};\r\n\r\nInputNode$1.prototype.createJSONNode = function ( meta ) {\r\n\r\n\tvar data = TempNode.prototype.createJSONNode.call( this, meta );\r\n\r\n\tif ( this.readonly === true ) { data.readonly = this.readonly; }\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nInputNode$1.prototype.generate = function ( builder, output, uuid, type, ns, needsUpdate ) {\r\n\r\n\tuuid = builder.getUuid( uuid || this.getUuid() );\r\n\ttype = type || this.getType( builder );\r\n\r\n\tvar data = builder.getNodeData( uuid ),\r\n\t\treadonly = this.isReadonly( builder ) && this.generateReadonly !== undefined;\r\n\r\n\tif ( readonly ) {\r\n\r\n\t\treturn this.generateReadonly( builder, output, uuid, type, ns, needsUpdate );\r\n\r\n\t} else {\r\n\r\n\t\tif ( builder.isShader( 'vertex' ) ) {\r\n\r\n\t\t\tif ( ! data.vertex ) {\r\n\r\n\t\t\t\tdata.vertex = builder.createVertexUniform( type, this, ns, needsUpdate );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn builder.format( data.vertex.name, type, output );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( ! data.fragment ) {\r\n\r\n\t\t\t\tdata.fragment = builder.createFragmentUniform( type, this, ns, needsUpdate );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn builder.format( data.fragment.name, type, output );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction FloatNode( value ) {\r\n\r\n\tInputNode$1.call( this, 'f' );\r\n\r\n\tthis.value = value || 0;\r\n\r\n}\r\n\r\nFloatNode.prototype = Object.create( InputNode$1.prototype );\r\nFloatNode.prototype.constructor = FloatNode;\r\nFloatNode.prototype.nodeType = \"Float\";\r\n\r\nFloatNode.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {\r\n\r\n\treturn builder.format( this.value + ( this.value % 1 ? '' : '.0' ), type, output );\r\n\r\n};\r\n\r\nFloatNode.prototype.copy = function ( source ) {\r\n\r\n\tInputNode$1.prototype.copy.call( this, source );\r\n\r\n\tthis.value = source.value;\r\n\r\n};\r\n\r\nFloatNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.value = this.value;\r\n\r\n\t\tif ( this.readonly === true ) { data.readonly = true; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction TimerNode( scale, scope, timeScale ) {\r\n\r\n\tFloatNode.call( this );\r\n\r\n\tthis.scale = scale !== undefined ? scale : 1;\r\n\tthis.scope = scope || TimerNode.GLOBAL;\r\n\r\n\tthis.timeScale = timeScale !== undefined ? timeScale : this.scale !== 1;\r\n\r\n}\r\n\r\nTimerNode.GLOBAL = 'global';\r\nTimerNode.LOCAL = 'local';\r\nTimerNode.DELTA = 'delta';\r\n\r\nTimerNode.prototype = Object.create( FloatNode.prototype );\r\nTimerNode.prototype.constructor = TimerNode;\r\nTimerNode.prototype.nodeType = \"Timer\";\r\n\r\nTimerNode.prototype.isReadonly = function () {\r\n\r\n\t// never use TimerNode as readonly but aways as \"uniform\"\r\n\r\n\treturn false;\r\n\r\n};\r\n\r\nTimerNode.prototype.isUnique = function () {\r\n\r\n\t// share TimerNode \"uniform\" input if is used on more time with others TimerNode\r\n\r\n\treturn this.timeScale && ( this.scope === TimerNode.GLOBAL || this.scope === TimerNode.DELTA );\r\n\r\n};\r\n\r\nTimerNode.prototype.updateFrame = function ( frame ) {\r\n\r\n\tvar scale = this.timeScale ? this.scale : 1;\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase TimerNode.LOCAL:\r\n\r\n\t\t\tthis.value += frame.delta * scale;\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase TimerNode.DELTA:\r\n\r\n\t\t\tthis.value = frame.delta * scale;\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\r\n\t\t\tthis.value = frame.time * scale;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTimerNode.prototype.copy = function ( source ) {\r\n\r\n\tFloatNode.prototype.copy.call( this, source );\r\n\r\n\tthis.scope = source.scope;\r\n\tthis.scale = source.scale;\r\n\r\n\tthis.timeScale = source.timeScale;\r\n\r\n};\r\n\r\nTimerNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.scope = this.scope;\r\n\t\tdata.scale = this.scale;\r\n\r\n\t\tdata.timeScale = this.timeScale;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nNodeLib.addKeyword( 'time', function () {\r\n\r\n\treturn new TimerNode();\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar declarationRegexp = /^([a-z_0-9]+)\\s([a-z_0-9]+)\\s?\\=?\\s?(.*?)(\\;|$)/i;\r\n\r\nfunction ConstNode( src, useDefine ) {\r\n\r\n\tTempNode.call( this );\r\n\r\n\tthis.eval( src || ConstNode.PI, useDefine );\r\n\r\n}\r\n\r\nConstNode.PI = 'PI';\r\nConstNode.PI2 = 'PI2';\r\nConstNode.RECIPROCAL_PI = 'RECIPROCAL_PI';\r\nConstNode.RECIPROCAL_PI2 = 'RECIPROCAL_PI2';\r\nConstNode.LOG2 = 'LOG2';\r\nConstNode.EPSILON = 'EPSILON';\r\n\r\nConstNode.prototype = Object.create( TempNode.prototype );\r\nConstNode.prototype.constructor = ConstNode;\r\nConstNode.prototype.nodeType = \"Const\";\r\n\r\nConstNode.prototype.getType = function ( builder ) {\r\n\r\n\treturn builder.getTypeByFormat( this.type );\r\n\r\n};\r\n\r\nConstNode.prototype.eval = function ( src, useDefine ) {\r\n\r\n\tthis.src = src || '';\r\n\r\n\tvar name, type, value = \"\";\r\n\r\n\tvar match = this.src.match( declarationRegexp );\r\n\r\n\tthis.useDefine = useDefine || this.src.charAt( 0 ) === '#';\r\n\r\n\tif ( match && match.length > 1 ) {\r\n\r\n\t\ttype = match[ 1 ];\r\n\t\tname = match[ 2 ];\r\n\t\tvalue = match[ 3 ];\r\n\r\n\t} else {\r\n\r\n\t\tname = this.src;\r\n\t\ttype = 'f';\r\n\r\n\t}\r\n\r\n\tthis.name = name;\r\n\tthis.type = type;\r\n\tthis.value = value;\r\n\r\n};\r\n\r\nConstNode.prototype.build = function ( builder, output ) {\r\n\r\n\tif ( output === 'source' ) {\r\n\r\n\t\tif ( this.value ) {\r\n\r\n\t\t\tif ( this.useDefine ) {\r\n\r\n\t\t\t\treturn '#define ' + this.name + ' ' + this.value;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 'const ' + this.type + ' ' + this.name + ' = ' + this.value + ';';\r\n\r\n\t\t} else if ( this.useDefine ) {\r\n\r\n\t\t\treturn this.src;\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tbuilder.include( this );\r\n\r\n\t\treturn builder.format( this.name, this.getType( builder ), output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nConstNode.prototype.generate = function ( builder, output ) {\r\n\r\n\treturn builder.format( this.name, this.getType( builder ), output );\r\n\r\n};\r\n\r\nConstNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.eval( source.src, source.useDefine );\r\n\r\n};\r\n\r\nConstNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.src = this.src;\r\n\r\n\t\tif ( data.useDefine === true ) { data.useDefine = true; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// Fix circular dependency, see #2\r\n\r\n//\r\n//\tKeywords\r\n//\r\n\r\nNodeLib.addKeyword( 'uv', function() {\r\n\r\n\treturn new UVNode();\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'uv2', function() {\r\n\r\n\treturn new UVNode( 1 );\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'position', function() {\r\n\r\n\treturn new PositionNode();\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'worldPosition', function() {\r\n\r\n\treturn new PositionNode( PositionNode.WORLD );\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'normal', function() {\r\n\r\n\treturn new NormalNode$1();\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'worldNormal', function() {\r\n\r\n\treturn new NormalNode$1( NormalNode$1.WORLD );\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'viewPosition', function() {\r\n\r\n\treturn new PositionNode( NormalNode$1.VIEW );\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'viewNormal', function() {\r\n\r\n\treturn new NormalNode$1( NormalNode$1.VIEW );\r\n\r\n} );\r\n\r\nNodeLib.addKeyword( 'time', function() {\r\n\r\n\treturn new TimerNode();\r\n\r\n} );\r\n\r\n//\r\n//\tLuma\r\n//\r\n\r\nNodeLib.add( new ConstNode( \"vec3 LUMA vec3(0.2125, 0.7154, 0.0721)\" ) );\r\n\r\n//\r\n//\tNormalMap\r\n//\r\n\r\nNodeLib.add( new FunctionNode( [\r\n\t// Per-Pixel Tangent Space Normal Mapping\r\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\r\n\t\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 mUv, vec2 scale ) {\",\r\n\t\"\tvec3 q0 = dFdx( eye_pos );\",\r\n\t\"\tvec3 q1 = dFdy( eye_pos );\",\r\n\t\"\tvec2 st0 = dFdx( mUv.st );\",\r\n\t\"\tvec2 st1 = dFdy( mUv.st );\",\r\n\t\"\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\",\r\n\t\"\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\",\r\n\t\"\tvec3 N = normalize( surf_norm );\",\r\n\t\"\tvec3 mapN = map * 2.0 - 1.0;\",\r\n\t\"\tmapN.xy = scale * mapN.xy;\",\r\n\t\"\tmat3 tsn = mat3( S, T, N );\",\r\n\t\"\treturn normalize( tsn * mapN );\",\r\n\t\"}\"\r\n].join( \"\\n\" ), null, { derivatives: true } ) );\r\n\r\n//\r\n//\tNoise\r\n//\r\n\r\nNodeLib.add( new FunctionNode( [\r\n\t\"float snoise(vec2 co) {\",\r\n\t\"\treturn fract( sin( dot(co.xy, vec2(12.9898,78.233) ) ) * 43758.5453 );\",\r\n\t\"}\"\r\n].join( \"\\n\" ) ) );\r\n\r\n//\r\n//\tHue\r\n//\r\n\r\nNodeLib.add( new FunctionNode( [\r\n\t\"vec3 hue_rgb(vec3 rgb, float adjustment) {\",\r\n\t\"\tconst mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);\",\r\n\t\"\tconst mat3 YIQtoRGB = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.107, 1.7046);\",\r\n\t\"\tvec3 yiq = RGBtoYIQ * rgb;\",\r\n\t\"\tfloat hue = atan(yiq.z, yiq.y) + adjustment;\",\r\n\t\"\tfloat chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\",\r\n\t\"\treturn YIQtoRGB * vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\",\r\n\t\"}\"\r\n].join( \"\\n\" ) ) );\r\n\r\n//\r\n//\tSaturation\r\n//\r\n\r\nNodeLib.add( new FunctionNode( [\r\n\t// Algorithm from Chapter 16 of OpenGL Shading Language\r\n\t\"vec3 saturation_rgb(vec3 rgb, float adjustment) {\",\r\n\t\"\tvec3 intensity = vec3(dot(rgb, LUMA));\",\r\n\t\"\treturn mix(intensity, rgb, adjustment);\",\r\n\t\"}\"\r\n].join( \"\\n\" ) ) );\r\n\r\n//\r\n//\tLuminance\r\n//\r\n\r\nNodeLib.add( new FunctionNode( [\r\n\t// Algorithm from Chapter 10 of Graphics Shaders\r\n\t\"float luminance_rgb(vec3 rgb) {\",\r\n\t\"\treturn dot(rgb, LUMA);\",\r\n\t\"}\"\r\n].join( \"\\n\" ) ) );\r\n\r\n//\r\n//\tVibrance\r\n//\r\n\r\nNodeLib.add( new FunctionNode( [\r\n\t// Shader by Evan Wallace adapted by @lo-th\r\n\t\"vec3 vibrance_rgb(vec3 rgb, float adjustment) {\",\r\n\t\"\tfloat average = (rgb.r + rgb.g + rgb.b) / 3.0;\",\r\n\t\"\tfloat mx = max(rgb.r, max(rgb.g, rgb.b));\",\r\n\t\"\tfloat amt = (mx - average) * (-3.0 * adjustment);\",\r\n\t\"\treturn mix(rgb.rgb, vec3(mx), amt);\",\r\n\t\"}\"\r\n].join( \"\\n\" ) ) );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// Fix circular dependency, see #2\r\n\r\nFunctionNode.prototype.isShared = function( builder, output ) {\r\n\r\n\treturn ! this.isMethod;\r\n\r\n};\r\n\r\nFunctionNode.prototype.getType = function( builder ) {\r\n\r\n\treturn builder.getTypeByFormat( this.type );\r\n\r\n};\r\n\r\nFunctionNode.prototype.getInputByName = function( name ) {\n\tvar this$1 = this;\n\r\n\r\n\tvar i = this.inputs.length;\r\n\r\n\twhile ( i -- ) {\r\n\r\n\t\tif ( this$1.inputs[ i ].name === name )\r\n\t\t\t{ return this$1.inputs[ i ]; }\r\n\r\n\t}\r\n\r\n};\r\n\r\nFunctionNode.prototype.getIncludeByName = function( name ) {\n\tvar this$1 = this;\n\r\n\r\n\tvar i = this.includes.length;\r\n\r\n\twhile ( i -- ) {\r\n\r\n\t\tif ( this$1.includes[ i ].name === name )\r\n\t\t\t{ return this$1.includes[ i ]; }\r\n\r\n\t}\r\n\r\n};\r\n\r\nFunctionNode.prototype.generate = function( builder, output ) {\n\tvar this$1 = this;\n\r\n\r\n\tvar match, offset = 0, src = this.value;\r\n\r\n\tfor ( var i = 0; i < this.includes.length; i ++ ) {\r\n\r\n\t\tbuilder.include( this$1.includes[ i ], this$1 );\r\n\r\n\t}\r\n\r\n\tfor ( var ext in this$1.extensions ) {\r\n\r\n\t\tbuilder.material.extensions[ ext ] = true;\r\n\r\n\t}\r\n\r\n\twhile ( match = FunctionNode.rProperties.exec( this.value ) ) {\r\n\r\n\t\tvar prop = match[ 0 ], isGlobal = this$1.isMethod ? ! this$1.getInputByName( prop ) : true;\r\n\t\tvar reference = prop;\r\n\r\n\t\tif ( this$1.keywords[ prop ] || ( this$1.useKeywords && isGlobal && NodeLib.containsKeyword( prop ) ) ) {\r\n\r\n\t\t\tvar node = this$1.keywords[ prop ];\r\n\r\n\t\t\tif ( ! node ) {\r\n\r\n\t\t\t\tvar keyword = NodeLib.getKeywordData( prop );\r\n\r\n\t\t\t\tif ( keyword.cache ) { node = builder.keywords[ prop ]; }\r\n\r\n\t\t\t\tnode = node || NodeLib.getKeyword( prop, builder );\r\n\r\n\t\t\t\tif ( keyword.cache ) { builder.keywords[ prop ] = node; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treference = node.build( builder );\r\n\r\n\t\t}\r\n\r\n\t\tif ( prop != reference ) {\r\n\r\n\t\t\tsrc = src.substring( 0, match.index + offset ) + reference + src.substring( match.index + prop.length + offset );\r\n\r\n\t\t\toffset += reference.length - prop.length;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this$1.getIncludeByName( reference ) === undefined && NodeLib.contains( reference ) ) {\r\n\r\n\t\t\tbuilder.include( NodeLib.get( reference ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( output === 'source' ) {\r\n\r\n\t\treturn src;\r\n\r\n\t} else if ( this.isMethod ) {\r\n\r\n\t\tbuilder.include( this, false, src );\r\n\r\n\t\treturn this.name;\r\n\r\n\t} else {\r\n\r\n\t\treturn builder.format( \"(\" + src + \")\", this.getType( builder ), output );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CameraNode( scope, camera ) {\r\n\r\n\tTempNode.call( this, 'v3' );\r\n\r\n\tthis.setScope( scope || CameraNode.POSITION );\r\n\tthis.setCamera( camera );\r\n\r\n}\r\n\r\nCameraNode.Nodes = ( function () {\r\n\r\n\tvar depthColor = new FunctionNode( [\r\n\t\t\"float depthColor( float mNear, float mFar ) {\",\r\n\r\n\t\t\"\t#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n\t\t\"\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\",\r\n\r\n\t\t\"\t#else\",\r\n\r\n\t\t\"\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\r\n\t\t\"\t#endif\",\r\n\r\n\t\t\"\treturn 1.0 - smoothstep( mNear, mFar, depth );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\treturn {\r\n\t\tdepthColor: depthColor\r\n\t};\r\n\r\n} )();\r\n\r\nCameraNode.POSITION = 'position';\r\nCameraNode.DEPTH = 'depth';\r\nCameraNode.TO_VERTEX = 'toVertex';\r\n\r\nCameraNode.prototype = Object.create( TempNode.prototype );\r\nCameraNode.prototype.constructor = CameraNode;\r\nCameraNode.prototype.nodeType = \"Camera\";\r\n\r\nCameraNode.prototype.setCamera = function ( camera ) {\r\n\r\n\tthis.camera = camera;\r\n\tthis.updateFrame = camera !== undefined ? this.onUpdateFrame : undefined;\r\n\r\n};\r\n\r\nCameraNode.prototype.setScope = function ( scope ) {\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase CameraNode.DEPTH:\r\n\r\n\t\t\tdelete this.near;\r\n\t\t\tdelete this.far;\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n\tthis.scope = scope;\r\n\r\n\tswitch ( scope ) {\r\n\r\n\t\tcase CameraNode.DEPTH:\r\n\r\n\t\t\tvar camera = this.camera;\r\n\r\n\t\t\tthis.near = new FloatNode( camera ? camera.near : 1 );\r\n\t\t\tthis.far = new FloatNode( camera ? camera.far : 1200 );\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n};\r\n\r\nCameraNode.prototype.getType = function ( builder ) {\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase CameraNode.DEPTH:\r\n\r\n\t\t\treturn 'f';\r\n\r\n\t}\r\n\r\n\treturn this.type;\r\n\r\n};\r\n\r\nCameraNode.prototype.isUnique = function ( builder ) {\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase CameraNode.DEPTH:\r\n\t\tcase CameraNode.TO_VERTEX:\r\n\r\n\t\t\treturn true;\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n};\r\n\r\nCameraNode.prototype.isShared = function ( builder ) {\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase CameraNode.POSITION:\r\n\r\n\t\t\treturn false;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n};\r\n\r\nCameraNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar result;\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase CameraNode.POSITION:\r\n\r\n\t\t\tresult = 'cameraPosition';\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase CameraNode.DEPTH:\r\n\r\n\t\t\tvar depthColor = builder.include( CameraNode.Nodes.depthColor );\r\n\r\n\t\t\tresult = depthColor + '( ' + this.near.build( builder, 'f' ) + ', ' + this.far.build( builder, 'f' ) + ' )';\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase CameraNode.TO_VERTEX:\r\n\r\n\t\t\tresult = 'normalize( ' + new PositionNode( PositionNode.WORLD ).build( builder, 'v3' ) + ' - cameraPosition )';\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n\treturn builder.format( result, this.getType( builder ), output );\r\n\r\n};\r\n\r\nCameraNode.prototype.onUpdateFrame = function ( frame ) {\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase CameraNode.DEPTH:\r\n\r\n\t\t\tvar camera = this.camera;\r\n\r\n\t\t\tthis.near.value = camera.near;\r\n\t\t\tthis.far.value = camera.far;\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n};\r\n\r\nCameraNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.setScope( source.scope );\r\n\r\n\tif ( source.camera ) {\r\n\r\n\t\tthis.setCamera( source.camera );\r\n\r\n\t}\r\n\r\n\tswitch ( source.scope ) {\r\n\r\n\t\tcase CameraNode.DEPTH:\r\n\r\n\t\t\tthis.near.number = source.near;\r\n\t\t\tthis.far.number = source.far;\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n};\r\n\r\nCameraNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.scope = this.scope;\r\n\r\n\t\tif ( this.camera ) { data.camera = this.camera.uuid; }\r\n\r\n\t\tswitch ( this.scope ) {\r\n\r\n\t\t\tcase CameraNode.DEPTH:\r\n\r\n\t\t\t\tdata.near = this.near.value;\r\n\t\t\t\tdata.far = this.far.value;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar NodeMaterialLoader = function ( manager, library ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\tthis.nodes = {};\r\n\tthis.materials = {};\r\n\tthis.passes = {};\r\n\tthis.names = {};\r\n\tthis.library = library || {};\r\n\r\n};\r\n\r\nObject.assign( NodeMaterialLoader.prototype, {\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetObjectByName: function ( uuid ) {\r\n\r\n\t\treturn this.names[ uuid ];\r\n\r\n\t},\r\n\r\n\tgetObjectById: function ( uuid ) {\r\n\r\n\t\treturn this.library[ uuid ] || \r\n\t\t\tthis.nodes[ uuid ] || \r\n\t\t\tthis.materials[ uuid ] ||\r\n\t\t\tthis.passes[ uuid ] || \r\n\t\t\tthis.names[ uuid ];\r\n\r\n\t},\r\n\r\n\tgetNode: function ( uuid ) {\r\n\r\n\t\tvar object = this.getObjectById( uuid );\r\n\r\n\t\tif ( ! object ) {\r\n\r\n\t\t\tconsole.warn( \"Node \\\"\" + uuid + \"\\\" not found.\" );\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t},\r\n\r\n\tresolve: function( json ) {\n\t\tvar this$1 = this;\n\r\n\t\t\r\n\t\tswitch( typeof json ) {\r\n\t\t\t\r\n\t\t\tcase \"boolean\":\r\n\t\t\tcase \"number\":\r\n\t\t\t\r\n\t\t\t\treturn json;\r\n\t\t\t\r\n\t\t\tcase \"string\":\r\n\t\t\t\r\n\t\t\t\tif (/^\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}$/i.test(json) || this.library[ json ]) {\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn this.getNode( json );\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn json;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\r\n\t\t\t\tif ( Array.isArray( json ) ) {\r\n\t\t\t\r\n\t\t\t\t\tfor(var i = 0; i < json.length; i++) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tjson[i] = this$1.resolve( json[i] );\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor ( var prop in json ) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (prop === \"uuid\") { continue; }\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tjson[ prop ] = this$1.resolve( json[ prop ] );\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn json;\r\n\t\t\r\n\t},\r\n\t\r\n\tdeclare: function( json ) {\n\t\tvar this$1 = this;\n\r\n\t\t\r\n\t\tvar uuid, node, object;\r\n\r\n\t\tfor ( uuid in json.nodes ) {\r\n\r\n\t\t\tnode = json.nodes[ uuid ];\r\n\r\n\t\t\tobject = new THREE[ node.nodeType + \"Node\" ]();\r\n\r\n\t\t\tif ( node.name ) {\r\n\r\n\t\t\t\tobject.name = node.name;\r\n\r\n\t\t\t\tthis$1.names[ object.name ] = object;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis$1.nodes[ uuid ] = object;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( uuid in json.materials ) {\r\n\r\n\t\t\tnode = json.materials[ uuid ];\r\n\r\n\t\t\tobject = new THREE[ node.type ]();\r\n\r\n\t\t\tif ( node.name ) {\r\n\r\n\t\t\t\tobject.name = node.name;\r\n\r\n\t\t\t\tthis$1.names[ object.name ] = object;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis$1.materials[ uuid ] = object;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( uuid in json.passes ) {\r\n\r\n\t\t\tnode = json.passes[ uuid ];\r\n\r\n\t\t\tobject = new THREE[ node.type ]();\r\n\r\n\t\t\tif ( node.name ) {\r\n\r\n\t\t\t\tobject.name = node.name;\r\n\r\n\t\t\t\tthis$1.names[ object.name ] = object;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis$1.passes[ uuid ] = object;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.material ) { this.material = this.materials[ json.material ]; }\r\n\t\t\r\n\t\tif ( json.pass ) { this.pass = this.passes[ json.pass ]; }\r\n\t\t\r\n\t\treturn json;\r\n\t\t\r\n\t},\r\n\t\r\n\tparse: function ( json ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar uuid;\r\n\t\r\n\t\tjson = this.resolve( this.declare( json ) );\r\n\t\t\r\n\t\tfor ( uuid in json.nodes ) {\r\n\r\n\t\t\tthis$1.nodes[ uuid ].copy( json.nodes[ uuid ] );\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfor ( uuid in json.materials ) {\r\n\r\n\t\t\tthis$1.materials[ uuid ].copy( json.materials[ uuid ] );\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfor ( uuid in json.passes ) {\r\n\r\n\t\t\tthis$1.passes[ uuid ].copy( json.passes[ uuid ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.material || this.pass || this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar OBJLoader = ( function () {\r\n\r\n\t// o object_name | g group_name\r\n\tvar object_pattern = /^[og]\\s*(.+)?/;\r\n\t// mtllib file_reference\r\n\tvar material_library_pattern = /^mtllib /;\r\n\t// usemtl material_name\r\n\tvar material_use_pattern = /^usemtl /;\r\n\r\n\tfunction ParserState() {\r\n\r\n\t\tvar state = {\r\n\t\t\tobjects: [],\r\n\t\t\tobject: {},\r\n\r\n\t\t\tvertices: [],\r\n\t\t\tnormals: [],\r\n\t\t\tcolors: [],\r\n\t\t\tuvs: [],\r\n\r\n\t\t\tmaterialLibraries: [],\r\n\r\n\t\t\tstartObject: function ( name, fromDeclaration ) {\r\n\r\n\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\r\n\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\r\n\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\r\n\r\n\t\t\t\t\tthis.object.name = name;\r\n\t\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\r\n\r\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\r\n\r\n\t\t\t\t\tthis.object._finalize( true );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.object = {\r\n\t\t\t\t\tname: name || '',\r\n\t\t\t\t\tfromDeclaration: ( fromDeclaration !== false ),\r\n\r\n\t\t\t\t\tgeometry: {\r\n\t\t\t\t\t\tvertices: [],\r\n\t\t\t\t\t\tnormals: [],\r\n\t\t\t\t\t\tcolors: [],\r\n\t\t\t\t\t\tuvs: []\r\n\t\t\t\t\t},\r\n\t\t\t\t\tmaterials: [],\r\n\t\t\t\t\tsmooth: true,\r\n\r\n\t\t\t\t\tstartMaterial: function ( name, libraries ) {\r\n\r\n\t\t\t\t\t\tvar previous = this._finalize( false );\r\n\r\n\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\r\n\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\r\n\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\r\n\r\n\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar material = {\r\n\t\t\t\t\t\t\tindex: this.materials.length,\r\n\t\t\t\t\t\t\tname: name || '',\r\n\t\t\t\t\t\t\tmtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\r\n\t\t\t\t\t\t\tsmooth: ( previous !== undefined ? previous.smooth : this.smooth ),\r\n\t\t\t\t\t\t\tgroupStart: ( previous !== undefined ? previous.groupEnd : 0 ),\r\n\t\t\t\t\t\t\tgroupEnd: - 1,\r\n\t\t\t\t\t\t\tgroupCount: - 1,\r\n\t\t\t\t\t\t\tinherited: false,\r\n\r\n\t\t\t\t\t\t\tclone: function ( index ) {\r\n\r\n\t\t\t\t\t\t\t\tvar cloned = {\r\n\t\t\t\t\t\t\t\t\tindex: ( typeof index === 'number' ? index : this.index ),\r\n\t\t\t\t\t\t\t\t\tname: this.name,\r\n\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\r\n\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\r\n\t\t\t\t\t\t\t\t\tgroupStart: 0,\r\n\t\t\t\t\t\t\t\t\tgroupEnd: - 1,\r\n\t\t\t\t\t\t\t\t\tgroupCount: - 1,\r\n\t\t\t\t\t\t\t\t\tinherited: false\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );\r\n\t\t\t\t\t\t\t\treturn cloned;\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tthis.materials.push( material );\r\n\r\n\t\t\t\t\t\treturn material;\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tcurrentMaterial: function () {\r\n\r\n\t\t\t\t\t\tif ( this.materials.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn undefined;\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_finalize: function ( end ) {\n\t\t\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\r\n\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {\r\n\r\n\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\r\n\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\r\n\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\r\n\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var mi = this.materials.length - 1; mi >= 0; mi -- ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( this$1.materials[ mi ].groupCount <= 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tthis$1.materials.splice( mi, 1 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\r\n\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {\r\n\r\n\t\t\t\t\t\t\tthis.materials.push( {\r\n\t\t\t\t\t\t\t\tname: '',\r\n\t\t\t\t\t\t\t\tsmooth: this.smooth\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn lastMultiMaterial;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Inherit previous objects material.\r\n\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\r\n\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\r\n\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\r\n\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\r\n\r\n\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {\r\n\r\n\t\t\t\t\tvar declared = previousMaterial.clone( 0 );\r\n\t\t\t\t\tdeclared.inherited = true;\r\n\t\t\t\t\tthis.object.materials.push( declared );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.objects.push( this.object );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfinalize: function () {\r\n\r\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\r\n\r\n\t\t\t\t\tthis.object._finalize( true );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tparseVertexIndex: function ( value, len ) {\r\n\r\n\t\t\t\tvar index = parseInt( value, 10 );\r\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tparseNormalIndex: function ( value, len ) {\r\n\r\n\t\t\t\tvar index = parseInt( value, 10 );\r\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tparseUVIndex: function ( value, len ) {\r\n\r\n\t\t\t\tvar index = parseInt( value, 10 );\r\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddVertex: function ( a, b, c ) {\r\n\r\n\t\t\t\tvar src = this.vertices;\r\n\t\t\t\tvar dst = this.object.geometry.vertices;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\r\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\r\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddVertexPoint: function ( a ) {\r\n\r\n\t\t\t\tvar src = this.vertices;\r\n\t\t\t\tvar dst = this.object.geometry.vertices;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddVertexLine: function ( a ) {\r\n\r\n\t\t\t\tvar src = this.vertices;\r\n\t\t\t\tvar dst = this.object.geometry.vertices;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddNormal: function ( a, b, c ) {\r\n\r\n\t\t\t\tvar src = this.normals;\r\n\t\t\t\tvar dst = this.object.geometry.normals;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\r\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\r\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddColor: function ( a, b, c ) {\r\n\r\n\t\t\t\tvar src = this.colors;\r\n\t\t\t\tvar dst = this.object.geometry.colors;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\r\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\r\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddUV: function ( a, b, c ) {\r\n\r\n\t\t\t\tvar src = this.uvs;\r\n\t\t\t\tvar dst = this.object.geometry.uvs;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\r\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );\r\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddUVLine: function ( a ) {\r\n\r\n\t\t\t\tvar src = this.uvs;\r\n\t\t\t\tvar dst = this.object.geometry.uvs;\r\n\r\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {\r\n\r\n\t\t\t\tvar vLen = this.vertices.length;\r\n\r\n\t\t\t\tvar ia = this.parseVertexIndex( a, vLen );\r\n\t\t\t\tvar ib = this.parseVertexIndex( b, vLen );\r\n\t\t\t\tvar ic = this.parseVertexIndex( c, vLen );\r\n\r\n\t\t\t\tthis.addVertex( ia, ib, ic );\r\n\r\n\t\t\t\tif ( ua !== undefined && ua !== '' ) {\r\n\r\n\t\t\t\t\tvar uvLen = this.uvs.length;\r\n\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );\r\n\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );\r\n\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );\r\n\t\t\t\t\tthis.addUV( ia, ib, ic );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( na !== undefined && na !== '' ) {\r\n\r\n\t\t\t\t\t// Normals are many times the same. If so, skip function call and parseInt.\r\n\t\t\t\t\tvar nLen = this.normals.length;\r\n\t\t\t\t\tia = this.parseNormalIndex( na, nLen );\r\n\r\n\t\t\t\t\tib = na === nb ? ia : this.parseNormalIndex( nb, nLen );\r\n\t\t\t\t\tic = na === nc ? ia : this.parseNormalIndex( nc, nLen );\r\n\r\n\t\t\t\t\tthis.addNormal( ia, ib, ic );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( this.colors.length > 0 ) {\r\n\r\n\t\t\t\t\tthis.addColor( ia, ib, ic );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddPointGeometry: function ( vertices ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tthis.object.geometry.type = 'Points';\r\n\r\n\t\t\t\tvar vLen = this.vertices.length;\r\n\r\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\r\n\r\n\t\t\t\t\tthis$1.addVertexPoint( this$1.parseVertexIndex( vertices[ vi ], vLen ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\taddLineGeometry: function ( vertices, uvs ) {\n\t\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t\tthis.object.geometry.type = 'Line';\r\n\r\n\t\t\t\tvar vLen = this.vertices.length;\r\n\t\t\t\tvar uvLen = this.uvs.length;\r\n\r\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\r\n\r\n\t\t\t\t\tthis$1.addVertexLine( this$1.parseVertexIndex( vertices[ vi ], vLen ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\r\n\r\n\t\t\t\t\tthis$1.addUVLine( this$1.parseUVIndex( uvs[ uvi ], uvLen ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tstate.startObject( '', false );\r\n\r\n\t\treturn state;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction OBJLoader( manager ) {\r\n\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\t\tthis.materials = null;\r\n\r\n\t}\r\n\r\n\tOBJLoader.prototype = {\r\n\r\n\t\tconstructor: OBJLoader,\r\n\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tvar loader = new FileLoader( scope.manager );\r\n\t\t\tloader.setPath( this.path );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\r\n\t\tsetPath: function ( value ) {\r\n\r\n\t\t\tthis.path = value;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetMaterials: function ( materials ) {\r\n\r\n\t\t\tthis.materials = materials;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( text ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tconsole.time( 'OBJLoader' );\r\n\r\n\t\t\tvar state = new ParserState();\r\n\r\n\t\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\r\n\r\n\t\t\t\t// This is faster than String.split with regex that splits on both\r\n\t\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {\r\n\r\n\t\t\t\t// join lines separated by a line continuation character (\\)\r\n\t\t\t\ttext = text.replace( /\\\\\\n/g, '' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar lines = text.split( '\\n' );\r\n\t\t\tvar line = '', lineFirstChar = '';\r\n\t\t\tvar lineLength = 0;\r\n\t\t\tvar result = [];\r\n\r\n\t\t\t// Faster to just trim left side of the line. Use if available.\r\n\t\t\tvar trimLeft = ( typeof ''.trimLeft === 'function' );\r\n\r\n\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tline = lines[ i ];\r\n\r\n\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\r\n\r\n\t\t\t\tlineLength = line.length;\r\n\r\n\t\t\t\tif ( lineLength === 0 ) { continue; }\r\n\r\n\t\t\t\tlineFirstChar = line.charAt( 0 );\r\n\r\n\t\t\t\t// @todo invoke passed in handler if any\r\n\t\t\t\tif ( lineFirstChar === '#' ) { continue; }\r\n\r\n\t\t\t\tif ( lineFirstChar === 'v' ) {\r\n\r\n\t\t\t\t\tvar data = line.split( /\\s+/ );\r\n\r\n\t\t\t\t\tswitch ( data[ 0 ] ) {\r\n\r\n\t\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\t\tstate.vertices.push(\r\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\r\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\r\n\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tif ( data.length === 8 ) {\r\n\r\n\t\t\t\t\t\t\t\tstate.colors.push(\r\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 4 ] ),\r\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 5 ] ),\r\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 6 ] )\r\n\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'vn':\r\n\t\t\t\t\t\t\tstate.normals.push(\r\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\r\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\r\n\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'vt':\r\n\t\t\t\t\t\t\tstate.uvs.push(\r\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\r\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] )\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( lineFirstChar === 'f' ) {\r\n\r\n\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\r\n\t\t\t\t\tvar vertexData = lineData.split( /\\s+/ );\r\n\t\t\t\t\tvar faceVertices = [];\r\n\r\n\t\t\t\t\t// Parse the face vertex data into an easy to work with format\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar vertex = vertexData[ j ];\r\n\r\n\t\t\t\t\t\tif ( vertex.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\tvar vertexParts = vertex.split( '/' );\r\n\t\t\t\t\t\t\tfaceVertices.push( vertexParts );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\r\n\r\n\t\t\t\t\tvar v1 = faceVertices[ 0 ];\r\n\r\n\t\t\t\t\tfor ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar v2 = faceVertices[ j ];\r\n\t\t\t\t\t\tvar v3 = faceVertices[ j + 1 ];\r\n\r\n\t\t\t\t\t\tstate.addFace(\r\n\t\t\t\t\t\t\tv1[ 0 ], v2[ 0 ], v3[ 0 ],\r\n\t\t\t\t\t\t\tv1[ 1 ], v2[ 1 ], v3[ 1 ],\r\n\t\t\t\t\t\t\tv1[ 2 ], v2[ 2 ], v3[ 2 ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( lineFirstChar === 'l' ) {\r\n\r\n\t\t\t\t\tvar lineParts = line.substring( 1 ).trim().split( \" \" );\r\n\t\t\t\t\tvar lineVertices = [], lineUVs = [];\r\n\r\n\t\t\t\t\tif ( line.indexOf( \"/\" ) === - 1 ) {\r\n\r\n\t\t\t\t\t\tlineVertices = lineParts;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar parts = lineParts[ li ].split( \"/\" );\r\n\r\n\t\t\t\t\t\t\tif ( parts[ 0 ] !== \"\" ) { lineVertices.push( parts[ 0 ] ); }\r\n\t\t\t\t\t\t\tif ( parts[ 1 ] !== \"\" ) { lineUVs.push( parts[ 1 ] ); }\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\r\n\r\n\t\t\t\t} else if ( lineFirstChar === 'p' ) {\r\n\r\n\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\r\n\t\t\t\t\tvar pointData = lineData.split( \" \" );\r\n\r\n\t\t\t\t\tstate.addPointGeometry( pointData );\r\n\r\n\t\t\t\t} else if ( ( result = object_pattern.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t// o object_name\r\n\t\t\t\t\t// or\r\n\t\t\t\t\t// g group_name\r\n\r\n\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\r\n\t\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\r\n\t\t\t\t\tvar name = ( \" \" + result[ 0 ].substr( 1 ).trim() ).substr( 1 );\r\n\r\n\t\t\t\t\tstate.startObject( name );\r\n\r\n\t\t\t\t} else if ( material_use_pattern.test( line ) ) {\r\n\r\n\t\t\t\t\t// material\r\n\r\n\t\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\r\n\r\n\t\t\t\t} else if ( material_library_pattern.test( line ) ) {\r\n\r\n\t\t\t\t\t// mtl file\r\n\r\n\t\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\r\n\r\n\t\t\t\t} else if ( lineFirstChar === 's' ) {\r\n\r\n\t\t\t\t\tresult = line.split( ' ' );\r\n\r\n\t\t\t\t\t// smooth shading\r\n\r\n\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\r\n\t\t\t\t\t// but does not define a usemtl for each face set.\r\n\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\r\n\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\r\n\t\t\t\t\t// where explicit usemtl defines geometry groups.\r\n\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\r\n\t\t\t\t\t\r\n\t\t\t\t\tif ( result.length > 1 ) {\r\n\r\n\t\t\t\t\t\tvar value = result[ 1 ].trim().toLowerCase();\r\n\t\t\t\t\t\tstate.object.smooth = ( value !== '0' && value !== 'off' );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\r\n\t\t\t\t\t\tstate.object.smooth = true;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar material = state.object.currentMaterial();\r\n\t\t\t\t\tif ( material ) { material.smooth = state.object.smooth; }\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Handle null terminated files without exception\r\n\t\t\t\t\tif ( line === '\\0' ) { continue; }\r\n\r\n\t\t\t\t\tthrow new Error( 'OBJLoader: Unexpected line: \"' + line + '\"' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstate.finalize();\r\n\r\n\t\t\tvar container = new Group();\r\n\t\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\r\n\r\n\t\t\tfor ( var i = 0, l = state.objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar object = state.objects[ i ];\r\n\t\t\t\tvar geometry = object.geometry;\r\n\t\t\t\tvar materials = object.materials;\r\n\t\t\t\tvar isLine = ( geometry.type === 'Line' );\r\n\t\t\t\tvar isPoints = ( geometry.type === 'Points' );\r\n\t\t\t\tvar hasVertexColors = false;\r\n\r\n\t\t\t\t// Skip o/g line declarations that did not follow with any faces\r\n\t\t\t\tif ( geometry.vertices.length === 0 ) { continue; }\r\n\r\n\t\t\t\tvar buffergeometry = new BufferGeometry();\r\n\r\n\t\t\t\tbuffergeometry.addAttribute( 'position', new Float32BufferAttribute( geometry.vertices, 3 ) );\r\n\r\n\t\t\t\tif ( geometry.normals.length > 0 ) {\r\n\r\n\t\t\t\t\tbuffergeometry.addAttribute( 'normal', new Float32BufferAttribute( geometry.normals, 3 ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbuffergeometry.computeVertexNormals();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geometry.colors.length > 0 ) {\r\n\r\n\t\t\t\t\thasVertexColors = true;\r\n\t\t\t\t\tbuffergeometry.addAttribute( 'color', new Float32BufferAttribute( geometry.colors, 3 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geometry.uvs.length > 0 ) {\r\n\r\n\t\t\t\t\tbuffergeometry.addAttribute( 'uv', new Float32BufferAttribute( geometry.uvs, 2 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Create materials\r\n\r\n\t\t\t\tvar createdMaterials = [];\r\n\r\n\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\r\n\r\n\t\t\t\t\tvar sourceMaterial = materials[ mi ];\r\n\t\t\t\t\tvar material = undefined;\r\n\r\n\t\t\t\t\tif ( this$1.materials !== null ) {\r\n\r\n\t\t\t\t\t\tmaterial = this$1.materials.create( sourceMaterial.name );\r\n\r\n\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\r\n\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof LineBasicMaterial ) ) {\r\n\r\n\t\t\t\t\t\t\tvar materialLine = new LineBasicMaterial();\r\n\t\t\t\t\t\t\tmaterialLine.copy( material );\r\n\t\t\t\t\t\t\tmaterialLine.lights = false; // TOFIX\r\n\t\t\t\t\t\t\tmaterial = materialLine;\r\n\r\n\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof PointsMaterial ) ) {\r\n\r\n\t\t\t\t\t\t\tvar materialPoints = new PointsMaterial( { size: 10, sizeAttenuation: false } );\r\n\t\t\t\t\t\t\tmaterialLine.copy( material );\r\n\t\t\t\t\t\t\tmaterial = materialPoints;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ! material ) {\r\n\r\n\t\t\t\t\t\tif ( isLine ) {\r\n\r\n\t\t\t\t\t\t\tmaterial = new LineBasicMaterial();\r\n\r\n\t\t\t\t\t\t} else if ( isPoints ) {\r\n\r\n\t\t\t\t\t\t\tmaterial = new PointsMaterial( { size: 1, sizeAttenuation: false } );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tmaterial = new MeshPhongMaterial();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\r\n\t\t\t\t\tmaterial.vertexColors = hasVertexColors ? VertexColors : NoColors;\r\n\r\n\t\t\t\t\tcreatedMaterials.push( material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Create mesh\r\n\r\n\t\t\t\tvar mesh;\r\n\r\n\t\t\t\tif ( createdMaterials.length > 1 ) {\r\n\r\n\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\r\n\r\n\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\r\n\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( isLine ) {\r\n\r\n\t\t\t\t\t\tmesh = new LineSegments( buffergeometry, createdMaterials );\r\n\r\n\t\t\t\t\t} else if ( isPoints ) {\r\n\r\n\t\t\t\t\t\tmesh = new Points( buffergeometry, createdMaterials );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmesh = new Mesh( buffergeometry, createdMaterials );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( isLine ) {\r\n\r\n\t\t\t\t\t\tmesh = new LineSegments( buffergeometry, createdMaterials[ 0 ] );\r\n\r\n\t\t\t\t\t} else if ( isPoints ) {\r\n\r\n\t\t\t\t\t\tmesh = new Points( buffergeometry, createdMaterials[ 0 ] );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmesh = new Mesh( buffergeometry, createdMaterials[ 0 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmesh.name = object.name;\r\n\r\n\t\t\t\tcontainer.add( mesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.timeEnd( 'OBJLoader' );\r\n\r\n\t\t\treturn container;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\treturn OBJLoader;\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nif ( LoaderSupport === undefined ) { console.error( '\"LoaderSupport\" is not available. \"OBJLoader2\" requires it. Please include \"LoaderSupport.js\" in your HTML.' ); }\r\n\r\nvar OBJLoader2 = (function () {\r\n\r\n\tvar OBJLOADER2_VERSION = '2.4.2';\r\n\tvar Validator = LoaderSupport.Validator;\r\n\r\n\tfunction OBJLoader2( manager ) {\r\n\t\tconsole.info( 'Using OBJLoader2 version: ' + OBJLOADER2_VERSION );\r\n\r\n\t\tthis.manager = Validator.verifyInput( manager, DefaultLoadingManager );\r\n\t\tthis.logging = {\r\n\t\t\tenabled: true,\r\n\t\t\tdebug: false\r\n\t\t};\r\n\r\n\t\tthis.modelName = '';\r\n\t\tthis.instanceNo = 0;\r\n\t\tthis.path = '';\r\n\t\tthis.useIndices = false;\r\n\t\tthis.disregardNormals = false;\r\n\t\tthis.materialPerSmoothingGroup = false;\r\n\t\tthis.useOAsMesh = false;\r\n\t\tthis.loaderRootNode = new Group();\r\n\r\n\t\tthis.meshBuilder = new LoaderSupport.MeshBuilder();\r\n\t\tthis.callbacks = new LoaderSupport.Callbacks();\r\n\t\tthis.workerSupport = new LoaderSupport.WorkerSupport();\r\n\t\tthis.terminateWorkerOnLoad = true;\r\n\t}\r\n\t\r\n\tOBJLoader2.prototype.setLogging = function ( enabled, debug ) {\r\n\t\tthis.logging.enabled = enabled === true;\r\n\t\tthis.logging.debug = debug === true;\r\n\t\tthis.meshBuilder.setLogging( this.logging.enabled, this.logging.debug );\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.setModelName = function ( modelName ) {\r\n\t\tthis.modelName = Validator.verifyInput( modelName, this.modelName );\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.setPath = function ( path ) {\r\n\t\tthis.path = Validator.verifyInput( path, this.path );\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.setStreamMeshesTo = function ( streamMeshesTo ) {\r\n\t\tthis.loaderRootNode = Validator.verifyInput( streamMeshesTo, this.loaderRootNode );\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.setMaterials = function ( materials ) {\r\n\t\tthis.meshBuilder.setMaterials( materials );\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.setUseIndices = function ( useIndices ) {\r\n\t\tthis.useIndices = useIndices === true;\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.setDisregardNormals = function ( disregardNormals ) {\r\n\t\tthis.disregardNormals = disregardNormals === true;\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.setMaterialPerSmoothingGroup = function ( materialPerSmoothingGroup ) {\r\n\t\tthis.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.setUseOAsMesh = function ( useOAsMesh ) {\r\n\t\tthis.useOAsMesh = useOAsMesh === true;\r\n\t};\r\n\r\n\tOBJLoader2.prototype._setCallbacks = function ( callbacks ) {\r\n\t\tif ( Validator.isValid( callbacks.onProgress ) ) { this.callbacks.setCallbackOnProgress( callbacks.onProgress ); }\r\n\t\tif ( Validator.isValid( callbacks.onReportError ) ) { this.callbacks.setCallbackOnReportError( callbacks.onReportError ); }\r\n\t\tif ( Validator.isValid( callbacks.onMeshAlter ) ) { this.callbacks.setCallbackOnMeshAlter( callbacks.onMeshAlter ); }\r\n\t\tif ( Validator.isValid( callbacks.onLoad ) ) { this.callbacks.setCallbackOnLoad( callbacks.onLoad ); }\r\n\t\tif ( Validator.isValid( callbacks.onLoadMaterials ) ) { this.callbacks.setCallbackOnLoadMaterials( callbacks.onLoadMaterials ); }\r\n\r\n\t\tthis.meshBuilder._setCallbacks( this.callbacks );\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.onProgress = function ( type, text, numericalValue ) {\r\n\t\tvar content = Validator.isValid( text ) ? text: '';\r\n\t\tvar event = {\r\n\t\t\tdetail: {\r\n\t\t\t\ttype: type,\r\n\t\t\t\tmodelName: this.modelName,\r\n\t\t\t\tinstanceNo: this.instanceNo,\r\n\t\t\t\ttext: content,\r\n\t\t\t\tnumericalValue: numericalValue\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif ( Validator.isValid( this.callbacks.onProgress ) ) { this.callbacks.onProgress( event ); }\r\n\r\n\t\tif ( this.logging.enabled && this.logging.debug ) { console.debug( content ); }\r\n\t};\r\n\r\n\tOBJLoader2.prototype._onError = function ( event ) {\r\n\t\tvar output = 'Error occurred while downloading!';\r\n\r\n\t\tif ( event.currentTarget && event.currentTarget.statusText !== null ) {\r\n\r\n\t\t\toutput += '\\nurl: ' + event.currentTarget.responseURL + '\\nstatus: ' + event.currentTarget.statusText;\r\n\r\n\t\t}\r\n\t\tthis.onProgress( 'error', output, -1 );\r\n\t\tthis._throwError( output );\r\n\t};\r\n\r\n\tOBJLoader2.prototype._throwError = function ( errorMessage ) {\r\n\t\tif ( Validator.isValid( this.callbacks.onReportError ) )  {\r\n\r\n\t\t\tthis.callbacks.onReportError( errorMessage );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthrow errorMessage;\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.load = function ( url, onLoad, onProgress, onError, onMeshAlter, useAsync ) {\r\n\t\tvar resource = new LoaderSupport.ResourceDescriptor( url, 'OBJ' );\r\n\t\tthis._loadObj( resource, onLoad, onProgress, onError, onMeshAlter, useAsync );\r\n\t};\r\n\r\n\tOBJLoader2.prototype._loadObj = function ( resource, onLoad, onProgress, onError, onMeshAlter, useAsync ) {\r\n\t\tvar scope = this;\r\n\t\tif ( ! Validator.isValid( onError ) ) {\r\n\t\t\tonError = function ( event ) {\r\n\t\t\t\tscope._onError( event );\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// fast-fail\r\n\t\tif ( ! Validator.isValid( resource ) ) { onError( 'An invalid ResourceDescriptor was provided. Unable to continue!' ); }\r\n\t\tvar fileLoaderOnLoad = function ( content ) {\r\n\r\n\t\t\tresource.content = content;\r\n\t\t\tif ( useAsync ) {\r\n\r\n\t\t\t\tscope.parseAsync( content, onLoad );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar callbacks = new LoaderSupport.Callbacks();\r\n\t\t\t\tcallbacks.setCallbackOnMeshAlter( onMeshAlter );\r\n\t\t\t\tscope._setCallbacks( callbacks );\r\n\t\t\t\tonLoad(\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdetail: {\r\n\t\t\t\t\t\t\tloaderRootNode: scope.parse( content ),\r\n\t\t\t\t\t\t\tmodelName: scope.modelName,\r\n\t\t\t\t\t\t\tinstanceNo: scope.instanceNo\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// fast-fail\r\n\t\tif ( ! Validator.isValid( resource.url ) || Validator.isValid( resource.content ) ) {\r\n\r\n\t\t\tfileLoaderOnLoad( Validator.isValid( resource.content ) ? resource.content : null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( ! Validator.isValid( onProgress ) ) {\r\n\t\t\t\tvar numericalValueRef = 0;\r\n\t\t\t\tvar numericalValue = 0;\r\n\t\t\t\tonProgress = function ( event ) {\r\n\t\t\t\t\tif ( ! event.lengthComputable ) { return; }\r\n\r\n\t\t\t\t\tnumericalValue = event.loaded / event.total;\r\n\t\t\t\t\tif ( numericalValue > numericalValueRef ) {\r\n\r\n\t\t\t\t\t\tnumericalValueRef = numericalValue;\r\n\t\t\t\t\t\tvar output = 'Download of \"' + resource.url + '\": ' + ( numericalValue * 100 ).toFixed( 2 ) + '%';\r\n\t\t\t\t\t\tscope.onProgress( 'progressLoad', output, numericalValue );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tvar fileLoader = new FileLoader( this.manager );\r\n\t\t\tfileLoader.setPath( this.path );\r\n\t\t\tfileLoader.setResponseType( 'arraybuffer' );\r\n\t\t\tfileLoader.load( resource.url, fileLoaderOnLoad, onProgress, onError );\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.run = function ( prepData, workerSupportExternal ) {\r\n\t\tthis._applyPrepData( prepData );\r\n\t\tvar available = prepData.checkResourceDescriptorFiles( prepData.resources,\r\n\t\t\t[\r\n\t\t\t\t{ ext: \"obj\", type: \"ArrayBuffer\", ignore: false },\r\n\t\t\t\t{ ext: \"mtl\", type: \"String\", ignore: false },\r\n\t\t\t\t{ ext: \"zip\", type: \"String\", ignore: true }\r\n\t\t\t]\r\n\t\t);\r\n\t\tif ( Validator.isValid( workerSupportExternal ) ) {\r\n\r\n\t\t\tthis.terminateWorkerOnLoad = false;\r\n\t\t\tthis.workerSupport = workerSupportExternal;\r\n\t\t\tthis.logging.enabled = this.workerSupport.logging.enabled;\r\n\t\t\tthis.logging.debug = this.workerSupport.logging.debug;\r\n\r\n\t\t}\r\n\t\tvar scope = this;\r\n\t\tvar onMaterialsLoaded = function ( materials ) {\r\n\t\t\tif ( materials !== null ) { scope.meshBuilder.setMaterials( materials ); }\r\n\t\t\tscope._loadObj( available.obj, scope.callbacks.onLoad, null, null, scope.callbacks.onMeshAlter, prepData.useAsync );\r\n\r\n\t\t};\r\n\t\tthis._loadMtl( available.mtl, onMaterialsLoaded, null, null, prepData.crossOrigin, prepData.materialOptions );\r\n\t};\r\n\r\n\tOBJLoader2.prototype._applyPrepData = function ( prepData ) {\r\n\t\tif ( Validator.isValid( prepData ) ) {\r\n\r\n\t\t\tthis.setLogging( prepData.logging.enabled, prepData.logging.debug );\r\n\t\t\tthis.setModelName( prepData.modelName );\r\n\t\t\tthis.setStreamMeshesTo( prepData.streamMeshesTo );\r\n\t\t\tthis.meshBuilder.setMaterials( prepData.materials );\r\n\t\t\tthis.setUseIndices( prepData.useIndices );\r\n\t\t\tthis.setDisregardNormals( prepData.disregardNormals );\r\n\t\t\tthis.setMaterialPerSmoothingGroup( prepData.materialPerSmoothingGroup );\r\n\t\t\tthis.setUseOAsMesh( prepData.useOAsMesh );\r\n\r\n\t\t\tthis._setCallbacks( prepData.getCallbacks() );\r\n\r\n\t\t}\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.parse = function ( content ) {\r\n\t\t// fast-fail in case of illegal data\r\n\t\tif ( ! Validator.isValid( content ) ) {\r\n\r\n\t\t\tconsole.warn( 'Provided content is not a valid ArrayBuffer or String.' );\r\n\t\t\treturn this.loaderRootNode;\r\n\r\n\t\t}\r\n\t\tif ( this.logging.enabled ) { console.time( 'OBJLoader2 parse: ' + this.modelName ); }\r\n\t\tthis.meshBuilder.init();\r\n\r\n\t\tvar parser = new Parser();\r\n\t\tparser.setLogging( this.logging.enabled, this.logging.debug );\r\n\t\tparser.setMaterialPerSmoothingGroup( this.materialPerSmoothingGroup );\r\n\t\tparser.setUseOAsMesh( this.useOAsMesh );\r\n\t\tparser.setUseIndices( this.useIndices );\r\n\t\tparser.setDisregardNormals( this.disregardNormals );\r\n\t\t// sync code works directly on the material references\r\n\t\tparser.setMaterials( this.meshBuilder.getMaterials() );\r\n\r\n\t\tvar scope = this;\r\n\t\tvar onMeshLoaded = function ( payload ) {\r\n\t\t\tvar meshes = scope.meshBuilder.processPayload( payload );\r\n\t\t\tvar mesh;\r\n\t\t\tfor ( var i in meshes ) {\r\n\t\t\t\tmesh = meshes[ i ];\r\n\t\t\t\tscope.loaderRootNode.add( mesh );\r\n\t\t\t}\r\n\t\t};\r\n\t\tparser.setCallbackMeshBuilder( onMeshLoaded );\r\n\t\tvar onProgressScoped = function ( text, numericalValue ) {\r\n\t\t\tscope.onProgress( 'progressParse', text, numericalValue );\r\n\t\t};\r\n\t\tparser.setCallbackProgress( onProgressScoped );\r\n\r\n\t\tif ( content instanceof ArrayBuffer || content instanceof Uint8Array ) {\r\n\r\n\t\t\tif ( this.logging.enabled ) { console.info( 'Parsing arrayBuffer...' ); }\r\n\t\t\tparser.parse( content );\r\n\r\n\t\t} else if ( typeof( content ) === 'string' || content instanceof String ) {\r\n\r\n\t\t\tif ( this.logging.enabled ) { console.info( 'Parsing text...' ); }\r\n\t\t\tparser.parseText( content );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._throwError( 'Provided content was neither of type String nor Uint8Array! Aborting...' );\r\n\r\n\t\t}\r\n\t\tif ( this.logging.enabled ) { console.timeEnd( 'OBJLoader2 parse: ' + this.modelName ); }\r\n\r\n\t\treturn this.loaderRootNode;\r\n\t};\r\n\t\r\n\tOBJLoader2.prototype.parseAsync = function ( content, onLoad ) {\r\n\t\tvar scope = this;\r\n\t\tvar measureTime = false;\r\n\t\tvar scopedOnLoad = function () {\r\n\t\t\tonLoad(\r\n\t\t\t\t{\r\n\t\t\t\t\tdetail: {\r\n\t\t\t\t\t\tloaderRootNode: scope.loaderRootNode,\r\n\t\t\t\t\t\tmodelName: scope.modelName,\r\n\t\t\t\t\t\tinstanceNo: scope.instanceNo\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\tif ( measureTime && scope.logging.enabled ) { console.timeEnd( 'OBJLoader2 parseAsync: ' + scope.modelName ); }\r\n\t\t};\r\n\t\t// fast-fail in case of illegal data\r\n\t\tif ( ! Validator.isValid( content ) ) {\r\n\r\n\t\t\tconsole.warn( 'Provided content is not a valid ArrayBuffer.' );\r\n\t\t\tscopedOnLoad();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmeasureTime = true;\r\n\r\n\t\t}\r\n\t\tif ( measureTime && this.logging.enabled ) { console.time( 'OBJLoader2 parseAsync: ' + this.modelName ); }\r\n\t\tthis.meshBuilder.init();\r\n\r\n\t\tvar scopedOnMeshLoaded = function ( payload ) {\r\n\t\t\tvar meshes = scope.meshBuilder.processPayload( payload );\r\n\t\t\tvar mesh;\r\n\t\t\tfor ( var i in meshes ) {\r\n\t\t\t\tmesh = meshes[ i ];\r\n\t\t\t\tscope.loaderRootNode.add( mesh );\r\n\t\t\t}\r\n\t\t};\r\n\t\tvar buildCode = function ( funcBuildObject, funcBuildSingleton ) {\r\n\t\t\tvar workerCode = '';\r\n\t\t\tworkerCode += '\\n\\n';\r\n\t\t\tworkerCode += 'THREE = { ' + LoaderSupport.constructor.name + ': {} };\\n\\n';\r\n\t\t\tworkerCode += funcBuildObject( '' + LoaderSupport.constructor.name + '.' + LoaderSupport.Validator.constructor.name, Validator );\r\n\t\t\tworkerCode += funcBuildSingleton( 'Parser', Parser );\r\n\r\n\t\t\treturn workerCode;\r\n\t\t};\r\n\t\tthis.workerSupport.validate( buildCode, 'Parser' );\r\n\t\tthis.workerSupport.setCallbacks( scopedOnMeshLoaded, scopedOnLoad );\r\n\t\tif ( scope.terminateWorkerOnLoad ) { this.workerSupport.setTerminateRequested( true ); }\r\n\r\n\t\tvar materialNames = {};\r\n\t\tvar materials = this.meshBuilder.getMaterials();\r\n\t\tfor ( var materialName in materials ) {\r\n\r\n\t\t\tmaterialNames[ materialName ] = materialName;\r\n\r\n\t\t}\r\n\t\tthis.workerSupport.run(\r\n\t\t\t{\r\n\t\t\t\tparams: {\r\n\t\t\t\t\tuseAsync: true,\r\n\t\t\t\t\tmaterialPerSmoothingGroup: this.materialPerSmoothingGroup,\r\n\t\t\t\t\tuseOAsMesh: this.useOAsMesh,\r\n\t\t\t\t\tuseIndices: this.useIndices,\r\n\t\t\t\t\tdisregardNormals: this.disregardNormals\r\n\t\t\t\t},\r\n\t\t\t\tlogging: {\r\n\t\t\t\t\tenabled: this.logging.enabled,\r\n\t\t\t\t\tdebug: this.logging.debug\r\n\t\t\t\t},\r\n\t\t\t\tmaterials: {\r\n\t\t\t\t\t// in async case only material names are supplied to parser\r\n\t\t\t\t\tmaterials: materialNames\r\n\t\t\t\t},\r\n\t\t\t\tdata: {\r\n\t\t\t\t\tinput: content,\r\n\t\t\t\t\toptions: null\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t};\r\n\t\r\n\tvar Parser = (function () {\r\n\r\n\t\tfunction Parser() {\r\n\t\t\tthis.callbackProgress = null;\r\n\t\t\tthis.callbackMeshBuilder = null;\r\n\t\t\tthis.contentRef = null;\r\n\t\t\tthis.legacyMode = false;\r\n\r\n\t\t\tthis.materials = {};\r\n\t\t\tthis.useAsync = false;\r\n\t\t\tthis.materialPerSmoothingGroup = false;\r\n\t\t\tthis.useOAsMesh = false;\r\n\t\t\tthis.useIndices = false;\r\n\t\t\tthis.disregardNormals = false;\r\n\r\n\t\t\tthis.vertices = [];\r\n\t\t\tthis.colors = [];\r\n\t\t\tthis.normals = [];\r\n\t\t\tthis.uvs = [];\r\n\r\n\t\t\tthis.rawMesh = {\r\n\t\t\t\tobjectName: '',\r\n\t\t\t\tgroupName: '',\r\n\t\t\t\tactiveMtlName: '',\r\n\t\t\t\tmtllibName: '',\r\n\r\n\t\t\t\t// reset with new mesh\r\n\t\t\t\tfaceType: -1,\r\n\t\t\t\tsubGroups: [],\r\n\t\t\t\tsubGroupInUse: null,\r\n\t\t\t\tsmoothingGroup: {\r\n\t\t\t\t\tsplitMaterials: false,\r\n\t\t\t\t\tnormalized: -1,\r\n\t\t\t\t\treal: -1\r\n\t\t\t\t},\r\n\t\t\t\tcounts: {\r\n\t\t\t\t\tdoubleIndicesCount: 0,\r\n\t\t\t\t\tfaceCount: 0,\r\n\t\t\t\t\tmtlCount: 0,\r\n\t\t\t\t\tsmoothingGroupCount: 0\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tthis.inputObjectCount = 1;\r\n\t\t\tthis.outputObjectCount = 1;\r\n\t\t\tthis.globalCounts = {\r\n\t\t\t\tvertices: 0,\r\n\t\t\t\tfaces: 0,\r\n\t\t\t\tdoubleIndicesCount: 0,\r\n\t\t\t\tlineByte: 0,\r\n\t\t\t\tcurrentByte: 0,\r\n\t\t\t\ttotalBytes: 0\r\n\t\t\t};\r\n\r\n\t\t\tthis.logging = {\r\n\t\t\t\tenabled: true,\r\n\t\t\t\tdebug: false\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tParser.prototype.resetRawMesh = function () {\r\n\t\t\t// faces are stored according combined index of group, material and smoothingGroup (0 or not)\r\n\t\t\tthis.rawMesh.subGroups = [];\r\n\t\t\tthis.rawMesh.subGroupInUse = null;\r\n\t\t\tthis.rawMesh.smoothingGroup.normalized = -1;\r\n\t\t\tthis.rawMesh.smoothingGroup.real = -1;\r\n\r\n\t\t\t// this default index is required as it is possible to define faces without 'g' or 'usemtl'\r\n\t\t\tthis.pushSmoothingGroup( 1 );\r\n\r\n\t\t\tthis.rawMesh.counts.doubleIndicesCount = 0;\r\n\t\t\tthis.rawMesh.counts.faceCount = 0;\r\n\t\t\tthis.rawMesh.counts.mtlCount = 0;\r\n\t\t\tthis.rawMesh.counts.smoothingGroupCount = 0;\r\n\t\t};\r\n\r\n\t\tParser.prototype.setUseAsync = function ( useAsync ) {\r\n\t\t\tthis.useAsync = useAsync;\r\n\t\t};\r\n\r\n\t\tParser.prototype.setMaterialPerSmoothingGroup = function ( materialPerSmoothingGroup ) {\r\n\t\t\tthis.materialPerSmoothingGroup = materialPerSmoothingGroup;\r\n\t\t};\r\n\r\n\t\tParser.prototype.setUseOAsMesh = function ( useOAsMesh ) {\r\n\t\t\tthis.useOAsMesh = useOAsMesh;\r\n\t\t};\r\n\r\n\t\tParser.prototype.setUseIndices = function ( useIndices ) {\r\n\t\t\tthis.useIndices = useIndices;\r\n\t\t};\r\n\r\n\t\tParser.prototype.setDisregardNormals = function ( disregardNormals ) {\r\n\t\t\tthis.disregardNormals = disregardNormals;\r\n\t\t};\r\n\r\n\t\tParser.prototype.setMaterials = function ( materials ) {\r\n\t\t\tthis.materials = LoaderSupport.Validator.verifyInput( materials, this.materials );\r\n\t\t\tthis.materials = LoaderSupport.Validator.verifyInput( this.materials, {} );\r\n\t\t};\r\n\r\n\t\tParser.prototype.setCallbackMeshBuilder = function ( callbackMeshBuilder ) {\r\n\t\t\tif ( ! LoaderSupport.Validator.isValid( callbackMeshBuilder ) ) {\r\n\r\n\t\t\t\tthis._throwError( 'Unable to run as no \"MeshBuilder\" callback is set.' );\r\n\r\n\t\t\t}\r\n\t\t\tthis.callbackMeshBuilder = callbackMeshBuilder;\r\n\t\t};\r\n\r\n\t\tParser.prototype.setCallbackProgress = function ( callbackProgress ) {\r\n\t\t\tthis.callbackProgress = callbackProgress;\r\n\t\t};\r\n\r\n\t\tParser.prototype.setLogging = function ( enabled, debug ) {\r\n\t\t\tthis.logging.enabled = enabled === true;\r\n\t\t\tthis.logging.debug = debug === true;\r\n\t\t};\r\n\r\n\t\tParser.prototype.configure = function () {\r\n\t\t\tthis.pushSmoothingGroup( 1 );\r\n\r\n\t\t\tif ( this.logging.enabled ) {\r\n\r\n\t\t\t\tvar matKeys = Object.keys( this.materials );\r\n\t\t\t\tvar matNames = ( matKeys.length > 0 ) ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join( '\\n\\t\\t- ' ) : '\\n\\tmaterialNames: None';\r\n\t\t\t\tvar printedConfig = 'OBJLoader2.Parser configuration:'\r\n\t\t\t\t\t+ matNames\r\n\t\t\t\t\t+ '\\n\\tuseAsync: ' + this.useAsync\r\n\t\t\t\t\t+ '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup\r\n\t\t\t\t\t+ '\\n\\tuseOAsMesh: ' + this.useOAsMesh\r\n\t\t\t\t\t+ '\\n\\tuseIndices: ' + this.useIndices\r\n\t\t\t\t\t+ '\\n\\tdisregardNormals: ' + this.disregardNormals\r\n\t\t\t\t\t+ '\\n\\tcallbackMeshBuilderName: ' + this.callbackMeshBuilder.name\r\n\t\t\t\t\t+ '\\n\\tcallbackProgressName: ' + this.callbackProgress.name;\r\n\t\t\t\tconsole.info( printedConfig );\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tParser.prototype.parse = function ( arrayBuffer ) {\n\t\t\tvar this$1 = this;\n\r\n\t\t\tif ( this.logging.enabled ) { console.time( 'OBJLoader2.Parser.parse' ); }\r\n\t\t\tthis.configure();\r\n\r\n\t\t\tvar arrayBufferView = new Uint8Array( arrayBuffer );\r\n\t\t\tthis.contentRef = arrayBufferView;\r\n\t\t\tvar length = arrayBufferView.byteLength;\r\n\t\t\tthis.globalCounts.totalBytes = length;\r\n\t\t\tvar buffer = new Array( 128 );\r\n\r\n\t\t\tfor ( var code, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++ ) {\r\n\r\n\t\t\t\tcode = arrayBufferView[ i ];\r\n\t\t\t\tswitch ( code ) {\r\n\t\t\t\t\t// space\r\n\t\t\t\t\tcase 32:\r\n\t\t\t\t\t\tif ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }\r\n\t\t\t\t\t\tword = '';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t// slash\r\n\t\t\t\t\tcase 47:\r\n\t\t\t\t\t\tif ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }\r\n\t\t\t\t\t\tslashesCount++;\r\n\t\t\t\t\t\tword = '';\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t// LF\r\n\t\t\t\t\tcase 10:\r\n\t\t\t\t\t\tif ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }\r\n\t\t\t\t\t\tword = '';\r\n\t\t\t\t\t\tthis$1.globalCounts.lineByte = this$1.globalCounts.currentByte;\r\n\t\t\t\t\t\tthis$1.globalCounts.currentByte = i;\r\n\t\t\t\t\t\tthis$1.processLine( buffer, bufferPointer, slashesCount );\r\n\t\t\t\t\t\tbufferPointer = 0;\r\n\t\t\t\t\t\tslashesCount = 0;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t// CR\r\n\t\t\t\t\tcase 13:\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tword += String.fromCharCode( code );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.finalizeParsing();\r\n\t\t\tif ( this.logging.enabled ) { console.timeEnd(  'OBJLoader2.Parser.parse' ); }\r\n\t\t};\r\n\t\t\r\n\t\tParser.prototype.parseText = function ( text ) {\n\t\t\tvar this$1 = this;\n\r\n\t\t\tif ( this.logging.enabled ) { console.time(  'OBJLoader2.Parser.parseText' ); }\r\n\t\t\tthis.configure();\r\n\t\t\tthis.legacyMode = true;\r\n\t\t\tthis.contentRef = text;\r\n\t\t\tvar length = text.length;\r\n\t\t\tthis.globalCounts.totalBytes = length;\r\n\t\t\tvar buffer = new Array( 128 );\r\n\r\n\t\t\tfor ( var char, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++ ) {\r\n\r\n\t\t\t\tchar = text[ i ];\r\n\t\t\t\tswitch ( char ) {\r\n\t\t\t\t\tcase ' ':\r\n\t\t\t\t\t\tif ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }\r\n\t\t\t\t\t\tword = '';\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '/':\r\n\t\t\t\t\t\tif ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }\r\n\t\t\t\t\t\tslashesCount++;\r\n\t\t\t\t\t\tword = '';\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '\\n':\r\n\t\t\t\t\t\tif ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }\r\n\t\t\t\t\t\tword = '';\r\n\t\t\t\t\t\tthis$1.globalCounts.lineByte = this$1.globalCounts.currentByte;\r\n\t\t\t\t\t\tthis$1.globalCounts.currentByte = i;\r\n\t\t\t\t\t\tthis$1.processLine( buffer, bufferPointer, slashesCount );\r\n\t\t\t\t\t\tbufferPointer = 0;\r\n\t\t\t\t\t\tslashesCount = 0;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '\\r':\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tword += char;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.finalizeParsing();\r\n\t\t\tif ( this.logging.enabled ) { console.timeEnd( 'OBJLoader2.Parser.parseText' ); }\r\n\t\t};\r\n\r\n\t\tParser.prototype.processLine = function ( buffer, bufferPointer, slashesCount ) {\n\t\t\tvar this$1 = this;\n\r\n\t\t\tif ( bufferPointer < 1 ) { return; }\r\n\r\n\t\t\tvar reconstructString = function ( content, legacyMode, start, stop ) {\r\n\t\t\t\tvar line = '';\r\n\t\t\t\tif ( stop > start ) {\r\n\r\n\t\t\t\t\tvar i;\r\n\t\t\t\t\tif ( legacyMode ) {\r\n\r\n\t\t\t\t\t\tfor ( i = start; i < stop; i++ ) { line += content[ i ]; }\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor ( i = start; i < stop; i++ ) { line += String.fromCharCode( content[ i ] ); }\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tline = line.trim();\r\n\r\n\t\t\t\t}\r\n\t\t\t\treturn line;\r\n\t\t\t};\r\n\r\n\t\t\tvar bufferLength, length, i, lineDesignation;\r\n\t\t\tlineDesignation = buffer [ 0 ];\r\n\t\t\tswitch ( lineDesignation ) {\r\n\t\t\t\tcase 'v':\r\n\t\t\t\t\tthis.vertices.push( parseFloat( buffer[ 1 ] ) );\r\n\t\t\t\t\tthis.vertices.push( parseFloat( buffer[ 2 ] ) );\r\n\t\t\t\t\tthis.vertices.push( parseFloat( buffer[ 3 ] ) );\r\n\t\t\t\t\tif ( bufferPointer > 4 ) {\r\n\r\n\t\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 4 ] ) );\r\n\t\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 5 ] ) );\r\n\t\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 6 ] ) );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'vt':\r\n\t\t\t\t\tthis.uvs.push( parseFloat( buffer[ 1 ] ) );\r\n\t\t\t\t\tthis.uvs.push( parseFloat( buffer[ 2 ] ) );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'vn':\r\n\t\t\t\t\tthis.normals.push( parseFloat( buffer[ 1 ] ) );\r\n\t\t\t\t\tthis.normals.push( parseFloat( buffer[ 2 ] ) );\r\n\t\t\t\t\tthis.normals.push( parseFloat( buffer[ 3 ] ) );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'f':\r\n\t\t\t\t\tbufferLength = bufferPointer - 1;\r\n\r\n\t\t\t\t\t// \"f vertex ...\"\r\n\t\t\t\t\tif ( slashesCount === 0 ) {\r\n\r\n\t\t\t\t\t\tthis.checkFaceType( 0 );\r\n\t\t\t\t\t\tfor ( i = 2, length = bufferLength; i < length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ 1 ] );\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ i ] );\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ i + 1 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// \"f vertex/uv ...\"\r\n\t\t\t\t\t} else if  ( bufferLength === slashesCount * 2 ) {\r\n\r\n\t\t\t\t\t\tthis.checkFaceType( 1 );\r\n\t\t\t\t\t\tfor ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\r\n\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ 1 ], buffer[ 2 ] );\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ i ], buffer[ i + 1 ] );\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ i + 2 ], buffer[ i + 3 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// \"f vertex/uv/normal ...\"\r\n\t\t\t\t\t} else if  ( bufferLength * 2 === slashesCount * 3 ) {\r\n\r\n\t\t\t\t\t\tthis.checkFaceType( 2 );\r\n\t\t\t\t\t\tfor ( i = 4, length = bufferLength - 3; i < length; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ 1 ], buffer[ 2 ], buffer[ 3 ] );\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ i ], buffer[ i + 1 ], buffer[ i + 2 ] );\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ i + 3 ], buffer[ i + 4 ], buffer[ i + 5 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// \"f vertex//normal ...\"\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis.checkFaceType( 3 );\r\n\t\t\t\t\t\tfor ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\r\n\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ 1 ], undefined, buffer[ 2 ] );\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ i ], undefined, buffer[ i + 1 ] );\r\n\t\t\t\t\t\t\tthis$1.buildFace( buffer[ i + 2 ], undefined, buffer[ i + 3 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'l':\r\n\t\t\t\tcase 'p':\r\n\t\t\t\t\tbufferLength = bufferPointer - 1;\r\n\t\t\t\t\tif ( bufferLength === slashesCount * 2 )  {\r\n\r\n\t\t\t\t\t\tthis.checkFaceType( 4 );\r\n\t\t\t\t\t\tfor ( i = 1, length = bufferLength + 1; i < length; i += 2 ) { this$1.buildFace( buffer[ i ], buffer[ i + 1 ] ); }\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis.checkFaceType( ( lineDesignation === 'l' ) ? 5 : 6  );\r\n\t\t\t\t\t\tfor ( i = 1, length = bufferLength + 1; i < length; i ++ ) { this$1.buildFace( buffer[ i ] ); }\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 's':\r\n\t\t\t\t\tthis.pushSmoothingGroup( buffer[ 1 ] );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'g':\r\n\t\t\t\t\t// 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set\r\n\t\t\t\t\tthis.processCompletedMesh();\r\n\t\t\t\t\tthis.rawMesh.groupName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'o':\r\n\t\t\t\t\t// 'o' is meta-information and usually does not result in creation of new meshes, but can be enforced with \"useOAsMesh\"\r\n\t\t\t\t\tif ( this.useOAsMesh ) { this.processCompletedMesh(); }\r\n\t\t\t\t\tthis.rawMesh.objectName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'mtllib':\r\n\t\t\t\t\tthis.rawMesh.mtllibName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'usemtl':\r\n\t\t\t\t\tvar mtlName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\r\n\t\t\t\t\tif ( mtlName !== '' && this.rawMesh.activeMtlName !== mtlName ) {\r\n\r\n\t\t\t\t\t\tthis.rawMesh.activeMtlName = mtlName;\r\n\t\t\t\t\t\tthis.rawMesh.counts.mtlCount++;\r\n\t\t\t\t\t\tthis.checkSubGroup();\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tParser.prototype.pushSmoothingGroup = function ( smoothingGroup ) {\r\n\t\t\tvar smoothingGroupInt = parseInt( smoothingGroup );\r\n\t\t\tif ( isNaN( smoothingGroupInt ) ) {\r\n\t\t\t\tsmoothingGroupInt = smoothingGroup === \"off\" ? 0 : 1;\r\n\t\t\t}\r\n\r\n\t\t\tvar smoothCheck = this.rawMesh.smoothingGroup.normalized;\r\n\t\t\tthis.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : ( smoothingGroupInt === 0 ) ? 0 : 1;\r\n\t\t\tthis.rawMesh.smoothingGroup.real = smoothingGroupInt;\r\n\r\n\t\t\tif ( smoothCheck !== smoothingGroupInt ) {\r\n\r\n\t\t\t\tthis.rawMesh.counts.smoothingGroupCount++;\r\n\t\t\t\tthis.checkSubGroup();\r\n\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tParser.prototype.checkFaceType = function ( faceType ) {\r\n\t\t\tif ( this.rawMesh.faceType !== faceType ) {\r\n\r\n\t\t\t\tthis.processCompletedMesh();\r\n\t\t\t\tthis.rawMesh.faceType = faceType;\r\n\t\t\t\tthis.checkSubGroup();\r\n\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tParser.prototype.checkSubGroup = function () {\r\n\t\t\tvar index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\r\n\t\t\tthis.rawMesh.subGroupInUse = this.rawMesh.subGroups[ index ];\r\n\r\n\t\t\tif ( ! LoaderSupport.Validator.isValid( this.rawMesh.subGroupInUse ) ) {\r\n\r\n\t\t\t\tthis.rawMesh.subGroupInUse = {\r\n\t\t\t\t\tindex: index,\r\n\t\t\t\t\tobjectName: this.rawMesh.objectName,\r\n\t\t\t\t\tgroupName: this.rawMesh.groupName,\r\n\t\t\t\t\tmaterialName: this.rawMesh.activeMtlName,\r\n\t\t\t\t\tsmoothingGroup: this.rawMesh.smoothingGroup.normalized,\r\n\t\t\t\t\tvertices: [],\r\n\t\t\t\t\tindexMappingsCount: 0,\r\n\t\t\t\t\tindexMappings: [],\r\n\t\t\t\t\tindices: [],\r\n\t\t\t\t\tcolors: [],\r\n\t\t\t\t\tuvs: [],\r\n\t\t\t\t\tnormals: []\r\n\t\t\t\t};\r\n\t\t\t\tthis.rawMesh.subGroups[ index ] = this.rawMesh.subGroupInUse;\r\n\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tParser.prototype.buildFace = function ( faceIndexV, faceIndexU, faceIndexN ) {\r\n\t\t\tif ( this.disregardNormals ) { faceIndexN = undefined; }\r\n\t\t\tvar scope = this;\r\n\t\t\tvar updateSubGroupInUse = function () {\r\n\r\n\t\t\t\tvar faceIndexVi = parseInt( faceIndexV );\r\n\t\t\t\tvar indexPointerV = 3 * ( faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3 );\r\n\r\n\t\t\t\tvar vertices = scope.rawMesh.subGroupInUse.vertices;\r\n\t\t\t\tvertices.push( scope.vertices[ indexPointerV++ ] );\r\n\t\t\t\tvertices.push( scope.vertices[ indexPointerV++ ] );\r\n\t\t\t\tvertices.push( scope.vertices[ indexPointerV ] );\r\n\r\n\t\t\t\tvar indexPointerC = scope.colors.length > 0 ? indexPointerV + 1 : null;\r\n\t\t\t\tif ( indexPointerC !== null ) {\r\n\r\n\t\t\t\t\tvar colors = scope.rawMesh.subGroupInUse.colors;\r\n\t\t\t\t\tcolors.push( scope.colors[ indexPointerC++ ] );\r\n\t\t\t\t\tcolors.push( scope.colors[ indexPointerC++ ] );\r\n\t\t\t\t\tcolors.push( scope.colors[ indexPointerC ] );\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( faceIndexU ) {\r\n\r\n\t\t\t\t\tvar faceIndexUi = parseInt( faceIndexU );\r\n\t\t\t\t\tvar indexPointerU = 2 * ( faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2 );\r\n\t\t\t\t\tvar uvs = scope.rawMesh.subGroupInUse.uvs;\r\n\t\t\t\t\tuvs.push( scope.uvs[ indexPointerU++ ] );\r\n\t\t\t\t\tuvs.push( scope.uvs[ indexPointerU ] );\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( faceIndexN ) {\r\n\r\n\t\t\t\t\tvar faceIndexNi = parseInt( faceIndexN );\r\n\t\t\t\t\tvar indexPointerN = 3 * ( faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3 );\r\n\t\t\t\t\tvar normals = scope.rawMesh.subGroupInUse.normals;\r\n\t\t\t\t\tnormals.push( scope.normals[ indexPointerN++ ] );\r\n\t\t\t\t\tnormals.push( scope.normals[ indexPointerN++ ] );\r\n\t\t\t\t\tnormals.push( scope.normals[ indexPointerN ] );\r\n\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tif ( this.useIndices ) {\r\n\r\n\t\t\t\tvar mappingName = faceIndexV + ( faceIndexU ? '_' + faceIndexU : '_n' ) + ( faceIndexN ? '_' + faceIndexN : '_n' );\r\n\t\t\t\tvar indicesPointer = this.rawMesh.subGroupInUse.indexMappings[ mappingName ];\r\n\t\t\t\tif ( LoaderSupport.Validator.isValid( indicesPointer ) ) {\r\n\r\n\t\t\t\t\tthis.rawMesh.counts.doubleIndicesCount++;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tindicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\r\n\t\t\t\t\tupdateSubGroupInUse();\r\n\t\t\t\t\tthis.rawMesh.subGroupInUse.indexMappings[ mappingName ] = indicesPointer;\r\n\t\t\t\t\tthis.rawMesh.subGroupInUse.indexMappingsCount++;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tthis.rawMesh.subGroupInUse.indices.push( indicesPointer );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tupdateSubGroupInUse();\r\n\r\n\t\t\t}\r\n\t\t\tthis.rawMesh.counts.faceCount++;\r\n\t\t};\r\n\r\n\t\tParser.prototype.createRawMeshReport = function ( inputObjectCount ) {\r\n\t\t\treturn 'Input Object number: ' + inputObjectCount +\r\n\t\t\t\t'\\n\\tObject name: ' + this.rawMesh.objectName +\r\n\t\t\t\t'\\n\\tGroup name: ' + this.rawMesh.groupName +\r\n\t\t\t\t'\\n\\tMtllib name: ' + this.rawMesh.mtllibName +\r\n\t\t\t\t'\\n\\tVertex count: ' + this.vertices.length / 3 +\r\n\t\t\t\t'\\n\\tNormal count: ' + this.normals.length / 3 +\r\n\t\t\t\t'\\n\\tUV count: ' + this.uvs.length / 2 +\r\n\t\t\t\t'\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount +\r\n\t\t\t\t'\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount +\r\n\t\t\t\t'\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\r\n\t\t};\r\n\t\t\r\n\t\tParser.prototype.finalizeRawMesh = function () {\n\t\t\tvar this$1 = this;\n\r\n\t\t\tvar meshOutputGroupTemp = [];\r\n\t\t\tvar meshOutputGroup;\r\n\t\t\tvar absoluteVertexCount = 0;\r\n\t\t\tvar absoluteIndexMappingsCount = 0;\r\n\t\t\tvar absoluteIndexCount = 0;\r\n\t\t\tvar absoluteColorCount = 0;\r\n\t\t\tvar absoluteNormalCount = 0;\r\n\t\t\tvar absoluteUvCount = 0;\r\n\t\t\tvar indices;\r\n\t\t\tfor ( var name in this$1.rawMesh.subGroups ) {\r\n\r\n\t\t\t\tmeshOutputGroup = this$1.rawMesh.subGroups[ name ];\r\n\t\t\t\tif ( meshOutputGroup.vertices.length > 0 ) {\r\n\r\n\t\t\t\t\tindices = meshOutputGroup.indices;\r\n\t\t\t\t\tif ( indices.length > 0 && absoluteIndexMappingsCount > 0 ) {\r\n\r\n\t\t\t\t\t\tfor ( var i in indices ) { indices[ i ] = indices[ i ] + absoluteIndexMappingsCount; }\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmeshOutputGroupTemp.push( meshOutputGroup );\r\n\t\t\t\t\tabsoluteVertexCount += meshOutputGroup.vertices.length;\r\n\t\t\t\t\tabsoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\r\n\t\t\t\t\tabsoluteIndexCount += meshOutputGroup.indices.length;\r\n\t\t\t\t\tabsoluteColorCount += meshOutputGroup.colors.length;\r\n\t\t\t\t\tabsoluteUvCount += meshOutputGroup.uvs.length;\r\n\t\t\t\t\tabsoluteNormalCount += meshOutputGroup.normals.length;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// do not continue if no result\r\n\t\t\tvar result = null;\r\n\t\t\tif ( meshOutputGroupTemp.length > 0 ) {\r\n\r\n\t\t\t\tresult = {\r\n\t\t\t\t\tname: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\r\n\t\t\t\t\tsubGroups: meshOutputGroupTemp,\r\n\t\t\t\t\tabsoluteVertexCount: absoluteVertexCount,\r\n\t\t\t\t\tabsoluteIndexCount: absoluteIndexCount,\r\n\t\t\t\t\tabsoluteColorCount: absoluteColorCount,\r\n\t\t\t\t\tabsoluteNormalCount: absoluteNormalCount,\r\n\t\t\t\t\tabsoluteUvCount: absoluteUvCount,\r\n\t\t\t\t\tfaceCount: this.rawMesh.counts.faceCount,\r\n\t\t\t\t\tdoubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\tParser.prototype.processCompletedMesh = function () {\r\n\t\t\tvar result = this.finalizeRawMesh();\r\n\t\t\tif ( LoaderSupport.Validator.isValid( result ) ) {\r\n\r\n\t\t\t\tif ( this.colors.length > 0 && this.colors.length !== this.vertices.length ) {\r\n\r\n\t\t\t\t\tthis._throwError( 'Vertex Colors were detected, but vertex count and color count do not match!' );\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( this.logging.enabled && this.logging.debug ) { console.debug( this.createRawMeshReport( this.inputObjectCount ) ); }\r\n\t\t\t\tthis.inputObjectCount++;\r\n\r\n\t\t\t\tthis.buildMesh( result );\r\n\t\t\t\tvar progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\r\n\t\t\t\tthis.callbackProgress( 'Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '] Total progress: ' + ( progressBytesPercent * 100 ).toFixed( 2 ) + '%', progressBytesPercent );\r\n\t\t\t\tthis.resetRawMesh();\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tParser.prototype.buildMesh = function ( result ) {\n\t\t\tvar this$1 = this;\n\r\n\t\t\tvar meshOutputGroups = result.subGroups;\r\n\r\n\t\t\tvar vertexFA = new Float32Array( result.absoluteVertexCount );\r\n\t\t\tthis.globalCounts.vertices += result.absoluteVertexCount / 3;\r\n\t\t\tthis.globalCounts.faces += result.faceCount;\r\n\t\t\tthis.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\r\n\t\t\tvar indexUA = ( result.absoluteIndexCount > 0 ) ? new Uint32Array( result.absoluteIndexCount ) : null;\r\n\t\t\tvar colorFA = ( result.absoluteColorCount > 0 ) ? new Float32Array( result.absoluteColorCount ) : null;\r\n\t\t\tvar normalFA = ( result.absoluteNormalCount > 0 ) ? new Float32Array( result.absoluteNormalCount ) : null;\r\n\t\t\tvar uvFA = ( result.absoluteUvCount > 0 ) ? new Float32Array( result.absoluteUvCount ) : null;\r\n\t\t\tvar haveVertexColors = LoaderSupport.Validator.isValid( colorFA );\r\n\r\n\t\t\tvar meshOutputGroup;\r\n\t\t\tvar materialNames = [];\r\n\r\n\t\t\tvar createMultiMaterial = ( meshOutputGroups.length > 1 );\r\n\t\t\tvar materialIndex = 0;\r\n\t\t\tvar materialIndexMapping = [];\r\n\t\t\tvar selectedMaterialIndex;\r\n\t\t\tvar materialGroup;\r\n\t\t\tvar materialGroups = [];\r\n\r\n\t\t\tvar vertexFAOffset = 0;\r\n\t\t\tvar indexUAOffset = 0;\r\n\t\t\tvar colorFAOffset = 0;\r\n\t\t\tvar normalFAOffset = 0;\r\n\t\t\tvar uvFAOffset = 0;\r\n\t\t\tvar materialGroupOffset = 0;\r\n\t\t\tvar materialGroupLength = 0;\r\n\r\n\t\t\tvar materialOrg, material, materialName, materialNameOrg;\r\n\t\t\t// only one specific face type\r\n\t\t\tfor ( var oodIndex in meshOutputGroups ) {\r\n\r\n\t\t\t\tif ( ! meshOutputGroups.hasOwnProperty( oodIndex ) ) { continue; }\r\n\t\t\t\tmeshOutputGroup = meshOutputGroups[ oodIndex ];\r\n\r\n\t\t\t\tmaterialNameOrg = meshOutputGroup.materialName;\r\n\t\t\t\tif ( this$1.rawMesh.faceType < 4 ) {\r\n\r\n\t\t\t\t\tmaterialName = materialNameOrg + ( haveVertexColors ? '_vertexColor' : '' ) + ( meshOutputGroup.smoothingGroup === 0 ? '_flat' : '' );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterialName = this$1.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\r\n\r\n\t\t\t\t}\r\n\t\t\t\tmaterialOrg = this$1.materials[ materialNameOrg ];\r\n\t\t\t\tmaterial = this$1.materials[ materialName ];\r\n\r\n\t\t\t\t// both original and derived names do not lead to an existing material => need to use a default material\r\n\t\t\t\tif ( ! LoaderSupport.Validator.isValid( materialOrg ) && ! LoaderSupport.Validator.isValid( material ) ) {\r\n\r\n\t\t\t\t\tvar defaultMaterialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\r\n\t\t\t\t\tmaterialOrg = this$1.materials[ defaultMaterialName ];\r\n\t\t\t\t\tif ( this$1.logging.enabled ) { console.warn( 'object_group \"' + meshOutputGroup.objectName + '_' +\r\n\t\t\t\t\t\tmeshOutputGroup.groupName + '\" was defined with unresolvable material \"' +\r\n\t\t\t\t\t\tmaterialNameOrg + '\"! Assigning \"' + defaultMaterialName + '\".' ); }\r\n\t\t\t\t\tmaterialNameOrg = defaultMaterialName;\r\n\r\n\t\t\t\t\t// if names are identical then there is no need for later manipulation\r\n\t\t\t\t\tif ( materialNameOrg === materialName ) {\r\n\r\n\t\t\t\t\t\tmaterial = materialOrg;\r\n\t\t\t\t\t\tmaterialName = defaultMaterialName;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( ! LoaderSupport.Validator.isValid( material ) ) {\r\n\r\n\t\t\t\t\tvar materialCloneInstructions = {\r\n\t\t\t\t\t\tmaterialNameOrg: materialNameOrg,\r\n\t\t\t\t\t\tmaterialName: materialName,\r\n\t\t\t\t\t\tmaterialProperties: {\r\n\t\t\t\t\t\t\tvertexColors: haveVertexColors ? 2 : 0,\r\n\t\t\t\t\t\t\tflatShading: meshOutputGroup.smoothingGroup === 0\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\tvar payload = {\r\n\t\t\t\t\t\tcmd: 'materialData',\r\n\t\t\t\t\t\tmaterials: {\r\n\t\t\t\t\t\t\tmaterialCloneInstructions: materialCloneInstructions\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\tthis$1.callbackMeshBuilder( payload );\r\n\r\n\t\t\t\t\t// fake entry for async; sync Parser always works on material references (Builder update directly visible here)\r\n\t\t\t\t\tif ( this$1.useAsync ) { this$1.materials[ materialName ] = materialCloneInstructions; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( createMultiMaterial ) {\r\n\r\n\t\t\t\t\t// re-use material if already used before. Reduces materials array size and eliminates duplicates\r\n\t\t\t\t\tselectedMaterialIndex = materialIndexMapping[ materialName ];\r\n\t\t\t\t\tif ( ! selectedMaterialIndex ) {\r\n\r\n\t\t\t\t\t\tselectedMaterialIndex = materialIndex;\r\n\t\t\t\t\t\tmaterialIndexMapping[ materialName ] = materialIndex;\r\n\t\t\t\t\t\tmaterialNames.push( materialName );\r\n\t\t\t\t\t\tmaterialIndex++;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmaterialGroupLength = this$1.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\r\n\t\t\t\t\tmaterialGroup = {\r\n\t\t\t\t\t\tstart: materialGroupOffset,\r\n\t\t\t\t\t\tcount: materialGroupLength,\r\n\t\t\t\t\t\tindex: selectedMaterialIndex\r\n\t\t\t\t\t};\r\n\t\t\t\t\tmaterialGroups.push( materialGroup );\r\n\t\t\t\t\tmaterialGroupOffset += materialGroupLength;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterialNames.push( materialName );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvertexFA.set( meshOutputGroup.vertices, vertexFAOffset );\r\n\t\t\t\tvertexFAOffset += meshOutputGroup.vertices.length;\r\n\r\n\t\t\t\tif ( indexUA ) {\r\n\r\n\t\t\t\t\tindexUA.set( meshOutputGroup.indices, indexUAOffset );\r\n\t\t\t\t\tindexUAOffset += meshOutputGroup.indices.length;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( colorFA ) {\r\n\r\n\t\t\t\t\tcolorFA.set( meshOutputGroup.colors, colorFAOffset );\r\n\t\t\t\t\tcolorFAOffset += meshOutputGroup.colors.length;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( normalFA ) {\r\n\r\n\t\t\t\t\tnormalFA.set( meshOutputGroup.normals, normalFAOffset );\r\n\t\t\t\t\tnormalFAOffset += meshOutputGroup.normals.length;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( uvFA ) {\r\n\r\n\t\t\t\t\tuvFA.set( meshOutputGroup.uvs, uvFAOffset );\r\n\t\t\t\t\tuvFAOffset += meshOutputGroup.uvs.length;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( this$1.logging.enabled && this$1.logging.debug ) {\r\n\t\t\t\t\tvar materialIndexLine = LoaderSupport.Validator.isValid( selectedMaterialIndex ) ? '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex : '';\r\n\t\t\t\t\tvar createdReport = '\\tOutput Object no.: ' + this$1.outputObjectCount +\r\n\t\t\t\t\t\t'\\n\\t\\tgroupName: ' + meshOutputGroup.groupName +\r\n\t\t\t\t\t\t'\\n\\t\\tIndex: ' + meshOutputGroup.index +\r\n\t\t\t\t\t\t'\\n\\t\\tfaceType: ' + this$1.rawMesh.faceType +\r\n\t\t\t\t\t\t'\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName +\r\n\t\t\t\t\t\t'\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup +\r\n\t\t\t\t\t\tmaterialIndexLine +\r\n\t\t\t\t\t\t'\\n\\t\\tobjectName: ' + meshOutputGroup.objectName +\r\n\t\t\t\t\t\t'\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 +\r\n\t\t\t\t\t\t'\\n\\t\\t#indices: ' + meshOutputGroup.indices.length +\r\n\t\t\t\t\t\t'\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 +\r\n\t\t\t\t\t\t'\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 +\r\n\t\t\t\t\t\t'\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\r\n\t\t\t\t\tconsole.debug( createdReport );\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.outputObjectCount++;\r\n\t\t\tthis.callbackMeshBuilder(\r\n\t\t\t\t{\r\n\t\t\t\t\tcmd: 'meshData',\r\n\t\t\t\t\tprogress: {\r\n\t\t\t\t\t\tnumericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes\r\n\t\t\t\t\t},\r\n\t\t\t\t\tparams: {\r\n\t\t\t\t\t\tmeshName: result.name\r\n\t\t\t\t\t},\r\n\t\t\t\t\tmaterials: {\r\n\t\t\t\t\t\tmultiMaterial: createMultiMaterial,\r\n\t\t\t\t\t\tmaterialNames: materialNames,\r\n\t\t\t\t\t\tmaterialGroups: materialGroups\r\n\t\t\t\t\t},\r\n\t\t\t\t\tbuffers: {\r\n\t\t\t\t\t\tvertices: vertexFA,\r\n\t\t\t\t\t\tindices: indexUA,\r\n\t\t\t\t\t\tcolors: colorFA,\r\n\t\t\t\t\t\tnormals: normalFA,\r\n\t\t\t\t\t\tuvs: uvFA\r\n\t\t\t\t\t},\r\n\t\t\t\t\t// 0: mesh, 1: line, 2: point\r\n\t\t\t\t\tgeometryType: this.rawMesh.faceType < 4 ? 0 : ( this.rawMesh.faceType === 6 ) ? 2 : 1\r\n\t\t\t\t},\r\n\t\t\t\t[ vertexFA.buffer ],\r\n\t\t\t\tLoaderSupport.Validator.isValid( indexUA ) ? [ indexUA.buffer ] : null,\r\n\t\t\t\tLoaderSupport.Validator.isValid( colorFA ) ? [ colorFA.buffer ] : null,\r\n\t\t\t\tLoaderSupport.Validator.isValid( normalFA ) ? [ normalFA.buffer ] : null,\r\n\t\t\t\tLoaderSupport.Validator.isValid( uvFA ) ? [ uvFA.buffer ] : null\r\n\t\t\t);\r\n\t\t};\r\n\r\n\t\tParser.prototype.finalizeParsing = function () {\r\n\t\t\tif ( this.logging.enabled ) { console.info( 'Global output object count: ' + this.outputObjectCount ); }\r\n\t\t\tif ( this.processCompletedMesh() && this.logging.enabled ) {\r\n\r\n\t\t\t\tvar parserFinalReport = 'Overall counts: ' +\r\n\t\t\t\t\t'\\n\\tVertices: ' + this.globalCounts.vertices +\r\n\t\t\t\t\t'\\n\\tFaces: ' + this.globalCounts.faces +\r\n\t\t\t\t\t'\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\r\n\t\t\t\tconsole.info( parserFinalReport );\r\n\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\treturn Parser;\r\n\t})();\r\n\t\r\n\tOBJLoader2.prototype.loadMtl = function ( url, content, onLoad, onProgress, onError, crossOrigin, materialOptions ) {\r\n\t\tvar resource = new LoaderSupport.ResourceDescriptor( url, 'MTL' );\r\n\t\tresource.setContent( content );\r\n\t\tthis._loadMtl( resource, onLoad, onProgress, onError, crossOrigin, materialOptions );\r\n\t};\r\n\r\n\tOBJLoader2.prototype._loadMtl = function ( resource, onLoad, onProgress, onError, crossOrigin, materialOptions ) {\r\n\t\tif ( MTLLoader === undefined ) { console.error( '\"MTLLoader\" is not available. \"OBJLoader2\" requires it for loading MTL files.' ); }\r\n\t\tif ( Validator.isValid( resource ) && this.logging.enabled ) { console.time( 'Loading MTL: ' + resource.name ); }\r\n\r\n\t\tvar materials = [];\r\n\t\tvar scope = this;\r\n\t\tvar processMaterials = function ( materialCreator ) {\r\n\t\t\tvar materialCreatorMaterials = [];\r\n\t\t\tif ( Validator.isValid( materialCreator ) ) {\r\n\r\n\t\t\t\tmaterialCreator.preload();\r\n\t\t\t\tmaterialCreatorMaterials = materialCreator.materials;\r\n\t\t\t\tfor ( var materialName in materialCreatorMaterials ) {\r\n\r\n\t\t\t\t\tif ( materialCreatorMaterials.hasOwnProperty( materialName ) ) {\r\n\r\n\t\t\t\t\t\tmaterials[ materialName ] = materialCreatorMaterials[ materialName ];\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( Validator.isValid( resource ) && scope.logging.enabled ) { console.timeEnd( 'Loading MTL: ' + resource.name ); }\r\n\t\t\tonLoad( materials, materialCreator );\r\n\t\t};\r\n\r\n\t\t// fast-fail\r\n\t\tif ( ! Validator.isValid( resource ) || ( ! Validator.isValid( resource.content ) && ! Validator.isValid( resource.url ) ) ) {\r\n\r\n\t\t\tprocessMaterials();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar mtlLoader = new MTLLoader( this.manager );\r\n\t\t\tcrossOrigin = Validator.verifyInput( crossOrigin, 'anonymous' );\r\n\t\t\tmtlLoader.setCrossOrigin( crossOrigin );\r\n\t\t\tmtlLoader.setPath( resource.path );\r\n\t\t\tif ( Validator.isValid( materialOptions ) ) { mtlLoader.setMaterialOptions( materialOptions ); }\r\n\r\n\t\t\tvar parseTextWithMtlLoader = function ( content ) {\r\n\t\t\t\tvar contentAsText = content;\r\n\t\t\t\tif ( typeof( content ) !== 'string' && ! ( content instanceof String ) ) {\r\n\r\n\t\t\t\t\tif ( content.length > 0 || content.byteLength > 0 ) {\r\n\r\n\t\t\t\t\t\tcontentAsText = LoaderUtils.decodeText( content );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis._throwError( 'Unable to parse mtl as it it seems to be neither a String, an Array or an ArrayBuffer!' );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tprocessMaterials( mtlLoader.parse( contentAsText ) );\r\n\t\t\t};\r\n\r\n\t\t\tif ( Validator.isValid( resource.content ) ) {\r\n\r\n\t\t\t\tparseTextWithMtlLoader( resource.content );\r\n\r\n\t\t\t} else if ( Validator.isValid( resource.url ) ) {\r\n\r\n\t\t\t\tvar fileLoader = new FileLoader( this.manager );\r\n\t\t\t\tif ( ! Validator.isValid( onError ) ) {\r\n\t\t\t\t\tonError = function ( event ) {\r\n\t\t\t\t\t\tscope._onError( event );\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tif ( ! Validator.isValid( onProgress ) ) {\r\n\t\t\t\t\tvar numericalValueRef = 0;\r\n\t\t\t\t\tvar numericalValue = 0;\r\n\t\t\t\t\tonProgress = function ( event ) {\r\n\t\t\t\t\t\tif ( ! event.lengthComputable ) { return; }\r\n\r\n\t\t\t\t\t\tnumericalValue = event.loaded / event.total;\r\n\t\t\t\t\t\tif ( numericalValue > numericalValueRef ) {\r\n\r\n\t\t\t\t\t\t\tnumericalValueRef = numericalValue;\r\n\t\t\t\t\t\t\tvar output = 'Download of \"' + resource.url + '\": ' + ( numericalValue * 100 ).toFixed( 2 ) + '%';\r\n\t\t\t\t\t\t\tscope.onProgress( 'progressLoad', output, numericalValue );\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfileLoader.load( resource.url, parseTextWithMtlLoader, onProgress, onError );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\treturn OBJLoader2;\r\n})();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PCDLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\tthis.littleEndian = true;\r\n\r\n};\r\n\r\nPCDLoader.prototype = {\r\n\r\n\tconstructor: PCDLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( data ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( data, url ) );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow e;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( data, url ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfunction parseHeader( data ) {\r\n\r\n\t\t\tvar PCDheader = {};\r\n\t\t\tvar result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i );\r\n\t\t\tvar result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.substr( result1 - 1 ) );\r\n\r\n\t\t\tPCDheader.data = result2[ 1 ];\r\n\t\t\tPCDheader.headerLen = result2[ 0 ].length + result1;\r\n\t\t\tPCDheader.str = data.substr( 0, PCDheader.headerLen );\r\n\r\n\t\t\t// remove comments\r\n\r\n\t\t\tPCDheader.str = PCDheader.str.replace( /\\#.*/gi, '' );\r\n\r\n\t\t\t// parse\r\n\r\n\t\t\tPCDheader.version = /VERSION (.*)/i.exec( PCDheader.str );\r\n\t\t\tPCDheader.fields = /FIELDS (.*)/i.exec( PCDheader.str );\r\n\t\t\tPCDheader.size = /SIZE (.*)/i.exec( PCDheader.str );\r\n\t\t\tPCDheader.type = /TYPE (.*)/i.exec( PCDheader.str );\r\n\t\t\tPCDheader.count = /COUNT (.*)/i.exec( PCDheader.str );\r\n\t\t\tPCDheader.width = /WIDTH (.*)/i.exec( PCDheader.str );\r\n\t\t\tPCDheader.height = /HEIGHT (.*)/i.exec( PCDheader.str );\r\n\t\t\tPCDheader.viewpoint = /VIEWPOINT (.*)/i.exec( PCDheader.str );\r\n\t\t\tPCDheader.points = /POINTS (.*)/i.exec( PCDheader.str );\r\n\r\n\t\t\t// evaluate\r\n\r\n\t\t\tif ( PCDheader.version !== null )\r\n\t\t\t\t{ PCDheader.version = parseFloat( PCDheader.version[ 1 ] ); }\r\n\r\n\t\t\tif ( PCDheader.fields !== null )\r\n\t\t\t\t{ PCDheader.fields = PCDheader.fields[ 1 ].split( ' ' ); }\r\n\r\n\t\t\tif ( PCDheader.type !== null )\r\n\t\t\t\t{ PCDheader.type = PCDheader.type[ 1 ].split( ' ' ); }\r\n\r\n\t\t\tif ( PCDheader.width !== null )\r\n\t\t\t\t{ PCDheader.width = parseInt( PCDheader.width[ 1 ] ); }\r\n\r\n\t\t\tif ( PCDheader.height !== null )\r\n\t\t\t\t{ PCDheader.height = parseInt( PCDheader.height[ 1 ] ); }\r\n\r\n\t\t\tif ( PCDheader.viewpoint !== null )\r\n\t\t\t\t{ PCDheader.viewpoint = PCDheader.viewpoint[ 1 ]; }\r\n\r\n\t\t\tif ( PCDheader.points !== null )\r\n\t\t\t\t{ PCDheader.points = parseInt( PCDheader.points[ 1 ], 10 ); }\r\n\r\n\t\t\tif ( PCDheader.points === null )\r\n\t\t\t\t{ PCDheader.points = PCDheader.width * PCDheader.height; }\r\n\r\n\t\t\tif ( PCDheader.size !== null ) {\r\n\r\n\t\t\t\tPCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {\r\n\r\n\t\t\t\t\treturn parseInt( x, 10 );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( PCDheader.count !== null ) {\r\n\r\n\t\t\t\tPCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {\r\n\r\n\t\t\t\t\treturn parseInt( x, 10 );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tPCDheader.count = [];\r\n\r\n\t\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tPCDheader.count.push( 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tPCDheader.offset = {};\r\n\r\n\t\t\tvar sizeSum = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tif ( PCDheader.data === 'ascii' ) {\r\n\r\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = i;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;\r\n\t\t\t\t\tsizeSum += PCDheader.size[ i ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// for binary only\r\n\r\n\t\t\tPCDheader.rowSize = sizeSum;\r\n\r\n\t\t\treturn PCDheader;\r\n\r\n\t\t}\r\n\r\n\t\tvar textData = LoaderUtils.decodeText( data );\r\n\r\n\t\t// parse header (always ascii format)\r\n\r\n\t\tvar PCDheader = parseHeader( textData );\r\n\r\n\t\t// parse data\r\n\r\n\t\tvar position = [];\r\n\t\tvar normal = [];\r\n\t\tvar color = [];\r\n\r\n\t\t// ascii\r\n\r\n\t\tif ( PCDheader.data === 'ascii' ) {\r\n\r\n\t\t\tvar offset = PCDheader.offset;\r\n\t\t\tvar pcdData = textData.substr( PCDheader.headerLen );\r\n\t\t\tvar lines = pcdData.split( '\\n' );\r\n\r\n\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tif ( lines[ i ] === '' ) { continue; }\r\n\r\n\t\t\t\tvar line = lines[ i ].split( ' ' );\r\n\r\n\t\t\t\tif ( offset.x !== undefined ) {\r\n\r\n\t\t\t\t\tposition.push( parseFloat( line[ offset.x ] ) );\r\n\t\t\t\t\tposition.push( parseFloat( line[ offset.y ] ) );\r\n\t\t\t\t\tposition.push( parseFloat( line[ offset.z ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( offset.rgb !== undefined ) {\r\n\r\n\t\t\t\t\tvar c = new Float32Array( [ parseFloat( line[ offset.rgb ] ) ] );\r\n\t\t\t\t\tvar dataview = new DataView( c.buffer, 0 );\r\n\t\t\t\t\tcolor.push( dataview.getUint8( 0 ) / 255.0 );\r\n\t\t\t\t\tcolor.push( dataview.getUint8( 1 ) / 255.0 );\r\n\t\t\t\t\tcolor.push( dataview.getUint8( 2 ) / 255.0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( offset.normal_x !== undefined ) {\r\n\r\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_x ] ) );\r\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_y ] ) );\r\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_z ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// binary\r\n\r\n\t\tif ( PCDheader.data === 'binary_compressed' ) {\r\n\r\n\t\t\tconsole.error( 'PCDLoader: binary_compressed files are not supported' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( PCDheader.data === 'binary' ) {\r\n\r\n\t\t\tvar dataview = new DataView( data, PCDheader.headerLen );\r\n\t\t\tvar offset = PCDheader.offset;\r\n\r\n\t\t\tfor ( var i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {\r\n\r\n\t\t\t\tif ( offset.x !== undefined ) {\r\n\r\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.x, this$1.littleEndian ) );\r\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.y, this$1.littleEndian ) );\r\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.z, this$1.littleEndian ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( offset.rgb !== undefined ) {\r\n\r\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 0 ) / 255.0 );\r\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 1 ) / 255.0 );\r\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 2 ) / 255.0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( offset.normal_x !== undefined ) {\r\n\r\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_x, this$1.littleEndian ) );\r\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_y, this$1.littleEndian ) );\r\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_z, this$1.littleEndian ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n\r\n\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\tif ( position.length > 0 ) { geometry.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) ); }\r\n\t\tif ( normal.length > 0 ) { geometry.addAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) ); }\r\n\t\tif ( color.length > 0 ) { geometry.addAttribute( 'color', new Float32BufferAttribute( color, 3 ) ); }\r\n\r\n\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t// build material\r\n\r\n\t\tvar material = new PointsMaterial( { size: 0.005 } );\r\n\r\n\t\tif ( color.length > 0 ) {\r\n\r\n\t\t\tmaterial.vertexColors = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.color.setHex( Math.random() * 0xffffff );\r\n\r\n\t\t}\r\n\r\n\t\t// build mesh\r\n\r\n\t\tvar mesh = new Points( geometry, material );\r\n\t\tvar name = url.split( '' ).reverse().join( '' );\r\n\t\tname = /([^\\/]*)/.exec( name );\r\n\t\tname = name[ 1 ].split( '' ).reverse().join( '' );\r\n\t\tmesh.name = name;\r\n\r\n\t\treturn mesh;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PDBLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nPDBLoader.prototype = {\r\n\r\n\tconstructor: PDBLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\t// Based on CanvasMol PDB parser\r\n\r\n\tparse: function ( text ) {\r\n\r\n\t\tfunction trim( text ) {\r\n\r\n\t\t\treturn text.replace( /^\\s\\s*/, '' ).replace( /\\s\\s*$/, '' );\r\n\r\n\t\t}\r\n\r\n\t\tfunction capitalize( text ) {\r\n\r\n\t\t\treturn text.charAt( 0 ).toUpperCase() + text.substr( 1 ).toLowerCase();\r\n\r\n\t\t}\r\n\r\n\t\tfunction hash( s, e ) {\r\n\r\n\t\t\treturn 's' + Math.min( s, e ) + 'e' + Math.max( s, e );\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseBond( start, length ) {\r\n\r\n\t\t\tvar eatom = parseInt( lines[ i ].substr( start, length ) );\r\n\r\n\t\t\tif ( eatom ) {\r\n\r\n\t\t\t\tvar h = hash( satom, eatom );\r\n\r\n\t\t\t\tif ( bhash[ h ] === undefined ) {\r\n\r\n\t\t\t\t\tbonds.push( [ satom - 1, eatom - 1, 1 ] );\r\n\t\t\t\t\tbhash[ h ] = bonds.length - 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildGeometry() {\r\n\r\n\t\t\tvar build = {\r\n\t\t\t\tgeometryAtoms: new BufferGeometry(),\r\n\t\t\t\tgeometryBonds: new BufferGeometry(),\r\n\t\t\t\tjson: {\r\n\t\t\t\t\tatoms: atoms,\r\n\t\t\t\t\tbonds: bonds\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tvar geometryAtoms = build.geometryAtoms;\r\n\t\t\tvar geometryBonds = build.geometryBonds;\r\n\r\n\t\t\tvar i, l;\r\n\r\n\t\t\tvar verticesAtoms = [];\r\n\t\t\tvar colorsAtoms = [];\r\n\t\t\tvar verticesBonds = [];\r\n\r\n\t\t\t// atoms\r\n\r\n\t\t\tfor ( i = 0, l = atoms.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar atom = atoms[ i ];\r\n\r\n\t\t\t\tvar x = atom[ 0 ];\r\n\t\t\t\tvar y = atom[ 1 ];\r\n\t\t\t\tvar z = atom[ 2 ];\r\n\r\n\t\t\t\tverticesAtoms.push( x, y, z );\r\n\r\n\t\t\t\tvar r = atom[ 3 ][ 0 ] / 255;\r\n\t\t\t\tvar g = atom[ 3 ][ 1 ] / 255;\r\n\t\t\t\tvar b = atom[ 3 ][ 2 ] / 255;\r\n\r\n\t\t\t\tcolorsAtoms.push( r, g, b );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// bonds\r\n\r\n\t\t\tfor ( i = 0, l = bonds.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar bond = bonds[ i ];\r\n\r\n\t\t\t\tvar start = bond[ 0 ];\r\n\t\t\t\tvar end = bond[ 1 ];\r\n\r\n\t\t\t\tverticesBonds.push( verticesAtoms[ ( start * 3 ) + 0 ] );\r\n\t\t\t\tverticesBonds.push( verticesAtoms[ ( start * 3 ) + 1 ] );\r\n\t\t\t\tverticesBonds.push( verticesAtoms[ ( start * 3 ) + 2 ] );\r\n\r\n\t\t\t\tverticesBonds.push( verticesAtoms[ ( end * 3 ) + 0 ] );\r\n\t\t\t\tverticesBonds.push( verticesAtoms[ ( end * 3 ) + 1 ] );\r\n\t\t\t\tverticesBonds.push( verticesAtoms[ ( end * 3 ) + 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// build geometry\r\n\r\n\t\t\tgeometryAtoms.addAttribute( 'position', new Float32BufferAttribute( verticesAtoms, 3 ) );\r\n\t\t\tgeometryAtoms.addAttribute( 'color', new Float32BufferAttribute( colorsAtoms, 3 ) );\r\n\r\n\t\t\tgeometryBonds.addAttribute( 'position', new Float32BufferAttribute( verticesBonds, 3 ) );\r\n\r\n\t\t\treturn build;\r\n\r\n\t\t}\r\n\r\n\t\tvar CPK = { h: [ 255, 255, 255 ], he: [ 217, 255, 255 ], li: [ 204, 128, 255 ], be: [ 194, 255, 0 ], b: [ 255, 181, 181 ], c: [ 144, 144, 144 ], n: [ 48, 80, 248 ], o: [ 255, 13, 13 ], f: [ 144, 224, 80 ], ne: [ 179, 227, 245 ], na: [ 171, 92, 242 ], mg: [ 138, 255, 0 ], al: [ 191, 166, 166 ], si: [ 240, 200, 160 ], p: [ 255, 128, 0 ], s: [ 255, 255, 48 ], cl: [ 31, 240, 31 ], ar: [ 128, 209, 227 ], k: [ 143, 64, 212 ], ca: [ 61, 255, 0 ], sc: [ 230, 230, 230 ], ti: [ 191, 194, 199 ], v: [ 166, 166, 171 ], cr: [ 138, 153, 199 ], mn: [ 156, 122, 199 ], fe: [ 224, 102, 51 ], co: [ 240, 144, 160 ], ni: [ 80, 208, 80 ], cu: [ 200, 128, 51 ], zn: [ 125, 128, 176 ], ga: [ 194, 143, 143 ], ge: [ 102, 143, 143 ], as: [ 189, 128, 227 ], se: [ 255, 161, 0 ], br: [ 166, 41, 41 ], kr: [ 92, 184, 209 ], rb: [ 112, 46, 176 ], sr: [ 0, 255, 0 ], y: [ 148, 255, 255 ], zr: [ 148, 224, 224 ], nb: [ 115, 194, 201 ], mo: [ 84, 181, 181 ], tc: [ 59, 158, 158 ], ru: [ 36, 143, 143 ], rh: [ 10, 125, 140 ], pd: [ 0, 105, 133 ], ag: [ 192, 192, 192 ], cd: [ 255, 217, 143 ], in: [ 166, 117, 115 ], sn: [ 102, 128, 128 ], sb: [ 158, 99, 181 ], te: [ 212, 122, 0 ], i: [ 148, 0, 148 ], xe: [ 66, 158, 176 ], cs: [ 87, 23, 143 ], ba: [ 0, 201, 0 ], la: [ 112, 212, 255 ], ce: [ 255, 255, 199 ], pr: [ 217, 255, 199 ], nd: [ 199, 255, 199 ], pm: [ 163, 255, 199 ], sm: [ 143, 255, 199 ], eu: [ 97, 255, 199 ], gd: [ 69, 255, 199 ], tb: [ 48, 255, 199 ], dy: [ 31, 255, 199 ], ho: [ 0, 255, 156 ], er: [ 0, 230, 117 ], tm: [ 0, 212, 82 ], yb: [ 0, 191, 56 ], lu: [ 0, 171, 36 ], hf: [ 77, 194, 255 ], ta: [ 77, 166, 255 ], w: [ 33, 148, 214 ], re: [ 38, 125, 171 ], os: [ 38, 102, 150 ], ir: [ 23, 84, 135 ], pt: [ 208, 208, 224 ], au: [ 255, 209, 35 ], hg: [ 184, 184, 208 ], tl: [ 166, 84, 77 ], pb: [ 87, 89, 97 ], bi: [ 158, 79, 181 ], po: [ 171, 92, 0 ], at: [ 117, 79, 69 ], rn: [ 66, 130, 150 ], fr: [ 66, 0, 102 ], ra: [ 0, 125, 0 ], ac: [ 112, 171, 250 ], th: [ 0, 186, 255 ], pa: [ 0, 161, 255 ], u: [ 0, 143, 255 ], np: [ 0, 128, 255 ], pu: [ 0, 107, 255 ], am: [ 84, 92, 242 ], cm: [ 120, 92, 227 ], bk: [ 138, 79, 227 ], cf: [ 161, 54, 212 ], es: [ 179, 31, 212 ], fm: [ 179, 31, 186 ], md: [ 179, 13, 166 ], no: [ 189, 13, 135 ], lr: [ 199, 0, 102 ], rf: [ 204, 0, 89 ], db: [ 209, 0, 79 ], sg: [ 217, 0, 69 ], bh: [ 224, 0, 56 ], hs: [ 230, 0, 46 ], mt: [ 235, 0, 38 ], ds: [ 235, 0, 38 ], rg: [ 235, 0, 38 ], cn: [ 235, 0, 38 ], uut: [ 235, 0, 38 ], uuq: [ 235, 0, 38 ], uup: [ 235, 0, 38 ], uuh: [ 235, 0, 38 ], uus: [ 235, 0, 38 ], uuo: [ 235, 0, 38 ] };\r\n\r\n\t\tvar atoms = [];\r\n\t\tvar bonds = [];\r\n\r\n\t\tvar bhash = {};\r\n\r\n\t\tvar x, y, z, index, e;\r\n\r\n\t\t// parse\r\n\r\n\t\tvar lines = text.split( '\\n' );\r\n\r\n\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( lines[ i ].substr( 0, 4 ) === 'ATOM' || lines[ i ].substr( 0, 6 ) === 'HETATM' ) {\r\n\r\n\t\t\t\tx = parseFloat( lines[ i ].substr( 30, 7 ) );\r\n\t\t\t\ty = parseFloat( lines[ i ].substr( 38, 7 ) );\r\n\t\t\t\tz = parseFloat( lines[ i ].substr( 46, 7 ) );\r\n\t\t\t\tindex = parseInt( lines[ i ].substr( 6, 5 ) ) - 1;\r\n\r\n\t\t\t\te = trim( lines[ i ].substr( 76, 2 ) ).toLowerCase();\r\n\r\n\t\t\t\tif ( e === '' ) {\r\n\r\n\t\t\t\t\te = trim( lines[ i ].substr( 12, 2 ) ).toLowerCase();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tatoms[ index ] = [ x, y, z, CPK[ e ], capitalize( e ) ];\r\n\r\n\t\t\t} else if ( lines[ i ].substr( 0, 6 ) === 'CONECT' ) {\r\n\r\n\t\t\t\tvar satom = parseInt( lines[ i ].substr( 6, 5 ) );\r\n\r\n\t\t\t\tparseBond( 11, 5 );\r\n\t\t\t\tparseBond( 16, 5 );\r\n\t\t\t\tparseBond( 21, 5 );\r\n\t\t\t\tparseBond( 26, 5 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// build and return geometry\r\n\r\n\t\treturn buildGeometry();\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PlayCanvasLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nPlayCanvasLoader.prototype = {\r\n\r\n\tconstructor: PlayCanvasLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tfunction parseVertices( data ) {\r\n\r\n\t\t\tvar attributes = {};\r\n\r\n\t\t\t// create a buffer attribute for each array that contains vertex information\r\n\r\n\t\t\tfor ( var name in data ) {\r\n\r\n\t\t\t\tvar array = data[ name ];\r\n\r\n\t\t\t\tvar type = array.type;\r\n\t\t\t\tvar size = array.components;\r\n\r\n\t\t\t\tvar attribute;\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\tcase 'float32':\r\n\t\t\t\t\t\tattribute = new Float32BufferAttribute( array.data, size );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'uint8':\r\n\t\t\t\t\t\tattribute = new Uint8BufferAttribute( array.data, size );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'uint16':\r\n\t\t\t\t\t\tattribute = new Uint16BufferAttribute( array.data, size );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.log( 'PlayCanvasLoader: Array type \"%s\" not yet supported.', type );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tattributes[ name ] = attribute;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdata._attributes = attributes;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseMeshes( data ) {\r\n\r\n\t\t\t// create buffer geometry\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\tgeometry.setIndex( data.indices );\r\n\r\n\t\t\tvar attributes = model.vertices[ data.vertices ]._attributes;\r\n\r\n\t\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\t\tvar attribute = attributes[ name ];\r\n\r\n\t\t\t\tif ( name === 'texCoord0' ) { name = 'uv'; }\r\n\r\n\t\t\t\tgeometry.addAttribute( name, attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdata._geometry = geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseMeshInstances( data ) {\r\n\r\n\t\t\tvar node = model.nodes[ data.node ];\r\n\t\t\tvar mesh = model.meshes[ data.mesh ];\r\n\r\n\t\t\tif ( node._geometries === undefined ) {\r\n\r\n\t\t\t\tnode._geometries = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnode._geometries.push( mesh._geometry );\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseNodes( data ) {\r\n\r\n\t\t\tvar object = new Group();\r\n\r\n\t\t\tvar geometries = data._geometries;\r\n\r\n\t\t\tif ( geometries !== undefined ) {\r\n\r\n\t\t\t\tvar material = new MeshPhongMaterial();\r\n\r\n\t\t\t\tfor ( var i = 0, l = geometries.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar geometry = geometries[ i ];\r\n\r\n\t\t\t\t\tobject.add( new Mesh( geometry, material ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, l = data.rotation.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tdata.rotation[ i ] *= Math.PI / 180;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tobject.name = data.name;\r\n\r\n\t\t\tobject.position.fromArray( data.position );\r\n\t\t\tobject.quaternion.setFromEuler( new Euler().fromArray( data.rotation ) );\r\n\t\t\tobject.scale.fromArray( data.scale );\r\n\r\n\t\t\tdata._object = object;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar model = json.model;\r\n\r\n\t\tfor ( var i = 0, l = model.vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\tparseVertices( model.vertices[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = model.meshes.length; i < l; i ++ ) {\r\n\r\n\t\t\tparseMeshes( model.meshes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = model.meshInstances.length; i < l; i ++ ) {\r\n\r\n\t\t\tparseMeshInstances( model.meshInstances[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = model.nodes.length; i < l; i ++ ) {\r\n\r\n\t\t\tparseNodes( model.nodes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// setup scene hierarchy\r\n\r\n\t\tfor ( var i = 0, l = model.parents.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar parent = model.parents[ i ];\r\n\r\n\t\t\tif ( parent === - 1 ) { continue; }\r\n\r\n\t\t\tmodel.nodes[ parent ]._object.add( model.nodes[ i ]._object );\r\n\r\n\t\t}\r\n\r\n\t\treturn model.nodes[ 0 ]._object;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PLYLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\tthis.propertyNameMapping = {};\r\n\r\n};\r\n\r\nPLYLoader.prototype = {\r\n\r\n\tconstructor: PLYLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetPropertyNameMapping: function ( mapping ) {\r\n\r\n\t\tthis.propertyNameMapping = mapping;\r\n\r\n\t},\r\n\r\n\tparse: function ( data ) {\r\n\r\n\t\tfunction parseHeader( data ) {\r\n\r\n\t\t\tvar patternHeader = /ply([\\s\\S]*)end_header\\s/;\r\n\t\t\tvar headerText = '';\r\n\t\t\tvar headerLength = 0;\r\n\t\t\tvar result = patternHeader.exec( data );\r\n\r\n\t\t\tif ( result !== null ) {\r\n\r\n\t\t\t\theaderText = result[ 1 ];\r\n\t\t\t\theaderLength = result[ 0 ].length;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar header = {\r\n\t\t\t\tcomments: [],\r\n\t\t\t\telements: [],\r\n\t\t\t\theaderLength: headerLength\r\n\t\t\t};\r\n\r\n\t\t\tvar lines = headerText.split( '\\n' );\r\n\t\t\tvar currentElement;\r\n\t\t\tvar lineType, lineValues;\r\n\r\n\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\r\n\r\n\t\t\t\tvar property = { type: propertValues[ 0 ] };\r\n\r\n\t\t\t\tif ( property.type === 'list' ) {\r\n\r\n\t\t\t\t\tproperty.name = propertValues[ 3 ];\r\n\t\t\t\t\tproperty.countType = propertValues[ 1 ];\r\n\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tproperty.name = propertValues[ 1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( property.name in propertyNameMapping ) {\r\n\r\n\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn property;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\t\tvar line = lines[ i ];\r\n\t\t\t\tline = line.trim();\r\n\r\n\t\t\t\tif ( line === '' ) { continue; }\r\n\r\n\t\t\t\tlineValues = line.split( /\\s+/ );\r\n\t\t\t\tlineType = lineValues.shift();\r\n\t\t\t\tline = lineValues.join( ' ' );\r\n\r\n\t\t\t\tswitch ( lineType ) {\r\n\r\n\t\t\t\t\tcase 'format':\r\n\r\n\t\t\t\t\t\theader.format = lineValues[ 0 ];\r\n\t\t\t\t\t\theader.version = lineValues[ 1 ];\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'comment':\r\n\r\n\t\t\t\t\t\theader.comments.push( line );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'element':\r\n\r\n\t\t\t\t\t\tif ( currentElement !== undefined ) {\r\n\r\n\t\t\t\t\t\t\theader.elements.push( currentElement );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcurrentElement = {};\r\n\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\r\n\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\r\n\t\t\t\t\t\tcurrentElement.properties = [];\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'property':\r\n\r\n\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( currentElement !== undefined ) {\r\n\r\n\t\t\t\theader.elements.push( currentElement );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn header;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseASCIINumber( n, type ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\r\n\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\r\n\r\n\t\t\t\t\treturn parseInt( n );\r\n\r\n\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\r\n\r\n\t\t\t\t\treturn parseFloat( n );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseASCIIElement( properties, line ) {\r\n\r\n\t\t\tvar values = line.split( /\\s+/ );\r\n\r\n\t\t\tvar element = {};\r\n\r\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\r\n\r\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\r\n\r\n\t\t\t\t\tvar list = [];\r\n\t\t\t\t\tvar n = parseASCIINumber( values.shift(), properties[ i ].countType );\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\r\n\r\n\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\telement[ properties[ i ].name ] = list;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn element;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseASCII( data, header ) {\r\n\r\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\r\n\r\n\t\t\tvar buffer = {\r\n\t\t\t\tindices: [],\r\n\t\t\t\tvertices: [],\r\n\t\t\t\tnormals: [],\r\n\t\t\t\tuvs: [],\r\n\t\t\t\tcolors: []\r\n\t\t\t};\r\n\r\n\t\t\tvar result;\r\n\r\n\t\t\tvar patternBody = /end_header\\s([\\s\\S]*)$/;\r\n\t\t\tvar body = '';\r\n\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\r\n\r\n\t\t\t\tbody = result[ 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar lines = body.split( '\\n' );\r\n\t\t\tvar currentElement = 0;\r\n\t\t\tvar currentElementCount = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\t\tvar line = lines[ i ];\r\n\t\t\t\tline = line.trim();\r\n\t\t\t\tif ( line === '' ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\r\n\r\n\t\t\t\t\tcurrentElement ++;\r\n\t\t\t\t\tcurrentElementCount = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar element = parseASCIIElement( header.elements[ currentElement ].properties, line );\r\n\r\n\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\r\n\r\n\t\t\t\tcurrentElementCount ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn postProcess( buffer );\r\n\r\n\t\t}\r\n\r\n\t\tfunction postProcess( buffer ) {\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\t// mandatory buffer data\r\n\r\n\t\t\tif ( buffer.indices.length > 0 ) {\r\n\r\n\t\t\t\tgeometry.setIndex( buffer.indices );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( buffer.vertices, 3 ) );\r\n\r\n\t\t\t// optional buffer data\r\n\r\n\t\t\tif ( buffer.normals.length > 0 ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'normal', new Float32BufferAttribute( buffer.normals, 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( buffer.uvs.length > 0 ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'uv', new Float32BufferAttribute( buffer.uvs, 2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( buffer.colors.length > 0 ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( buffer.colors, 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction handleElement( buffer, elementName, element ) {\r\n\r\n\t\t\tif ( elementName === 'vertex' ) {\r\n\r\n\t\t\t\tbuffer.vertices.push( element.x, element.y, element.z );\r\n\r\n\t\t\t\tif ( 'nx' in element && 'ny' in element && 'nz' in element ) {\r\n\r\n\t\t\t\t\tbuffer.normals.push( element.nx, element.ny, element.nz );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( 's' in element && 't' in element ) {\r\n\r\n\t\t\t\t\tbuffer.uvs.push( element.s, element.t );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( 'red' in element && 'green' in element && 'blue' in element ) {\r\n\r\n\t\t\t\t\tbuffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( elementName === 'face' ) {\r\n\r\n\t\t\t\tvar vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\r\n\r\n\t\t\t\tif ( vertex_indices.length === 3 ) {\r\n\r\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\r\n\r\n\t\t\t\t} else if ( vertex_indices.length === 4 ) {\r\n\r\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\r\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction binaryRead( dataview, at, type, little_endian ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t// corespondences for non-specific length types here match rply:\r\n\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\r\n\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\r\n\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\r\n\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\r\n\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\r\n\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\r\n\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\r\n\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\r\n\r\n\t\t\tvar element = {};\r\n\t\t\tvar result, read = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\r\n\r\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\r\n\r\n\t\t\t\t\tvar list = [];\r\n\r\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\r\n\t\t\t\t\tvar n = result[ 0 ];\r\n\t\t\t\t\tread += result[ 1 ];\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\r\n\r\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\r\n\t\t\t\t\t\tlist.push( result[ 0 ] );\r\n\t\t\t\t\t\tread += result[ 1 ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\telement[ properties[ i ].name ] = list;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\r\n\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\r\n\t\t\t\t\tread += result[ 1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn [ element, read ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseBinary( data, header ) {\r\n\r\n\t\t\tvar buffer = {\r\n\t\t\t\tindices: [],\r\n\t\t\t\tvertices: [],\r\n\t\t\t\tnormals: [],\r\n\t\t\t\tuvs: [],\r\n\t\t\t\tcolors: []\r\n\t\t\t};\r\n\r\n\t\t\tvar little_endian = ( header.format === 'binary_little_endian' );\r\n\t\t\tvar body = new DataView( data, header.headerLength );\r\n\t\t\tvar result, loc = 0;\r\n\r\n\t\t\tfor ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\r\n\r\n\t\t\t\tfor ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\r\n\r\n\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\r\n\t\t\t\t\tloc += result[ 1 ];\r\n\t\t\t\t\tvar element = result[ 0 ];\r\n\r\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn postProcess( buffer );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar geometry;\r\n\t\tvar scope = this;\r\n\r\n\t\tif ( data instanceof ArrayBuffer ) {\r\n\r\n\t\t\tvar text = LoaderUtils.decodeText( new Uint8Array( data ) );\r\n\t\t\tvar header = parseHeader( text );\r\n\r\n\t\t\tgeometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\tvar bigEndianPlatform = null;\r\n\t\r\n\tfunction isBigEndianPlatform() {\r\n\r\n\t\tif ( bigEndianPlatform === null ) {\r\n\r\n\t\t\tvar buffer = new ArrayBuffer( 2 ),\r\n\t\t\t\tuint8Array = new Uint8Array( buffer ),\r\n\t\t\t\tuint16Array = new Uint16Array( buffer );\r\n\r\n\t\t\tuint8Array[ 0 ] = 0xAA; // set first byte\r\n\t\t\tuint8Array[ 1 ] = 0xBB; // set second byte\r\n\t\t\tbigEndianPlatform = ( uint16Array[ 0 ] === 0xAABB );\r\n\r\n\t\t}\r\n\r\n\t\treturn bigEndianPlatform;\r\n\r\n\t}\r\n\r\n\t// match the values defined in the spec to the TypedArray types\r\n\tvar InvertedEncodingTypes = [\r\n\t\tnull,\r\n\t\tFloat32Array,\r\n\t\tnull,\r\n\t\tInt8Array,\r\n\t\tInt16Array,\r\n\t\tnull,\r\n\t\tInt32Array,\r\n\t\tUint8Array,\r\n\t\tUint16Array,\r\n\t\tnull,\r\n\t\tUint32Array\r\n\t];\r\n\r\n\t// define the method to use on a DataView, corresponding the TypedArray type\r\n\tvar getMethods = {\r\n\t\tUint16Array: 'getUint16',\r\n\t\tUint32Array: 'getUint32',\r\n\t\tInt16Array: 'getInt16',\r\n\t\tInt32Array: 'getInt32',\r\n\t\tFloat32Array: 'getFloat32',\r\n\t\tFloat64Array: 'getFloat64'\r\n\t};\r\n\r\n\tfunction copyFromBuffer( sourceArrayBuffer, viewType, position, length, fromBigEndian ) {\r\n\r\n\t\tvar bytesPerElement = viewType.BYTES_PER_ELEMENT,\r\n\t\t\tresult;\r\n\r\n\t\tif ( fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1 ) {\r\n\r\n\t\t\tresult = new viewType( sourceArrayBuffer, position, length );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar readView = new DataView( sourceArrayBuffer, position, length * bytesPerElement ),\r\n\t\t\t\tgetMethod = getMethods[ viewType.name ],\r\n\t\t\t\tlittleEndian = ! fromBigEndian,\r\n\t\t\t\ti = 0;\r\n\r\n\t\t\tresult = new viewType( length );\r\n\r\n\t\t\tfor ( ; i < length; i ++ ) {\r\n\r\n\t\t\t\tresult[ i ] = readView[ getMethod ]( i * bytesPerElement, littleEndian );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tfunction decodePrwm( buffer ) {\r\n\r\n\t\tvar array = new Uint8Array( buffer ),\r\n\t\t\tversion = array[ 0 ],\r\n\t\t\tflags = array[ 1 ],\r\n\t\t\tindexedGeometry = !! ( flags >> 7 & 0x01 ),\r\n\t\t\tindicesType = flags >> 6 & 0x01,\r\n\t\t\tbigEndian = ( flags >> 5 & 0x01 ) === 1,\r\n\t\t\tattributesNumber = flags & 0x1F,\r\n\t\t\tvaluesNumber = 0,\r\n\t\t\tindicesNumber = 0;\r\n\r\n\t\tif ( bigEndian ) {\r\n\r\n\t\t\tvaluesNumber = ( array[ 2 ] << 16 ) + ( array[ 3 ] << 8 ) + array[ 4 ];\r\n\t\t\tindicesNumber = ( array[ 5 ] << 16 ) + ( array[ 6 ] << 8 ) + array[ 7 ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvaluesNumber = array[ 2 ] + ( array[ 3 ] << 8 ) + ( array[ 4 ] << 16 );\r\n\t\t\tindicesNumber = array[ 5 ] + ( array[ 6 ] << 8 ) + ( array[ 7 ] << 16 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( version === 0 ) {\r\n\r\n\t\t\tthrow new Error( 'PRWM decoder: Invalid format version: 0' );\r\n\r\n\t\t} else if ( version !== 1 ) {\r\n\r\n\t\t\tthrow new Error( 'PRWM decoder: Unsupported format version: ' + version );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! indexedGeometry ) {\r\n\r\n\t\t\tif ( indicesType !== 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'PRWM decoder: Indices type must be set to 0 for non-indexed geometries' );\r\n\r\n\t\t\t} else if ( indicesNumber !== 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'PRWM decoder: Number of indices must be set to 0 for non-indexed geometries' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar pos = 8;\r\n\r\n\t\tvar attributes = {},\r\n\t\t\tattributeName,\r\n\t\t\tchar,\r\n\t\t\tattributeType,\r\n\t\t\tcardinality,\r\n\t\t\tencodingType,\r\n\t\t\tarrayType,\r\n\t\t\tvalues,\r\n\t\t\tindices,\r\n\t\t\ti;\r\n\r\n\t\tfor ( i = 0; i < attributesNumber; i ++ ) {\r\n\r\n\t\t\tattributeName = '';\r\n\r\n\t\t\twhile ( pos < array.length ) {\r\n\r\n\t\t\t\tchar = array[ pos ];\r\n\t\t\t\tpos ++;\r\n\r\n\t\t\t\tif ( char === 0 ) {\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tattributeName += String.fromCharCode( char );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tflags = array[ pos ];\r\n\r\n\t\t\tattributeType = flags >> 7 & 0x01;\r\n\t\t\tcardinality = ( flags >> 4 & 0x03 ) + 1;\r\n\t\t\tencodingType = flags & 0x0F;\r\n\t\t\tarrayType = InvertedEncodingTypes[ encodingType ];\r\n\r\n\t\t\tpos ++;\r\n\r\n\t\t\t// padding to next multiple of 4\r\n\t\t\tpos = Math.ceil( pos / 4 ) * 4;\r\n\r\n\t\t\tvalues = copyFromBuffer( buffer, arrayType, pos, cardinality * valuesNumber, bigEndian );\r\n\r\n\t\t\tpos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\r\n\r\n\t\t\tattributes[ attributeName ] = {\r\n\t\t\t\ttype: attributeType,\r\n\t\t\t\tcardinality: cardinality,\r\n\t\t\t\tvalues: values\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tpos = Math.ceil( pos / 4 ) * 4;\r\n\r\n\t\tindices = null;\r\n\r\n\t\tif ( indexedGeometry ) {\r\n\r\n\t\t\tindices = copyFromBuffer(\r\n\t\t\t\tbuffer,\r\n\t\t\t\tindicesType === 1 ? Uint32Array : Uint16Array,\r\n\t\t\t\tpos,\r\n\t\t\t\tindicesNumber,\r\n\t\t\t\tbigEndian\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tversion: version,\r\n\t\t\tattributes: attributes,\r\n\t\t\tindices: indices\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t// Define the public interface\r\n\r\n\tvar PRWMLoader = function PRWMLoader( manager ) {\r\n\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n\t};\r\n\r\n\tPRWMLoader.prototype = {\r\n\r\n\t\tconstructor: PRWMLoader,\r\n\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tvar loader = new FileLoader( scope.manager );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\t\turl = url.replace( /\\*/g, isBigEndianPlatform() ? 'be' : 'le' );\r\n\r\n\t\t\tloader.load( url, function ( arrayBuffer ) {\r\n\r\n\t\t\t\tonLoad( scope.parse( arrayBuffer ) );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( arrayBuffer ) {\r\n\r\n\t\t\tconsole.time( 'PRWMLoader' );\r\n\r\n\t\t\tvar data = decodePrwm( arrayBuffer ),\r\n\t\t\t\tattributesKey = Object.keys( data.attributes ),\r\n\t\t\t\tbufferGeometry = new BufferGeometry(),\r\n\t\t\t\tattribute,\r\n\t\t\t\ti;\r\n\r\n\t\t\tfor ( i = 0; i < attributesKey.length; i ++ ) {\r\n\r\n\t\t\t\tattribute = data.attributes[ attributesKey[ i ] ];\r\n\t\t\t\tbufferGeometry.addAttribute( attributesKey[ i ], new BufferAttribute( attribute.values, attribute.cardinality, attribute.normalized ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.indices !== null ) {\r\n\r\n\t\t\t\tbufferGeometry.setIndex( new BufferAttribute( data.indices, 1 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.timeEnd( 'PRWMLoader' );\r\n\r\n\t\t\treturn bufferGeometry;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tPRWMLoader.isBigEndianPlatform = function () {\r\n\r\n\t\treturn isBigEndianPlatform();\r\n\r\n\t};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PVRLoader = function ( manager ) {\r\n\r\n\tCompressedTextureLoader.call( this, manager );\r\n\r\n\tthis._parser = PVRLoader.parse;\r\n\r\n};\r\n\r\nPVRLoader.prototype = Object.create( CompressedTextureLoader.prototype );\r\nPVRLoader.prototype.constructor = PVRLoader;\r\n\r\nPVRLoader.parse = function ( buffer, loadMipmaps ) {\r\n\r\n\tvar headerLengthInt = 13;\r\n\tvar header = new Uint32Array( buffer, 0, headerLengthInt );\r\n\r\n\tvar pvrDatas = {\r\n\t\tbuffer: buffer,\r\n\t\theader: header,\r\n\t\tloadMipmaps: loadMipmaps\r\n\t};\r\n\r\n\tif ( header[ 0 ] === 0x03525650 ) {\r\n\r\n\t\t// PVR v3\r\n\r\n\t\treturn PVRLoader._parseV3( pvrDatas );\r\n\r\n\t} else if ( header[ 11 ] === 0x21525650 ) {\r\n\r\n\t\t// PVR v2\r\n\r\n\t\treturn PVRLoader._parseV2( pvrDatas );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.error( 'PVRLoader: Unknown PVR format.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nPVRLoader._parseV3 = function ( pvrDatas ) {\r\n\r\n\tvar header = pvrDatas.header;\r\n\tvar bpp, format;\r\n\r\n\tvar metaLen = header[ 12 ],\r\n\t\tpixelFormat = header[ 2 ],\r\n\t\theight = header[ 6 ],\r\n\t\twidth = header[ 7 ],\r\n\t\t// numSurfs = header[ 9 ],\r\n\t\tnumFaces = header[ 10 ],\r\n\t\tnumMipmaps = header[ 11 ];\r\n\r\n\tswitch ( pixelFormat ) {\r\n\r\n\t\tcase 0 : // PVRTC 2bpp RGB\r\n\t\t\tbpp = 2;\r\n\t\t\tformat = RGB_PVRTC_2BPPV1_Format;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 1 : // PVRTC 2bpp RGBA\r\n\t\t\tbpp = 2;\r\n\t\t\tformat = RGBA_PVRTC_2BPPV1_Format;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 2 : // PVRTC 4bpp RGB\r\n\t\t\tbpp = 4;\r\n\t\t\tformat = RGB_PVRTC_4BPPV1_Format;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 3 : // PVRTC 4bpp RGBA\r\n\t\t\tbpp = 4;\r\n\t\t\tformat = RGBA_PVRTC_4BPPV1_Format;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault :\r\n\t\t\tconsole.error( 'PVRLoader: Unsupported PVR format:', pixelFormat );\r\n\r\n\t}\r\n\r\n\tpvrDatas.dataPtr = 52 + metaLen;\r\n\tpvrDatas.bpp = bpp;\r\n\tpvrDatas.format = format;\r\n\tpvrDatas.width = width;\r\n\tpvrDatas.height = height;\r\n\tpvrDatas.numSurfaces = numFaces;\r\n\tpvrDatas.numMipmaps = numMipmaps;\r\n\tpvrDatas.isCubemap \t= ( numFaces === 6 );\r\n\r\n\treturn PVRLoader._extract( pvrDatas );\r\n\r\n};\r\n\r\nPVRLoader._parseV2 = function ( pvrDatas ) {\r\n\r\n\tvar header = pvrDatas.header;\r\n\r\n\tvar headerLength = header[ 0 ],\r\n\t\theight = header[ 1 ],\r\n\t\twidth = header[ 2 ],\r\n\t\tnumMipmaps = header[ 3 ],\r\n\t\tflags = header[ 4 ],\r\n\t\t// dataLength = header[ 5 ],\r\n\t\t// bpp =  header[ 6 ],\r\n\t\t// bitmaskRed = header[ 7 ],\r\n\t\t// bitmaskGreen = header[ 8 ],\r\n\t\t// bitmaskBlue = header[ 9 ],\r\n\t\tbitmaskAlpha = header[ 10 ],\r\n\t\t// pvrTag = header[ 11 ],\r\n\t\tnumSurfs = header[ 12 ];\r\n\r\n\tvar TYPE_MASK = 0xff;\r\n\tvar PVRTC_2 = 24,\r\n\t\tPVRTC_4 = 25;\r\n\r\n\tvar formatFlags = flags & TYPE_MASK;\r\n\r\n\tvar bpp, format;\r\n\tvar _hasAlpha = bitmaskAlpha > 0;\r\n\r\n\tif ( formatFlags === PVRTC_4 ) {\r\n\r\n\t\tformat = _hasAlpha ? RGBA_PVRTC_4BPPV1_Format : RGB_PVRTC_4BPPV1_Format;\r\n\t\tbpp = 4;\r\n\r\n\t} else if ( formatFlags === PVRTC_2 ) {\r\n\r\n\t\tformat = _hasAlpha ? RGBA_PVRTC_2BPPV1_Format : RGB_PVRTC_2BPPV1_Format;\r\n\t\tbpp = 2;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.error( 'PVRLoader: Unknown PVR format:', formatFlags );\r\n\r\n\t}\r\n\r\n\tpvrDatas.dataPtr = headerLength;\r\n\tpvrDatas.bpp = bpp;\r\n\tpvrDatas.format = format;\r\n\tpvrDatas.width = width;\r\n\tpvrDatas.height = height;\r\n\tpvrDatas.numSurfaces = numSurfs;\r\n\tpvrDatas.numMipmaps = numMipmaps + 1;\r\n\r\n\t// guess cubemap type seems tricky in v2\r\n\t// it juste a pvr containing 6 surface (no explicit cubemap type)\r\n\tpvrDatas.isCubemap \t= ( numSurfs === 6 );\r\n\r\n\treturn PVRLoader._extract( pvrDatas );\r\n\r\n};\r\n\r\nPVRLoader._extract = function ( pvrDatas ) {\r\n\r\n\tvar pvr = {\r\n\t\tmipmaps: [],\r\n\t\twidth: pvrDatas.width,\r\n\t\theight: pvrDatas.height,\r\n\t\tformat: pvrDatas.format,\r\n\t\tmipmapCount: pvrDatas.numMipmaps,\r\n\t\tisCubemap: pvrDatas.isCubemap\r\n\t};\r\n\r\n\tvar buffer = pvrDatas.buffer;\r\n\r\n\tvar dataOffset = pvrDatas.dataPtr,\r\n\t\tbpp = pvrDatas.bpp,\r\n\t\tnumSurfs = pvrDatas.numSurfaces,\r\n\t\tdataSize = 0,\r\n\t\tblockSize = 0,\r\n\t\tblockWidth = 0,\r\n\t\tblockHeight = 0,\r\n\t\twidthBlocks = 0,\r\n\t\theightBlocks = 0;\r\n\r\n\tif ( bpp === 2 ) {\r\n\r\n\t\tblockWidth = 8;\r\n\t\tblockHeight = 4;\r\n\r\n\t} else {\r\n\r\n\t\tblockWidth = 4;\r\n\t\tblockHeight = 4;\r\n\r\n\t}\r\n\r\n\tblockSize = ( blockWidth * blockHeight ) * bpp / 8;\r\n\r\n\tpvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\r\n\r\n\tvar mipLevel = 0;\r\n\r\n\twhile ( mipLevel < pvrDatas.numMipmaps ) {\r\n\r\n\t\tvar sWidth = pvrDatas.width >> mipLevel,\r\n\t\t\tsHeight = pvrDatas.height >> mipLevel;\r\n\r\n\t\twidthBlocks = sWidth / blockWidth;\r\n\t\theightBlocks = sHeight / blockHeight;\r\n\r\n\t\t// Clamp to minimum number of blocks\r\n\t\tif ( widthBlocks < 2 ) { widthBlocks = 2; }\r\n\t\tif ( heightBlocks < 2 ) { heightBlocks = 2; }\r\n\r\n\t\tdataSize = widthBlocks * heightBlocks * blockSize;\r\n\r\n\t\tfor ( var surfIndex = 0; surfIndex < numSurfs; surfIndex ++ ) {\r\n\r\n\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataSize );\r\n\r\n\t\t\tvar mipmap = {\r\n\t\t\t\tdata: byteArray,\r\n\t\t\t\twidth: sWidth,\r\n\t\t\t\theight: sHeight\r\n\t\t\t};\r\n\r\n\t\t\tpvr.mipmaps[ surfIndex * pvrDatas.numMipmaps + mipLevel ] = mipmap;\r\n\r\n\t\t\tdataOffset += dataSize;\r\n\r\n\t\t}\r\n\r\n\t\tmipLevel ++;\r\n\r\n\t}\r\n\r\n\treturn pvr;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar STLLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nSTLLoader.prototype = {\r\n\r\n\tconstructor: STLLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t\t} catch ( exception ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( exception );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( data ) {\r\n\r\n\t\tfunction isBinary( data ) {\r\n\r\n\t\t\tvar expect, face_size, n_faces, reader;\r\n\t\t\treader = new DataView( data );\r\n\t\t\tface_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\r\n\t\t\tn_faces = reader.getUint32( 80, true );\r\n\t\t\texpect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\r\n\r\n\t\t\tif ( expect === reader.byteLength ) {\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\r\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\r\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\r\n\r\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\r\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\r\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\r\n\r\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\r\n\r\n\t\t\tvar solid = [ 115, 111, 108, 105, 100 ];\r\n\r\n\t\t\tfor ( var off = 0; off < 5; off ++ ) {\r\n\r\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\r\n\r\n\t\t\t\tif ( matchDataViewAt ( solid, reader, off ) ) { return false; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tfunction matchDataViewAt( query, reader, offset ) {\r\n\r\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\r\n\r\n\t\t\tfor ( var i = 0, il = query.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i, false ) ) { return false; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseBinary( data ) {\r\n\r\n\t\t\tvar reader = new DataView( data );\r\n\t\t\tvar faces = reader.getUint32( 80, true );\r\n\r\n\t\t\tvar r, g, b, hasColors = false, colors;\r\n\t\t\tvar defaultR, defaultG, defaultB, alpha;\r\n\r\n\t\t\t// process STL header\r\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\r\n\r\n\t\t\tfor ( var index = 0; index < 80 - 10; index ++ ) {\r\n\r\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F  ) &&\r\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52  ) &&\r\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D  ) ) {\r\n\r\n\t\t\t\t\thasColors = true;\r\n\t\t\t\t\tcolors = [];\r\n\r\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\r\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\r\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\r\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar dataOffset = 84;\r\n\t\t\tvar faceLength = 12 * 4 + 2;\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\tvar vertices = [];\r\n\t\t\tvar normals = [];\r\n\r\n\t\t\tfor ( var face = 0; face < faces; face ++ ) {\r\n\r\n\t\t\t\tvar start = dataOffset + face * faceLength;\r\n\t\t\t\tvar normalX = reader.getFloat32( start, true );\r\n\t\t\t\tvar normalY = reader.getFloat32( start + 4, true );\r\n\t\t\t\tvar normalZ = reader.getFloat32( start + 8, true );\r\n\r\n\t\t\t\tif ( hasColors ) {\r\n\r\n\t\t\t\t\tvar packedColor = reader.getUint16( start + 48, true );\r\n\r\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\r\n\r\n\t\t\t\t\t\t// facet has its own unique color\r\n\r\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\r\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\r\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tr = defaultR;\r\n\t\t\t\t\t\tg = defaultG;\r\n\t\t\t\t\t\tb = defaultB;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 1; i <= 3; i ++ ) {\r\n\r\n\t\t\t\t\tvar vertexstart = start + i * 12;\r\n\r\n\t\t\t\t\tvertices.push( reader.getFloat32( vertexstart, true ) );\r\n\t\t\t\t\tvertices.push( reader.getFloat32( vertexstart + 4, true ) );\r\n\t\t\t\t\tvertices.push( reader.getFloat32( vertexstart + 8, true ) );\r\n\r\n\t\t\t\t\tnormals.push( normalX, normalY, normalZ );\r\n\r\n\t\t\t\t\tif ( hasColors ) {\r\n\r\n\t\t\t\t\t\tcolors.push( r, g, b );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );\r\n\t\t\tgeometry.addAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3 ) );\r\n\r\n\t\t\tif ( hasColors ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'color', new BufferAttribute( new Float32Array( colors ), 3 ) );\r\n\t\t\t\tgeometry.hasColors = true;\r\n\t\t\t\tgeometry.alpha = alpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseASCII( data ) {\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\t\t\tvar patternFace = /facet([\\s\\S]*?)endfacet/g;\r\n\t\t\tvar faceCounter = 0;\r\n\r\n\t\t\tvar patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\r\n\t\t\tvar patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\r\n\t\t\tvar patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\r\n\r\n\t\t\tvar vertices = [];\r\n\t\t\tvar normals = [];\r\n\r\n\t\t\tvar normal = new Vector3();\r\n\r\n\t\t\tvar result;\r\n\r\n\t\t\twhile ( ( result = patternFace.exec( data ) ) !== null ) {\r\n\r\n\t\t\t\tvar vertexCountPerFace = 0;\r\n\t\t\t\tvar normalCountPerFace = 0;\r\n\r\n\t\t\t\tvar text = result[ 0 ];\r\n\r\n\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\r\n\r\n\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\r\n\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\r\n\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\r\n\t\t\t\t\tnormalCountPerFace ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\r\n\r\n\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\r\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\t\t\t\t\tvertexCountPerFace ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// every face have to own ONE valid normal\r\n\r\n\t\t\t\tif ( normalCountPerFace !== 1 ) {\r\n\r\n\t\t\t\t\tconsole.error( 'STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// each face have to own THREE valid vertices\r\n\r\n\t\t\t\tif ( vertexCountPerFace !== 3 ) {\r\n\r\n\t\t\t\t\tconsole.error( 'STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCounter ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\t\tgeometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction ensureString( buffer ) {\r\n\r\n\t\t\tif ( typeof buffer !== 'string' ) {\r\n\r\n\t\t\t\treturn LoaderUtils.decodeText( new Uint8Array( buffer ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buffer;\r\n\r\n\t\t}\r\n\r\n\t\tfunction ensureBinary( buffer ) {\r\n\r\n\t\t\tif ( typeof buffer === 'string' ) {\r\n\r\n\t\t\t\tvar array_buffer = new Uint8Array( buffer.length );\r\n\t\t\t\tfor ( var i = 0; i < buffer.length; i ++ ) {\r\n\r\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\r\n\r\n\t\t\t\t}\r\n\t\t\t\treturn array_buffer.buffer || array_buffer;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn buffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// start\r\n\r\n\t\tvar binData = ensureBinary( data );\r\n\r\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'EllipseCurve';\r\n\r\n\tthis.aX = aX || 0;\r\n\tthis.aY = aY || 0;\r\n\r\n\tthis.xRadius = xRadius || 1;\r\n\tthis.yRadius = yRadius || 1;\r\n\r\n\tthis.aStartAngle = aStartAngle || 0;\r\n\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\r\n\r\n\tthis.aClockwise = aClockwise || false;\r\n\r\n\tthis.aRotation = aRotation || 0;\r\n\r\n}\r\n\r\nEllipseCurve.prototype = Object.create( Curve.prototype );\r\nEllipseCurve.prototype.constructor = EllipseCurve;\r\n\r\nEllipseCurve.prototype.isEllipseCurve = true;\r\n\r\nEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar twoPi = Math.PI * 2;\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\r\n\r\n\t// ensures that deltaAngle is 0 .. 2 PI\r\n\twhile ( deltaAngle < 0 ) { deltaAngle += twoPi; }\r\n\twhile ( deltaAngle > twoPi ) { deltaAngle -= twoPi; }\r\n\r\n\tif ( deltaAngle < Number.EPSILON ) {\r\n\r\n\t\tif ( samePoints ) {\r\n\r\n\t\t\tdeltaAngle = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdeltaAngle = twoPi;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( this.aClockwise === true && ! samePoints ) {\r\n\r\n\t\tif ( deltaAngle === twoPi ) {\r\n\r\n\t\t\tdeltaAngle = - twoPi;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdeltaAngle = deltaAngle - twoPi;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar angle = this.aStartAngle + t * deltaAngle;\r\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\r\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\tif ( this.aRotation !== 0 ) {\r\n\r\n\t\tvar cos = Math.cos( this.aRotation );\r\n\t\tvar sin = Math.sin( this.aRotation );\r\n\r\n\t\tvar tx = x - this.aX;\r\n\t\tvar ty = y - this.aY;\r\n\r\n\t\t// Rotate the point about the center of the ellipse.\r\n\t\tx = tx * cos - ty * sin + this.aX;\r\n\t\ty = tx * sin + ty * cos + this.aY;\r\n\r\n\t}\r\n\r\n\treturn point.set( x, y );\r\n\r\n};\r\n\r\nEllipseCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.aX = source.aX;\r\n\tthis.aY = source.aY;\r\n\r\n\tthis.xRadius = source.xRadius;\r\n\tthis.yRadius = source.yRadius;\r\n\r\n\tthis.aStartAngle = source.aStartAngle;\r\n\tthis.aEndAngle = source.aEndAngle;\r\n\r\n\tthis.aClockwise = source.aClockwise;\r\n\r\n\tthis.aRotation = source.aRotation;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nEllipseCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.aX = this.aX;\r\n\tdata.aY = this.aY;\r\n\r\n\tdata.xRadius = this.xRadius;\r\n\tdata.yRadius = this.yRadius;\r\n\r\n\tdata.aStartAngle = this.aStartAngle;\r\n\tdata.aEndAngle = this.aEndAngle;\r\n\r\n\tdata.aClockwise = this.aClockwise;\r\n\r\n\tdata.aRotation = this.aRotation;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nEllipseCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.aX = json.aX;\r\n\tthis.aY = json.aY;\r\n\r\n\tthis.xRadius = json.xRadius;\r\n\tthis.yRadius = json.yRadius;\r\n\r\n\tthis.aStartAngle = json.aStartAngle;\r\n\tthis.aEndAngle = json.aEndAngle;\r\n\r\n\tthis.aClockwise = json.aClockwise;\r\n\r\n\tthis.aRotation = json.aRotation;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n\tthis.type = 'ArcCurve';\r\n\r\n}\r\n\r\nArcCurve.prototype = Object.create( EllipseCurve.prototype );\r\nArcCurve.prototype.constructor = ArcCurve;\r\n\r\nArcCurve.prototype.isArcCurve = true;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CubicPoly() {\r\n\r\n\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\r\n\t\r\n\tfunction init( x0, x1, t0, t1 ) {\r\n\r\n\t\tc0 = x0;\r\n\t\tc1 = t0;\r\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\r\n\r\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\r\n\t\t},\r\n\r\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\r\n\t\t\t// compute tangents when parameterized in [t1,t2]\r\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\r\n\t\t\t// rescale tangents for parametrization in [0,1]\r\n\t\t\tt1 *= dt1;\r\n\t\t\tt2 *= dt1;\r\n\r\n\t\t\tinit( x1, x2, t1, t2 );\r\n\r\n\t\t},\r\n\r\n\t\tcalc: function ( t ) {\r\n\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t2 * t;\r\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\r\n\r\n//\r\n\r\nvar tmp = new Vector3();\r\nvar px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\r\n\r\nfunction CatmullRomCurve3( points, closed, curveType, tension ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CatmullRomCurve3';\r\n\r\n\tthis.points = points || [];\r\n\tthis.closed = closed || false;\r\n\tthis.curveType = curveType || 'centripetal';\r\n\tthis.tension = tension || 0.5;\r\n\r\n}\r\n\r\nCatmullRomCurve3.prototype = Object.create( Curve.prototype );\r\nCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\r\n\r\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\r\n\r\nCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tvar points = this.points;\r\n\tvar l = points.length;\r\n\r\n\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\r\n\tvar intPoint = Math.floor( p );\r\n\tvar weight = p - intPoint;\r\n\r\n\tif ( this.closed ) {\r\n\r\n\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\r\n\r\n\t} else if ( weight === 0 && intPoint === l - 1 ) {\r\n\r\n\t\tintPoint = l - 2;\r\n\t\tweight = 1;\r\n\r\n\t}\r\n\r\n\tvar p0, p1, p2, p3; // 4 points\r\n\r\n\tif ( this.closed || intPoint > 0 ) {\r\n\r\n\t\tp0 = points[ ( intPoint - 1 ) % l ];\r\n\r\n\t} else {\r\n\r\n\t\t// extrapolate first point\r\n\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n\t\tp0 = tmp;\r\n\r\n\t}\r\n\r\n\tp1 = points[ intPoint % l ];\r\n\tp2 = points[ ( intPoint + 1 ) % l ];\r\n\r\n\tif ( this.closed || intPoint + 2 < l ) {\r\n\r\n\t\tp3 = points[ ( intPoint + 2 ) % l ];\r\n\r\n\t} else {\r\n\r\n\t\t// extrapolate last point\r\n\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\r\n\t\tp3 = tmp;\r\n\r\n\t}\r\n\r\n\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\r\n\r\n\t\t// init Centripetal / Chordal Catmull-Rom\r\n\t\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\r\n\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\r\n\t\t// safety check for repeated points\r\n\t\tif ( dt1 < 1e-4 ) { dt1 = 1.0; }\r\n\t\tif ( dt0 < 1e-4 ) { dt0 = dt1; }\r\n\t\tif ( dt2 < 1e-4 ) { dt2 = dt1; }\r\n\r\n\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\r\n\t} else if ( this.curveType === 'catmullrom' ) {\r\n\r\n\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\r\n\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\r\n\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\r\n\r\n\t}\r\n\r\n\tpoint.set(\r\n\t\tpx.calc( weight ),\r\n\t\tpy.calc( weight ),\r\n\t\tpz.calc( weight )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nCatmullRomCurve3.prototype.copy = function ( source ) {\n\tvar this$1 = this;\n\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = source.points[ i ];\r\n\r\n\t\tthis$1.points.push( point.clone() );\r\n\r\n\t}\r\n\r\n\tthis.closed = source.closed;\r\n\tthis.curveType = source.curveType;\r\n\tthis.tension = source.tension;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nCatmullRomCurve3.prototype.toJSON = function () {\n\tvar this$1 = this;\n\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.points = [];\r\n\r\n\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = this$1.points[ i ];\r\n\t\tdata.points.push( point.toArray() );\r\n\r\n\t}\r\n\r\n\tdata.closed = this.closed;\r\n\tdata.curveType = this.curveType;\r\n\tdata.tension = this.tension;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nCatmullRomCurve3.prototype.fromJSON = function ( json ) {\n\tvar this$1 = this;\n\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = json.points[ i ];\r\n\t\tthis$1.points.push( new Vector3().fromArray( point ) );\r\n\r\n\t}\r\n\r\n\tthis.closed = json.closed;\r\n\tthis.curveType = json.curveType;\r\n\tthis.tension = json.tension;\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\r\n\r\n\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\tvar t2 = t * t;\r\n\tvar t3 = t * t2;\r\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n}\r\n\r\n//\r\n\r\nfunction QuadraticBezierP0( t, p ) {\r\n\r\n\tvar k = 1 - t;\r\n\treturn k * k * p;\r\n\r\n}\r\n\r\nfunction QuadraticBezierP1( t, p ) {\r\n\r\n\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n}\r\n\r\nfunction QuadraticBezierP2( t, p ) {\r\n\r\n\treturn t * t * p;\r\n\r\n}\r\n\r\nfunction QuadraticBezier( t, p0, p1, p2 ) {\r\n\r\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\r\n\t\tQuadraticBezierP2( t, p2 );\r\n\r\n}\r\n\r\n//\r\n\r\nfunction CubicBezierP0( t, p ) {\r\n\r\n\tvar k = 1 - t;\r\n\treturn k * k * k * p;\r\n\r\n}\r\n\r\nfunction CubicBezierP1( t, p ) {\r\n\r\n\tvar k = 1 - t;\r\n\treturn 3 * k * k * t * p;\r\n\r\n}\r\n\r\nfunction CubicBezierP2( t, p ) {\r\n\r\n\treturn 3 * ( 1 - t ) * t * t * p;\r\n\r\n}\r\n\r\nfunction CubicBezierP3( t, p ) {\r\n\r\n\treturn t * t * t * p;\r\n\r\n}\r\n\r\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\r\n\r\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\r\n\t\tCubicBezierP3( t, p3 );\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CubicBezierCurve( v0, v1, v2, v3 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CubicBezierCurve';\r\n\r\n\tthis.v0 = v0 || new Vector2();\r\n\tthis.v1 = v1 || new Vector2();\r\n\tthis.v2 = v2 || new Vector2();\r\n\tthis.v3 = v3 || new Vector2();\r\n\r\n}\r\n\r\nCubicBezierCurve.prototype = Object.create( Curve.prototype );\r\nCubicBezierCurve.prototype.constructor = CubicBezierCurve;\r\n\r\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\r\n\r\nCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\r\n\r\n\tpoint.set(\r\n\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\r\n\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nCubicBezierCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\tthis.v3.copy( source.v3 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nCubicBezierCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\tdata.v3 = this.v3.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nCubicBezierCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\tthis.v3.fromArray( json.v3 );\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CubicBezierCurve3';\r\n\r\n\tthis.v0 = v0 || new Vector3();\r\n\tthis.v1 = v1 || new Vector3();\r\n\tthis.v2 = v2 || new Vector3();\r\n\tthis.v3 = v3 || new Vector3();\r\n\r\n}\r\n\r\nCubicBezierCurve3.prototype = Object.create( Curve.prototype );\r\nCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\r\n\r\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\r\n\r\nCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\r\n\r\n\tpoint.set(\r\n\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\r\n\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\r\n\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nCubicBezierCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\tthis.v3.copy( source.v3 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nCubicBezierCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\tdata.v3 = this.v3.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nCubicBezierCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\tthis.v3.fromArray( json.v3 );\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LineCurve( v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'LineCurve';\r\n\r\n\tthis.v1 = v1 || new Vector2();\r\n\tthis.v2 = v2 || new Vector2();\r\n\r\n}\r\n\r\nLineCurve.prototype = Object.create( Curve.prototype );\r\nLineCurve.prototype.constructor = LineCurve;\r\n\r\nLineCurve.prototype.isLineCurve = true;\r\n\r\nLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tif ( t === 1 ) {\r\n\r\n\t\tpoint.copy( this.v2 );\r\n\r\n\t} else {\r\n\r\n\t\tpoint.copy( this.v2 ).sub( this.v1 );\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\t}\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\r\n\r\n\treturn this.getPoint( u, optionalTarget );\r\n\r\n};\r\n\r\nLineCurve.prototype.getTangent = function (  ) {\r\n\r\n\tvar tangent = this.v2.clone().sub( this.v1 );\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n\r\nLineCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nLineCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nLineCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LineCurve3( v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'LineCurve3';\r\n\r\n\tthis.v1 = v1 || new Vector3();\r\n\tthis.v2 = v2 || new Vector3();\r\n\r\n}\r\n\r\nLineCurve3.prototype = Object.create( Curve.prototype );\r\nLineCurve3.prototype.constructor = LineCurve3;\r\n\r\nLineCurve3.prototype.isLineCurve3 = true;\r\n\r\nLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tif ( t === 1 ) {\r\n\r\n\t\tpoint.copy( this.v2 );\r\n\r\n\t} else {\r\n\r\n\t\tpoint.copy( this.v2 ).sub( this.v1 );\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\t}\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\r\n\r\n\treturn this.getPoint( u, optionalTarget );\r\n\r\n};\r\n\r\nLineCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nLineCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nLineCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction QuadraticBezierCurve( v0, v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'QuadraticBezierCurve';\r\n\r\n\tthis.v0 = v0 || new Vector2();\r\n\tthis.v1 = v1 || new Vector2();\r\n\tthis.v2 = v2 || new Vector2();\r\n\r\n}\r\n\r\nQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\r\nQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\r\n\r\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\r\n\r\nQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\r\n\r\n\tpoint.set(\r\n\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\r\n\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nQuadraticBezierCurve.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nQuadraticBezierCurve.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction QuadraticBezierCurve3( v0, v1, v2 ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'QuadraticBezierCurve3';\r\n\r\n\tthis.v0 = v0 || new Vector3();\r\n\tthis.v1 = v1 || new Vector3();\r\n\tthis.v2 = v2 || new Vector3();\r\n\r\n}\r\n\r\nQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\r\nQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\r\n\r\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\r\n\r\nQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector3();\r\n\r\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\r\n\r\n\tpoint.set(\r\n\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\r\n\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\r\n\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nQuadraticBezierCurve3.prototype.copy = function ( source ) {\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.v0.copy( source.v0 );\r\n\tthis.v1.copy( source.v1 );\r\n\tthis.v2.copy( source.v2 );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nQuadraticBezierCurve3.prototype.toJSON = function () {\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.v0 = this.v0.toArray();\r\n\tdata.v1 = this.v1.toArray();\r\n\tdata.v2 = this.v2.toArray();\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.v0.fromArray( json.v0 );\r\n\tthis.v1.fromArray( json.v1 );\r\n\tthis.v2.fromArray( json.v2 );\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction SplineCurve( points  ) {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'SplineCurve';\r\n\r\n\tthis.points = points || [];\r\n\r\n}\r\n\r\nSplineCurve.prototype = Object.create( Curve.prototype );\r\nSplineCurve.prototype.constructor = SplineCurve;\r\n\r\nSplineCurve.prototype.isSplineCurve = true;\r\n\r\nSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\r\n\r\n\tvar point = optionalTarget || new Vector2();\r\n\r\n\tvar points = this.points;\r\n\tvar p = ( points.length - 1 ) * t;\r\n\r\n\tvar intPoint = Math.floor( p );\r\n\tvar weight = p - intPoint;\r\n\r\n\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n\tvar p1 = points[ intPoint ];\r\n\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\tpoint.set(\r\n\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\r\n\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\r\n\t);\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\nSplineCurve.prototype.copy = function ( source ) {\n\tvar this$1 = this;\n\r\n\r\n\tCurve.prototype.copy.call( this, source );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = source.points[ i ];\r\n\r\n\t\tthis$1.points.push( point.clone() );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nSplineCurve.prototype.toJSON = function () {\n\tvar this$1 = this;\n\r\n\r\n\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\tdata.points = [];\r\n\r\n\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = this$1.points[ i ];\r\n\t\tdata.points.push( point.toArray() );\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\nSplineCurve.prototype.fromJSON = function ( json ) {\n\tvar this$1 = this;\n\r\n\r\n\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\tthis.points = [];\r\n\r\n\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = json.points[ i ];\r\n\t\tthis$1.points.push( new Vector2().fromArray( point ) );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Curves$1 = {\r\n    ArcCurve: ArcCurve,\r\n    CatmullRomCurve3: CatmullRomCurve3,\r\n    CubicBezierCurve: CubicBezierCurve,\r\n    CubicBezierCurve3: CubicBezierCurve3,\r\n    EllipseCurve: EllipseCurve,\r\n    LineCurve: LineCurve,\r\n    LineCurve3: LineCurve3,\r\n    QuadraticBezierCurve: QuadraticBezierCurve,\r\n    QuadraticBezierCurve3: QuadraticBezierCurve3,\r\n    SplineCurve: SplineCurve\r\n};\r\nfunction CurvePath() {\r\n\r\n\tCurve.call( this );\r\n\r\n\tthis.type = 'CurvePath';\r\n\r\n\tthis.curves = [];\r\n\tthis.autoClose = false; // Automatically closes the path\r\n\r\n}\r\n\r\nCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\r\n\r\n\tconstructor: CurvePath,\r\n\r\n\tadd: function ( curve ) {\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t},\r\n\r\n\tclosePath: function () {\r\n\r\n\t\t// Add a line curve if start and end of lines are not connected\r\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\r\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\r\n\t\tif ( ! startPoint.equals( endPoint ) ) {\r\n\r\n\t\t\tthis.curves.push( new Curves$1[ 'LineCurve' ]( endPoint, startPoint ) );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// To get accurate point with reference to\r\n\t// entire path distance at time t,\r\n\t// following has to be done:\r\n\r\n\t// 1. Length of each sub path have to be known\r\n\t// 2. Locate and identify type of curve\r\n\t// 3. Get t for the curve\r\n\t// 4. Return curve.getPointAt(t')\r\n\r\n\tgetPoint: function ( t ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar d = t * this.getLength();\r\n\t\tvar curveLengths = this.getCurveLengths();\r\n\t\tvar i = 0;\r\n\r\n\t\t// To think about boundaries points.\r\n\r\n\t\twhile ( i < curveLengths.length ) {\r\n\r\n\t\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\t\tvar diff = curveLengths[ i ] - d;\r\n\t\t\t\tvar curve = this$1.curves[ i ];\r\n\r\n\t\t\t\tvar segmentLength = curve.getLength();\r\n\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\r\n\r\n\t\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ti ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n\t},\r\n\r\n\t// We cannot use the default Curve getPoint() with getLength() because in\r\n\t// Curve, getLength() depends on getPoint() but in CurvePath\r\n\t// getPoint() depends on getLength\r\n\r\n\tgetLength: function () {\r\n\r\n\t\tvar lens = this.getCurveLengths();\r\n\t\treturn lens[ lens.length - 1 ];\r\n\r\n\t},\r\n\r\n\t// cacheLengths must be recalculated.\r\n\tupdateArcLengths: function () {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.cacheLengths = null;\r\n\t\tthis.getCurveLengths();\r\n\r\n\t},\r\n\r\n\t// Compute lengths and cache them\r\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\n\tgetCurveLengths: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\t// We use cache values if curves and cache array are same length\r\n\r\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\r\n\t\t\treturn this.cacheLengths;\r\n\r\n\t\t}\r\n\r\n\t\t// Get length of sub-curve\r\n\t\t// Push sums into cached array\r\n\r\n\t\tvar lengths = [], sums = 0;\r\n\r\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tsums += this$1.curves[ i ].getLength();\r\n\t\t\tlengths.push( sums );\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheLengths = lengths;\r\n\r\n\t\treturn lengths;\r\n\r\n\t},\r\n\r\n\tgetSpacedPoints: function ( divisions ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( divisions === undefined ) { divisions = 40; }\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tfor ( var i = 0; i <= divisions; i ++ ) {\r\n\r\n\t\t\tpoints.push( this$1.getPoint( i / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClose ) {\r\n\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\tgetPoints: function ( divisions ) {\r\n\r\n\t\tdivisions = divisions || 12;\r\n\r\n\t\tvar points = [], last;\r\n\r\n\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\r\n\r\n\t\t\tvar curve = curves[ i ];\r\n\t\t\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\r\n\t\t\t\t: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1\r\n\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\r\n\t\t\t\t\t\t: divisions;\r\n\r\n\t\t\tvar pts = curve.getPoints( resolution );\r\n\r\n\t\t\tfor ( var j = 0; j < pts.length; j ++ ) {\r\n\r\n\t\t\t\tvar point = pts[ j ];\r\n\r\n\t\t\t\tif ( last && last.equals( point ) ) { continue; } // ensures no consecutive points are duplicates\r\n\r\n\t\t\t\tpoints.push( point );\r\n\t\t\t\tlast = point;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\r\n\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tCurve.prototype.copy.call( this, source );\r\n\r\n\t\tthis.curves = [];\r\n\r\n\t\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar curve = source.curves[ i ];\r\n\r\n\t\t\tthis$1.curves.push( curve.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.autoClose = source.autoClose;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar data = Curve.prototype.toJSON.call( this );\r\n\r\n\t\tdata.autoClose = this.autoClose;\r\n\t\tdata.curves = [];\r\n\r\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar curve = this$1.curves[ i ];\r\n\t\t\tdata.curves.push( curve.toJSON() );\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tCurve.prototype.fromJSON.call( this, json );\r\n\r\n\t\tthis.autoClose = json.autoClose;\r\n\t\tthis.curves = [];\r\n\r\n\t\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar curve = json.curves[ i ];\r\n\t\t\tthis$1.curves.push( new Curves$1[ curve.type ]().fromJSON( curve ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Path( points ) {\r\n\r\n\tCurvePath.call( this );\r\n\r\n\tthis.type = 'Path';\r\n\r\n\tthis.currentPoint = new Vector2();\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.setFromPoints( points );\r\n\r\n\t}\r\n\r\n}\r\n\r\nPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\r\n\r\n\tconstructor: Path,\r\n\r\n\tsetFromPoints: function ( points ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\r\n\r\n\t\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis$1.lineTo( points[ i ].x, points[ i ].y );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmoveTo: function ( x, y ) {\r\n\r\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\r\n\r\n\t},\r\n\r\n\tlineTo: function ( x, y ) {\r\n\r\n\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.set( x, y );\r\n\r\n\t},\r\n\r\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\r\n\r\n\t\tvar curve = new QuadraticBezierCurve(\r\n\t\t\tthis.currentPoint.clone(),\r\n\t\t\tnew Vector2( aCPx, aCPy ),\r\n\t\t\tnew Vector2( aX, aY )\r\n\t\t);\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.set( aX, aY );\r\n\r\n\t},\r\n\r\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\r\n\t\tvar curve = new CubicBezierCurve(\r\n\t\t\tthis.currentPoint.clone(),\r\n\t\t\tnew Vector2( aCP1x, aCP1y ),\r\n\t\t\tnew Vector2( aCP2x, aCP2y ),\r\n\t\t\tnew Vector2( aX, aY )\r\n\t\t);\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.set( aX, aY );\r\n\r\n\t},\r\n\r\n\tsplineThru: function ( pts  ) {\r\n\r\n\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\r\n\r\n\t\tvar curve = new SplineCurve( npts );\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\r\n\r\n\t},\r\n\r\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\t\tvar x0 = this.currentPoint.x;\r\n\t\tvar y0 = this.currentPoint.y;\r\n\r\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\r\n\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n\t},\r\n\r\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n\t},\r\n\r\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\t\tvar x0 = this.currentPoint.x;\r\n\t\tvar y0 = this.currentPoint.y;\r\n\r\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n\t},\r\n\r\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n\t\tif ( this.curves.length > 0 ) {\r\n\r\n\t\t\t// if a previous curve is present, attempt to join\r\n\t\t\tvar firstPoint = curve.getPoint( 0 );\r\n\r\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\r\n\r\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tvar lastPoint = curve.getPoint( 1 );\r\n\t\tthis.currentPoint.copy( lastPoint );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tCurvePath.prototype.copy.call( this, source );\r\n\r\n\t\tthis.currentPoint.copy( source.currentPoint );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = CurvePath.prototype.toJSON.call( this );\r\n\r\n\t\tdata.currentPoint = this.currentPoint.toArray();\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\r\n\r\n\t\tCurvePath.prototype.fromJSON.call( this, json );\r\n\r\n\t\tthis.currentPoint.fromArray( json.currentPoint );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nfunction Shape( points ) {\r\n\r\n\tPath.call( this, points );\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.type = 'Shape';\r\n\r\n\tthis.holes = [];\r\n\r\n}\r\n\r\nShape.prototype = Object.assign( Object.create( Path.prototype ), {\r\n\r\n\tconstructor: Shape,\r\n\r\n\tgetPointsHoles: function ( divisions ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar holesPts = [];\r\n\r\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tholesPts[ i ] = this$1.holes[ i ].getPoints( divisions );\r\n\r\n\t\t}\r\n\r\n\t\treturn holesPts;\r\n\r\n\t},\r\n\r\n\t// get points of shape and holes (keypoints based on segments parameter)\r\n\r\n\textractPoints: function ( divisions ) {\r\n\r\n\t\treturn {\r\n\r\n\t\t\tshape: this.getPoints( divisions ),\r\n\t\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t\t};\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tPath.prototype.copy.call( this, source );\r\n\r\n\t\tthis.holes = [];\r\n\r\n\t\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar hole = source.holes[ i ];\r\n\r\n\t\t\tthis$1.holes.push( hole.clone() );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar data = Path.prototype.toJSON.call( this );\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.holes = [];\r\n\r\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar hole = this$1.holes[ i ];\r\n\t\t\tdata.holes.push( hole.toJSON() );\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tfromJSON: function ( json ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tPath.prototype.fromJSON.call( this, json );\r\n\r\n\t\tthis.uuid = json.uuid;\r\n\t\tthis.holes = [];\r\n\r\n\t\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar hole = json.holes[ i ];\r\n\t\t\tthis$1.holes.push( new Path().fromJSON( hole ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Earcut = {\r\n\r\n\ttriangulate: function ( data, holeIndices, dim ) {\r\n\r\n\t\tdim = dim || 2;\r\n\r\n\t\tvar hasHoles = holeIndices && holeIndices.length,\r\n\t\t\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\r\n\t\t\touterNode = linkedList( data, 0, outerLen, dim, true ),\r\n\t\t\ttriangles = [];\r\n\r\n\t\tif ( ! outerNode ) { return triangles; }\r\n\r\n\t\tvar minX, minY, maxX, maxY, x, y, invSize;\r\n\r\n\t\tif ( hasHoles ) { outerNode = eliminateHoles( data, holeIndices, outerNode, dim ); }\r\n\r\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\r\n\r\n\t\tif ( data.length > 80 * dim ) {\r\n\r\n\t\t\tminX = maxX = data[ 0 ];\r\n\t\t\tminY = maxY = data[ 1 ];\r\n\r\n\t\t\tfor ( var i = dim; i < outerLen; i += dim ) {\r\n\r\n\t\t\t\tx = data[ i ];\r\n\t\t\t\ty = data[ i + 1 ];\r\n\t\t\t\tif ( x < minX ) { minX = x; }\r\n\t\t\t\tif ( y < minY ) { minY = y; }\r\n\t\t\t\tif ( x > maxX ) { maxX = x; }\r\n\t\t\t\tif ( y > maxY ) { maxY = y; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\r\n\r\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\r\n\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\r\n\r\n\t\t}\r\n\r\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\r\n\r\n\t\treturn triangles;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// create a circular doubly linked list from polygon points in the specified winding order\r\n\r\nfunction linkedList( data, start, end, dim, clockwise ) {\r\n\r\n\tvar i, last;\r\n\r\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\r\n\r\n\t\tfor ( i = start; i < end; i += dim ) { last = insertNode( i, data[ i ], data[ i + 1 ], last ); }\r\n\r\n\t} else {\r\n\r\n\t\tfor ( i = end - dim; i >= start; i -= dim ) { last = insertNode( i, data[ i ], data[ i + 1 ], last ); }\r\n\r\n\t}\r\n\r\n\tif ( last && equals( last, last.next ) ) {\r\n\r\n\t\tremoveNode( last );\r\n\t\tlast = last.next;\r\n\r\n\t}\r\n\r\n\treturn last;\r\n\r\n}\r\n\r\n// eliminate colinear or duplicate points\r\n\r\nfunction filterPoints( start, end ) {\r\n\r\n\tif ( ! start ) { return start; }\r\n\tif ( ! end ) { end = start; }\r\n\r\n\tvar p = start, again;\r\n\r\n\tdo {\r\n\r\n\t\tagain = false;\r\n\r\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\r\n\r\n\t\t\tremoveNode( p );\r\n\t\t\tp = end = p.prev;\r\n\t\t\tif ( p === p.next ) { break; }\r\n\t\t\tagain = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tp = p.next;\r\n\r\n\t\t}\r\n\r\n\t} while ( again || p !== end );\r\n\r\n\treturn end;\r\n\r\n}\r\n\r\n// main ear slicing loop which triangulates a polygon (given as a linked list)\r\n\r\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\r\n\r\n\tif ( ! ear ) { return; }\r\n\r\n\t// interlink polygon nodes in z-order\r\n\r\n\tif ( ! pass && invSize ) { indexCurve( ear, minX, minY, invSize ); }\r\n\r\n\tvar stop = ear, prev, next;\r\n\r\n\t// iterate through ears, slicing them one by one\r\n\r\n\twhile ( ear.prev !== ear.next ) {\r\n\r\n\t\tprev = ear.prev;\r\n\t\tnext = ear.next;\r\n\r\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\r\n\r\n\t\t\t// cut off the triangle\r\n\t\t\ttriangles.push( prev.i / dim );\r\n\t\t\ttriangles.push( ear.i / dim );\r\n\t\t\ttriangles.push( next.i / dim );\r\n\r\n\t\t\tremoveNode( ear );\r\n\r\n\t\t\t// skipping the next vertice leads to less sliver triangles\r\n\t\t\tear = next.next;\r\n\t\t\tstop = next.next;\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tear = next;\r\n\r\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\r\n\r\n\t\tif ( ear === stop ) {\r\n\r\n\t\t\t// try filtering points and slicing again\r\n\r\n\t\t\tif ( ! pass ) {\r\n\r\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\r\n\r\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\r\n\r\n\t\t\t} else if ( pass === 1 ) {\r\n\r\n\t\t\t\tear = cureLocalIntersections( ear, triangles, dim );\r\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\r\n\r\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\r\n\r\n\t\t\t} else if ( pass === 2 ) {\r\n\r\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// check whether a polygon node forms a valid ear with adjacent nodes\r\n\r\nfunction isEar( ear ) {\r\n\r\n\tvar a = ear.prev,\r\n\t\tb = ear,\r\n\t\tc = ear.next;\r\n\r\n\tif ( area( a, b, c ) >= 0 ) { return false; } // reflex, can't be an ear\r\n\r\n\t// now make sure we don't have other points inside the potential ear\r\n\tvar p = ear.next.next;\r\n\r\n\twhile ( p !== ear.prev ) {\r\n\r\n\t\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction isEarHashed( ear, minX, minY, invSize ) {\r\n\r\n\tvar a = ear.prev,\r\n\t\tb = ear,\r\n\t\tc = ear.next;\r\n\r\n\tif ( area( a, b, c ) >= 0 ) { return false; } // reflex, can't be an ear\r\n\r\n\t// triangle bbox; min & max are calculated like this for speed\r\n\r\n\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\r\n\t\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\r\n\t\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\r\n\t\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\r\n\r\n\t// z-order range for the current triangle bbox;\r\n\r\n\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\r\n\t\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\r\n\r\n\t// first look for points inside the triangle in increasing z-order\r\n\r\n\tvar p = ear.nextZ;\r\n\r\n\twhile ( p && p.z <= maxZ ) {\r\n\r\n\t\tif ( p !== ear.prev && p !== ear.next &&\r\n\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\r\n\t\t\t\tarea( p.prev, p, p.next ) >= 0 ) { return false; }\r\n\t\tp = p.nextZ;\r\n\r\n\t}\r\n\r\n\t// then look for points in decreasing z-order\r\n\r\n\tp = ear.prevZ;\r\n\r\n\twhile ( p && p.z >= minZ ) {\r\n\r\n\t\tif ( p !== ear.prev && p !== ear.next &&\r\n\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\r\n\t\t\t\tarea( p.prev, p, p.next ) >= 0 ) { return false; }\r\n\r\n\t\tp = p.prevZ;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\n// go through all polygon nodes and cure small local self-intersections\r\n\r\nfunction cureLocalIntersections( start, triangles, dim ) {\r\n\r\n\tvar p = start;\r\n\r\n\tdo {\r\n\r\n\t\tvar a = p.prev, b = p.next.next;\r\n\r\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\r\n\r\n\t\t\ttriangles.push( a.i / dim );\r\n\t\t\ttriangles.push( p.i / dim );\r\n\t\t\ttriangles.push( b.i / dim );\r\n\r\n\t\t\t// remove two nodes involved\r\n\r\n\t\t\tremoveNode( p );\r\n\t\t\tremoveNode( p.next );\r\n\r\n\t\t\tp = start = b;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== start );\r\n\r\n\treturn p;\r\n\r\n}\r\n\r\n// try splitting polygon into two and triangulate them independently\r\n\r\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\r\n\r\n\t// look for a valid diagonal that divides the polygon into two\r\n\r\n\tvar a = start;\r\n\r\n\tdo {\r\n\r\n\t\tvar b = a.next.next;\r\n\r\n\t\twhile ( b !== a.prev ) {\r\n\r\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\r\n\r\n\t\t\t\t// split the polygon in two by the diagonal\r\n\r\n\t\t\t\tvar c = splitPolygon( a, b );\r\n\r\n\t\t\t\t// filter colinear points around the cuts\r\n\r\n\t\t\t\ta = filterPoints( a, a.next );\r\n\t\t\t\tc = filterPoints( c, c.next );\r\n\r\n\t\t\t\t// run earcut on each half\r\n\r\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize );\r\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tb = b.next;\r\n\r\n\t\t}\r\n\r\n\t\ta = a.next;\r\n\r\n\t} while ( a !== start );\r\n\r\n}\r\n\r\n// link every hole into the outer loop, producing a single-ring polygon without holes\r\n\r\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\r\n\r\n\tvar queue = [], i, len, start, end, list;\r\n\r\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\r\n\r\n\t\tstart = holeIndices[ i ] * dim;\r\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\r\n\t\tlist = linkedList( data, start, end, dim, false );\r\n\t\tif ( list === list.next ) { list.steiner = true; }\r\n\t\tqueue.push( getLeftmost( list ) );\r\n\r\n\t}\r\n\r\n\tqueue.sort( compareX );\r\n\r\n\t// process holes from left to right\r\n\r\n\tfor ( i = 0; i < queue.length; i ++ ) {\r\n\r\n\t\teliminateHole( queue[ i ], outerNode );\r\n\t\touterNode = filterPoints( outerNode, outerNode.next );\r\n\r\n\t}\r\n\r\n\treturn outerNode;\r\n\r\n}\r\n\r\nfunction compareX( a, b ) {\r\n\r\n\treturn a.x - b.x;\r\n\r\n}\r\n\r\n// find a bridge between vertices that connects hole with an outer ring and and link it\r\n\r\nfunction eliminateHole( hole, outerNode ) {\r\n\r\n\touterNode = findHoleBridge( hole, outerNode );\r\n\r\n\tif ( outerNode ) {\r\n\r\n\t\tvar b = splitPolygon( outerNode, hole );\r\n\r\n\t\tfilterPoints( b, b.next );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\r\n\r\nfunction findHoleBridge( hole, outerNode ) {\r\n\r\n\tvar p = outerNode,\r\n\t\thx = hole.x,\r\n\t\thy = hole.y,\r\n\t\tqx = - Infinity,\r\n\t\tm;\r\n\r\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\r\n\t// segment's endpoint with lesser x will be potential connection point\r\n\r\n\tdo {\r\n\r\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\r\n\r\n\t\t\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\r\n\r\n\t\t\tif ( x <= hx && x > qx ) {\r\n\r\n\t\t\t\tqx = x;\r\n\r\n\t\t\t\tif ( x === hx ) {\r\n\r\n\t\t\t\t\tif ( hy === p.y ) { return p; }\r\n\t\t\t\t\tif ( hy === p.next.y ) { return p.next; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== outerNode );\r\n\r\n\tif ( ! m ) { return null; }\r\n\r\n\tif ( hx === qx ) { return m.prev; } // hole touches outer segment; pick lower endpoint\r\n\r\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\r\n\t// if there are no points found, we have a valid connection;\r\n\t// otherwise choose the point of the minimum angle with the ray as connection point\r\n\r\n\tvar stop = m,\r\n\t\tmx = m.x,\r\n\t\tmy = m.y,\r\n\t\ttanMin = Infinity,\r\n\t\ttan;\r\n\r\n\tp = m.next;\r\n\r\n\twhile ( p !== stop ) {\r\n\r\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\r\n\t\t\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\r\n\r\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\r\n\r\n\t\t\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\r\n\r\n\t\t\t\tm = p;\r\n\t\t\t\ttanMin = tan;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t}\r\n\r\n\treturn m;\r\n\r\n}\r\n\r\n// interlink polygon nodes in z-order\r\n\r\nfunction indexCurve( start, minX, minY, invSize ) {\r\n\r\n\tvar p = start;\r\n\r\n\tdo {\r\n\r\n\t\tif ( p.z === null ) { p.z = zOrder( p.x, p.y, minX, minY, invSize ); }\r\n\t\tp.prevZ = p.prev;\r\n\t\tp.nextZ = p.next;\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== start );\r\n\r\n\tp.prevZ.nextZ = null;\r\n\tp.prevZ = null;\r\n\r\n\tsortLinked( p );\r\n\r\n}\r\n\r\n// Simon Tatham's linked list merge sort algorithm\r\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\r\n\r\nfunction sortLinked( list ) {\r\n\r\n\tvar i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\r\n\r\n\tdo {\r\n\r\n\t\tp = list;\r\n\t\tlist = null;\r\n\t\ttail = null;\r\n\t\tnumMerges = 0;\r\n\r\n\t\twhile ( p ) {\r\n\r\n\t\t\tnumMerges ++;\r\n\t\t\tq = p;\r\n\t\t\tpSize = 0;\r\n\r\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\r\n\r\n\t\t\t\tpSize ++;\r\n\t\t\t\tq = q.nextZ;\r\n\t\t\t\tif ( ! q ) { break; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tqSize = inSize;\r\n\r\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\r\n\r\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\r\n\r\n\t\t\t\t\te = p;\r\n\t\t\t\t\tp = p.nextZ;\r\n\t\t\t\t\tpSize --;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\te = q;\r\n\t\t\t\t\tq = q.nextZ;\r\n\t\t\t\t\tqSize --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( tail ) { tail.nextZ = e; }\r\n\t\t\t\telse { list = e; }\r\n\r\n\t\t\t\te.prevZ = tail;\r\n\t\t\t\ttail = e;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp = q;\r\n\r\n\t\t}\r\n\r\n\t\ttail.nextZ = null;\r\n\t\tinSize *= 2;\r\n\r\n\t} while ( numMerges > 1 );\r\n\r\n\treturn list;\r\n\r\n}\r\n\r\n// z-order of a point given coords and inverse of the longer side of data bbox\r\n\r\nfunction zOrder( x, y, minX, minY, invSize ) {\r\n\r\n\t// coords are transformed into non-negative 15-bit integer range\r\n\r\n\tx = 32767 * ( x - minX ) * invSize;\r\n\ty = 32767 * ( y - minY ) * invSize;\r\n\r\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\r\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\r\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\r\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\r\n\r\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\r\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\r\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\r\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\r\n\r\n\treturn x | ( y << 1 );\r\n\r\n}\r\n\r\n// find the leftmost node of a polygon ring\r\n\r\nfunction getLeftmost( start ) {\r\n\r\n\tvar p = start, leftmost = start;\r\n\r\n\tdo {\r\n\r\n\t\tif ( p.x < leftmost.x ) { leftmost = p; }\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== start );\r\n\r\n\treturn leftmost;\r\n\r\n}\r\n\r\n// check if a point lies within a convex triangle\r\n\r\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\r\n\r\n\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\r\n\t ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\r\n\t ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\r\n\r\n}\r\n\r\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\r\n\r\nfunction isValidDiagonal( a, b ) {\r\n\r\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\r\n\t\tlocallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\r\n\r\n}\r\n\r\n// signed area of a triangle\r\n\r\nfunction area( p, q, r ) {\r\n\r\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\r\n\r\n}\r\n\r\n// check if two points are equal\r\n\r\nfunction equals( p1, p2 ) {\r\n\r\n\treturn p1.x === p2.x && p1.y === p2.y;\r\n\r\n}\r\n\r\n// check if two segments intersect\r\n\r\nfunction intersects( p1, q1, p2, q2 ) {\r\n\r\n\tif ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||\r\n\t\t\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) { return true; }\r\n\r\n\treturn area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&\r\n\t\t\t\t area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;\r\n\r\n}\r\n\r\n// check if a polygon diagonal intersects any polygon segments\r\n\r\nfunction intersectsPolygon( a, b ) {\r\n\r\n\tvar p = a;\r\n\r\n\tdo {\r\n\r\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\r\n\t\t\t\t\t\tintersects( p, p.next, a, b ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== a );\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\n// check if a polygon diagonal is locally inside the polygon\r\n\r\nfunction locallyInside( a, b ) {\r\n\r\n\treturn area( a.prev, a, a.next ) < 0 ?\r\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\r\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\r\n\r\n}\r\n\r\n// check if the middle point of a polygon diagonal is inside the polygon\r\n\r\nfunction middleInside( a, b ) {\r\n\r\n\tvar p = a,\r\n\t\tinside = false,\r\n\t\tpx = ( a.x + b.x ) / 2,\r\n\t\tpy = ( a.y + b.y ) / 2;\r\n\r\n\tdo {\r\n\r\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\r\n\t\t\t\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {\r\n\r\n\t\t\tinside = ! inside;\r\n\r\n\t\t}\r\n\r\n\t\tp = p.next;\r\n\r\n\t} while ( p !== a );\r\n\r\n\treturn inside;\r\n\r\n}\r\n\r\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\r\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\r\n\r\nfunction splitPolygon( a, b ) {\r\n\r\n\tvar a2 = new Node$1( a.i, a.x, a.y ),\r\n\t\tb2 = new Node$1( b.i, b.x, b.y ),\r\n\t\tan = a.next,\r\n\t\tbp = b.prev;\r\n\r\n\ta.next = b;\r\n\tb.prev = a;\r\n\r\n\ta2.next = an;\r\n\tan.prev = a2;\r\n\r\n\tb2.next = a2;\r\n\ta2.prev = b2;\r\n\r\n\tbp.next = b2;\r\n\tb2.prev = bp;\r\n\r\n\treturn b2;\r\n\r\n}\r\n\r\n// create a node and optionally link it with previous one (in a circular doubly linked list)\r\n\r\nfunction insertNode( i, x, y, last ) {\r\n\r\n\tvar p = new Node$1( i, x, y );\r\n\r\n\tif ( ! last ) {\r\n\r\n\t\tp.prev = p;\r\n\t\tp.next = p;\r\n\r\n\t} else {\r\n\r\n\t\tp.next = last.next;\r\n\t\tp.prev = last;\r\n\t\tlast.next.prev = p;\r\n\t\tlast.next = p;\r\n\r\n\t}\r\n\r\n\treturn p;\r\n\r\n}\r\n\r\nfunction removeNode( p ) {\r\n\r\n\tp.next.prev = p.prev;\r\n\tp.prev.next = p.next;\r\n\r\n\tif ( p.prevZ ) { p.prevZ.nextZ = p.nextZ; }\r\n\tif ( p.nextZ ) { p.nextZ.prevZ = p.prevZ; }\r\n\r\n}\r\n\r\nfunction Node$1( i, x, y ) {\r\n\r\n\t// vertice index in coordinates array\r\n\tthis.i = i;\r\n\r\n\t// vertex coordinates\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\r\n\t// previous and next vertice nodes in a polygon ring\r\n\tthis.prev = null;\r\n\tthis.next = null;\r\n\r\n\t// z-order curve value\r\n\tthis.z = null;\r\n\r\n\t// previous and next nodes in z-order\r\n\tthis.prevZ = null;\r\n\tthis.nextZ = null;\r\n\r\n\t// indicates whether this is a steiner point\r\n\tthis.steiner = false;\r\n\r\n}\r\n\r\nfunction signedArea( data, start, end, dim ) {\r\n\r\n\tvar sum = 0;\r\n\r\n\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\r\n\r\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\r\n\t\tj = i;\r\n\r\n\t}\r\n\r\n\treturn sum;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ShapeUtils = {\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tarea: function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t},\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn ShapeUtils.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\r\n\t\tvar holeIndices = []; // array of hole indices\r\n\t\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\r\n\r\n\t\tremoveDupEndPts( contour );\r\n\t\taddContour( vertices, contour );\r\n\r\n\t\t//\r\n\r\n\t\tvar holeIndex = contour.length;\r\n\r\n\t\tholes.forEach( removeDupEndPts );\r\n\r\n\t\tfor ( var i = 0; i < holes.length; i ++ ) {\r\n\r\n\t\t\tholeIndices.push( holeIndex );\r\n\t\t\tholeIndex += holes[ i ].length;\r\n\t\t\taddContour( vertices, holes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar triangles = Earcut.triangulate( vertices, holeIndices );\r\n\r\n\t\t//\r\n\r\n\t\tfor ( var i = 0; i < triangles.length; i += 3 ) {\r\n\r\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn faces;\r\n\r\n\t}\r\n\r\n};\r\n\r\nfunction removeDupEndPts( points ) {\r\n\r\n\tvar l = points.length;\r\n\r\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\r\n\r\n\t\tpoints.pop();\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction addContour( vertices, contour ) {\r\n\r\n\tfor ( var i = 0; i < contour.length; i ++ ) {\r\n\r\n\t\tvertices.push( contour[ i ].x );\r\n\t\tvertices.push( contour[ i ].y );\r\n\r\n\t}\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ShapePath() {\r\n\r\n\tthis.type = 'ShapePath';\r\n\r\n\tthis.color = new Color();\r\n\r\n\tthis.subPaths = [];\r\n\tthis.currentPath = null;\r\n\r\n}\r\n\r\nObject.assign( ShapePath.prototype, {\r\n\r\n\tmoveTo: function ( x, y ) {\r\n\r\n\t\tthis.currentPath = new Path();\r\n\t\tthis.subPaths.push( this.currentPath );\r\n\t\tthis.currentPath.moveTo( x, y );\r\n\r\n\t},\r\n\r\n\tlineTo: function ( x, y ) {\r\n\r\n\t\tthis.currentPath.lineTo( x, y );\r\n\r\n\t},\r\n\r\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\r\n\r\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\r\n\r\n\t},\r\n\r\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\r\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\r\n\r\n\t},\r\n\r\n\tsplineThru: function ( pts ) {\r\n\r\n\t\tthis.currentPath.splineThru( pts );\r\n\r\n\t},\r\n\r\n\ttoShapes: function ( isCCW, noHoles ) {\r\n\r\n\t\tfunction toShapesNoHoles( inSubpaths ) {\r\n\r\n\t\t\tvar shapes = [];\r\n\r\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\r\n\t\t\t\tvar tmpShape = new Shape();\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\t\tshapes.push( tmpShape );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shapes;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\r\n\t\t\tvar polyLen = inPolygon.length;\r\n\r\n\t\t\t// inPt on polygon contour => immediate success    or\r\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\t\tvar inside = false;\r\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\r\n\t\t\t\tvar edgeLowPt = inPolygon[ p ];\r\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\r\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t// not parallel\r\n\t\t\t\t\tif ( edgeDy < 0 ) {\r\n\r\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\t{ continue; }\r\n\r\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\r\n\r\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\t{ return\ttrue; }\t\t// inPt is on contour ?\r\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\r\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\t{ return\ttrue; }\t\t// inPt is on contour ?\r\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\t{ continue; }\r\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// parallel or collinear\r\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\t{ continue; }\t\t\t// parallel\r\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\r\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\t{ return\ttrue; }\t// inPt: Point on contour !\r\n\t\t\t\t\t// continue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn\tinside;\r\n\r\n\t\t}\r\n\r\n\t\tvar isClockWise = ShapeUtils.isClockWise;\r\n\r\n\t\tvar subPaths = this.subPaths;\r\n\t\tif ( subPaths.length === 0 ) { return []; }\r\n\r\n\t\tif ( noHoles === true )\t{ return\ttoShapesNoHoles( subPaths ); }\r\n\r\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\r\n\t\tif ( subPaths.length === 1 ) {\r\n\r\n\t\t\ttmpPath = subPaths[ 0 ];\r\n\t\t\ttmpShape = new Shape();\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\treturn shapes;\r\n\r\n\t\t}\r\n\r\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\r\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\r\n\t\t// console.log(\"Holes first\", holesFirst);\r\n\r\n\t\tvar betterShapeHoles = [];\r\n\t\tvar newShapes = [];\r\n\t\tvar newShapeHoles = [];\r\n\t\tvar mainIdx = 0;\r\n\t\tvar tmpPoints;\r\n\r\n\t\tnewShapes[ mainIdx ] = undefined;\r\n\t\tnewShapeHoles[ mainIdx ] = [];\r\n\r\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\r\n\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\t\t\ttmpPoints = tmpPath.getPoints();\r\n\t\t\tsolid = isClockWise( tmpPoints );\r\n\t\t\tsolid = isCCW ? ! solid : solid;\r\n\r\n\t\t\tif ( solid ) {\r\n\r\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\t{ mainIdx ++; }\r\n\r\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\r\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\r\n\r\n\t\t\t\tif ( holesFirst )\t{ mainIdx ++; }\r\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\r\n\r\n\t\t\t\t//console.log('cw', i);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\r\n\r\n\t\t\t\t//console.log('ccw', i);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// only Holes? -> probably all Shapes with wrong orientation\r\n\t\tif ( ! newShapes[ 0 ] )\t{ return\ttoShapesNoHoles( subPaths ); }\r\n\r\n\t\tif ( newShapes.length > 1 ) {\r\n\r\n\t\t\tvar ambiguous = false;\r\n\t\t\tvar toChange = [];\r\n\r\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\r\n\r\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\r\n\t\t\t\t\tvar ho = sho[ hIdx ];\r\n\t\t\t\t\tvar hole_unassigned = true;\r\n\r\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\r\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\r\n\r\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\t{ toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } ); }\r\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\r\n\t\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tambiguous = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( hole_unassigned ) {\r\n\r\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\r\n\t\t\tif ( toChange.length > 0 ) {\r\n\r\n\t\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\t\tif ( ! ambiguous )\t{ newShapeHoles = betterShapeHoles; }\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar tmpHoles;\r\n\r\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\r\n\t\t\ttmpShape = newShapes[ i ].s;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\ttmpHoles = newShapeHoles[ i ];\r\n\r\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//console.log(\"shape\", shapes);\r\n\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SVGLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nSVGLoader.prototype = {\r\n\r\n\tconstructor: SVGLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( text ) {\r\n\r\n\t\tfunction parseNode( node, style ) {\r\n\r\n\t\t\tif ( node.nodeType !== 1 ) { return; }\r\n\r\n\t\t\tvar transform = getNodeTransform( node );\r\n\r\n\t\t\tvar path = null;\r\n\r\n\t\t\tswitch ( node.nodeName ) {\r\n\r\n\t\t\t\tcase 'svg':\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'g':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'path':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) && isVisible( style ) ) { path = parsePathNode( node, style ); }\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'rect':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( isVisible( style ) ) { path = parseRectNode( node, style ); }\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'polygon':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( isVisible( style ) ) { path = parsePolygonNode( node, style ); }\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'polyline':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( isVisible( style ) ) { path = parsePolylineNode( node, style ); }\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'circle':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( isVisible( style ) ) { path = parseCircleNode( node, style ); }\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ellipse':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( isVisible( style ) ) { path = parseEllipseNode( node, style ); }\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'line':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( isVisible( style ) ) { path = parseLineNode( node, style ); }\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tconsole.log( node );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( path ) {\r\n\r\n\t\t\t\ttransformPath( path, currentTransform );\r\n\r\n\t\t\t\tpaths.push( path );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar nodes = node.childNodes;\r\n\r\n\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\r\n\r\n\t\t\t\tparseNode( nodes[ i ], style );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( transform ) {\r\n\r\n\t\t\t\tcurrentTransform.copy( transformStack.pop() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePathNode( node, style ) {\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.color.setStyle( style.fill );\r\n\r\n\t\t\tvar point = new Vector2();\r\n\t\t\tvar control = new Vector2();\r\n\r\n\t\t\tvar firstPoint = new Vector2();\r\n\t\t\tvar isFirstPoint = true;\r\n\t\t\tvar doSetFirstPoint = false;\r\n\r\n\t\t\tvar d = node.getAttribute( 'd' );\r\n\r\n\t\t\t// console.log( d );\r\n\r\n\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\r\n\r\n\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar command = commands[ i ];\r\n\r\n\t\t\t\tvar type = command.charAt( 0 );\r\n\t\t\t\tvar data = command.substr( 1 ).trim();\r\n\r\n\t\t\t\tif ( isFirstPoint ) {\r\n\t\t\t\t\tdoSetFirstPoint = true;\r\n\t\t\t\t}\r\n\t\t\t\tisFirstPoint = false;\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\tcase 'M':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tif ( j === 0 ) {\r\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'H':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'V':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'L':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'C':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'S':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\r\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Q':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'T':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\r\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\trx,\r\n\t\t\t\t\t\t\t\try,\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = rx;\r\n\t\t\t\t\t\t\tcontrol.y = ry;\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'A':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\r\n\t\t\t\t\t\t\tvar start = point.clone();\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tparseArcCommand(\r\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t//\r\n\r\n\t\t\t\t\tcase 'm':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tif ( j === 0 ) {\r\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'h':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'l':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'c':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 's':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\r\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'q':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 't':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\r\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\trx,\r\n\t\t\t\t\t\t\t\try,\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = rx;\r\n\t\t\t\t\t\t\tcontrol.y = ry;\r\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'a':\r\n\t\t\t\t\t\tvar numbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\r\n\t\t\t\t\t\t\tvar start = point.clone();\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tparseArcCommand(\r\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t//\r\n\r\n\t\t\t\t\tcase 'Z':\r\n\t\t\t\t\tcase 'z':\r\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\r\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\r\n\t\t\t\t\t\t\t// Reset point to beginning of Path\r\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\r\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\r\n\t\t\t\t\t\t\tisFirstPoint = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.warn( command );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\r\n\r\n\t\t\t\tif ( doSetFirstPoint ) {\r\n\r\n\t\t\t\t\tfirstPoint.copy( point );\r\n\r\n\t\t\t\t\tdoSetFirstPoint = false;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\r\n\r\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\r\n\r\n\t\t\t// Ensure radii are positive\r\n\t\t\trx = Math.abs( rx );\r\n\t\t\try = Math.abs( ry );\r\n\r\n\t\t\t// Compute (x1′, y1′)\r\n\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\r\n\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\r\n\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\r\n\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\r\n\r\n\t\t\t// Compute (cx′, cy′)\r\n\t\t\tvar rxs = rx * rx;\r\n\t\t\tvar rys = ry * ry;\r\n\t\t\tvar x1ps = x1p * x1p;\r\n\t\t\tvar y1ps = y1p * y1p;\r\n\r\n\t\t\t// Ensure radii are large enough\r\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\r\n\r\n\t\t\tif ( cr > 1 ) {\r\n\r\n\t\t\t\t// scale up rx,ry equally so cr == 1\r\n\t\t\t\tvar s = Math.sqrt( cr );\r\n\t\t\t\trx = s * rx;\r\n\t\t\t\try = s * ry;\r\n\t\t\t\trxs = rx * rx;\r\n\t\t\t\trys = ry * ry;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\r\n\t\t\tvar pq = ( rxs * rys - dq ) / dq;\r\n\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\r\n\t\t\tif ( large_arc_flag === sweep_flag ) { q = - q; }\r\n\t\t\tvar cxp = q * rx * y1p / ry;\r\n\t\t\tvar cyp = - q * ry * x1p / rx;\r\n\r\n\t\t\t// Step 3: Compute (cx, cy) from (cx′, cy′)\r\n\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\r\n\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\r\n\r\n\t\t\t// Step 4: Compute θ1 and Δθ\r\n\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\r\n\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\r\n\r\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\r\n\r\n\t\t}\r\n\r\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\r\n\r\n\t\t\tvar dot = ux * vx + uy * vy;\r\n\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) *  Math.sqrt( vx * vx + vy * vy );\r\n\t\t\tvar ang = Math.acos( Math.max( -1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\r\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) { ang = - ang; }\r\n\t\t\treturn ang;\r\n\r\n\t\t}\r\n\t\t\r\n\t\tfunction parseRectNode( node, style ) {\r\n\r\n\t\t\tvar x = parseFloat( node.getAttribute( 'x' ) || 0 );\r\n\t\t\tvar y = parseFloat( node.getAttribute( 'y' ) || 0 );\r\n\t\t\tvar rx = parseFloat( node.getAttribute( 'rx' ) || 0 );\r\n\t\t\tvar ry = parseFloat( node.getAttribute( 'ry' ) || 0 );\r\n\t\t\tvar w = parseFloat( node.getAttribute( 'width' ) );\r\n\t\t\tvar h = parseFloat( node.getAttribute( 'height' ) );\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.color.setStyle( style.fill );\r\n\t\t\tpath.moveTo( x + 2 * rx, y );\r\n\t\t\tpath.lineTo( x + w - 2 * rx, y );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry ); }\r\n\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h ); }\r\n\t\t\tpath.lineTo( x + 2 * rx, y + h );\r\n\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tpath.lineTo( x, y + 2 * ry );\r\n\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePolygonNode( node, style ) {\r\n\r\n\t\t\tfunction iterator( match, a, b ) {\r\n\r\n\t\t\t\tvar x = parseFloat( a );\r\n\t\t\t\tvar y = parseFloat( b );\r\n\r\n\t\t\t\tif ( index === 0 ) {\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.color.setStyle( style.fill );\r\n\r\n\t\t\tvar index = 0;\r\n\r\n\t\t\tnode.getAttribute( 'points' ).replace(regex, iterator);\r\n\r\n\t\t\tpath.currentPath.autoClose = true;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePolylineNode( node, style ) {\r\n\r\n\t\t\tfunction iterator( match, a, b ) {\r\n\r\n\t\t\t\tvar x = parseFloat( a );\r\n\t\t\t\tvar y = parseFloat( b );\r\n\r\n\t\t\t\tif ( index === 0 ) {\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.color.setStyle( style.fill );\r\n\r\n\t\t\tvar index = 0;\r\n\r\n\t\t\tnode.getAttribute( 'points' ).replace(regex, iterator);\r\n\r\n\t\t\tpath.currentPath.autoClose = false;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCircleNode( node, style ) {\r\n\r\n\t\t\tvar x = parseFloat( node.getAttribute( 'cx' ) );\r\n\t\t\tvar y = parseFloat( node.getAttribute( 'cy' ) );\r\n\t\t\tvar r = parseFloat( node.getAttribute( 'r' ) );\r\n\r\n\t\t\tvar subpath = new Path();\r\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.color.setStyle( style.fill );\r\n\t\t\tpath.subPaths.push( subpath );\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEllipseNode( node, style ) {\r\n\r\n\t\t\tvar x = parseFloat( node.getAttribute( 'cx' ) );\r\n\t\t\tvar y = parseFloat( node.getAttribute( 'cy' ) );\r\n\t\t\tvar rx = parseFloat( node.getAttribute( 'rx' ) );\r\n\t\t\tvar ry = parseFloat( node.getAttribute( 'ry' ) );\r\n\r\n\t\t\tvar subpath = new Path();\r\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.color.setStyle( style.fill );\r\n\t\t\tpath.subPaths.push( subpath );\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseLineNode( node, style ) {\r\n\r\n\t\t\tvar x1 = parseFloat( node.getAttribute( 'x1' ) );\r\n\t\t\tvar y1 = parseFloat( node.getAttribute( 'y1' ) );\r\n\t\t\tvar x2 = parseFloat( node.getAttribute( 'x2' ) );\r\n\t\t\tvar y2 = parseFloat( node.getAttribute( 'y2' ) );\r\n\r\n\t\t\tvar path = new ShapePath();\r\n\t\t\tpath.moveTo( x1, y1 );\r\n\t\t\tpath.lineTo( x2, y2 );\r\n\t\t\tpath.currentPath.autoClose = false;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfunction parseStyle( node, style ) {\r\n\r\n\t\t\tstyle = Object.assign( {}, style ); // clone style\r\n\r\n\t\t\tif ( node.hasAttribute( 'fill' ) ) { style.fill = node.getAttribute( 'fill' ); }\r\n\t\t\tif ( node.style.fill !== '' ) { style.fill = node.style.fill; }\r\n\r\n\t\t\treturn style;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isVisible( style ) {\r\n\r\n\t\t\treturn style.fill !== 'none' && style.fill !== 'transparent';\r\n\r\n\t\t}\r\n\r\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\r\n\r\n\t\tfunction getReflection( a, b ) {\r\n\r\n\t\t\treturn a - ( b - a );\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseFloats( string ) {\r\n\r\n\t\t\tvar array = string.split( /[\\s,]+|(?=\\s?[+\\-])/ );\r\n\r\n\t\t\tfor ( var i = 0; i < array.length; i ++ ) {\r\n\r\n\t\t\t\tvar number = array[ i ];\r\n\r\n\t\t\t\t// Handle values like 48.6037.7.8\r\n\t\t\t\t// TODO Find a regex for this\r\n\r\n\t\t\t\tif ( number.indexOf( '.' ) !== number.lastIndexOf( '.' ) ) {\r\n\r\n\t\t\t\t\tvar split = number.split( '.' );\r\n\r\n\t\t\t\t\tfor ( var s = 2; s < split.length; s ++ ) {\r\n\r\n\t\t\t\t\t\tarray.splice( i + s - 1, 0, '0.' + split[ s ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tarray[ i ] = parseFloat( number );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNodeTransform( node ) {\r\n\r\n\t\t\tif ( ! node.hasAttribute( 'transform' ) ) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar transform = parseTransformNode( node );\r\n\r\n\t\t\tif ( transform ) {\r\n\r\n\t\t\t\tif ( transformStack.length > 0 ) {\r\n\t\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrentTransform.copy( transform );\r\n\t\t\t\ttransformStack.push( transform );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transform;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseTransformNode( node ) {\r\n\r\n\t\t\tvar transformAttr = node.getAttribute( 'transform' );\r\n\t\t\tvar transform = null;\r\n\t\t\tvar openParPos = transformAttr.indexOf( \"(\" );\r\n\t\t\tvar closeParPos = transformAttr.indexOf( \")\" );\r\n\r\n\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\r\n\r\n\t\t\t\tvar transformType = transformAttr.substr( 0, openParPos );\r\n\r\n\t\t\t\tvar array = parseFloats( transformAttr.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\r\n\r\n\t\t\t\tswitch ( transformType ) {\r\n\r\n\t\t\t\t\tcase \"translate\":\r\n\r\n\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\ttransform = new Matrix3();\r\n\r\n\t\t\t\t\t\t\tvar tx = array[ 0 ];\r\n\t\t\t\t\t\t\tvar ty = tx;\r\n\r\n\t\t\t\t\t\t\tif ( array.length >= 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tty = array[ 1 ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttransform.translate( tx, ty );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"rotate\":\r\n\r\n\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\tvar angle = 0;\r\n\t\t\t\t\t\t\tvar cx = 0;\r\n\t\t\t\t\t\t\tvar cy = 0;\r\n\r\n\t\t\t\t\t\t\ttransform = new Matrix3();\r\n\r\n\t\t\t\t\t\t\t// Angle\r\n\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\r\n\r\n\t\t\t\t\t\t\tif ( array.length >= 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t// Center x, y\r\n\t\t\t\t\t\t\t\tcx = array[ 1 ];\r\n\t\t\t\t\t\t\t\tcy = array[ 2 ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Rotate around center (cx, cy)\r\n\t\t\t\t\t\t\ttempTransform1.identity().translate( -cx, -cy );\r\n\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\r\n\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\r\n\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\r\n\t\t\t\t\t\t\ttransform.multiplyMatrices( tempTransform1, tempTransform3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"scale\":\r\n\r\n\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\ttransform = new Matrix3();\r\n\r\n\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\r\n\t\t\t\t\t\t\tvar scaleY = scaleX;\r\n\r\n\t\t\t\t\t\t\tif ( array.length >= 2 ) {\r\n\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttransform.scale( scaleX, scaleY );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"skewX\":\r\n\r\n\t\t\t\t\t\tif ( array.length === 1 ) {\r\n\r\n\t\t\t\t\t\t\ttransform = new Matrix3();\r\n\r\n\t\t\t\t\t\t\ttransform.set(\r\n\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\r\n\t\t\t\t\t\t\t\t0, 1, 0,\r\n\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"skewY\":\r\n\r\n\t\t\t\t\t\tif ( array.length === 1 ) {\r\n\r\n\t\t\t\t\t\t\ttransform = new Matrix3();\r\n\r\n\t\t\t\t\t\t\ttransform.set(\r\n\t\t\t\t\t\t\t\t1, 0, 0,\r\n\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\r\n\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase \"matrix\":\r\n\r\n\t\t\t\t\t\tif ( array.length === 6 ) {\r\n\r\n\t\t\t\t\t\t\ttransform = new Matrix3();\r\n\r\n\t\t\t\t\t\t\ttransform.set(\r\n\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\r\n\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\r\n\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transform;\r\n\r\n\t\t}\r\n\r\n\t\tfunction transformPath( path, m ) {\r\n\r\n\t\t\tfunction transfVec2( v2 ) {\r\n\r\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\r\n\r\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar isRotated = isTransformRotated( m );\r\n\r\n\t\t\tvar tempV2 = new Vector2();\r\n\t\t\tvar tempV3 = new Vector3();\r\n\r\n\t\t\tvar subPaths = path.subPaths;\r\n\r\n\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i++ ) {\r\n\r\n\t\t\t\tvar subPath = subPaths[ i ];\r\n\t\t\t\tvar curves = subPath.curves;\r\n\r\n\t\t\t\tfor ( var j = 0; j < curves.length; j++ ) {\r\n\r\n\t\t\t\t\tvar curve = curves[ j ];\r\n\r\n\t\t\t\t\tif ( curve.isLineCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\r\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v0 );\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\t\t\t\t\t\ttransfVec2( curve.v3 );\r\n\r\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v0 );\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\r\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\r\n\r\n\t\t\t\t\t\tif ( isRotated ) {\r\n\t\t\t\t\t\t\tconsole.warn( \"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\" );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\r\n\t\t\t\t\t\ttransfVec2( tempV2 );\r\n\t\t\t\t\t\tcurve.aX = tempV2.x;\r\n\t\t\t\t\t\tcurve.aY = tempV2.y;\r\n\r\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\r\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction isTransformRotated( m ) {\r\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\r\n\t\t}\r\n\r\n\t\tfunction getTransformScaleX( m ) {\r\n\t\t\tvar te = m.elements;\r\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] )\r\n\t\t}\r\n\r\n\t\tfunction getTransformScaleY( m ) {\r\n\t\t\tvar te = m.elements;\r\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] )\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconsole.log( 'SVGLoader' );\r\n\r\n\t\tvar paths = [];\r\n\r\n\t\tvar transformStack = [];\r\n\r\n\t\tvar tempTransform1 = new Matrix3();\r\n\t\tvar tempTransform2 = new Matrix3();\r\n\t\tvar tempTransform3 = new Matrix3();\r\n\r\n\t\tvar currentTransform = new Matrix3();\r\n\r\n\t\tconsole.time( 'SVGLoader: DOMParser' );\r\n\r\n\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\r\n\r\n\t\tconsole.timeEnd( 'SVGLoader: DOMParser' );\r\n\r\n\t\tconsole.time( 'SVGLoader: Parse' );\r\n\r\n\t\tparseNode( xml.documentElement, { fill: '#000' } );\r\n\r\n\t\t// console.log( paths );\r\n\r\n\t\tconsole.timeEnd( 'SVGLoader: Parse' );\r\n\r\n\t\treturn paths;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TDSLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\tthis.debug = false;\r\n\r\n\tthis.group = null;\r\n\tthis.position = 0;\r\n\r\n\tthis.materials = [];\r\n\tthis.meshes = [];\r\n\r\n};\r\n\r\nTDSLoader.prototype = {\r\n\r\n\tconstructor: TDSLoader,\r\n\t\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar path = this.path !== undefined ? this.path : LoaderUtils.extractUrlBase( url );\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tloader.load( url, function ( data ) {\r\n\r\n\t\t\tonLoad( scope.parse( data, path ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\t\r\n\tparse: function ( arraybuffer, path ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.group = new Group();\r\n\t\tthis.position = 0;\r\n\t\tthis.materials = [];\r\n\t\tthis.meshes = [];\r\n\r\n\t\tthis.readFile( arraybuffer, path );\r\n\r\n\t\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\r\n\r\n\t\t\tthis$1.group.add( this$1.meshes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.group;\r\n\r\n\t},\r\n\t\r\n\treadFile: function ( arraybuffer, path ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar data = new DataView( arraybuffer );\r\n\t\tvar chunk = this.readChunk( data );\r\n\r\n\t\tif ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {\r\n\r\n\t\t\tvar next = this.nextChunk( data, chunk );\r\n\r\n\t\t\twhile ( next !== 0 ) {\r\n\r\n\t\t\t\tif ( next === M3D_VERSION ) {\r\n\r\n\t\t\t\t\tvar version = this$1.readDWord( data );\r\n\t\t\t\t\tthis$1.debugMessage( '3DS file version: ' + version );\r\n\r\n\t\t\t\t} else if ( next === MDATA ) {\r\n\r\n\t\t\t\t\tthis$1.resetPosition( data );\r\n\t\t\t\t\tthis$1.readMeshData( data, path );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis$1.debugMessage( 'Unknown main chunk: ' + next.toString( 16 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnext = this$1.nextChunk( data, chunk );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );\r\n\r\n\t},\r\n\t\r\n\treadMeshData: function ( data, path ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar chunk = this.readChunk( data );\r\n\t\tvar next = this.nextChunk( data, chunk );\r\n\r\n\t\twhile ( next !== 0 ) {\r\n\r\n\t\t\tif ( next === MESH_VERSION ) {\r\n\r\n\t\t\t\tvar version = + this$1.readDWord( data );\r\n\t\t\t\tthis$1.debugMessage( 'Mesh Version: ' + version );\r\n\r\n\t\t\t} else if ( next === MASTER_SCALE ) {\r\n\r\n\t\t\t\tvar scale = this$1.readFloat( data );\r\n\t\t\t\tthis$1.debugMessage( 'Master scale: ' + scale );\r\n\t\t\t\tthis$1.group.scale.set( scale, scale, scale );\r\n\r\n\t\t\t} else if ( next === NAMED_OBJECT ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( 'Named Object' );\r\n\t\t\t\tthis$1.resetPosition( data );\r\n\t\t\t\tthis$1.readNamedObject( data );\r\n\r\n\t\t\t} else if ( next === MAT_ENTRY ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( 'Material' );\r\n\t\t\t\tthis$1.resetPosition( data );\r\n\t\t\t\tthis$1.readMaterialEntry( data, path );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis$1.debugMessage( 'Unknown MDATA chunk: ' + next.toString( 16 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnext = this$1.nextChunk( data, chunk );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\t\r\n\treadNamedObject: function ( data ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar chunk = this.readChunk( data );\r\n\t\tvar name = this.readString( data, 64 );\r\n\t\tchunk.cur = this.position;\r\n\r\n\t\tvar next = this.nextChunk( data, chunk );\r\n\t\twhile ( next !== 0 ) {\r\n\r\n\t\t\tif ( next === N_TRI_OBJECT ) {\r\n\r\n\t\t\t\tthis$1.resetPosition( data );\r\n\t\t\t\tvar mesh = this$1.readMesh( data );\r\n\t\t\t\tmesh.name = name;\r\n\t\t\t\tthis$1.meshes.push( mesh );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis$1.debugMessage( 'Unknown named object chunk: ' + next.toString( 16 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnext = this$1.nextChunk( data, chunk );\r\n\r\n\t\t}\r\n\r\n\t\tthis.endChunk( chunk );\r\n\r\n\t},\r\n\t\r\n\treadMaterialEntry: function ( data, path ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar chunk = this.readChunk( data );\r\n\t\tvar next = this.nextChunk( data, chunk );\r\n\t\tvar material = new MeshPhongMaterial();\r\n\r\n\t\twhile ( next !== 0 ) {\r\n\r\n\t\t\tif ( next === MAT_NAME ) {\r\n\r\n\t\t\t\tmaterial.name = this$1.readString( data, 64 );\r\n\t\t\t\tthis$1.debugMessage( '   Name: ' + material.name );\r\n\r\n\t\t\t} else if ( next === MAT_WIRE ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   Wireframe' );\r\n\t\t\t\tmaterial.wireframe = true;\r\n\r\n\t\t\t} else if ( next === MAT_WIRE_SIZE ) {\r\n\r\n\t\t\t\tvar value = this$1.readByte( data );\r\n\t\t\t\tmaterial.wireframeLinewidth = value;\r\n\t\t\t\tthis$1.debugMessage( '   Wireframe Thickness: ' + value );\r\n\r\n\t\t\t} else if ( next === MAT_TWO_SIDE ) {\r\n\r\n\t\t\t\tmaterial.side = DoubleSide;\r\n\t\t\t\tthis$1.debugMessage( '   DoubleSided' );\r\n\r\n\t\t\t} else if ( next === MAT_ADDITIVE ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   Additive Blending' );\r\n\t\t\t\tmaterial.blending = AdditiveBlending;\r\n\r\n\t\t\t} else if ( next === MAT_DIFFUSE ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   Diffuse Color' );\r\n\t\t\t\tmaterial.color = this$1.readColor( data );\r\n\r\n\t\t\t} else if ( next === MAT_SPECULAR ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   Specular Color' );\r\n\t\t\t\tmaterial.specular = this$1.readColor( data );\r\n\r\n\t\t\t} else if ( next === MAT_AMBIENT ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   Ambient color' );\r\n\t\t\t\tmaterial.color = this$1.readColor( data );\r\n\r\n\t\t\t} else if ( next === MAT_SHININESS ) {\r\n\r\n\t\t\t\tvar shininess = this$1.readWord( data );\r\n\t\t\t\tmaterial.shininess = shininess;\r\n\t\t\t\tthis$1.debugMessage( '   Shininess : ' + shininess );\r\n\r\n\t\t\t} else if ( next === MAT_TEXMAP ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   ColorMap' );\r\n\t\t\t\tthis$1.resetPosition( data );\r\n\t\t\t\tmaterial.map = this$1.readMap( data, path );\r\n\r\n\t\t\t} else if ( next === MAT_BUMPMAP ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   BumpMap' );\r\n\t\t\t\tthis$1.resetPosition( data );\r\n\t\t\t\tmaterial.bumpMap = this$1.readMap( data, path );\r\n\r\n\t\t\t} else if ( next === MAT_OPACMAP ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   OpacityMap' );\r\n\t\t\t\tthis$1.resetPosition( data );\r\n\t\t\t\tmaterial.alphaMap = this$1.readMap( data, path );\r\n\r\n\t\t\t} else if ( next === MAT_SPECMAP ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   SpecularMap' );\r\n\t\t\t\tthis$1.resetPosition( data );\r\n\t\t\t\tmaterial.specularMap = this$1.readMap( data, path );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   Unknown material chunk: ' + next.toString( 16 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnext = this$1.nextChunk( data, chunk );\r\n\r\n\t\t}\r\n\r\n\t\tthis.endChunk( chunk );\r\n\r\n\t\tthis.materials[ material.name ] = material;\r\n\r\n\t},\r\n\t\r\n\treadMesh: function ( data ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar chunk = this.readChunk( data );\r\n\t\tvar next = this.nextChunk( data, chunk );\r\n\r\n\t\tvar geometry = new BufferGeometry();\r\n\t\tvar uvs = [];\r\n\r\n\t\tvar material = new MeshPhongMaterial();\r\n\t\tvar mesh = new Mesh( geometry, material );\r\n\t\tmesh.name = 'mesh';\r\n\r\n\t\twhile ( next !== 0 ) {\r\n\r\n\t\t\tif ( next === POINT_ARRAY ) {\r\n\r\n\t\t\t\tvar points = this$1.readWord( data );\r\n\r\n\t\t\t\tthis$1.debugMessage( '   Vertex: ' + points );\r\n\r\n\t\t\t\t//BufferGeometry\r\n\r\n\t\t\t\tvar vertices = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < points; i ++ )\t\t{\r\n\r\n\t\t\t\t\tvertices.push( this$1.readFloat( data ) );\r\n\t\t\t\t\tvertices.push( this$1.readFloat( data ) );\r\n\t\t\t\t\tvertices.push( this$1.readFloat( data ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\r\n\t\t\t} else if ( next === FACE_ARRAY ) {\r\n\r\n\t\t\t\tthis$1.resetPosition( data );\r\n\t\t\t\tthis$1.readFaceArray( data, mesh );\r\n\r\n\t\t\t} else if ( next === TEX_VERTS ) {\r\n\r\n\t\t\t\tvar texels = this$1.readWord( data );\r\n\r\n\t\t\t\tthis$1.debugMessage( '   UV: ' + texels );\r\n\r\n\t\t\t\t//BufferGeometry\r\n\r\n\t\t\t\tvar uvs = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < texels; i ++ )\t\t{\r\n\r\n\t\t\t\t\tuvs.push( this$1.readFloat( data ) );\r\n\t\t\t\t\tuvs.push( this$1.readFloat( data ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\t\t} else if ( next === MESH_MATRIX ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   Tranformation Matrix (TODO)' );\r\n\r\n\t\t\t\tvar values = [];\r\n\t\t\t\tfor ( var i = 0; i < 12; i ++ ) {\r\n\r\n\t\t\t\t\tvalues[ i ] = this$1.readFloat( data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar matrix = new Matrix4();\r\n\r\n\t\t\t\t//X Line\r\n\t\t\t\tmatrix.elements[ 0 ] = values[ 0 ];\r\n\t\t\t\tmatrix.elements[ 1 ] = values[ 6 ];\r\n\t\t\t\tmatrix.elements[ 2 ] = values[ 3 ];\r\n\t\t\t\tmatrix.elements[ 3 ] = values[ 9 ];\r\n\r\n\t\t\t\t//Y Line\r\n\t\t\t\tmatrix.elements[ 4 ] = values[ 2 ];\r\n\t\t\t\tmatrix.elements[ 5 ] = values[ 8 ];\r\n\t\t\t\tmatrix.elements[ 6 ] = values[ 5 ];\r\n\t\t\t\tmatrix.elements[ 7 ] = values[ 11 ];\r\n\r\n\t\t\t\t//Z Line\r\n\t\t\t\tmatrix.elements[ 8 ] = values[ 1 ];\r\n\t\t\t\tmatrix.elements[ 9 ] = values[ 7 ];\r\n\t\t\t\tmatrix.elements[ 10 ] = values[ 4 ];\r\n\t\t\t\tmatrix.elements[ 11 ] = values[ 10 ];\r\n\r\n\t\t\t\t//W Line\r\n\t\t\t\tmatrix.elements[ 12 ] = 0;\r\n\t\t\t\tmatrix.elements[ 13 ] = 0;\r\n\t\t\t\tmatrix.elements[ 14 ] = 0;\r\n\t\t\t\tmatrix.elements[ 15 ] = 1;\r\n\r\n\t\t\t\tmatrix.transpose();\r\n\r\n\t\t\t\tvar inverse = new Matrix4();\r\n\t\t\t\tinverse.getInverse( matrix, true );\r\n\t\t\t\tgeometry.applyMatrix( inverse );\r\n\r\n\t\t\t\tmatrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis$1.debugMessage( '   Unknown mesh chunk: ' + next.toString( 16 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnext = this$1.nextChunk( data, chunk );\r\n\r\n\t\t}\r\n\r\n\t\tthis.endChunk( chunk );\r\n\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t\treturn mesh;\r\n\r\n\t},\r\n\t\r\n\treadFaceArray: function ( data, mesh ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar chunk = this.readChunk( data );\r\n\t\tvar faces = this.readWord( data );\r\n\r\n\t\tthis.debugMessage( '   Faces: ' + faces );\r\n\r\n\t\tvar index = [];\r\n\r\n\t\tfor ( var i = 0; i < faces; ++ i ) {\r\n\r\n\t\t\tindex.push( this$1.readWord( data ), this$1.readWord( data ), this$1.readWord( data ) );\r\n\r\n\t\t\tvar visibility = this$1.readWord( data );\r\n\r\n\t\t}\r\n\r\n\t\tmesh.geometry.setIndex( index );\r\n\r\n\t\t//The rest of the FACE_ARRAY chunk is subchunks\r\n\r\n\t\twhile ( this.position < chunk.end ) {\r\n\r\n\t\t\tvar chunk = this$1.readChunk( data );\r\n\r\n\t\t\tif ( chunk.id === MSH_MAT_GROUP ) {\r\n\r\n\t\t\t\tthis$1.debugMessage( '      Material Group' );\r\n\r\n\t\t\t\tthis$1.resetPosition( data );\r\n\r\n\t\t\t\tvar group = this$1.readMaterialGroup( data );\r\n\r\n\t\t\t\tvar material = this$1.materials[ group.name ];\r\n\r\n\t\t\t\tif ( material !== undefined )\t{\r\n\r\n\t\t\t\t\tmesh.material = material;\r\n\r\n\t\t\t\t\tif ( material.name === '' )\t\t{\r\n\r\n\t\t\t\t\t\tmaterial.name = mesh.name;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis$1.debugMessage( '      Unknown face array chunk: ' + chunk.toString( 16 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis$1.endChunk( chunk );\r\n\r\n\t\t}\r\n\r\n\t\tthis.endChunk( chunk );\r\n\r\n\t},\r\n\t\r\n\treadMap: function ( data, path ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar chunk = this.readChunk( data );\r\n\t\tvar next = this.nextChunk( data, chunk );\r\n\t\tvar texture = {};\r\n\r\n\t\tvar loader = new TextureLoader( this.manager );\r\n\t\tloader.setPath( path );\r\n\r\n\t\twhile ( next !== 0 ) {\r\n\r\n\t\t\tif ( next === MAT_MAPNAME ) {\r\n\r\n\t\t\t\tvar name = this$1.readString( data, 128 );\r\n\t\t\t\ttexture = loader.load( name );\r\n\r\n\t\t\t\tthis$1.debugMessage( '      File: ' + path + name );\r\n\r\n\t\t\t} else if ( next === MAT_MAP_UOFFSET ) {\r\n\r\n\t\t\t\ttexture.offset.x = this$1.readFloat( data );\r\n\t\t\t\tthis$1.debugMessage( '      OffsetX: ' + texture.offset.x );\r\n\r\n\t\t\t} else if ( next === MAT_MAP_VOFFSET ) {\r\n\r\n\t\t\t\ttexture.offset.y = this$1.readFloat( data );\r\n\t\t\t\tthis$1.debugMessage( '      OffsetY: ' + texture.offset.y );\r\n\r\n\t\t\t} else if ( next === MAT_MAP_USCALE ) {\r\n\r\n\t\t\t\ttexture.repeat.x = this$1.readFloat( data );\r\n\t\t\t\tthis$1.debugMessage( '      RepeatX: ' + texture.repeat.x );\r\n\r\n\t\t\t} else if ( next === MAT_MAP_VSCALE ) {\r\n\r\n\t\t\t\ttexture.repeat.y = this$1.readFloat( data );\r\n\t\t\t\tthis$1.debugMessage( '      RepeatY: ' + texture.repeat.y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis$1.debugMessage( '      Unknown map chunk: ' + next.toString( 16 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnext = this$1.nextChunk( data, chunk );\r\n\r\n\t\t}\r\n\r\n\t\tthis.endChunk( chunk );\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\t\r\n\treadMaterialGroup: function ( data ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar chunk = this.readChunk( data );\r\n\t\tvar name = this.readString( data, 64 );\r\n\t\tvar numFaces = this.readWord( data );\r\n\r\n\t\tthis.debugMessage( '         Name: ' + name );\r\n\t\tthis.debugMessage( '         Faces: ' + numFaces );\r\n\r\n\t\tvar index = [];\r\n\t\tfor ( var i = 0; i < numFaces; ++ i ) {\r\n\r\n\t\t\tindex.push( this$1.readWord( data ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn { name: name, index: index };\r\n\r\n\t},\r\n\t\r\n\treadColor: function ( data ) {\r\n\r\n\t\tvar chunk = this.readChunk( data );\r\n\t\tvar color = new Color();\r\n\r\n\t\tif ( chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24 ) {\r\n\r\n\t\t\tvar r = this.readByte( data );\r\n\t\t\tvar g = this.readByte( data );\r\n\t\t\tvar b = this.readByte( data );\r\n\r\n\t\t\tcolor.setRGB( r / 255, g / 255, b / 255 );\r\n\r\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\r\n\r\n\t\t}\telse if ( chunk.id === COLOR_F || chunk.id === LIN_COLOR_F ) {\r\n\r\n\t\t\tvar r = this.readFloat( data );\r\n\t\t\tvar g = this.readFloat( data );\r\n\t\t\tvar b = this.readFloat( data );\r\n\r\n\t\t\tcolor.setRGB( r, g, b );\r\n\r\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\r\n\r\n\t\t}\telse {\r\n\r\n\t\t\tthis.debugMessage( '      Unknown color chunk: ' + chunk.toString( 16 ) );\r\n\r\n\t\t}\r\n\r\n\t\tthis.endChunk( chunk );\r\n\t\treturn color;\r\n\r\n\t},\r\n\t\r\n\treadChunk: function ( data ) {\r\n\r\n\t\tvar chunk = {};\r\n\r\n\t\tchunk.cur = this.position;\r\n\t\tchunk.id = this.readWord( data );\r\n\t\tchunk.size = this.readDWord( data );\r\n\t\tchunk.end = chunk.cur + chunk.size;\r\n\t\tchunk.cur += 6;\r\n\r\n\t\treturn chunk;\r\n\r\n\t},\r\n\t\r\n\tendChunk: function ( chunk ) {\r\n\r\n\t\tthis.position = chunk.end;\r\n\r\n\t},\r\n\t\r\n\tnextChunk: function ( data, chunk ) {\r\n\r\n\t\tif ( chunk.cur >= chunk.end ) {\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tthis.position = chunk.cur;\r\n\r\n\t\ttry {\r\n\r\n\t\t\tvar next = this.readChunk( data );\r\n\t\t\tchunk.cur += next.size;\r\n\t\t\treturn next.id;\r\n\r\n\t\t}\tcatch ( e ) {\r\n\r\n\t\t\tthis.debugMessage( 'Unable to read chunk at ' + this.position );\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\t\r\n\tresetPosition: function () {\r\n\r\n\t\tthis.position -= 6;\r\n\r\n\t},\r\n\t\r\n\treadByte: function ( data ) {\r\n\r\n\t\tvar v = data.getUint8( this.position, true );\r\n\t\tthis.position += 1;\r\n\t\treturn v;\r\n\r\n\t},\r\n\t\r\n\treadFloat: function ( data ) {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tvar v = data.getFloat32( this.position, true );\r\n\t\t\tthis.position += 4;\r\n\t\t\treturn v;\r\n\r\n\t\t}\tcatch ( e ) {\r\n\r\n\t\t\tthis.debugMessage( e + ' ' + this.position + ' ' + data.byteLength );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\t\r\n\treadInt: function ( data ) {\r\n\r\n\t\tvar v = data.getInt32( this.position, true );\r\n\t\tthis.position += 4;\r\n\t\treturn v;\r\n\r\n\t},\r\n\t\r\n\treadShort: function ( data ) {\r\n\r\n\t\tvar v = data.getInt16( this.position, true );\r\n\t\tthis.position += 2;\r\n\t\treturn v;\r\n\r\n\t},\r\n\t\r\n\treadDWord: function ( data ) {\r\n\r\n\t\tvar v = data.getUint32( this.position, true );\r\n\t\tthis.position += 4;\r\n\t\treturn v;\r\n\r\n\t},\r\n\t\r\n\treadWord: function ( data ) {\r\n\r\n\t\tvar v = data.getUint16( this.position, true );\r\n\t\tthis.position += 2;\r\n\t\treturn v;\r\n\r\n\t},\r\n\t\r\n\treadString: function ( data, maxLength ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar s = '';\r\n\r\n\t\tfor ( var i = 0; i < maxLength; i ++ ) {\r\n\r\n\t\t\tvar c = this$1.readByte( data );\r\n\t\t\tif ( ! c ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ts += String.fromCharCode( c );\r\n\r\n\t\t}\r\n\r\n\t\treturn s;\r\n\r\n\t},\r\n\t\r\n\tsetPath: function ( path ) {\r\n\r\n\t\tthis.path = path;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\t\r\n\tdebugMessage: function ( message ) {\r\n\r\n\t\tif ( this.debug ) {\r\n\r\n\t\t\tconsole.log( message );\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\nvar M3DMAGIC = 0x4D4D;\r\nvar MLIBMAGIC = 0x3DAA;\r\nvar CMAGIC = 0xC23D;\r\nvar M3D_VERSION = 0x0002;\r\nvar COLOR_F = 0x0010;\r\nvar COLOR_24 = 0x0011;\r\nvar LIN_COLOR_24 = 0x0012;\r\nvar LIN_COLOR_F = 0x0013;\r\nvar MDATA = 0x3D3D;\r\nvar MESH_VERSION = 0x3D3E;\r\nvar MASTER_SCALE = 0x0100;\r\nvar MAT_ENTRY = 0xAFFF;\r\nvar MAT_NAME = 0xA000;\r\nvar MAT_AMBIENT = 0xA010;\r\nvar MAT_DIFFUSE = 0xA020;\r\nvar MAT_SPECULAR = 0xA030;\r\nvar MAT_SHININESS = 0xA040;\r\nvar MAT_TWO_SIDE = 0xA081;\r\nvar MAT_ADDITIVE = 0xA083;\r\nvar MAT_WIRE = 0xA085;\r\nvar MAT_WIRE_SIZE = 0xA087;\r\nvar MAT_TEXMAP = 0xA200;\r\nvar MAT_OPACMAP = 0xA210;\r\nvar MAT_BUMPMAP = 0xA230;\r\nvar MAT_SPECMAP = 0xA204;\r\nvar MAT_MAPNAME = 0xA300;\r\nvar MAT_MAP_USCALE = 0xA354;\r\nvar MAT_MAP_VSCALE = 0xA356;\r\nvar MAT_MAP_UOFFSET = 0xA358;\r\nvar MAT_MAP_VOFFSET = 0xA35A;\r\nvar NAMED_OBJECT = 0x4000;\r\nvar N_TRI_OBJECT = 0x4100;\r\nvar POINT_ARRAY = 0x4110;\r\nvar FACE_ARRAY = 0x4120;\r\nvar MSH_MAT_GROUP = 0x4130;\r\nvar TEX_VERTS = 0x4140;\r\nvar MESH_MATRIX = 0x4160;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TTFLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\tthis.reversed = false;\r\n\r\n};\r\n\r\nTTFLoader.prototype = {\r\n\r\n\tconstructor: TTFLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tonLoad( scope.parse( buffer ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( arraybuffer ) {\r\n\r\n\t\tfunction convert( font, reversed ) {\r\n\r\n\t\t\tvar round = Math.round;\r\n\r\n\t\t\tvar glyphs = {};\r\n\t\t\tvar scale = ( 100000 ) / ( ( font.unitsPerEm || 2048 ) * 72 );\r\n\r\n\t\t\tfor ( var i = 0; i < font.glyphs.length; i ++ ) {\r\n\r\n\t\t\t\tvar glyph = font.glyphs.glyphs[ i ];\r\n\r\n\t\t\t\tif ( glyph.unicode !== undefined ) {\r\n\r\n\t\t\t\t\tvar token = {\r\n\t\t\t\t\t\tha: round( glyph.advanceWidth * scale ),\r\n\t\t\t\t\t\tx_min: round( glyph.xMin * scale ),\r\n\t\t\t\t\t\tx_max: round( glyph.xMax * scale ),\r\n\t\t\t\t\t\to: ''\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif ( reversed ) {\r\n\r\n\t\t\t\t\t\tglyph.path.commands = reverseCommands( glyph.path.commands );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tglyph.path.commands.forEach( function ( command, i ) {\r\n\r\n\t\t\t\t\t\tif ( command.type.toLowerCase() === 'c' ) {\r\n\r\n\t\t\t\t\t\t\tcommand.type = 'b';\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttoken.o += command.type.toLowerCase() + ' ';\r\n\r\n\t\t\t\t\t\tif ( command.x !== undefined && command.y !== undefined ) {\r\n\r\n\t\t\t\t\t\t\ttoken.o += round( command.x * scale ) + ' ' + round( command.y * scale ) + ' ';\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( command.x1 !== undefined && command.y1 !== undefined ) {\r\n\r\n\t\t\t\t\t\t\ttoken.o += round( command.x1 * scale ) + ' ' + round( command.y1 * scale ) + ' ';\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( command.x2 !== undefined && command.y2 !== undefined ) {\r\n\r\n\t\t\t\t\t\t\ttoken.o += round( command.x2 * scale ) + ' ' + round( command.y2 * scale ) + ' ';\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tglyphs[ String.fromCharCode( glyph.unicode ) ] = token;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tglyphs: glyphs,\r\n\t\t\t\tfamilyName: font.familyName,\r\n\t\t\t\tascender: round( font.ascender * scale ),\r\n\t\t\t\tdescender: round( font.descender * scale ),\r\n\t\t\t\tunderlinePosition: font.tables.post.underlinePosition,\r\n\t\t\t\tunderlineThickness: font.tables.post.underlineThickness,\r\n\t\t\t\tboundingBox: {\r\n\t\t\t\t\txMin: font.tables.head.xMin,\r\n\t\t\t\t\txMax: font.tables.head.xMax,\r\n\t\t\t\t\tyMin: font.tables.head.yMin,\r\n\t\t\t\t\tyMax: font.tables.head.yMax\r\n\t\t\t\t},\r\n\t\t\t\tresolution: 1000,\r\n\t\t\t\toriginal_font_information: font.tables.name\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction reverseCommands( commands ) {\r\n\r\n\t\t\tvar paths = [];\r\n\t\t\tvar path;\r\n\r\n\t\t\tcommands.forEach( function ( c ) {\r\n\r\n\t\t\t\tif ( c.type.toLowerCase() === 'm' ) {\r\n\r\n\t\t\t\t\tpath = [ c ];\r\n\t\t\t\t\tpaths.push( path );\r\n\r\n\t\t\t\t} else if ( c.type.toLowerCase() !== 'z' ) {\r\n\r\n\t\t\t\t\tpath.push( c );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tvar reversed = [];\r\n\r\n\t\t\tpaths.forEach( function ( p ) {\r\n\r\n\t\t\t\tvar result = {\r\n\t\t\t\t\ttype: 'm',\r\n\t\t\t\t\tx: p[ p.length - 1 ].x,\r\n\t\t\t\t\ty: p[ p.length - 1 ].y\r\n\t\t\t\t};\r\n\r\n\t\t\t\treversed.push( result );\r\n\r\n\t\t\t\tfor ( var i = p.length - 1; i > 0; i -- ) {\r\n\r\n\t\t\t\t\tvar command = p[ i ];\r\n\t\t\t\t\tvar result = { type: command.type };\r\n\r\n\t\t\t\t\tif ( command.x2 !== undefined && command.y2 !== undefined ) {\r\n\r\n\t\t\t\t\t\tresult.x1 = command.x2;\r\n\t\t\t\t\t\tresult.y1 = command.y2;\r\n\t\t\t\t\t\tresult.x2 = command.x1;\r\n\t\t\t\t\t\tresult.y2 = command.y1;\r\n\r\n\t\t\t\t\t} else if ( command.x1 !== undefined && command.y1 !== undefined ) {\r\n\r\n\t\t\t\t\t\tresult.x1 = command.x1;\r\n\t\t\t\t\t\tresult.y1 = command.y1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresult.x = p[ i - 1 ].x;\r\n\t\t\t\t\tresult.y = p[ i - 1 ].y;\r\n\t\t\t\t\treversed.push( result );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn reversed;\r\n\r\n\t\t}\r\n\r\n\t\tif ( typeof opentype === 'undefined' ) {\r\n\r\n\t\t\tconsole.warn( 'TTFLoader: The loader requires opentype.js. Make sure it\\'s included before using the loader.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn convert( opentype.parse( arraybuffer ), this.reversed );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar VRMLLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nVRMLLoader.prototype = {\r\n\r\n\tconstructor: VRMLLoader,\r\n\r\n\t// for IndexedFaceSet support\r\n\tisRecordingPoints: false,\r\n\tisRecordingFaces: false,\r\n\tpoints: [],\r\n\tindexes: [],\r\n\r\n\t// for Background support\r\n\tisRecordingAngles: false,\r\n\tisRecordingColors: false,\r\n\tangles: [],\r\n\tcolors: [],\r\n\r\n\trecordingFieldname: null,\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tparse: function ( data ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar texturePath = this.texturePath || '';\r\n\r\n\t\tvar textureLoader = new TextureLoader( this.manager );\r\n\t\ttextureLoader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tfunction parseV2( lines, scene ) {\r\n\r\n\t\t\tvar defines = {};\r\n\t\t\tvar float_pattern = /(\\b|\\-|\\+)([\\d\\.e]+)/;\r\n\t\t\tvar float2_pattern = /([\\d\\.\\+\\-e]+)\\s+([\\d\\.\\+\\-e]+)/g;\r\n\t\t\tvar float3_pattern = /([\\d\\.\\+\\-e]+)\\s+([\\d\\.\\+\\-e]+)\\s+([\\d\\.\\+\\-e]+)/g;\r\n\t\t\t\r\n\t\t\tfunction paintFaces( geometry, radius, angles, colors, topDown ) {\r\n\r\n\t\t\t\tvar direction = ( topDown === true ) ? 1 : - 1;\r\n\r\n\t\t\t\tvar coord = [], A = {}, B = {}, applyColor = false;\r\n\r\n\t\t\t\tfor ( var k = 0; k < angles.length; k ++ ) {\r\n\r\n\t\t\t\t\t// push the vector at which the color changes\r\n\r\n\t\t\t\t\tvar vec = {\r\n\t\t\t\t\t\tx: direction * ( Math.cos( angles[ k ] ) * radius ),\r\n\t\t\t\t\t\ty: direction * ( Math.sin( angles[ k ] ) * radius )\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tcoord.push( vec );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar positionAttribute = geometry.attributes.position;\r\n\t\t\t\tvar colorAttribute = new BufferAttribute( new Float32Array( geometry.attributes.position.count * 3 ), 3 );\r\n\r\n\t\t\t\tvar position = new Vector3();\r\n\t\t\t\tvar color = new Color();\r\n\r\n\t\t\t\tfor ( var i = 0; i < index.count; i ++ ) {\r\n\r\n\t\t\t\t\tvar vertexIndex = index.getX( i );\r\n\r\n\t\t\t\t\tposition.fromBufferAttribute( positionAttribute, vertexIndex );\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < colors.length; j ++ ) {\r\n\r\n\t\t\t\t\t\t// linear interpolation between aColor and bColor, calculate proportion\r\n\t\t\t\t\t\t// A is previous point (angle)\r\n\r\n\t\t\t\t\t\tif ( j === 0 ) {\r\n\r\n\t\t\t\t\t\t\tA.x = 0;\r\n\t\t\t\t\t\t\tA.y = ( topDown === true ) ? radius : - 1 * radius;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tA.x = coord[ j - 1 ].x;\r\n\t\t\t\t\t\t\tA.y = coord[ j - 1 ].y;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// B is current point (angle)\r\n\r\n\t\t\t\t\t\tB = coord[ j ];\r\n\r\n\t\t\t\t\t\tif ( B !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t// p has to be between the points A and B which we interpolate\r\n\r\n\t\t\t\t\t\t\tapplyColor = ( topDown === true ) ? ( position.y <= A.y && position.y > B.y ) : ( position.y >= A.y && position.y < B.y );\r\n\r\n\t\t\t\t\t\t\tif ( applyColor === true ) {\r\n\r\n\t\t\t\t\t\t\t\tvar aColor = colors[ j ];\r\n\t\t\t\t\t\t\t\tvar bColor = colors[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\t\t// below is simple linear interpolation\r\n\r\n\t\t\t\t\t\t\t\tvar t = Math.abs( position.y - A.y ) / ( A.y - B.y );\r\n\r\n\t\t\t\t\t\t\t\t// to make it faster, you can only calculate this if the y coord changes, the color is the same for points with the same y\r\n\r\n\t\t\t\t\t\t\t\tcolor.copy( aColor ).lerp( bColor, t );\r\n\r\n\t\t\t\t\t\t\t\tcolorAttribute.setXYZ( vertexIndex, color.r, color.g, color.b );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tvar colorIndex = ( topDown === true ) ? colors.length - 1 : 0;\r\n\t\t\t\t\t\t\t\tvar c = colors[ colorIndex ];\r\n\t\t\t\t\t\t\t\tcolorAttribute.setXYZ( vertexIndex, c.r, c.g, c.b );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.addAttribute( 'color', colorAttribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar index = [];\r\n\r\n\t\t\tfunction parseProperty( node, line ) {\r\n\r\n\t\t\t\tvar parts = [], part, property = {}, fieldName;\r\n\t\t\t\t\r\n\t\t\t\tvar regex = /[^\\s,\\[\\]]+/g;\r\n\r\n\t\t\t\tvar point;\r\n\r\n\t\t\t\twhile ( null !== ( part = regex.exec( line ) ) ) {\r\n\r\n\t\t\t\t\tparts.push( part[ 0 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfieldName = parts[ 0 ];\r\n\r\n\t\t\t\t// trigger several recorders\r\n\t\t\t\tswitch ( fieldName ) {\r\n\r\n\t\t\t\t\tcase 'skyAngle':\r\n\t\t\t\t\tcase 'groundAngle':\r\n\t\t\t\t\t\tscope.recordingFieldname = fieldName;\r\n\t\t\t\t\t\tscope.isRecordingAngles = true;\r\n\t\t\t\t\t\tscope.angles = [];\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'skyColor':\r\n\t\t\t\t\tcase 'groundColor':\r\n\t\t\t\t\t\tscope.recordingFieldname = fieldName;\r\n\t\t\t\t\t\tscope.isRecordingColors = true;\r\n\t\t\t\t\t\tscope.colors = [];\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'point':\r\n\t\t\t\t\t\tscope.recordingFieldname = fieldName;\r\n\t\t\t\t\t\tscope.isRecordingPoints = true;\r\n\t\t\t\t\t\tscope.points = [];\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'coordIndex':\r\n\t\t\t\t\tcase 'texCoordIndex':\r\n\t\t\t\t\t\tscope.recordingFieldname = fieldName;\r\n\t\t\t\t\t\tscope.isRecordingFaces = true;\r\n\t\t\t\t\t\tscope.indexes = [];\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( scope.isRecordingFaces ) {\r\n\r\n\t\t\t\t\t// the parts hold the indexes as strings\r\n\t\t\t\t\tif ( parts.length > 0 ) {\r\n\r\n\t\t\t\t\t\tfor ( var ind = 0; ind < parts.length; ind ++ ) {\r\n\r\n\t\t\t\t\t\t\t// the part should either be positive integer or -1\r\n\t\t\t\t\t\t\tif ( ! /(-?\\d+)/.test( parts[ ind ] ) ) {\r\n\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// end of current face\r\n\t\t\t\t\t\t\tif ( parts[ ind ] === '-1' ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( index.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tscope.indexes.push( index );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// start new one\r\n\t\t\t\t\t\t\t\tindex = [];\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tindex.push( parseInt( parts[ ind ] ) );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// end\r\n\t\t\t\t\tif ( /]/.exec( line ) ) {\r\n\r\n\t\t\t\t\t\tif ( index.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\tscope.indexes.push( index );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// start new one\r\n\t\t\t\t\t\tindex = [];\r\n\r\n\t\t\t\t\t\tscope.isRecordingFaces = false;\r\n\t\t\t\t\t\tnode[ scope.recordingFieldname ] = scope.indexes;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( scope.isRecordingPoints ) {\r\n\r\n\t\t\t\t\tif ( node.nodeType == 'Coordinate' ) {\r\n\r\n\t\t\t\t\t\twhile ( null !== ( parts = float3_pattern.exec( line ) ) ) {\r\n\r\n\t\t\t\t\t\t\tpoint = {\r\n\t\t\t\t\t\t\t\tx: parseFloat( parts[ 1 ] ),\r\n\t\t\t\t\t\t\t\ty: parseFloat( parts[ 2 ] ),\r\n\t\t\t\t\t\t\t\tz: parseFloat( parts[ 3 ] )\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\tscope.points.push( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( node.nodeType == 'TextureCoordinate' ) {\r\n\r\n\t\t\t\t\t\twhile ( null !== ( parts = float2_pattern.exec( line ) ) ) {\r\n\r\n\t\t\t\t\t\t\tpoint = {\r\n\t\t\t\t\t\t\t\tx: parseFloat( parts[ 1 ] ),\r\n\t\t\t\t\t\t\t\ty: parseFloat( parts[ 2 ] )\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\tscope.points.push( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// end\r\n\t\t\t\t\tif ( /]/.exec( line ) ) {\r\n\r\n\t\t\t\t\t\tscope.isRecordingPoints = false;\r\n\t\t\t\t\t\tnode.points = scope.points;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( scope.isRecordingAngles ) {\r\n\r\n\t\t\t\t\t// the parts hold the angles as strings\r\n\t\t\t\t\tif ( parts.length > 0 ) {\r\n\r\n\t\t\t\t\t\tfor ( var ind = 0; ind < parts.length; ind ++ ) {\r\n\r\n\t\t\t\t\t\t\t// the part should be a float\r\n\t\t\t\t\t\t\tif ( ! float_pattern.test( parts[ ind ] ) ) {\r\n\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tscope.angles.push( parseFloat( parts[ ind ] ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// end\r\n\t\t\t\t\tif ( /]/.exec( line ) ) {\r\n\r\n\t\t\t\t\t\tscope.isRecordingAngles = false;\r\n\t\t\t\t\t\tnode[ scope.recordingFieldname ] = scope.angles;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( scope.isRecordingColors ) {\r\n\r\n\t\t\t\t\twhile ( null !== ( parts = float3_pattern.exec( line ) ) ) {\r\n\r\n\t\t\t\t\t\tvar color = {\r\n\t\t\t\t\t\t\tr: parseFloat( parts[ 1 ] ),\r\n\t\t\t\t\t\t\tg: parseFloat( parts[ 2 ] ),\r\n\t\t\t\t\t\t\tb: parseFloat( parts[ 3 ] )\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tscope.colors.push( color );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// end\r\n\t\t\t\t\tif ( /]/.exec( line ) ) {\r\n\r\n\t\t\t\t\t\tscope.isRecordingColors = false;\r\n\t\t\t\t\t\tnode[ scope.recordingFieldname ] = scope.colors;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( parts[ parts.length - 1 ] !== 'NULL' && fieldName !== 'children' ) {\r\n\r\n\t\t\t\t\tswitch ( fieldName ) {\r\n\r\n\t\t\t\t\t\tcase 'diffuseColor':\r\n\t\t\t\t\t\tcase 'emissiveColor':\r\n\t\t\t\t\t\tcase 'specularColor':\r\n\t\t\t\t\t\tcase 'color':\r\n\r\n\t\t\t\t\t\t\tif ( parts.length !== 4 ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'VRMLLoader: Invalid color format detected for %s.', fieldName );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tproperty = {\r\n\t\t\t\t\t\t\t\tr: parseFloat( parts[ 1 ] ),\r\n\t\t\t\t\t\t\t\tg: parseFloat( parts[ 2 ] ),\r\n\t\t\t\t\t\t\t\tb: parseFloat( parts[ 3 ] )\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'location':\r\n\t\t\t\t\t\tcase 'direction':\r\n\t\t\t\t\t\tcase 'translation':\r\n\t\t\t\t\t\tcase 'scale':\r\n\t\t\t\t\t\tcase 'size':\r\n\t\t\t\t\t\t\tif ( parts.length !== 4 ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'VRMLLoader: Invalid vector format detected for %s.', fieldName );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tproperty = {\r\n\t\t\t\t\t\t\t\tx: parseFloat( parts[ 1 ] ),\r\n\t\t\t\t\t\t\t\ty: parseFloat( parts[ 2 ] ),\r\n\t\t\t\t\t\t\t\tz: parseFloat( parts[ 3 ] )\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'intensity':\r\n\t\t\t\t\t\tcase 'cutOffAngle':\r\n\t\t\t\t\t\tcase 'radius':\r\n\t\t\t\t\t\tcase 'topRadius':\r\n\t\t\t\t\t\tcase 'bottomRadius':\r\n\t\t\t\t\t\tcase 'height':\r\n\t\t\t\t\t\tcase 'transparency':\r\n\t\t\t\t\t\tcase 'shininess':\r\n\t\t\t\t\t\tcase 'ambientIntensity':\r\n\t\t\t\t\t\t\tif ( parts.length !== 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'VRMLLoader: Invalid single float value specification detected for %s.', fieldName );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tproperty = parseFloat( parts[ 1 ] );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'rotation':\r\n\t\t\t\t\t\t\tif ( parts.length !== 5 ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'VRMLLoader: Invalid quaternion format detected for %s.', fieldName );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tproperty = {\r\n\t\t\t\t\t\t\t\tx: parseFloat( parts[ 1 ] ),\r\n\t\t\t\t\t\t\t\ty: parseFloat( parts[ 2 ] ),\r\n\t\t\t\t\t\t\t\tz: parseFloat( parts[ 3 ] ),\r\n\t\t\t\t\t\t\t\tw: parseFloat( parts[ 4 ] )\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'on':\r\n\t\t\t\t\t\tcase 'ccw':\r\n\t\t\t\t\t\tcase 'solid':\r\n\t\t\t\t\t\tcase 'colorPerVertex':\r\n\t\t\t\t\t\tcase 'convex':\r\n\t\t\t\t\t\t\tif ( parts.length !== 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tconsole.warn( 'VRMLLoader: Invalid format detected for %s.', fieldName );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tproperty = parts[ 1 ] === 'TRUE' ? true : false;\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnode[ fieldName ] = property;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn property;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getTree( lines ) {\r\n\r\n\t\t\t\tvar tree = { 'string': 'Scene', children: [] };\r\n\t\t\t\tvar current = tree;\r\n\t\t\t\tvar matches;\r\n\t\t\t\tvar specification;\r\n\r\n\t\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar comment = '';\r\n\r\n\t\t\t\t\tvar line = lines[ i ];\r\n\r\n\t\t\t\t\t// omit whitespace only lines\r\n\t\t\t\t\tif ( null !== ( /^\\s+?$/g.exec( line ) ) ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tline = line.trim();\r\n\r\n\t\t\t\t\t// skip empty lines\r\n\t\t\t\t\tif ( line === '' ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( /#/.exec( line ) ) {\r\n\r\n\t\t\t\t\t\tvar parts = line.split( '#' );\r\n\r\n\t\t\t\t\t\t// discard everything after the #, it is a comment\r\n\t\t\t\t\t\tline = parts[ 0 ];\r\n\r\n\t\t\t\t\t\t// well, let's also keep the comment\r\n\t\t\t\t\t\tcomment = parts[ 1 ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( matches = /([^\\s]*){1}(?:\\s+)?{/.exec( line ) ) {\r\n\r\n\t\t\t\t\t\t// first subpattern should match the Node name\r\n\r\n\t\t\t\t\t\tvar block = { 'nodeType': matches[ 1 ], 'string': line, 'parent': current, 'children': [], 'comment': comment };\r\n\t\t\t\t\t\tcurrent.children.push( block );\r\n\t\t\t\t\t\tcurrent = block;\r\n\r\n\t\t\t\t\t\tif ( /}/.exec( line ) ) {\r\n\r\n\t\t\t\t\t\t\t// example: geometry Box { size 1 1 1 } # all on the same line\r\n\t\t\t\t\t\t\tspecification = /{(.*)}/.exec( line )[ 1 ];\r\n\r\n\t\t\t\t\t\t\t// todo: remove once new parsing is complete?\r\n\t\t\t\t\t\t\tblock.children.push( specification );\r\n\r\n\t\t\t\t\t\t\tparseProperty( current, specification );\r\n\r\n\t\t\t\t\t\t\tcurrent = current.parent;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( /}/.exec( line ) ) {\r\n\r\n\t\t\t\t\t\tcurrent = current.parent;\r\n\r\n\t\t\t\t\t} else if ( line !== '' ) {\r\n\r\n\t\t\t\t\t\tparseProperty( current, line );\r\n\t\t\t\t\t\t// todo: remove once new parsing is complete? we still do not parse geometry and appearance the new way\r\n\t\t\t\t\t\tcurrent.children.push( line );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn tree;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseNode( data, parent ) {\r\n\r\n\t\t\t\tvar object;\r\n\r\n\t\t\t\tif ( typeof data === 'string' ) {\r\n\r\n\t\t\t\t\tif ( /USE/.exec( data ) ) {\r\n\r\n\t\t\t\t\t\tvar defineKey = /USE\\s+?([^\\s]+)/.exec( data )[ 1 ];\r\n\r\n\t\t\t\t\t\tif ( undefined == defines[ defineKey ] ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( 'VRMLLoader: %s is not defined.', defineKey );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tif ( /appearance/.exec( data ) && defineKey ) {\r\n\r\n\t\t\t\t\t\t\t\tparent.material = defines[ defineKey ].clone();\r\n\r\n\t\t\t\t\t\t\t} else if ( /geometry/.exec( data ) && defineKey ) {\r\n\r\n\t\t\t\t\t\t\t\tparent.geometry = defines[ defineKey ].clone();\r\n\r\n\t\t\t\t\t\t\t\t// the solid property is not cloned with clone(), is only needed for VRML loading, so we need to transfer it\r\n\t\t\t\t\t\t\t\tif ( undefined !== defines[ defineKey ].solid && defines[ defineKey ].solid === false ) {\r\n\r\n\t\t\t\t\t\t\t\t\tparent.geometry.solid = false;\r\n\t\t\t\t\t\t\t\t\tparent.material.side = DoubleSide;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else if ( defineKey ) {\r\n\r\n\t\t\t\t\t\t\t\tobject = defines[ defineKey ].clone();\r\n\t\t\t\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject = parent;\r\n\r\n\t\t\t\tif ( data.string.indexOf( 'AmbientLight' ) > - 1 && data.nodeType === 'PointLight' ) {\r\n\r\n\t\t\t\t\tdata.nodeType = 'AmbientLight';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar l_visible = data.on !== undefined ? data.on : true;\r\n\t\t\t\tvar l_intensity = data.intensity !== undefined ? data.intensity : 1;\r\n\t\t\t\tvar l_color = new Color();\r\n\r\n\t\t\t\tif ( data.color ) {\r\n\r\n\t\t\t\t\tl_color.copy( data.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.nodeType === 'AmbientLight' ) {\r\n\r\n\t\t\t\t\tobject = new AmbientLight( l_color, l_intensity );\r\n\t\t\t\t\tobject.visible = l_visible;\r\n\r\n\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t} else if ( data.nodeType === 'PointLight' ) {\r\n\r\n\t\t\t\t\tvar l_distance = 0;\r\n\r\n\t\t\t\t\tif ( data.radius !== undefined && data.radius < 1000 ) {\r\n\r\n\t\t\t\t\t\tl_distance = data.radius;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject = new PointLight( l_color, l_intensity, l_distance );\r\n\t\t\t\t\tobject.visible = l_visible;\r\n\r\n\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t} else if ( data.nodeType === 'SpotLight' ) {\r\n\r\n\t\t\t\t\tvar l_intensity = 1;\r\n\t\t\t\t\tvar l_distance = 0;\r\n\t\t\t\t\tvar l_angle = Math.PI / 3;\r\n\t\t\t\t\tvar l_penumbra = 0;\r\n\t\t\t\t\tvar l_visible = true;\r\n\r\n\t\t\t\t\tif ( data.radius !== undefined && data.radius < 1000 ) {\r\n\r\n\t\t\t\t\t\tl_distance = data.radius;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( data.cutOffAngle !== undefined ) {\r\n\r\n\t\t\t\t\t\tl_angle = data.cutOffAngle;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject = new SpotLight( l_color, l_intensity, l_distance, l_angle, l_penumbra );\r\n\t\t\t\t\tobject.visible = l_visible;\r\n\r\n\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t} else if ( data.nodeType === 'Transform' || data.nodeType === 'Group' ) {\r\n\r\n\t\t\t\t\tobject = new Object3D();\r\n\r\n\t\t\t\t\tif ( /DEF/.exec( data.string ) ) {\r\n\r\n\t\t\t\t\t\tobject.name = /DEF\\s+([^\\s]+)/.exec( data.string )[ 1 ];\r\n\t\t\t\t\t\tdefines[ object.name ] = object;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( data.translation !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar t = data.translation;\r\n\r\n\t\t\t\t\t\tobject.position.set( t.x, t.y, t.z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( data.rotation !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar r = data.rotation;\r\n\r\n\t\t\t\t\t\tobject.quaternion.setFromAxisAngle( new Vector3( r.x, r.y, r.z ), r.w );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( data.scale !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar s = data.scale;\r\n\r\n\t\t\t\t\t\tobject.scale.set( s.x, s.y, s.z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t} else if ( data.nodeType === 'Shape' ) {\r\n\r\n\t\t\t\t\tobject = new Mesh();\r\n\r\n\t\t\t\t\tif ( /DEF/.exec( data.string ) ) {\r\n\r\n\t\t\t\t\t\tobject.name = /DEF\\s+([^\\s]+)/.exec( data.string )[ 1 ];\r\n\r\n\t\t\t\t\t\tdefines[ object.name ] = object;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t} else if ( data.nodeType === 'Background' ) {\r\n\r\n\t\t\t\t\tvar segments = 20;\r\n\r\n\t\t\t\t\t// sky (full sphere):\r\n\r\n\t\t\t\t\tvar radius = 2e4;\r\n\r\n\t\t\t\t\tvar skyGeometry = new SphereBufferGeometry( radius, segments, segments );\r\n\t\t\t\t\tvar skyMaterial = new MeshBasicMaterial( { fog: false, side: BackSide } );\r\n\r\n\t\t\t\t\tif ( data.skyColor.length > 1 ) {\r\n\r\n\t\t\t\t\t\tpaintFaces( skyGeometry, radius, data.skyAngle, data.skyColor, true );\r\n\r\n\t\t\t\t\t\tskyMaterial.vertexColors = VertexColors;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar color = data.skyColor[ 0 ];\r\n\t\t\t\t\t\tskyMaterial.color.setRGB( color.r, color.b, color.g );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tscene.add( new Mesh( skyGeometry, skyMaterial ) );\r\n\r\n\t\t\t\t\t// ground (half sphere):\r\n\r\n\t\t\t\t\tif ( data.groundColor !== undefined ) {\r\n\r\n\t\t\t\t\t\tradius = 1.2e4;\r\n\r\n\t\t\t\t\t\tvar groundGeometry = new SphereBufferGeometry( radius, segments, segments, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );\r\n\t\t\t\t\t\tvar groundMaterial = new MeshBasicMaterial( { fog: false, side: BackSide, vertexColors: VertexColors } );\r\n\r\n\t\t\t\t\t\tpaintFaces( groundGeometry, radius, data.groundAngle, data.groundColor, false );\r\n\r\n\t\t\t\t\t\tscene.add( new Mesh( groundGeometry, groundMaterial ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( /geometry/.exec( data.string ) ) {\r\n\r\n\t\t\t\t\tif ( data.nodeType === 'Box' ) {\r\n\r\n\t\t\t\t\t\tvar s = data.size;\r\n\r\n\t\t\t\t\t\tparent.geometry = new BoxBufferGeometry( s.x, s.y, s.z );\r\n\r\n\t\t\t\t\t} else if ( data.nodeType === 'Cylinder' ) {\r\n\r\n\t\t\t\t\t\tparent.geometry = new CylinderBufferGeometry( data.radius, data.radius, data.height );\r\n\r\n\t\t\t\t\t} else if ( data.nodeType === 'Cone' ) {\r\n\r\n\t\t\t\t\t\tparent.geometry = new CylinderBufferGeometry( data.topRadius, data.bottomRadius, data.height );\r\n\r\n\t\t\t\t\t} else if ( data.nodeType === 'Sphere' ) {\r\n\r\n\t\t\t\t\t\tparent.geometry = new SphereBufferGeometry( data.radius );\r\n\r\n\t\t\t\t\t} else if ( data.nodeType === 'IndexedFaceSet' ) {\r\n\r\n\t\t\t\t\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\t\t\t\t\tvar positions = [];\r\n\t\t\t\t\t\tvar uvs = [];\r\n\r\n\t\t\t\t\t\tvar position, uv;\r\n\r\n\t\t\t\t\t\tvar i, il, j, jl;\r\n\r\n\t\t\t\t\t\tfor ( i = 0, il = data.children.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar child = data.children[ i ];\r\n\r\n\t\t\t\t\t\t\t// uvs\r\n\r\n\t\t\t\t\t\t\tif ( child.nodeType === 'TextureCoordinate' ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( child.points ) {\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( j = 0, jl = child.points.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tuv = child.points[ j ];\r\n\t\t\t\t\t\t\t\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// positions\r\n\r\n\t\t\t\t\t\t\tif ( child.nodeType === 'Coordinate' ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( child.points ) {\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( j = 0, jl = child.points.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tposition = child.points[ j ];\r\n\t\t\t\t\t\t\t\t\t\tpositions.push( position.x, position.y, position.z );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif ( child.string.indexOf( 'DEF' ) > - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar name = /DEF\\s+([^\\s]+)/.exec( child.string )[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\tdefines[ name ] = positions.slice( 0 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif ( child.string.indexOf( 'USE' ) > - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar defineKey = /USE\\s+([^\\s]+)/.exec( child.string )[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\tpositions = defines[ defineKey ];\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar skip = 0;\r\n\r\n\t\t\t\t\t\t// some shapes only have vertices for use in other shapes\r\n\r\n\t\t\t\t\t\tif ( data.coordIndex ) {\r\n\r\n\t\t\t\t\t\t\tvar newPositions = [];\r\n\t\t\t\t\t\t\tvar newUvs = [];\r\n\r\n\t\t\t\t\t\t\tposition = new Vector3();\r\n\t\t\t\t\t\t\tuv = new Vector2();\r\n\r\n\t\t\t\t\t\t\tfor ( i = 0, il = data.coordIndex.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar indexes = data.coordIndex[ i ];\r\n\r\n\t\t\t\t\t\t\t\t// VRML support multipoint indexed face sets (more then 3 vertices). You must calculate the composing triangles here\r\n\r\n\t\t\t\t\t\t\t\tskip = 0;\r\n\r\n\t\t\t\t\t\t\t\twhile ( indexes.length >= 3 && skip < ( indexes.length - 2 ) ) {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( data.ccw === undefined ) { data.ccw = true; } // ccw is true by default\r\n\r\n\t\t\t\t\t\t\t\t\tvar i1 = indexes[ 0 ];\r\n\t\t\t\t\t\t\t\t\tvar i2 = indexes[ skip + ( data.ccw ? 1 : 2 ) ];\r\n\t\t\t\t\t\t\t\t\tvar i3 = indexes[ skip + ( data.ccw ? 2 : 1 ) ];\r\n\r\n\t\t\t\t\t\t\t\t\t// create non indexed geometry, necessary for face normal generation\r\n\r\n\t\t\t\t\t\t\t\t\tposition.fromArray( positions, i1 * 3 );\r\n\t\t\t\t\t\t\t\t\tuv.fromArray( uvs, i1 * 2 );\r\n\t\t\t\t\t\t\t\t\tnewPositions.push( position.x, position.y, position.z );\r\n\t\t\t\t\t\t\t\t\tnewUvs.push( uv.x, uv.y );\r\n\r\n\t\t\t\t\t\t\t\t\tposition.fromArray( positions, i2 * 3 );\r\n\t\t\t\t\t\t\t\t\tuv.fromArray( uvs, i2 * 2 );\r\n\t\t\t\t\t\t\t\t\tnewPositions.push( position.x, position.y, position.z );\r\n\t\t\t\t\t\t\t\t\tnewUvs.push( uv.x, uv.y );\r\n\r\n\t\t\t\t\t\t\t\t\tposition.fromArray( positions, i3 * 3 );\r\n\t\t\t\t\t\t\t\t\tuv.fromArray( uvs, i3 * 2 );\r\n\t\t\t\t\t\t\t\t\tnewPositions.push( position.x, position.y, position.z );\r\n\t\t\t\t\t\t\t\t\tnewUvs.push( uv.x, uv.y );\r\n\r\n\t\t\t\t\t\t\t\t\tskip ++;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tpositions = newPositions;\r\n\t\t\t\t\t\t\tuvs = newUvs;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// do not add dummy mesh to the scene\r\n\r\n\t\t\t\t\t\t\tparent.parent.remove( parent );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( false === data.solid ) {\r\n\r\n\t\t\t\t\t\t\tparent.material.side = DoubleSide;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// we need to store it on the geometry for use with defines\r\n\t\t\t\t\t\tgeometry.solid = data.solid;\r\n\r\n\t\t\t\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\r\n\r\n\t\t\t\t\t\tif ( uvs.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\tgeometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tgeometry.computeVertexNormals();\r\n\t\t\t\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t\t\t\t\t// see if it's a define\r\n\t\t\t\t\t\tif ( /DEF/.exec( data.string ) ) {\r\n\r\n\t\t\t\t\t\t\tgeometry.name = /DEF ([^\\s]+)/.exec( data.string )[ 1 ];\r\n\t\t\t\t\t\t\tdefines[ geometry.name ] = geometry;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tparent.geometry = geometry;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t} else if ( /appearance/.exec( data.string ) ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < data.children.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar child = data.children[ i ];\r\n\r\n\t\t\t\t\t\tif ( child.nodeType === 'Material' ) {\r\n\r\n\t\t\t\t\t\t\tvar material = new MeshPhongMaterial();\r\n\r\n\t\t\t\t\t\t\tif ( child.diffuseColor !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tvar d = child.diffuseColor;\r\n\r\n\t\t\t\t\t\t\t\tmaterial.color.setRGB( d.r, d.g, d.b );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( child.emissiveColor !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tvar e = child.emissiveColor;\r\n\r\n\t\t\t\t\t\t\t\tmaterial.emissive.setRGB( e.r, e.g, e.b );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( child.specularColor !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tvar s = child.specularColor;\r\n\r\n\t\t\t\t\t\t\t\tmaterial.specular.setRGB( s.r, s.g, s.b );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( child.transparency !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tvar t = child.transparency;\r\n\r\n\t\t\t\t\t\t\t\t// transparency is opposite of opacity\r\n\t\t\t\t\t\t\t\tmaterial.opacity = Math.abs( 1 - t );\r\n\r\n\t\t\t\t\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( /DEF/.exec( data.string ) ) {\r\n\r\n\t\t\t\t\t\t\t\tmaterial.name = /DEF ([^\\s]+)/.exec( data.string )[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\tdefines[ material.name ] = material;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tparent.material = material;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( child.nodeType === 'ImageTexture' ) {\r\n\r\n\t\t\t\t\t\t\tvar textureName = /\"([^\"]+)\"/.exec( child.children[ 0 ] );\r\n\r\n\t\t\t\t\t\t\tif ( textureName ) {\r\n\r\n\t\t\t\t\t\t\t\tparent.material.name = textureName[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\tparent.material.map = textureLoader.load( texturePath + textureName[ 1 ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0, l = data.children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tparseNode( data.children[ i ], object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparseNode( getTree( lines ), scene );\r\n\r\n\t\t}\r\n\r\n\t\tvar scene = new Scene();\r\n\r\n\t\tvar lines = data.split( '\\n' );\r\n\r\n\t\t// some lines do not have breaks\r\n\r\n\t\tfor ( var i = lines.length - 1; i > - 1; i -- ) {\r\n\r\n\t\t\tvar line = lines[ i ];\r\n\r\n\t\t\t// split lines with {..{ or {..[ - some have both\r\n\t\t\tif ( /{.*[{\\[]/.test( line ) ) {\r\n\r\n\t\t\t\tvar parts = line.split( '{' ).join( '{\\n' ).split( '\\n' );\r\n\t\t\t\tparts.unshift( 1 );\r\n\t\t\t\tparts.unshift( i );\r\n\t\t\t\tlines.splice.apply( lines, parts );\r\n\r\n\t\t\t} else if ( /\\].*}/.test( line ) ) {\r\n\r\n\t\t\t\t// split lines with ]..}\r\n\t\t\t\tvar parts = line.split( ']' ).join( ']\\n' ).split( '\\n' );\r\n\t\t\t\tparts.unshift( 1 );\r\n\t\t\t\tparts.unshift( i );\r\n\t\t\t\tlines.splice.apply( lines, parts );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( /}.*}/.test( line ) ) {\r\n\r\n\t\t\t\t// split lines with }..}\r\n\t\t\t\tvar parts = line.split( '}' ).join( '}\\n' ).split( '\\n' );\r\n\t\t\t\tparts.unshift( 1 );\r\n\t\t\t\tparts.unshift( i );\r\n\t\t\t\tlines.splice.apply( lines, parts );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( /^\\b[^\\s]+\\b$/.test( line.trim() ) ) {\r\n\r\n\t\t\t\t// prevent lines with single words like \"coord\" or \"geometry\", see #12209\r\n\t\t\t\tlines[ i + 1 ] = line + ' ' + lines[ i + 1 ].trim();\r\n\t\t\t\tlines.splice( i, 1 );\r\n\r\n\t\t\t} else if ( ( line.indexOf( 'coord' ) > - 1 ) && ( line.indexOf( '[' ) < 0 ) && ( line.indexOf( '{' ) < 0 ) ) {\r\n\r\n\t\t\t\t// force the parser to create Coordinate node for empty coords\r\n\t\t\t\t// coord USE something -> coord USE something Coordinate {}\r\n\r\n\t\t\t\tlines[ i ] += ' Coordinate {}';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar header = lines.shift();\r\n\r\n\t\tif ( /V1.0/.exec( header ) ) {\r\n\r\n\t\t\tconsole.warn( 'VRMLLoader: V1.0 not supported yet.' );\r\n\r\n\t\t} else if ( /V2.0/.exec( header ) ) {\r\n\r\n\t\t\tparseV2( lines, scene );\r\n\r\n\t\t}\r\n\r\n\t\treturn scene;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// VRM Specification: https://dwango.github.io/vrm/vrm_spec/\r\n//\r\n// VRM is based on glTF 2.0 and VRM extension is defined\r\n// in top-level json.extensions.VRM\r\n\r\nvar VRMLoader = ( function () {\r\n\r\n\tfunction VRMLoader( manager ) {\r\n\r\n\t\tif ( GLTFLoader === undefined ) {\r\n\r\n\t\t\tthrow new Error( 'VRMLoader: Import GLTFLoader.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\t\tthis.gltfLoader = new GLTFLoader( this.manager );\r\n\r\n\t}\r\n\r\n\tVRMLoader.prototype = {\r\n\r\n\t\tconstructor: VRMLoader,\r\n\r\n\t\tcrossOrigin: 'anonymous',\r\n\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tthis.gltfLoader.load( url, function ( gltf ) {\r\n\r\n\t\t\t\tscope.parse( gltf, onLoad );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\t\tthis.glTFLoader.setCrossOrigin( value );\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetPath: function ( value ) {\r\n\r\n\t\t\tthis.glTFLoader.setPath( value );\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetDRACOLoader: function ( dracoLoader ) {\r\n\r\n\t\t\tthis.glTFLoader.setDRACOLoader( dracoLoader );\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( gltf, onLoad ) {\r\n\r\n\t\t\tvar gltfParser = gltf.parser;\r\n\t\t\tvar gltfExtensions = gltf.userData.gltfExtensions || {};\r\n\t\t\tvar vrmExtension = gltfExtensions.VRM || {};\r\n\r\n\t\t\t// handle VRM Extension here\r\n\r\n\t\t\tonLoad( gltf );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\treturn VRMLoader;\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar VTKLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n};\r\n\r\nObject.assign( VTKLoader.prototype, EventDispatcher.prototype, {\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( data ) {\r\n\r\n\t\tfunction parseASCII( data ) {\r\n\r\n\t\t\t// connectivity of the triangles\r\n\t\t\tvar indices = [];\r\n\r\n\t\t\t// triangles vertices\r\n\t\t\tvar positions = [];\r\n\r\n\t\t\t// red, green, blue colors in the range 0 to 1\r\n\t\t\tvar colors = [];\r\n\r\n\t\t\t// normal vector, one per vertex\r\n\t\t\tvar normals = [];\r\n\r\n\t\t\tvar result;\r\n\r\n\t\t\t// pattern for reading vertices, 3 floats or integers\r\n\t\t\tvar pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\r\n\r\n\t\t\t// pattern for connectivity, an integer followed by any number of ints\r\n\t\t\t// the first integer is the number of polygon nodes\r\n\t\t\tvar patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\r\n\r\n\t\t\t// indicates start of vertex data section\r\n\t\t\tvar patPOINTS = /^POINTS /;\r\n\r\n\t\t\t// indicates start of polygon connectivity section\r\n\t\t\tvar patPOLYGONS = /^POLYGONS /;\r\n\r\n\t\t\t// indicates start of triangle strips section\r\n\t\t\tvar patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\r\n\r\n\t\t\t// POINT_DATA number_of_values\r\n\t\t\tvar patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\r\n\r\n\t\t\t// CELL_DATA number_of_polys\r\n\t\t\tvar patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\r\n\r\n\t\t\t// Start of color section\r\n\t\t\tvar patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\r\n\r\n\t\t\t// NORMALS Normals float\r\n\t\t\tvar patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\r\n\r\n\t\t\tvar inPointsSection = false;\r\n\t\t\tvar inPolygonsSection = false;\r\n\t\t\tvar inTriangleStripSection = false;\r\n\t\t\tvar inPointDataSection = false;\r\n\t\t\tvar inCellDataSection = false;\r\n\t\t\tvar inColorSection = false;\r\n\t\t\tvar inNormalsSection = false;\r\n\r\n\t\t\tvar lines = data.split( '\\n' );\r\n\r\n\t\t\tfor ( var i in lines ) {\r\n\r\n\t\t\t\tvar line = lines[ i ];\r\n\r\n\t\t\t\tif ( inPointsSection ) {\r\n\r\n\t\t\t\t\t// get the vertices\r\n\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t\tvar x = parseFloat( result[ 1 ] );\r\n\t\t\t\t\t\tvar y = parseFloat( result[ 2 ] );\r\n\t\t\t\t\t\tvar z = parseFloat( result[ 3 ] );\r\n\t\t\t\t\t\tpositions.push( x, y, z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( inPolygonsSection ) {\r\n\r\n\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\r\n\t\t\t\t\t\tvar numVertices = parseInt( result[ 1 ] );\r\n\t\t\t\t\t\tvar inds = result[ 2 ].split( /\\s+/ );\r\n\r\n\t\t\t\t\t\tif ( numVertices >= 3 ) {\r\n\r\n\t\t\t\t\t\t\tvar i0 = parseInt( inds[ 0 ] );\r\n\t\t\t\t\t\t\tvar i1, i2;\r\n\t\t\t\t\t\t\tvar k = 1;\r\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\r\n\t\t\t\t\t\t\tfor ( var j = 0; j < numVertices - 2; ++ j ) {\r\n\r\n\t\t\t\t\t\t\t\ti1 = parseInt( inds[ k ] );\r\n\t\t\t\t\t\t\t\ti2 = parseInt( inds[ k + 1 ] );\r\n\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\r\n\t\t\t\t\t\t\t\tk ++;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( inTriangleStripSection ) {\r\n\r\n\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\r\n\t\t\t\t\t\tvar numVertices = parseInt( result[ 1 ] );\r\n\t\t\t\t\t\tvar inds = result[ 2 ].split( /\\s+/ );\r\n\r\n\t\t\t\t\t\tif ( numVertices >= 3 ) {\r\n\r\n\t\t\t\t\t\t\tvar i0, i1, i2;\r\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\r\n\t\t\t\t\t\t\tfor ( var j = 0; j < numVertices - 2; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( j % 2 === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\ti0 = parseInt( inds[ j ] );\r\n\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ j + 2 ] );\r\n\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ j + 1 ] );\r\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\ti0 = parseInt( inds[ j ] );\r\n\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ j + 1 ] );\r\n\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ j + 2 ] );\r\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( inPointDataSection || inCellDataSection ) {\r\n\r\n\t\t\t\t\tif ( inColorSection ) {\r\n\r\n\t\t\t\t\t\t// Get the colors\r\n\r\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t\t\tvar r = parseFloat( result[ 1 ] );\r\n\t\t\t\t\t\t\tvar g = parseFloat( result[ 2 ] );\r\n\t\t\t\t\t\t\tvar b = parseFloat( result[ 3 ] );\r\n\t\t\t\t\t\t\tcolors.push( r, g, b );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( inNormalsSection ) {\r\n\r\n\t\t\t\t\t\t// Get the normal vectors\r\n\r\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t\t\tvar nx = parseFloat( result[ 1 ] );\r\n\t\t\t\t\t\t\tvar ny = parseFloat( result[ 2 ] );\r\n\t\t\t\t\t\t\tvar nz = parseFloat( result[ 3 ] );\r\n\t\t\t\t\t\t\tnormals.push( nx, ny, nz );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( patPOLYGONS.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinPolygonsSection = true;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t} else if ( patPOINTS.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinPointsSection = true;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t} else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = true;\r\n\r\n\t\t\t\t} else if ( patPOINT_DATA.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinPointDataSection = true;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t} else if ( patCELL_DATA.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinCellDataSection = true;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t} else if ( patCOLOR_SCALARS.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinColorSection = true;\r\n\t\t\t\t\tinNormalsSection = false;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t} else if ( patNORMALS.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinNormalsSection = true;\r\n\t\t\t\t\tinColorSection = false;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\t\t\tgeometry.setIndex( indices );\r\n\t\t\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\r\n\r\n\t\t\tif ( normals.length === positions.length ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colors.length !== indices.length ) {\r\n\r\n\t\t\t\t// stagger\r\n\r\n\t\t\t\tif ( colors.length === positions.length ) {\r\n\r\n\t\t\t\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// cell\r\n\r\n\t\t\t\tgeometry = geometry.toNonIndexed();\r\n\t\t\t\tvar numTriangles = geometry.attributes.position.count / 3;\r\n\r\n\t\t\t\tif ( colors.length === ( numTriangles * 3 ) ) {\r\n\r\n\t\t\t\t\tvar newColors = [];\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < numTriangles; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar r = colors[ 3 * i + 0 ];\r\n\t\t\t\t\t\tvar g = colors[ 3 * i + 1 ];\r\n\t\t\t\t\t\tvar b = colors[ 3 * i + 2 ];\r\n\r\n\t\t\t\t\t\tnewColors.push( r, g, b );\r\n\t\t\t\t\t\tnewColors.push( r, g, b );\r\n\t\t\t\t\t\tnewColors.push( r, g, b );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.addAttribute( 'color', new Float32BufferAttribute( newColors, 3 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseBinary( data ) {\r\n\r\n\t\t\tvar count, pointIndex, i, numberOfPoints, s;\r\n\t\t\tvar buffer = new Uint8Array( data );\r\n\t\t\tvar dataView = new DataView( data );\r\n\r\n\t\t\t// Points and normals, by default, are empty\r\n\t\t\tvar points = [];\r\n\t\t\tvar normals = [];\r\n\t\t\tvar indices = [];\r\n\t\t\tvar index = 0;\r\n\r\n\t\t\tfunction findString( buffer, start ) {\r\n\r\n\t\t\t\tvar index = start;\r\n\t\t\t\tvar c = buffer[ index ];\r\n\t\t\t\tvar s = [];\r\n\t\t\t\twhile ( c !== 10 ) {\r\n\r\n\t\t\t\t\ts.push( String.fromCharCode( c ) );\r\n\t\t\t\t\tindex ++;\r\n\t\t\t\t\tc = buffer[ index ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn { start: start,\r\n\t\t\t\t\tend: index,\r\n\t\t\t\t\tnext: index + 1,\r\n\t\t\t\t\tparsedString: s.join( '' ) };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar state, line;\r\n\r\n\t\t\twhile ( true ) {\r\n\r\n\t\t\t\t// Get a string\r\n\t\t\t\tstate = findString( buffer, index );\r\n\t\t\t\tline = state.parsedString;\r\n\r\n\t\t\t\tif ( line.indexOf( 'POINTS' ) === 0 ) {\r\n\t\t\t\t\t// Add the points\r\n\t\t\t\t\tnumberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\r\n\r\n\t\t\t\t\t// Each point is 3 4-byte floats\r\n\t\t\t\t\tcount = numberOfPoints * 4 * 3;\r\n\r\n\t\t\t\t\tpoints = new Float32Array( numberOfPoints * 3 );\r\n\r\n\t\t\t\t\tpointIndex = state.next;\r\n\t\t\t\t\tfor ( i = 0; i < numberOfPoints; i ++ ) {\r\n\r\n\t\t\t\t\t\tpoints[ 3 * i ] = dataView.getFloat32( pointIndex, false );\r\n\t\t\t\t\t\tpoints[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\r\n\t\t\t\t\t\tpoints[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\r\n\t\t\t\t\t\tpointIndex = pointIndex + 12;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// increment our next pointer\r\n\t\t\t\t\tstate.next = state.next + count + 1;\r\n\r\n\t\t\t\t} else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {\r\n\r\n\t\t\t\t\tvar numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\r\n\t\t\t\t\tvar size = parseInt( line.split( ' ' )[ 2 ], 10 );\r\n\t\t\t\t\t// 4 byte integers\r\n\t\t\t\t\tcount = size * 4;\r\n\r\n\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\r\n\t\t\t\t\tvar indicesIndex = 0;\r\n\r\n\t\t\t\t\tpointIndex = state.next;\r\n\t\t\t\t\tfor ( i = 0; i < numberOfStrips; i ++ ) {\r\n\r\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\r\n\t\t\t\t\t\tvar indexCount = dataView.getInt32( pointIndex, false );\r\n\t\t\t\t\t\tvar strip = [];\r\n\t\t\t\t\t\tpointIndex += 4;\r\n\t\t\t\t\t\tfor ( s = 0; s < indexCount; s ++ ) {\r\n\r\n\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\r\n\t\t\t\t\t\t\tpointIndex += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// retrieves the n-2 triangles from the triangle strip\r\n\t\t\t\t\t\tfor ( var j = 0; j < indexCount - 2; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( j % 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// increment our next pointer\r\n\t\t\t\t\tstate.next = state.next + count + 1;\r\n\r\n\t\t\t\t} else if ( line.indexOf( 'POLYGONS' ) === 0 ) {\r\n\r\n\t\t\t\t\tvar numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\r\n\t\t\t\t\tvar size = parseInt( line.split( ' ' )[ 2 ], 10 );\r\n\t\t\t\t\t// 4 byte integers\r\n\t\t\t\t\tcount = size * 4;\r\n\r\n\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\r\n\t\t\t\t\tvar indicesIndex = 0;\r\n\r\n\t\t\t\t\tpointIndex = state.next;\r\n\t\t\t\t\tfor ( i = 0; i < numberOfStrips; i ++ ) {\r\n\r\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\r\n\t\t\t\t\t\tvar indexCount = dataView.getInt32( pointIndex, false );\r\n\t\t\t\t\t\tvar strip = [];\r\n\t\t\t\t\t\tpointIndex += 4;\r\n\t\t\t\t\t\tfor ( s = 0; s < indexCount; s ++ ) {\r\n\r\n\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\r\n\t\t\t\t\t\t\tpointIndex += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// divide the polygon in n-2 triangle\r\n\t\t\t\t\t\tfor ( var j = 1; j < indexCount - 1; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ 0 ];\r\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\r\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// increment our next pointer\r\n\t\t\t\t\tstate.next = state.next + count + 1;\r\n\r\n\t\t\t\t} else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {\r\n\r\n\t\t\t\t\tnumberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\r\n\r\n\t\t\t\t\t// Grab the next line\r\n\t\t\t\t\tstate = findString( buffer, state.next );\r\n\r\n\t\t\t\t\t// Now grab the binary data\r\n\t\t\t\t\tcount = numberOfPoints * 4 * 3;\r\n\r\n\t\t\t\t\tnormals = new Float32Array( numberOfPoints * 3 );\r\n\t\t\t\t\tpointIndex = state.next;\r\n\t\t\t\t\tfor ( i = 0; i < numberOfPoints; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormals[ 3 * i ] = dataView.getFloat32( pointIndex, false );\r\n\t\t\t\t\t\tnormals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\r\n\t\t\t\t\t\tnormals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\r\n\t\t\t\t\t\tpointIndex += 12;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Increment past our data\r\n\t\t\t\t\tstate.next = state.next + count;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Increment index\r\n\t\t\t\tindex = state.next;\r\n\r\n\t\t\t\tif ( index >= buffer.byteLength ) {\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometry = new BufferGeometry();\r\n\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\r\n\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( points, 3 ) );\r\n\r\n\t\t\tif ( normals.length === points.length ) {\r\n\r\n\t\t\t\tgeometry.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Float32Concat( first, second ) {\r\n\r\n\t\t    var firstLength = first.length, result = new Float32Array( firstLength + second.length );\r\n\r\n\t\t    result.set( first );\r\n\t\t    result.set( second, firstLength );\r\n\r\n\t\t    return result;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Int32Concat( first, second ) {\r\n\r\n\t\t    var firstLength = first.length, result = new Int32Array( firstLength + second.length );\r\n\r\n\t\t    result.set( first );\r\n\t\t    result.set( second, firstLength );\r\n\r\n\t\t    return result;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseXML( stringFile ) {\r\n\r\n\t\t\t// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\r\n\r\n\t\t\tfunction xmlToJson( xml ) {\r\n\r\n\t\t\t\t// Create the return object\r\n\t\t\t\tvar obj = {};\r\n\r\n\t\t\t\tif ( xml.nodeType === 1 ) { // element\r\n\r\n\t\t\t\t\t// do attributes\r\n\r\n\t\t\t\t\tif ( xml.attributes ) {\r\n\r\n\t\t\t\t\t\tif ( xml.attributes.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\tobj[ 'attributes' ] = {};\r\n\r\n\t\t\t\t\t\t\tfor ( var j = 0; j < xml.attributes.length; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar attribute = xml.attributes.item( j );\r\n\t\t\t\t\t\t\t\tobj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( xml.nodeType === 3 ) { // text\r\n\r\n\t\t\t\t\tobj = xml.nodeValue.trim();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// do children\r\n\t\t\t\tif ( xml.hasChildNodes() ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar item = xml.childNodes.item( i );\r\n\t\t\t\t\t\tvar nodeName = item.nodeName;\r\n\r\n\t\t\t\t\t\tif ( typeof obj[ nodeName ] === 'undefined' ) {\r\n\r\n\t\t\t\t\t\t\tvar tmp = xmlToJson( item );\r\n\r\n\t\t\t\t\t\t\tif ( tmp !== '' ) { obj[ nodeName ] = tmp; }\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tif ( typeof obj[ nodeName ].push === 'undefined' ) {\r\n\r\n\t\t\t\t\t\t\t\tvar old = obj[ nodeName ];\r\n\t\t\t\t\t\t\t\tobj[ nodeName ] = [ old ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tvar tmp = xmlToJson( item );\r\n\r\n\t\t\t\t\t\t\tif ( tmp !== '' ) { obj[ nodeName ].push( tmp ); }\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn obj;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Taken from Base64-js\r\n\t\t\tfunction Base64toByteArray( b64 ) {\r\n\r\n\t\t\t\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\r\n\t\t\t\tvar i;\r\n\t\t\t\tvar lookup = [];\r\n\t\t\t\tvar revLookup = [];\r\n\t\t\t\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\t\t\t\tvar len = code.length;\r\n\r\n\t\t\t\tfor ( i = 0; i < len; i ++ ) {\r\n\r\n\t\t\t\t\tlookup[ i ] = code[ i ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0; i < len; ++ i ) {\r\n\r\n\t\t\t\t\trevLookup[ code.charCodeAt( i ) ] = i;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\trevLookup[ '-'.charCodeAt( 0 ) ] = 62;\r\n\t\t\t\trevLookup[ '_'.charCodeAt( 0 ) ] = 63;\r\n\r\n\t\t\t\tvar j, l, tmp, placeHolders, arr;\r\n\t\t\t\tvar len = b64.length;\r\n\r\n\t\t\t\tif ( len % 4 > 0 ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'Invalid string. Length must be a multiple of 4' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tplaceHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;\r\n\t\t\t\tarr = new Arr( len * 3 / 4 - placeHolders );\r\n\t\t\t\tl = placeHolders > 0 ? len - 4 : len;\r\n\r\n\t\t\t\tvar L = 0;\r\n\r\n\t\t\t\tfor ( i = 0, j = 0; i < l; i += 4, j += 3 ) {\r\n\r\n\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];\r\n\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;\r\n\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;\r\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( placeHolders === 2 ) {\r\n\r\n\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );\r\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\r\n\r\n\t\t\t\t} else if ( placeHolders === 1 ) {\r\n\r\n\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );\r\n\t\t\t\t\tarr[ L ++ ] = ( tmp >> 8 ) & 0xFF;\r\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn arr;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseDataArray( ele, compressed ) {\r\n\r\n\t\t\t\tvar numBytes = 0;\r\n\r\n\t\t\t\tif ( json.attributes.header_type === 'UInt64' ) {\r\n\r\n\t\t\t\t\tnumBytes = 8;\r\n\r\n\t\t\t\t}\telse if ( json.attributes.header_type === 'UInt32' ) {\r\n\r\n\t\t\t\t\tnumBytes = 4;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check the format\r\n\t\t\t\tif ( ele.attributes.format === 'binary' && compressed ) {\r\n\r\n\t\t\t\t\tvar rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\r\n\r\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\r\n\r\n\t\t\t\t\t\tvar txt = new Float32Array( );\r\n\r\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\r\n\r\n\t\t\t\t\t\tvar txt = new Int32Array( );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// VTP data with the header has the following structure:\r\n\t\t\t\t\t// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\r\n\t\t\t\t\t// [#blocks] = Number of blocks\r\n\t\t\t\t\t// [#u-size] = Block size before compression\r\n\t\t\t\t\t// [#p-size] = Size of last partial block (zero if it not needed)\r\n\t\t\t\t\t// [#c-size-i] = Size in bytes of block i after compression\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\r\n\t\t\t\t\t// computed by summing the compressed block sizes from preceding blocks according to the header.\r\n\r\n\t\t\t\t\trawData = ele[ '#text' ];\r\n\r\n\t\t\t\t\tbyteData = Base64toByteArray( rawData );\r\n\r\n\t\t\t\t\tblocks = byteData[ 0 ];\r\n\t\t\t\t\tfor ( var i = 1; i < numBytes - 1; i ++ ) {\r\n\r\n\t\t\t\t\t\tblocks = blocks | ( byteData[ i ] << ( i * numBytes ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\theaderSize = ( blocks + 3 ) * numBytes;\r\n\t\t\t\t\tpadding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;\r\n\t\t\t\t\theaderSize = headerSize + padding;\r\n\r\n\t\t\t\t\tdataOffsets = [];\r\n\t\t\t\t\tcurrentOffset = headerSize;\r\n\t\t\t\t\tdataOffsets.push( currentOffset );\r\n\r\n\t\t\t\t\t// Get the blocks sizes after the compression.\r\n\t\t\t\t\t// There are three blocks before c-size-i, so we skip 3*numBytes\r\n\t\t\t\t\tcSizeStart = 3 * numBytes;\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < blocks; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar currentBlockSize = byteData[ i * numBytes + cSizeStart ];\r\n\r\n\t\t\t\t\t\tfor ( var j = 1; j < numBytes - 1; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t// Each data point consists of 8 bytes regardless of the header type\r\n\t\t\t\t\t\t\tcurrentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * 8 ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcurrentOffset = currentOffset + currentBlockSize;\r\n\t\t\t\t\t\tdataOffsets.push( currentOffset );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < dataOffsets.length - 1; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar inflate = new Zlib.Inflate( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ), { resize: true, verify: true } ); // eslint-disable-line no-undef\r\n\t\t\t\t\t\tcontent = inflate.decompress();\r\n\t\t\t\t\t\tcontent = content.buffer;\r\n\r\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\r\n\r\n\t\t\t\t\t\t\tcontent = new Float32Array( content );\r\n\t\t\t\t\t\t\ttxt = Float32Concat( txt, content );\r\n\r\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\r\n\r\n\t\t\t\t\t\t\tcontent = new Int32Array( content );\r\n\t\t\t\t\t\t\ttxt = Int32Concat( txt, content );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdelete ele[ '#text' ];\r\n\r\n\t\t\t\t\t// Get the content and optimize it\r\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\r\n\r\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\r\n\r\n\t\t\t\t\t\t\tif ( ! compressed ) {\r\n\r\n\t\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( idx !== 0 ) { return true; }\r\n\r\n\t\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\r\n\r\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\r\n\r\n\t\t\t\t\t\t\tif ( ! compressed ) {\r\n\r\n\t\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( idx !== 0 ) { return true; }\r\n\r\n\t\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) { return true; }\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( ele.attributes.format === 'binary' && ! compressed ) {\r\n\r\n\t\t\t\t\t\tvar content = Base64toByteArray( ele[ '#text' ] );\r\n\r\n\t\t\t\t\t\t//  VTP data for the uncompressed case has the following structure:\r\n\t\t\t\t\t\t// [#bytes][DATA]\r\n\t\t\t\t\t\t// where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\r\n\t\t\t\t\t\tcontent = content.slice( numBytes ).buffer;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( ele[ '#text' ] ) {\r\n\r\n\t\t\t\t\t\t\tvar content = ele[ '#text' ].split( /\\s+/ ).filter( function ( el ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( el !== '' ) { return el; }\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar content = new Int32Array( 0 ).buffer;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdelete ele[ '#text' ];\r\n\r\n\t\t\t\t\t// Get the content and optimize it\r\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\r\n\r\n\t\t\t\t\t\tvar txt = new Float32Array( content );\r\n\r\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' ) {\r\n\r\n\t\t\t\t\t\tvar txt = new Int32Array( content );\r\n\r\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\r\n\r\n\t\t\t\t\t\tvar txt = new Int32Array( content );\r\n\r\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\r\n\r\n\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) { return true; }\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // endif ( ele.attributes.format === 'binary' && compressed )\r\n\r\n\t\t\t\treturn txt;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Main part\r\n\t\t\t// Get Dom\r\n\t\t\tvar dom = null;\r\n\r\n\t\t\tif ( window.DOMParser ) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tdom = ( new DOMParser() ).parseFromString( stringFile, 'text/xml' );\r\n\r\n\t\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t\tdom = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( window.ActiveXObject ) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tdom = new ActiveXObject( 'Microsoft.XMLDOM' ); // eslint-disable-line no-undef\r\n\t\t\t\t\tdom.async = false;\r\n\r\n\t\t\t\t\tif ( ! dom.loadXML(  ) ) {\r\n\r\n\t\t\t\t\t\tthrow new Error( dom.parseError.reason + dom.parseError.srcText );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t\tdom = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'Cannot parse xml string!' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Get the doc\r\n\t\t\tvar doc = dom.documentElement;\r\n\t\t\t// Convert to json\r\n\t\t\tvar json = xmlToJson( doc );\r\n\t\t\tvar points = [];\r\n\t\t\tvar normals = [];\r\n\t\t\tvar indices = [];\r\n\r\n\t\t\tif ( json.PolyData ) {\r\n\r\n\t\t\t\tvar piece = json.PolyData.Piece;\r\n\t\t\t\tvar compressed = json.attributes.hasOwnProperty( 'compressor' );\r\n\r\n\t\t\t\t// Can be optimized\r\n\t\t\t\t// Loop through the sections\r\n\t\t\t\tvar sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];\r\n\t\t\t\tvar sectionIndex = 0, numberOfSections = sections.length;\r\n\r\n\t\t\t\twhile ( sectionIndex < numberOfSections ) {\r\n\r\n\t\t\t\t\tvar section = piece[ sections[ sectionIndex ] ];\r\n\r\n\t\t\t\t\t// If it has a DataArray in it\r\n\r\n\t\t\t\t\tif ( section && section.DataArray ) {\r\n\r\n\t\t\t\t\t\t// Depending on the number of DataArrays\r\n\r\n\t\t\t\t\t\tif ( Object.prototype.toString.call( section.DataArray ) === '[object Array]' ) {\r\n\r\n\t\t\t\t\t\t\tvar arr = section.DataArray;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar arr = [ section.DataArray ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar dataArrayIndex = 0, numberOfDataArrays = arr.length;\r\n\r\n\t\t\t\t\t\twhile ( dataArrayIndex < numberOfDataArrays ) {\r\n\r\n\t\t\t\t\t\t\t// Parse the DataArray\r\n\t\t\t\t\t\t\tif ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {\r\n\r\n\t\t\t\t\t\t\t\tarr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tdataArrayIndex ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tswitch ( sections[ sectionIndex ] ) {\r\n\r\n\t\t\t\t\t\t\t// if iti is point data\r\n\t\t\t\t\t\t\tcase 'PointData':\r\n\r\n\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\r\n\t\t\t\t\t\t\t\tvar normalsName = section.attributes.Normals;\r\n\r\n\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( var i = 0, len = arr.length; i < len; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( normalsName === arr[ i ].attributes.Name ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvar components = arr[ i ].attributes.NumberOfComponents;\r\n\t\t\t\t\t\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * components );\r\n\t\t\t\t\t\t\t\t\t\t\tnormals.set( arr[ i ].text, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t// if it is points\r\n\t\t\t\t\t\t\tcase 'Points':\r\n\r\n\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\r\n\r\n\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar components = section.DataArray.attributes.NumberOfComponents;\r\n\t\t\t\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * components );\r\n\t\t\t\t\t\t\t\t\tpoints.set( section.DataArray.text, 0 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t// if it is strips\r\n\t\t\t\t\t\t\tcase 'Strips':\r\n\r\n\t\t\t\t\t\t\t\tvar numberOfStrips = parseInt( piece.attributes.NumberOfStrips );\r\n\r\n\t\t\t\t\t\t\t\tif ( numberOfStrips > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\r\n\t\t\t\t\t\t\t\t\tvar offset = new Int32Array( section.DataArray[ 1 ].text.length );\r\n\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\r\n\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\tvar size = numberOfStrips + connectivity.length;\r\n\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\r\n\r\n\t\t\t\t\t\t\t\t\tvar indicesIndex = 0;\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( var i = 0, len = numberOfStrips; i < len; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tvar strip = [];\r\n\r\n\t\t\t\t\t\t\t\t\t\tfor ( var s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tstrip.push( connectivity[ s ] );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) { len0 = offset[ i - 1 ]; }\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tfor ( var j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( j % 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\r\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\r\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\r\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\r\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) { len0 = offset[ i - 1 ]; }\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t// if it is polys\r\n\t\t\t\t\t\t\tcase 'Polys':\r\n\r\n\t\t\t\t\t\t\t\tvar numberOfPolys = parseInt( piece.attributes.NumberOfPolys );\r\n\r\n\t\t\t\t\t\t\t\tif ( numberOfPolys > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\r\n\t\t\t\t\t\t\t\t\tvar offset = new Int32Array( section.DataArray[ 1 ].text.length );\r\n\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\r\n\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\tvar size = numberOfPolys + connectivity.length;\r\n\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfPolys );\r\n\t\t\t\t\t\t\t\t\tvar indicesIndex = 0, connectivityIndex = 0;\r\n\t\t\t\t\t\t\t\t\tvar i = 0, len = numberOfPolys, len0 = 0;\r\n\r\n\t\t\t\t\t\t\t\t\twhile ( i < len ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tvar poly = [];\r\n\t\t\t\t\t\t\t\t\t\tvar s = 0, len1 = offset[ i ];\r\n\r\n\t\t\t\t\t\t\t\t\t\twhile ( s < len1 - len0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tpoly.push( connectivity[ connectivityIndex ++ ] );\r\n\t\t\t\t\t\t\t\t\t\t\ts ++;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tvar j = 1;\r\n\r\n\t\t\t\t\t\t\t\t\t\twhile ( j < len1 - len0 - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ 0 ];\r\n\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j ];\r\n\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j + 1 ];\r\n\t\t\t\t\t\t\t\t\t\t\tj ++;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\ti ++;\r\n\t\t\t\t\t\t\t\t\t\tlen0 = offset[ i - 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsectionIndex ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar geometry = new BufferGeometry();\r\n\t\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\r\n\t\t\t\tgeometry.addAttribute( 'position', new BufferAttribute( points, 3 ) );\r\n\r\n\t\t\t\tif ( normals.length === points.length ) {\r\n\r\n\t\t\t\t\tgeometry.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction getStringFile( data ) {\r\n\r\n\t\t\tvar stringFile = '';\r\n\t\t\tvar charArray = new Uint8Array( data );\r\n\t\t\tvar i = 0;\r\n\t\t\tvar len = charArray.length;\r\n\r\n\t\t\twhile ( len -- ) {\r\n\r\n\t\t\t\tstringFile += String.fromCharCode( charArray[ i ++ ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn stringFile;\r\n\r\n\t\t}\r\n\r\n\t\t// get the 5 first lines of the files to check if there is the key word binary\r\n\t\tvar meta = LoaderUtils.decodeText( new Uint8Array( data, 0, 250 ) ).split( '\\n' );\r\n\r\n\t\tif ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {\r\n\r\n\t\t\treturn parseXML( getStringFile( data ) );\r\n\r\n\t\t} else if ( meta[ 2 ].includes( 'ASCII' ) ) {\r\n\r\n\t\t\treturn parseASCII( getStringFile( data ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn parseBinary( data );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ImmediateRenderObject( material ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.material = material;\r\n\tthis.render = function (  ) {};\r\n\r\n}\r\n\r\nImmediateRenderObject.prototype = Object.create( Object3D.prototype );\r\nImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\r\n\r\nImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MarchingCubes = function ( resolution, material, enableUvs, enableColors ) {\r\n\r\n\tImmediateRenderObject.call( this, material );\r\n\r\n\tvar scope = this;\r\n\r\n\t// temp buffers used in polygonize\r\n\r\n\tvar vlist = new Float32Array( 12 * 3 );\r\n\tvar nlist = new Float32Array( 12 * 3 );\r\n\r\n\tthis.enableUvs = enableUvs !== undefined ? enableUvs : false;\r\n\tthis.enableColors = enableColors !== undefined ? enableColors : false;\r\n\r\n\t// functions have to be object properties\r\n\t// prototype functions kill performance\r\n\t// (tested and it was 4x slower !!!)\r\n\r\n\tthis.init = function ( resolution ) {\r\n\r\n\t\tthis.resolution = resolution;\r\n\r\n\t\t// parameters\r\n\r\n\t\tthis.isolation = 80.0;\r\n\r\n\t\t// size of field, 32 is pushing it in Javascript :)\r\n\r\n\t\tthis.size = resolution;\r\n\t\tthis.size2 = this.size * this.size;\r\n\t\tthis.size3 = this.size2 * this.size;\r\n\t\tthis.halfsize = this.size / 2.0;\r\n\r\n\t\t// deltas\r\n\r\n\t\tthis.delta = 2.0 / this.size;\r\n\t\tthis.yd = this.size;\r\n\t\tthis.zd = this.size2;\r\n\r\n\t\tthis.field = new Float32Array( this.size3 );\r\n\t\tthis.normal_cache = new Float32Array( this.size3 * 3 );\r\n\r\n\t\t// immediate render mode simulator\r\n\r\n\t\tthis.maxCount = 4096; // TODO: find the fastest size for this buffer\r\n\t\tthis.count = 0;\r\n\r\n\t\tthis.hasPositions = false;\r\n\t\tthis.hasNormals = false;\r\n\t\tthis.hasColors = false;\r\n\t\tthis.hasUvs = false;\r\n\r\n\t\tthis.positionArray = new Float32Array( this.maxCount * 3 );\r\n\t\tthis.normalArray = new Float32Array( this.maxCount * 3 );\r\n\r\n\t\tif ( this.enableUvs ) {\r\n\r\n\t\t\tthis.uvArray = new Float32Array( this.maxCount * 2 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.enableColors ) {\r\n\r\n\t\t\tthis.colorArray = new Float32Array( this.maxCount * 3 );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t///////////////////////\r\n\t// Polygonization\r\n\t///////////////////////\r\n\r\n\tfunction lerp( a, b, t ) {\r\n\r\n\t\treturn a + ( b - a ) * t;\r\n\r\n\t}\r\n\r\n\tfunction VIntX( q, offset, isol, x, y, z, valp1, valp2 ) {\r\n\r\n\t\tvar mu = ( isol - valp1 ) / ( valp2 - valp1 ),\r\n\t\t\tnc = scope.normal_cache;\r\n\r\n\t\tvlist[ offset + 0 ] = x + mu * scope.delta;\r\n\t\tvlist[ offset + 1 ] = y;\r\n\t\tvlist[ offset + 2 ] = z;\r\n\r\n\t\tnlist[ offset + 0 ] = lerp( nc[ q + 0 ], nc[ q + 3 ], mu );\r\n\t\tnlist[ offset + 1 ] = lerp( nc[ q + 1 ], nc[ q + 4 ], mu );\r\n\t\tnlist[ offset + 2 ] = lerp( nc[ q + 2 ], nc[ q + 5 ], mu );\r\n\r\n\t}\r\n\r\n\tfunction VIntY( q, offset, isol, x, y, z, valp1, valp2 ) {\r\n\r\n\t\tvar mu = ( isol - valp1 ) / ( valp2 - valp1 ),\r\n\t\t\tnc = scope.normal_cache;\r\n\r\n\t\tvlist[ offset + 0 ] = x;\r\n\t\tvlist[ offset + 1 ] = y + mu * scope.delta;\r\n\t\tvlist[ offset + 2 ] = z;\r\n\r\n\t\tvar q2 = q + scope.yd * 3;\r\n\r\n\t\tnlist[ offset + 0 ] = lerp( nc[ q + 0 ], nc[ q2 + 0 ], mu );\r\n\t\tnlist[ offset + 1 ] = lerp( nc[ q + 1 ], nc[ q2 + 1 ], mu );\r\n\t\tnlist[ offset + 2 ] = lerp( nc[ q + 2 ], nc[ q2 + 2 ], mu );\r\n\r\n\t}\r\n\r\n\tfunction VIntZ( q, offset, isol, x, y, z, valp1, valp2 ) {\r\n\r\n\t\tvar mu = ( isol - valp1 ) / ( valp2 - valp1 ),\r\n\t\t\tnc = scope.normal_cache;\r\n\r\n\t\tvlist[ offset + 0 ] = x;\r\n\t\tvlist[ offset + 1 ] = y;\r\n\t\tvlist[ offset + 2 ] = z + mu * scope.delta;\r\n\r\n\t\tvar q2 = q + scope.zd * 3;\r\n\r\n\t\tnlist[ offset + 0 ] = lerp( nc[ q + 0 ], nc[ q2 + 0 ], mu );\r\n\t\tnlist[ offset + 1 ] = lerp( nc[ q + 1 ], nc[ q2 + 1 ], mu );\r\n\t\tnlist[ offset + 2 ] = lerp( nc[ q + 2 ], nc[ q2 + 2 ], mu );\r\n\r\n\t}\r\n\r\n\tfunction compNorm( q ) {\r\n\r\n\t\tvar q3 = q * 3;\r\n\r\n\t\tif ( scope.normal_cache[ q3 ] === 0.0 ) {\r\n\r\n\t\t\tscope.normal_cache[ q3 + 0 ] = scope.field[ q - 1 ] - scope.field[ q + 1 ];\r\n\t\t\tscope.normal_cache[ q3 + 1 ] = scope.field[ q - scope.yd ] - scope.field[ q + scope.yd ];\r\n\t\t\tscope.normal_cache[ q3 + 2 ] = scope.field[ q - scope.zd ] - scope.field[ q + scope.zd ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Returns total number of triangles. Fills triangles.\r\n\t// (this is where most of time is spent - it's inner work of O(n3) loop )\r\n\r\n\tfunction polygonize( fx, fy, fz, q, isol, renderCallback ) {\r\n\r\n\t\t// cache indices\r\n\t\tvar q1 = q + 1,\r\n\t\t\tqy = q + scope.yd,\r\n\t\t\tqz = q + scope.zd,\r\n\t\t\tq1y = q1 + scope.yd,\r\n\t\t\tq1z = q1 + scope.zd,\r\n\t\t\tqyz = q + scope.yd + scope.zd,\r\n\t\t\tq1yz = q1 + scope.yd + scope.zd;\r\n\r\n\t\tvar cubeindex = 0,\r\n\t\t\tfield0 = scope.field[ q ],\r\n\t\t\tfield1 = scope.field[ q1 ],\r\n\t\t\tfield2 = scope.field[ qy ],\r\n\t\t\tfield3 = scope.field[ q1y ],\r\n\t\t\tfield4 = scope.field[ qz ],\r\n\t\t\tfield5 = scope.field[ q1z ],\r\n\t\t\tfield6 = scope.field[ qyz ],\r\n\t\t\tfield7 = scope.field[ q1yz ];\r\n\r\n\t\tif ( field0 < isol ) { cubeindex |= 1; }\r\n\t\tif ( field1 < isol ) { cubeindex |= 2; }\r\n\t\tif ( field2 < isol ) { cubeindex |= 8; }\r\n\t\tif ( field3 < isol ) { cubeindex |= 4; }\r\n\t\tif ( field4 < isol ) { cubeindex |= 16; }\r\n\t\tif ( field5 < isol ) { cubeindex |= 32; }\r\n\t\tif ( field6 < isol ) { cubeindex |= 128; }\r\n\t\tif ( field7 < isol ) { cubeindex |= 64; }\r\n\r\n\t\t// if cube is entirely in/out of the surface - bail, nothing to draw\r\n\r\n\t\tvar bits = edgeTable[ cubeindex ];\r\n\t\tif ( bits === 0 ) { return 0; }\r\n\r\n\t\tvar d = scope.delta,\r\n\t\t\tfx2 = fx + d,\r\n\t\t\tfy2 = fy + d,\r\n\t\t\tfz2 = fz + d;\r\n\r\n\t\t// top of the cube\r\n\r\n\t\tif ( bits & 1 ) {\r\n\r\n\t\t\tcompNorm( q );\r\n\t\t\tcompNorm( q1 );\r\n\t\t\tVIntX( q * 3, 0, isol, fx, fy, fz, field0, field1 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( bits & 2 ) {\r\n\r\n\t\t\tcompNorm( q1 );\r\n\t\t\tcompNorm( q1y );\r\n\t\t\tVIntY( q1 * 3, 3, isol, fx2, fy, fz, field1, field3 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( bits & 4 ) {\r\n\r\n\t\t\tcompNorm( qy );\r\n\t\t\tcompNorm( q1y );\r\n\t\t\tVIntX( qy * 3, 6, isol, fx, fy2, fz, field2, field3 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( bits & 8 ) {\r\n\r\n\t\t\tcompNorm( q );\r\n\t\t\tcompNorm( qy );\r\n\t\t\tVIntY( q * 3, 9, isol, fx, fy, fz, field0, field2 );\r\n\r\n\t\t}\r\n\r\n\t\t// bottom of the cube\r\n\r\n\t\tif ( bits & 16 ) {\r\n\r\n\t\t\tcompNorm( qz );\r\n\t\t\tcompNorm( q1z );\r\n\t\t\tVIntX( qz * 3, 12, isol, fx, fy, fz2, field4, field5 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( bits & 32 ) {\r\n\r\n\t\t\tcompNorm( q1z );\r\n\t\t\tcompNorm( q1yz );\r\n\t\t\tVIntY( q1z * 3, 15, isol, fx2, fy, fz2, field5, field7 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( bits & 64 ) {\r\n\r\n\t\t\tcompNorm( qyz );\r\n\t\t\tcompNorm( q1yz );\r\n\t\t\tVIntX( qyz * 3, 18, isol, fx, fy2, fz2, field6, field7 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( bits & 128 ) {\r\n\r\n\t\t\tcompNorm( qz );\r\n\t\t\tcompNorm( qyz );\r\n\t\t\tVIntY( qz * 3, 21, isol, fx, fy, fz2, field4, field6 );\r\n\r\n\t\t}\r\n\r\n\t\t// vertical lines of the cube\r\n\r\n\t\tif ( bits & 256 ) {\r\n\r\n\t\t\tcompNorm( q );\r\n\t\t\tcompNorm( qz );\r\n\t\t\tVIntZ( q * 3, 24, isol, fx, fy, fz, field0, field4 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( bits & 512 ) {\r\n\r\n\t\t\tcompNorm( q1 );\r\n\t\t\tcompNorm( q1z );\r\n\t\t\tVIntZ( q1 * 3, 27, isol, fx2, fy, fz, field1, field5 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( bits & 1024 ) {\r\n\r\n\t\t\tcompNorm( q1y );\r\n\t\t\tcompNorm( q1yz );\r\n\t\t\tVIntZ( q1y * 3, 30, isol, fx2, fy2, fz, field3, field7 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( bits & 2048 ) {\r\n\r\n\t\t\tcompNorm( qy );\r\n\t\t\tcompNorm( qyz );\r\n\t\t\tVIntZ( qy * 3, 33, isol, fx, fy2, fz, field2, field6 );\r\n\r\n\t\t}\r\n\r\n\t\tcubeindex <<= 4; // re-purpose cubeindex into an offset into triTable\r\n\r\n\t\tvar o1, o2, o3, numtris = 0, i = 0;\r\n\r\n\t\t// here is where triangles are created\r\n\r\n\t\twhile ( triTable[ cubeindex + i ] != - 1 ) {\r\n\r\n\t\t\to1 = cubeindex + i;\r\n\t\t\to2 = o1 + 1;\r\n\t\t\to3 = o1 + 2;\r\n\r\n\t\t\tposnormtriv( vlist, nlist,\r\n\t\t\t\t3 * triTable[ o1 ],\r\n\t\t\t\t3 * triTable[ o2 ],\r\n\t\t\t\t3 * triTable[ o3 ],\r\n\t\t\t\trenderCallback );\r\n\r\n\t\t\ti += 3;\r\n\t\t\tnumtris ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn numtris;\r\n\r\n\t}\r\n\r\n\t/////////////////////////////////////\r\n\t// Immediate render mode simulator\r\n\t/////////////////////////////////////\r\n\r\n\tfunction posnormtriv( pos, norm, o1, o2, o3, renderCallback ) {\r\n\r\n\t\tvar c = scope.count * 3;\r\n\r\n\t\t// positions\r\n\r\n\t\tscope.positionArray[ c + 0 ] = pos[ o1 ];\r\n\t\tscope.positionArray[ c + 1 ] = pos[ o1 + 1 ];\r\n\t\tscope.positionArray[ c + 2 ] = pos[ o1 + 2 ];\r\n\r\n\t\tscope.positionArray[ c + 3 ] = pos[ o2 ];\r\n\t\tscope.positionArray[ c + 4 ] = pos[ o2 + 1 ];\r\n\t\tscope.positionArray[ c + 5 ] = pos[ o2 + 2 ];\r\n\r\n\t\tscope.positionArray[ c + 6 ] = pos[ o3 ];\r\n\t\tscope.positionArray[ c + 7 ] = pos[ o3 + 1 ];\r\n\t\tscope.positionArray[ c + 8 ] = pos[ o3 + 2 ];\r\n\r\n\t\t// normals\r\n\r\n\t\tif ( scope.material.flatShading === true ) {\r\n\r\n\t\t\tvar nx = ( norm[ o1 + 0 ] + norm[ o2 + 0 ] + norm[ o3 + 0 ] ) / 3;\r\n\t\t\tvar ny = ( norm[ o1 + 1 ] + norm[ o2 + 1 ] + norm[ o3 + 1 ] ) / 3;\r\n\t\t\tvar nz = ( norm[ o1 + 2 ] + norm[ o2 + 2 ] + norm[ o3 + 2 ] ) / 3;\r\n\r\n\t\t\tscope.normalArray[ c + 0 ] = nx;\r\n\t\t\tscope.normalArray[ c + 1 ] = ny;\r\n\t\t\tscope.normalArray[ c + 2 ] = nz;\r\n\r\n\t\t\tscope.normalArray[ c + 3 ] = nx;\r\n\t\t\tscope.normalArray[ c + 4 ] = ny;\r\n\t\t\tscope.normalArray[ c + 5 ] = nz;\r\n\r\n\t\t\tscope.normalArray[ c + 6 ] = nx;\r\n\t\t\tscope.normalArray[ c + 7 ] = ny;\r\n\t\t\tscope.normalArray[ c + 8 ] = nz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tscope.normalArray[ c + 0 ] = norm[ o1 + 0 ];\r\n\t\t\tscope.normalArray[ c + 1 ] = norm[ o1 + 1 ];\r\n\t\t\tscope.normalArray[ c + 2 ] = norm[ o1 + 2 ];\r\n\r\n\t\t\tscope.normalArray[ c + 3 ] = norm[ o2 + 0 ];\r\n\t\t\tscope.normalArray[ c + 4 ] = norm[ o2 + 1 ];\r\n\t\t\tscope.normalArray[ c + 5 ] = norm[ o2 + 2 ];\r\n\r\n\t\t\tscope.normalArray[ c + 6 ] = norm[ o3 + 0 ];\r\n\t\t\tscope.normalArray[ c + 7 ] = norm[ o3 + 1 ];\r\n\t\t\tscope.normalArray[ c + 8 ] = norm[ o3 + 2 ];\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tif ( scope.enableUvs ) {\r\n\r\n\t\t\tvar d = scope.count * 2;\r\n\r\n\t\t\tscope.uvArray[ d + 0 ] = pos[ o1 + 0 ];\r\n\t\t\tscope.uvArray[ d + 1 ] = pos[ o1 + 2 ];\r\n\r\n\t\t\tscope.uvArray[ d + 2 ] = pos[ o2 + 0 ];\r\n\t\t\tscope.uvArray[ d + 3 ] = pos[ o2 + 2 ];\r\n\r\n\t\t\tscope.uvArray[ d + 4 ] = pos[ o3 + 0 ];\r\n\t\t\tscope.uvArray[ d + 5 ] = pos[ o3 + 2 ];\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tif ( scope.enableColors ) {\r\n\r\n\t\t\tscope.colorArray[ c + 0 ] = pos[ o1 + 0 ];\r\n\t\t\tscope.colorArray[ c + 1 ] = pos[ o1 + 1 ];\r\n\t\t\tscope.colorArray[ c + 2 ] = pos[ o1 + 2 ];\r\n\r\n\t\t\tscope.colorArray[ c + 3 ] = pos[ o2 + 0 ];\r\n\t\t\tscope.colorArray[ c + 4 ] = pos[ o2 + 1 ];\r\n\t\t\tscope.colorArray[ c + 5 ] = pos[ o2 + 2 ];\r\n\r\n\t\t\tscope.colorArray[ c + 6 ] = pos[ o3 + 0 ];\r\n\t\t\tscope.colorArray[ c + 7 ] = pos[ o3 + 1 ];\r\n\t\t\tscope.colorArray[ c + 8 ] = pos[ o3 + 2 ];\r\n\r\n\t\t}\r\n\r\n\t\tscope.count += 3;\r\n\r\n\t\tif ( scope.count >= scope.maxCount - 3 ) {\r\n\r\n\t\t\tscope.hasPositions = true;\r\n\t\t\tscope.hasNormals = true;\r\n\r\n\t\t\tif ( scope.enableUvs ) {\r\n\r\n\t\t\t\tscope.hasUvs = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scope.enableColors ) {\r\n\r\n\t\t\t\tscope.hasColors = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\trenderCallback( scope );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.begin = function () {\r\n\r\n\t\tthis.count = 0;\r\n\r\n\t\tthis.hasPositions = false;\r\n\t\tthis.hasNormals = false;\r\n\t\tthis.hasUvs = false;\r\n\t\tthis.hasColors = false;\r\n\r\n\t};\r\n\r\n\tthis.end = function ( renderCallback ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( this.count === 0 ) { return; }\r\n\r\n\t\tfor ( var i = this.count * 3; i < this.positionArray.length; i ++ ) {\r\n\r\n\t\t\tthis$1.positionArray[ i ] = 0.0;\r\n\r\n\t\t}\r\n\r\n\t\tthis.hasPositions = true;\r\n\t\tthis.hasNormals = true;\r\n\r\n\t\tif ( this.enableUvs && this.material.map ) {\r\n\r\n\t\t\tthis.hasUvs = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.enableColors && this.material.vertexColors !== NoColors ) {\r\n\r\n\t\t\tthis.hasColors = true;\r\n\r\n\t\t}\r\n\r\n\t\trenderCallback( this );\r\n\r\n\t};\r\n\r\n\t/////////////////////////////////////\r\n\t// Metaballs\r\n\t/////////////////////////////////////\r\n\r\n\t// Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after\r\n\t// a fixed distance, determined by strength and subtract.\r\n\r\n\tthis.addBall = function ( ballx, bally, ballz, strength, subtract ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar sign = Math.sign( strength );\r\n\t\tstrength = Math.abs( strength );\r\n\r\n\t\t// Let's solve the equation to find the radius:\r\n\t\t// 1.0 / (0.000001 + radius^2) * strength - subtract = 0\r\n\t\t// strength / (radius^2) = subtract\r\n\t\t// strength = subtract * radius^2\r\n\t\t// radius^2 = strength / subtract\r\n\t\t// radius = sqrt(strength / subtract)\r\n\r\n\t\tvar radius = this.size * Math.sqrt( strength / subtract ),\r\n\t\t\tzs = ballz * this.size,\r\n\t\t\tys = bally * this.size,\r\n\t\t\txs = ballx * this.size;\r\n\r\n\t\tvar min_z = Math.floor( zs - radius ); if ( min_z < 1 ) { min_z = 1; }\r\n\t\tvar max_z = Math.floor( zs + radius ); if ( max_z > this.size - 1 ) { max_z = this.size - 1; }\r\n\t\tvar min_y = Math.floor( ys - radius ); if ( min_y < 1 ) { min_y = 1; }\r\n\t\tvar max_y = Math.floor( ys + radius ); if ( max_y > this.size - 1 ) { max_y = this.size - 1; }\r\n\t\tvar min_x = Math.floor( xs - radius ); if ( min_x < 1 ) { min_x = 1; }\r\n\t\tvar max_x = Math.floor( xs + radius ); if ( max_x > this.size - 1 ) { max_x = this.size - 1; }\r\n\r\n\t\t// Don't polygonize in the outer layer because normals aren't\r\n\t\t// well-defined there.\r\n\r\n\t\tvar x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;\r\n\r\n\t\tfor ( z = min_z; z < max_z; z ++ ) {\r\n\r\n\t\t\tz_offset = this$1.size2 * z;\r\n\t\t\tfz = z / this$1.size - ballz;\r\n\t\t\tfz2 = fz * fz;\r\n\r\n\t\t\tfor ( y = min_y; y < max_y; y ++ ) {\r\n\r\n\t\t\t\ty_offset = z_offset + this$1.size * y;\r\n\t\t\t\tfy = y / this$1.size - bally;\r\n\t\t\t\tfy2 = fy * fy;\r\n\r\n\t\t\t\tfor ( x = min_x; x < max_x; x ++ ) {\r\n\r\n\t\t\t\t\tfx = x / this$1.size - ballx;\r\n\t\t\t\t\tval = strength / ( 0.000001 + fx * fx + fy2 + fz2 ) - subtract;\r\n\t\t\t\t\tif ( val > 0.0 ) { this$1.field[ y_offset + x ] += val * sign; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.addPlaneX = function ( strength, subtract ) {\r\n\r\n\t\tvar x, y, z, xx, val, xdiv, cxy,\r\n\r\n\t\t\t// cache attribute lookups\r\n\t\t\tsize = this.size,\r\n\t\t\tyd = this.yd,\r\n\t\t\tzd = this.zd,\r\n\t\t\tfield = this.field,\r\n\r\n\t\t\tdist = size * Math.sqrt( strength / subtract );\r\n\r\n\t\tif ( dist > size ) { dist = size; }\r\n\r\n\t\tfor ( x = 0; x < dist; x ++ ) {\r\n\r\n\t\t\txdiv = x / size;\r\n\t\t\txx = xdiv * xdiv;\r\n\t\t\tval = strength / ( 0.0001 + xx ) - subtract;\r\n\r\n\t\t\tif ( val > 0.0 ) {\r\n\r\n\t\t\t\tfor ( y = 0; y < size; y ++ ) {\r\n\r\n\t\t\t\t\tcxy = x + y * yd;\r\n\r\n\t\t\t\t\tfor ( z = 0; z < size; z ++ ) {\r\n\r\n\t\t\t\t\t\tfield[ zd * z + cxy ] += val;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.addPlaneY = function ( strength, subtract ) {\r\n\r\n\t\tvar x, y, z, yy, val, ydiv, cy, cxy,\r\n\r\n\t\t\t// cache attribute lookups\r\n\t\t\tsize = this.size,\r\n\t\t\tyd = this.yd,\r\n\t\t\tzd = this.zd,\r\n\t\t\tfield = this.field,\r\n\r\n\t\t\tdist = size * Math.sqrt( strength / subtract );\r\n\r\n\t\tif ( dist > size ) { dist = size; }\r\n\r\n\t\tfor ( y = 0; y < dist; y ++ ) {\r\n\r\n\t\t\tydiv = y / size;\r\n\t\t\tyy = ydiv * ydiv;\r\n\t\t\tval = strength / ( 0.0001 + yy ) - subtract;\r\n\r\n\t\t\tif ( val > 0.0 ) {\r\n\r\n\t\t\t\tcy = y * yd;\r\n\r\n\t\t\t\tfor ( x = 0; x < size; x ++ ) {\r\n\r\n\t\t\t\t\tcxy = cy + x;\r\n\r\n\t\t\t\t\tfor ( z = 0; z < size; z ++ )\r\n\t\t\t\t\t\t{ field[ zd * z + cxy ] += val; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.addPlaneZ = function ( strength, subtract ) {\r\n\r\n\t\tvar x, y, z, zz, val, zdiv, cz, cyz,\r\n\r\n\t\t\t// cache attribute lookups\r\n\t\t\tsize = this.size,\r\n\t\t\tyd = this.yd,\r\n\t\t\tzd = this.zd,\r\n\t\t\tfield = this.field,\r\n\r\n\t\t\tdist = size * Math.sqrt( strength / subtract );\r\n\r\n\t\tif ( dist > size ) { dist = size; }\r\n\r\n\t\tfor ( z = 0; z < dist; z ++ ) {\r\n\r\n\t\t\tzdiv = z / size;\r\n\t\t\tzz = zdiv * zdiv;\r\n\t\t\tval = strength / ( 0.0001 + zz ) - subtract;\r\n\t\t\tif ( val > 0.0 ) {\r\n\r\n\t\t\t\tcz = zd * z;\r\n\r\n\t\t\t\tfor ( y = 0; y < size; y ++ ) {\r\n\r\n\t\t\t\t\tcyz = cz + y * yd;\r\n\r\n\t\t\t\t\tfor ( x = 0; x < size; x ++ )\r\n\t\t\t\t\t\t{ field[ cyz + x ] += val; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t/////////////////////////////////////\r\n\t// Updates\r\n\t/////////////////////////////////////\r\n\r\n\tthis.reset = function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar i;\r\n\r\n\t\t// wipe the normal cache\r\n\r\n\t\tfor ( i = 0; i < this.size3; i ++ ) {\r\n\r\n\t\t\tthis$1.normal_cache[ i * 3 ] = 0.0;\r\n\t\t\tthis$1.field[ i ] = 0.0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.render = function ( renderCallback ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.begin();\r\n\r\n\t\t// Triangulate. Yeah, this is slow.\r\n\r\n\t\tvar smin2 = this.size - 2;\r\n\r\n\t\tfor ( var z = 1; z < smin2; z ++ ) {\r\n\r\n\t\t\tvar z_offset = this$1.size2 * z;\r\n\t\t\tvar fz = ( z - this$1.halfsize ) / this$1.halfsize; //+ 1\r\n\r\n\t\t\tfor ( var y = 1; y < smin2; y ++ ) {\r\n\r\n\t\t\t\tvar y_offset = z_offset + this$1.size * y;\r\n\t\t\t\tvar fy = ( y - this$1.halfsize ) / this$1.halfsize; //+ 1\r\n\r\n\t\t\t\tfor ( var x = 1; x < smin2; x ++ ) {\r\n\r\n\t\t\t\t\tvar fx = ( x - this$1.halfsize ) / this$1.halfsize; //+ 1\r\n\t\t\t\t\tvar q = y_offset + x;\r\n\r\n\t\t\t\t\tpolygonize( fx, fy, fz, q, this$1.isolation, renderCallback );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.end( renderCallback );\r\n\r\n\t};\r\n\r\n\tthis.generateGeometry = function () {\r\n\r\n\t\tconsole.warn( 'MarchingCubes: generateGeometry() now returns BufferGeometry' );\r\n\t\treturn this.generateBufferGeometry();\r\n\r\n\t};\r\n\r\n\tfunction concatenate( a, b, length ) {\r\n\r\n\t\tvar result = new Float32Array( a.length + length );\r\n\t\tresult.set( a, 0 );\r\n\t\tresult.set( b.slice( 0, length ), a.length );\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tthis.generateBufferGeometry = function () {\r\n\r\n\t\tvar geo = new BufferGeometry();\r\n\t\tvar posArray = new Float32Array();\r\n\t\tvar normArray = new Float32Array();\r\n\t\tvar colorArray = new Float32Array();\r\n\t\tvar uvArray = new Float32Array();\r\n\t\tvar scope = this;\r\n\r\n\t\tvar geo_callback = function ( object ) {\r\n\r\n\t\t\tif ( scope.hasPositions ) { posArray = concatenate( posArray, object.positionArray, object.count * 3 ); }\r\n\t\t\tif ( scope.hasNormals ) { normArray = concatenate( normArray, object.normalArray, object.count * 3 ); }\r\n\t\t\tif ( scope.hasColors ) { colorArray = concatenate( colorArray, object.colorArray, object.count * 3 ); }\r\n\t\t\tif ( scope.hasUvs ) { uvArray = concatenate( uvArray, object.uvArray, object.count * 2 ); }\r\n\r\n\t\t\tobject.count = 0;\r\n\r\n\t\t};\r\n\r\n\t\tthis.render( geo_callback );\r\n\r\n\t\tif ( this.hasPositions ) { geo.addAttribute( 'position', new BufferAttribute( posArray, 3 ) ); }\r\n\t\tif ( this.hasNormals ) { geo.addAttribute( 'normal', new BufferAttribute( normArray, 3 ) ); }\r\n\t\tif ( this.hasColors ) { geo.addAttribute( 'color', new BufferAttribute( colorArray, 3 ) ); }\r\n\t\tif ( this.hasUvs ) { geo.addAttribute( 'uv', new BufferAttribute( uvArray, 2 ) ); }\r\n\r\n\t\treturn geo;\r\n\r\n\t};\r\n\r\n\tthis.init( resolution );\r\n\r\n};\r\n\r\nMarchingCubes.prototype = Object.create( ImmediateRenderObject.prototype );\r\nMarchingCubes.prototype.constructor = MarchingCubes;\r\n\r\n/////////////////////////////////////\r\n// Marching cubes lookup tables\r\n/////////////////////////////////////\r\n\r\n// These tables are straight from Paul Bourke's page:\r\n// http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/\r\n// who in turn got them from Cory Gene Bloyd.\r\n\r\nvar edgeTable = new Int32Array( [\r\n\t0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,\r\n\t0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,\r\n\t0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,\r\n\t0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,\r\n\t0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,\r\n\t0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,\r\n\t0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,\r\n\t0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,\r\n\t0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,\r\n\t0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,\r\n\t0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,\r\n\t0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,\r\n\t0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,\r\n\t0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,\r\n\t0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,\r\n\t0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,\r\n\t0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,\r\n\t0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,\r\n\t0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,\r\n\t0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,\r\n\t0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,\r\n\t0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,\r\n\t0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,\r\n\t0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,\r\n\t0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,\r\n\t0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,\r\n\t0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,\r\n\t0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,\r\n\t0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,\r\n\t0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,\r\n\t0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,\r\n\t0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0 ] );\r\n\r\nvar triTable = new Int32Array( [\r\n\t- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 1, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 8, 3, 9, 8, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 8, 3, 1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 2, 10, 0, 2, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t2, 8, 3, 2, 10, 8, 10, 9, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 11, 2, 8, 11, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 9, 0, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 11, 2, 1, 9, 11, 9, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 10, 1, 11, 10, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 10, 1, 0, 8, 10, 8, 11, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 9, 0, 3, 11, 9, 11, 10, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 8, 10, 10, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 3, 0, 7, 3, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 1, 9, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 1, 9, 4, 7, 1, 7, 3, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 2, 10, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 4, 7, 3, 0, 4, 1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 2, 10, 9, 0, 2, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, - 1, - 1, - 1, - 1,\r\n\t8, 4, 7, 3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t11, 4, 7, 11, 2, 4, 2, 0, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 0, 1, 8, 4, 7, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, - 1, - 1, - 1, - 1,\r\n\t3, 10, 1, 3, 11, 10, 7, 8, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, - 1, - 1, - 1, - 1,\r\n\t4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, - 1, - 1, - 1, - 1,\r\n\t4, 7, 11, 4, 11, 9, 9, 11, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 5, 4, 0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 5, 4, 1, 5, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t8, 5, 4, 8, 3, 5, 3, 1, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 2, 10, 9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 0, 8, 1, 2, 10, 4, 9, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t5, 2, 10, 5, 4, 2, 4, 0, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, - 1, - 1, - 1, - 1,\r\n\t9, 5, 4, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 11, 2, 0, 8, 11, 4, 9, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 5, 4, 0, 1, 5, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, - 1, - 1, - 1, - 1,\r\n\t10, 3, 11, 10, 1, 3, 9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, - 1, - 1, - 1, - 1,\r\n\t5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, - 1, - 1, - 1, - 1,\r\n\t5, 4, 8, 5, 8, 10, 10, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 7, 8, 5, 7, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 3, 0, 9, 5, 3, 5, 7, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 7, 8, 0, 1, 7, 1, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 5, 3, 3, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 7, 8, 9, 5, 7, 10, 1, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, - 1, - 1, - 1, - 1,\r\n\t8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, - 1, - 1, - 1, - 1,\r\n\t2, 10, 5, 2, 5, 3, 3, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t7, 9, 5, 7, 8, 9, 3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, - 1, - 1, - 1, - 1,\r\n\t2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, - 1, - 1, - 1, - 1,\r\n\t11, 2, 1, 11, 1, 7, 7, 1, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, - 1, - 1, - 1, - 1,\r\n\t5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, - 1,\r\n\t11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, - 1,\r\n\t11, 10, 5, 7, 11, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 8, 3, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 0, 1, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 8, 3, 1, 9, 8, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 6, 5, 2, 6, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 6, 5, 1, 2, 6, 3, 0, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 6, 5, 9, 0, 6, 0, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, - 1, - 1, - 1, - 1,\r\n\t2, 3, 11, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t11, 0, 8, 11, 2, 0, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 1, 9, 2, 3, 11, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, - 1, - 1, - 1, - 1,\r\n\t6, 3, 11, 6, 5, 3, 5, 1, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, - 1, - 1, - 1, - 1,\r\n\t3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, - 1, - 1, - 1, - 1,\r\n\t6, 5, 9, 6, 9, 11, 11, 9, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t5, 10, 6, 4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 3, 0, 4, 7, 3, 6, 5, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 9, 0, 5, 10, 6, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, - 1, - 1, - 1, - 1,\r\n\t6, 1, 2, 6, 5, 1, 4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, - 1, - 1, - 1, - 1,\r\n\t8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, - 1, - 1, - 1, - 1,\r\n\t7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, - 1,\r\n\t3, 11, 2, 7, 8, 4, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, - 1, - 1, - 1, - 1,\r\n\t0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, - 1, - 1, - 1, - 1,\r\n\t9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, - 1,\r\n\t8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, - 1, - 1, - 1, - 1,\r\n\t5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, - 1,\r\n\t0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, - 1,\r\n\t6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, - 1, - 1, - 1, - 1,\r\n\t10, 4, 9, 6, 4, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 10, 6, 4, 9, 10, 0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t10, 0, 1, 10, 6, 0, 6, 4, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, - 1, - 1, - 1, - 1,\r\n\t1, 4, 9, 1, 2, 4, 2, 6, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, - 1, - 1, - 1, - 1,\r\n\t0, 2, 4, 4, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t8, 3, 2, 8, 2, 4, 4, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t10, 4, 9, 10, 6, 4, 11, 2, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, - 1, - 1, - 1, - 1,\r\n\t3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, - 1, - 1, - 1, - 1,\r\n\t6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, - 1,\r\n\t9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, - 1, - 1, - 1, - 1,\r\n\t8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, - 1,\r\n\t3, 11, 6, 3, 6, 0, 0, 6, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t6, 4, 8, 11, 6, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t7, 10, 6, 7, 8, 10, 8, 9, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, - 1, - 1, - 1, - 1,\r\n\t10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, - 1, - 1, - 1, - 1,\r\n\t10, 6, 7, 10, 7, 1, 1, 7, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, - 1, - 1, - 1, - 1,\r\n\t2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, - 1,\r\n\t7, 8, 0, 7, 0, 6, 6, 0, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t7, 3, 2, 6, 7, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, - 1, - 1, - 1, - 1,\r\n\t2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, - 1,\r\n\t1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, - 1,\r\n\t11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, - 1, - 1, - 1, - 1,\r\n\t8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, - 1,\r\n\t0, 9, 1, 11, 6, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, - 1, - 1, - 1, - 1,\r\n\t7, 11, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 0, 8, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 1, 9, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t8, 1, 9, 8, 3, 1, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t10, 1, 2, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 2, 10, 3, 0, 8, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t2, 9, 0, 2, 10, 9, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, - 1, - 1, - 1, - 1,\r\n\t7, 2, 3, 6, 2, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t7, 0, 8, 7, 6, 0, 6, 2, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t2, 7, 6, 2, 3, 7, 0, 1, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, - 1, - 1, - 1, - 1,\r\n\t10, 7, 6, 10, 1, 7, 1, 3, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, - 1, - 1, - 1, - 1,\r\n\t0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, - 1, - 1, - 1, - 1,\r\n\t7, 6, 10, 7, 10, 8, 8, 10, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t6, 8, 4, 11, 8, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 6, 11, 3, 0, 6, 0, 4, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t8, 6, 11, 8, 4, 6, 9, 0, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, - 1, - 1, - 1, - 1,\r\n\t6, 8, 4, 6, 11, 8, 2, 10, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, - 1, - 1, - 1, - 1,\r\n\t4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, - 1, - 1, - 1, - 1,\r\n\t10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, - 1,\r\n\t8, 2, 3, 8, 4, 2, 4, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 4, 2, 4, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, - 1, - 1, - 1, - 1,\r\n\t1, 9, 4, 1, 4, 2, 2, 4, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, - 1, - 1, - 1, - 1,\r\n\t10, 1, 0, 10, 0, 6, 6, 0, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, - 1,\r\n\t10, 9, 4, 6, 10, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 9, 5, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 8, 3, 4, 9, 5, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t5, 0, 1, 5, 4, 0, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, - 1, - 1, - 1, - 1,\r\n\t9, 5, 4, 10, 1, 2, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, - 1, - 1, - 1, - 1,\r\n\t7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, - 1, - 1, - 1, - 1,\r\n\t3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, - 1,\r\n\t7, 2, 3, 7, 6, 2, 5, 4, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, - 1, - 1, - 1, - 1,\r\n\t3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, - 1, - 1, - 1, - 1,\r\n\t6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, - 1,\r\n\t9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, - 1, - 1, - 1, - 1,\r\n\t1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, - 1,\r\n\t4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, - 1,\r\n\t7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, - 1, - 1, - 1, - 1,\r\n\t6, 9, 5, 6, 11, 9, 11, 8, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, - 1, - 1, - 1, - 1,\r\n\t0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, - 1, - 1, - 1, - 1,\r\n\t6, 11, 3, 6, 3, 5, 5, 3, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, - 1, - 1, - 1, - 1,\r\n\t0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, - 1,\r\n\t11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, - 1,\r\n\t6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, - 1, - 1, - 1, - 1,\r\n\t5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, - 1, - 1, - 1, - 1,\r\n\t9, 5, 6, 9, 6, 0, 0, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, - 1,\r\n\t1, 5, 6, 2, 1, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, - 1,\r\n\t10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, - 1, - 1, - 1, - 1,\r\n\t0, 3, 8, 5, 6, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t10, 5, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t11, 5, 10, 7, 5, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t11, 5, 10, 11, 7, 5, 8, 3, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t5, 11, 7, 5, 10, 11, 1, 9, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, - 1, - 1, - 1, - 1,\r\n\t11, 1, 2, 11, 7, 1, 7, 5, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, - 1, - 1, - 1, - 1,\r\n\t9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, - 1, - 1, - 1, - 1,\r\n\t7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, - 1,\r\n\t2, 5, 10, 2, 3, 5, 3, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, - 1, - 1, - 1, - 1,\r\n\t9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, - 1, - 1, - 1, - 1,\r\n\t9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, - 1,\r\n\t1, 3, 5, 3, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 8, 7, 0, 7, 1, 1, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 0, 3, 9, 3, 5, 5, 3, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 8, 7, 5, 9, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t5, 8, 4, 5, 10, 8, 10, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, - 1, - 1, - 1, - 1,\r\n\t0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, - 1, - 1, - 1, - 1,\r\n\t10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, - 1,\r\n\t2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, - 1, - 1, - 1, - 1,\r\n\t0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, - 1,\r\n\t0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, - 1,\r\n\t9, 4, 5, 2, 11, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, - 1, - 1, - 1, - 1,\r\n\t5, 10, 2, 5, 2, 4, 4, 2, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, - 1,\r\n\t5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, - 1, - 1, - 1, - 1,\r\n\t8, 4, 5, 8, 5, 3, 3, 5, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 4, 5, 1, 0, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, - 1, - 1, - 1, - 1,\r\n\t9, 4, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 11, 7, 4, 9, 11, 9, 10, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, - 1, - 1, - 1, - 1,\r\n\t1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, - 1, - 1, - 1, - 1,\r\n\t3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, - 1,\r\n\t4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, - 1, - 1, - 1, - 1,\r\n\t9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, - 1,\r\n\t11, 7, 4, 11, 4, 2, 2, 4, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, - 1, - 1, - 1, - 1,\r\n\t2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, - 1, - 1, - 1, - 1,\r\n\t9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, - 1,\r\n\t3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, - 1,\r\n\t1, 10, 2, 8, 7, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 9, 1, 4, 1, 7, 7, 1, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, - 1, - 1, - 1, - 1,\r\n\t4, 0, 3, 7, 4, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t4, 8, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 10, 8, 10, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 0, 9, 3, 9, 11, 11, 9, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 1, 10, 0, 10, 8, 8, 10, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 1, 10, 11, 3, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 2, 11, 1, 11, 9, 9, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, - 1, - 1, - 1, - 1,\r\n\t0, 2, 11, 8, 0, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t3, 2, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t2, 3, 8, 2, 8, 10, 10, 8, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t9, 10, 2, 0, 9, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, - 1, - 1, - 1, - 1,\r\n\t1, 10, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t1, 3, 8, 9, 1, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 9, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t0, 3, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,\r\n\t- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1 ] );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ColorConverter = {\r\n\r\n\tsetHSV: function ( color, h, s, v ) {\r\n\r\n\t\t// https://gist.github.com/xpansive/1337890#file-index-js\r\n\r\n\t\th = _Math.euclideanModulo( h, 1 );\r\n\t\ts = _Math.clamp( s, 0, 1 );\r\n\t\tv = _Math.clamp( v, 0, 1 );\r\n\r\n\t\treturn color.setHSL( h, ( s * v ) / ( ( h = ( 2 - s ) * v ) < 1 ? h : ( 2 - h ) ), h * 0.5 );\r\n\r\n\t},\r\n\r\n\tgetHSV: function() {\r\n\r\n\t\tvar hsl = {};\r\n\r\n\t\treturn function getHSV( color, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'ColorConverter: .getHSV() target is now required' );\r\n\t\t\t\ttarget = { h: 0, s: 0, l: 0 };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolor.getHSL( hsl );\r\n\r\n\t\t\t// based on https://gist.github.com/xpansive/1337890#file-index-js\r\n\t\t\thsl.s *= ( hsl.l < 0.5 ) ? hsl.l : ( 1 - hsl.l );\r\n\r\n\t\t\ttarget.h = hsl.h;\r\n\t\t\ttarget.s = 2 * hsl.s / ( hsl.l + hsl.s );\r\n\t\t\ttarget.v = hsl.l + hsl.s;\r\n\r\n\t\t\treturn target;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\t// where c, m, y, k is between 0 and 1\r\n\t\r\n\tsetCMYK: function ( color, c, m, y, k ) {\r\n\r\n\t\tvar r = ( 1 - c ) * ( 1 - k );\r\n\t\tvar g = ( 1 - m ) * ( 1 - k );\r\n\t\tvar b = ( 1 - y ) * ( 1 - k );\r\n\r\n\t\treturn color.setRGB( r, g, b );\r\n\r\n\t},\r\n\r\n\tgetCMYK: function ( color, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'ColorConverter: .getCMYK() target is now required' );\r\n\t\t\ttarget = { c: 0, m: 0, y: 0, k:0 };\r\n\r\n\t\t}\r\n\r\n\t\tvar r = color.r;\r\n\t\tvar g = color.g;\r\n\t\tvar b = color.b;\r\n\r\n\t\tvar k = 1 - Math.max( r, g, b );\r\n\t\tvar c = ( 1 - r - k ) / ( 1 - k );\r\n\t\tvar m = ( 1 - g - k ) / ( 1 - k );\r\n\t\tvar y = ( 1 - b - k ) / ( 1 - k );\r\n\r\n\t\ttarget.c = c;\r\n\t\ttarget.m = m;\r\n\t\ttarget.y = y;\r\n\t\ttarget.k = k;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.needsUpdate = true;\r\n\r\n}\r\n\r\nCanvasTexture.prototype = Object.create( Texture.prototype );\r\nCanvasTexture.prototype.constructor = CanvasTexture;\r\nCanvasTexture.prototype.isCanvasTexture = true;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar geometry;\r\n\r\nfunction Sprite( material ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'Sprite';\r\n\r\n\tif ( geometry === undefined ) {\r\n\r\n\t\tgeometry = new BufferGeometry();\r\n\r\n\t\tvar float32Array = new Float32Array( [\r\n\t\t\t- 0.5, - 0.5, 0, 0, 0,\r\n\t\t\t0.5, - 0.5, 0, 1, 0,\r\n\t\t\t0.5, 0.5, 0, 1, 1,\r\n\t\t\t- 0.5, 0.5, 0, 0, 1\r\n\t\t] );\r\n\r\n\t\tvar interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\r\n\r\n\t\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\r\n\t\tgeometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\r\n\t\tgeometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\r\n\r\n\t}\r\n\r\n\tthis.geometry = geometry;\r\n\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\r\n\r\n\tthis.center = new Vector2( 0.5, 0.5 );\r\n\r\n}\r\n\r\nSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: Sprite,\r\n\r\n\tisSprite: true,\r\n\r\n\traycast: ( function () {\r\n\r\n\t\tvar intersectPoint = new Vector3();\r\n\t\tvar worldScale = new Vector3();\r\n\t\tvar mvPosition = new Vector3();\r\n\r\n\t\tvar alignedPosition = new Vector2();\r\n\t\tvar rotatedPosition = new Vector2();\r\n\t\tvar viewWorldMatrix = new Matrix4();\r\n\r\n\t\tvar vA = new Vector3();\r\n\t\tvar vB = new Vector3();\r\n\t\tvar vC = new Vector3();\r\n\r\n\t\tvar uvA = new Vector2();\r\n\t\tvar uvB = new Vector2();\r\n\t\tvar uvC = new Vector2();\r\n\r\n\t\tfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\r\n\r\n\t\t\t// compute position in camera space\r\n\t\t\talignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\r\n\r\n\t\t\t// to check if rotation is not zero\r\n\t\t\tif ( sin !== undefined ) {\r\n\r\n\t\t\t\trotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );\r\n\t\t\t\trotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trotatedPosition.copy( alignedPosition );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertexPosition.copy( mvPosition );\r\n\t\t\tvertexPosition.x += rotatedPosition.x;\r\n\t\t\tvertexPosition.y += rotatedPosition.y;\r\n\r\n\t\t\t// transform to world space\r\n\t\t\tvertexPosition.applyMatrix4( viewWorldMatrix );\r\n\r\n\t\t}\r\n\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\t\tworldScale.setFromMatrixScale( this.matrixWorld );\r\n\t\t\tviewWorldMatrix.getInverse( this.modelViewMatrix ).premultiply( this.matrixWorld );\r\n\t\t\tmvPosition.setFromMatrixPosition( this.modelViewMatrix );\r\n\r\n\t\t\tvar rotation = this.material.rotation;\r\n\t\t\tvar sin, cos;\r\n\t\t\tif ( rotation !== 0 ) {\r\n\r\n\t\t\t\tcos = Math.cos( rotation );\r\n\t\t\t\tsin = Math.sin( rotation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar center = this.center;\r\n\r\n\t\t\ttransformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\r\n\t\t\ttransformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\r\n\t\t\ttransformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\r\n\r\n\t\t\tuvA.set( 0, 0 );\r\n\t\t\tuvB.set( 1, 0 );\r\n\t\t\tuvC.set( 1, 1 );\r\n\r\n\t\t\t// check first triangle\r\n\t\t\tvar intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );\r\n\r\n\t\t\tif ( intersect === null ) {\r\n\r\n\t\t\t\t// check second triangle\r\n\t\t\t\ttransformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\r\n\t\t\t\tuvB.set( 0, 1 );\r\n\r\n\t\t\t\tintersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );\r\n\t\t\t\tif ( intersect === null ) {\r\n\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) { return; }\r\n\r\n\t\t\tintersects.push( {\r\n\r\n\t\t\t\tdistance: distance,\r\n\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\tuv: Triangle.getUV( intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() ),\r\n\t\t\t\tface: null,\r\n\t\t\t\tobject: this\r\n\r\n\t\t\t} );\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.material ).copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tObject3D.prototype.copy.call( this, source );\r\n\r\n\t\tif ( source.center !== undefined ) { this.center.copy( source.center ); }\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Lut = function ( colormap, numberofcolors ) {\n\tvar this$1 = this;\n\r\n\r\n\tthis.lut = [];\r\n\tthis.map = ColorMapKeywords[ colormap ];\r\n\tthis.n = numberofcolors;\r\n\tthis.mapname = colormap;\r\n\r\n\tvar step = 1.0 / this.n;\r\n\r\n\tfor ( var i = 0; i <= 1; i += step ) {\r\n\r\n\t\tfor ( var j = 0; j < this.map.length - 1; j ++ ) {\r\n\r\n\t\t\tif ( i >= this$1.map[ j ][ 0 ] && i < this$1.map[ j + 1 ][ 0 ] ) {\r\n\r\n\t\t\t\tvar min = this$1.map[ j ][ 0 ];\r\n\t\t\t\tvar max = this$1.map[ j + 1 ][ 0 ];\r\n\r\n\t\t\t\tvar minColor = new Color( 0xffffff ).setHex( this$1.map[ j ][ 1 ] );\r\n\t\t\t\tvar maxColor = new Color( 0xffffff ).setHex( this$1.map[ j + 1 ][ 1 ] );\r\n\r\n\t\t\t\tvar color = minColor.lerp( maxColor, ( i - min ) / ( max - min ) );\r\n\r\n\t\t\t\tthis$1.lut.push( color );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn this.set( this );\r\n\r\n};\r\n\r\nLut.prototype = {\r\n\r\n\tconstructor: Lut,\r\n\r\n\tlut: [], map: [], mapname: 'rainbow', n: 256, minV: 0, maxV: 1, legend: null,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value instanceof Lut ) {\r\n\r\n\t\t\tthis.copy( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetMin: function ( min ) {\r\n\r\n\t\tthis.minV = min;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetMax: function ( max ) {\r\n\r\n\t\tthis.maxV = max;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tchangeNumberOfColors: function ( numberofcolors ) {\r\n\r\n\t\tthis.n = numberofcolors;\r\n\r\n\t\treturn new Lut( this.mapname, this.n );\r\n\r\n\t},\r\n\r\n\tchangeColorMap: function ( colormap ) {\r\n\r\n\t\tthis.mapname = colormap;\r\n\r\n\t\treturn new Lut( this.mapname, this.n );\r\n\r\n\t},\r\n\r\n\tcopy: function ( lut ) {\r\n\r\n\t\tthis.lut = lut.lut;\r\n\t\tthis.mapname = lut.mapname;\r\n\t\tthis.map = lut.map;\r\n\t\tthis.n = lut.n;\r\n\t\tthis.minV = lut.minV;\r\n\t\tthis.maxV = lut.maxV;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetColor: function ( alpha ) {\r\n\r\n\t\tif ( alpha <= this.minV ) {\r\n\r\n\t\t\talpha = this.minV;\r\n\r\n\t\t} else if ( alpha >= this.maxV ) {\r\n\r\n\t\t\talpha = this.maxV;\r\n\r\n\t\t}\r\n\r\n\t\talpha = ( alpha - this.minV ) / ( this.maxV - this.minV );\r\n\r\n\t\tvar colorPosition = Math.round( alpha * this.n );\r\n\t\tcolorPosition == this.n ? colorPosition -= 1 : colorPosition;\r\n\r\n\t\treturn this.lut[ colorPosition ];\r\n\r\n\t},\r\n\r\n\taddColorMap: function ( colormapName, arrayOfColors ) {\r\n\r\n\t\tColorMapKeywords[ colormapName ] = arrayOfColors;\r\n\r\n\t},\r\n\r\n\tsetLegendOn: function ( parameters ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( parameters === undefined ) {\r\n\r\n\t\t\tparameters = {};\r\n\r\n\t\t}\r\n\r\n\t\tthis.legend = {};\r\n\r\n\t\tthis.legend.layout = parameters.hasOwnProperty( 'layout' ) ? parameters[ 'layout' ] : 'vertical';\r\n\r\n\t\tthis.legend.position = parameters.hasOwnProperty( 'position' ) ? parameters[ 'position' ] : { 'x': 4, 'y': 0, 'z': 0 };\r\n\r\n\t\tthis.legend.dimensions = parameters.hasOwnProperty( 'dimensions' ) ? parameters[ 'dimensions' ] : { 'width': 0.5, 'height': 3 };\r\n\r\n\t\tthis.legend.canvas = document.createElement( 'canvas' );\r\n\r\n\t\tthis.legend.canvas.setAttribute( 'id', 'legend' );\r\n\t\tthis.legend.canvas.setAttribute( 'hidden', true );\r\n\r\n\t\tdocument.body.appendChild( this.legend.canvas );\r\n\r\n\t\tthis.legend.ctx = this.legend.canvas.getContext( '2d' );\r\n\r\n\t\tthis.legend.canvas.setAttribute( 'width', 1 );\r\n\t\tthis.legend.canvas.setAttribute( 'height', this.n );\r\n\r\n\t\tthis.legend.texture = new Texture( this.legend.canvas );\r\n\r\n\t\tvar imageData = this.legend.ctx.getImageData( 0, 0, 1, this.n );\r\n\r\n\t\tvar data = imageData.data;\r\n\r\n\t\tthis.map = ColorMapKeywords[ this.mapname ];\r\n\r\n\t\tvar k = 0;\r\n\r\n\t\tvar step = 1.0 / this.n;\r\n\r\n\t\tfor ( var i = 1; i >= 0; i -= step ) {\r\n\r\n\t\t\tfor ( var j = this.map.length - 1; j >= 0; j -- ) {\r\n\r\n\t\t\t\tif ( i < this$1.map[ j ][ 0 ] && i >= this$1.map[ j - 1 ][ 0 ] ) {\r\n\r\n\t\t\t\t\tvar min = this$1.map[ j - 1 ][ 0 ];\r\n\t\t\t\t\tvar max = this$1.map[ j ][ 0 ];\r\n\r\n\t\t\t\t\tvar minColor = new Color( 0xffffff ).setHex( this$1.map[ j - 1 ][ 1 ] );\r\n\t\t\t\t\tvar maxColor = new Color( 0xffffff ).setHex( this$1.map[ j ][ 1 ] );\r\n\r\n\t\t\t\t\tvar color = minColor.lerp( maxColor, ( i - min ) / ( max - min ) );\r\n\r\n\t\t\t\t\tdata[ k * 4 ] = Math.round( color.r * 255 );\r\n\t\t\t\t\tdata[ k * 4 + 1 ] = Math.round( color.g * 255 );\r\n\t\t\t\t\tdata[ k * 4 + 2 ] = Math.round( color.b * 255 );\r\n\t\t\t\t\tdata[ k * 4 + 3 ] = 255;\r\n\r\n\t\t\t\t\tk += 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.legend.ctx.putImageData( imageData, 0, 0 );\r\n\t\tthis.legend.texture.needsUpdate = true;\r\n\r\n\t\tthis.legend.legendGeometry = new PlaneBufferGeometry( this.legend.dimensions.width, this.legend.dimensions.height );\r\n\t\tthis.legend.legendMaterial = new MeshBasicMaterial( { map: this.legend.texture, side: DoubleSide } );\r\n\r\n\t\tthis.legend.mesh = new Mesh( this.legend.legendGeometry, this.legend.legendMaterial );\r\n\r\n\t\tif ( this.legend.layout == 'horizontal' ) {\r\n\r\n\t\t\tthis.legend.mesh.rotation.z = - 90 * ( Math.PI / 180 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.legend.mesh.position.copy( this.legend.position );\r\n\r\n\t\treturn this.legend.mesh;\r\n\r\n\t},\r\n\r\n\tsetLegendOff: function () {\r\n\r\n\t\tthis.legend = null;\r\n\r\n\t\treturn this.legend;\r\n\r\n\t},\r\n\r\n\tsetLegendLayout: function ( layout ) {\r\n\r\n\t\tif ( ! this.legend ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.legend.layout == layout ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( layout != 'horizontal' && layout != 'vertical' ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tthis.layout = layout;\r\n\r\n\t\tif ( layout == 'horizontal' ) {\r\n\r\n\t\t\tthis.legend.mesh.rotation.z = 90 * ( Math.PI / 180 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( layout == 'vertical' ) {\r\n\r\n\t\t\tthis.legend.mesh.rotation.z = - 90 * ( Math.PI / 180 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.legend.mesh;\r\n\r\n\t},\r\n\r\n\tsetLegendPosition: function ( position ) {\r\n\r\n\t\tthis.legend.position = new Vector3( position.x, position.y, position.z );\r\n\r\n\t\treturn this.legend;\r\n\r\n\t},\r\n\r\n\tsetLegendLabels: function ( parameters, callback ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( ! this.legend ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( typeof parameters === 'function' ) {\r\n\r\n\t\t\tcallback = parameters;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters === undefined ) {\r\n\r\n\t\t\tparameters = {};\r\n\r\n\t\t}\r\n\r\n\t\tthis.legend.labels = {};\r\n\r\n\t\tthis.legend.labels.fontsize = parameters.hasOwnProperty( 'fontsize' ) ? parameters[ 'fontsize' ] : 24;\r\n\r\n\t\tthis.legend.labels.fontface = parameters.hasOwnProperty( 'fontface' ) ? parameters[ 'fontface' ] : 'Arial';\r\n\r\n\t\tthis.legend.labels.title = parameters.hasOwnProperty( 'title' ) ? parameters[ 'title' ] : '';\r\n\r\n\t\tthis.legend.labels.um = parameters.hasOwnProperty( 'um' ) ? ' [ ' + parameters[ 'um' ] + ' ]' : '';\r\n\r\n\t\tthis.legend.labels.ticks = parameters.hasOwnProperty( 'ticks' ) ? parameters[ 'ticks' ] : 0;\r\n\r\n\t\tthis.legend.labels.decimal = parameters.hasOwnProperty( 'decimal' ) ? parameters[ 'decimal' ] : 2;\r\n\r\n\t\tthis.legend.labels.notation = parameters.hasOwnProperty( 'notation' ) ? parameters[ 'notation' ] : 'standard';\r\n\r\n\t\tvar backgroundColor = { r: 255, g: 100, b: 100, a: 0.8 };\r\n\t\tvar borderColor = { r: 255, g: 0, b: 0, a: 1.0 };\r\n\t\tvar borderThickness = 4;\r\n\r\n\t\tvar canvasTitle = document.createElement( 'canvas' );\r\n\t\tvar contextTitle = canvasTitle.getContext( '2d' );\r\n\r\n\t\tcontextTitle.font = 'Normal ' + this.legend.labels.fontsize * 1.2 + 'px ' + this.legend.labels.fontface;\r\n\r\n\t\tcontextTitle.fillStyle = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + backgroundColor.a + ')';\r\n\r\n\t\tcontextTitle.strokeStyle = 'rgba(' + borderColor.r + ',' + borderColor.g + ',' + borderColor.b + ',' + borderColor.a + ')';\r\n\r\n\t\tcontextTitle.lineWidth = borderThickness;\r\n\r\n\t\tcontextTitle.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\r\n\r\n\t\tcontextTitle.fillText( this.legend.labels.title.toString() + this.legend.labels.um.toString(), borderThickness, this.legend.labels.fontsize + borderThickness );\r\n\r\n\t\tvar txtTitle = new CanvasTexture( canvasTitle );\r\n\t\ttxtTitle.minFilter = LinearFilter;\r\n\r\n\t\tvar spriteMaterialTitle = new SpriteMaterial( { map: txtTitle } );\r\n\r\n\t\tvar spriteTitle = new Sprite( spriteMaterialTitle );\r\n\r\n\t\tspriteTitle.scale.set( 2, 1, 1.0 );\r\n\r\n\t\tif ( this.legend.layout == 'vertical' ) {\r\n\r\n\t\t\tspriteTitle.position.set( this.legend.position.x + this.legend.dimensions.width, this.legend.position.y + ( this.legend.dimensions.height * 0.45 ), this.legend.position.z );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.legend.layout == 'horizontal' ) {\r\n\r\n\t\t\tspriteTitle.position.set( this.legend.position.x * 1.015, this.legend.position.y + ( this.legend.dimensions.height * 0.03 ), this.legend.position.z );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.legend.labels.ticks > 0 ) {\r\n\r\n\t\t\tvar ticks = {};\r\n\t\t\tvar lines = {};\r\n\r\n\t\t\tif ( this.legend.layout == 'vertical' ) {\r\n\r\n\t\t\t\tvar topPositionY = this.legend.position.y + ( this.legend.dimensions.height * 0.36 );\r\n\t\t\t\tvar bottomPositionY = this.legend.position.y - ( this.legend.dimensions.height * 0.61 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.legend.layout == 'horizontal' ) {\r\n\r\n\t\t\t\tvar topPositionX = this.legend.position.x + ( this.legend.dimensions.height * 0.75 );\r\n\t\t\t\tvar bottomPositionX = this.legend.position.x - ( this.legend.dimensions.width * 1.2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < this.legend.labels.ticks; i ++ ) {\r\n\r\n\t\t\t\tvar value = ( this$1.maxV - this$1.minV ) / ( this$1.legend.labels.ticks - 1 ) * i + this$1.minV;\r\n\r\n\t\t\t\tif ( callback ) {\r\n\r\n\t\t\t\t\tvalue = callback( value );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( this$1.legend.labels.notation == 'scientific' ) {\r\n\r\n\t\t\t\t\t\tvalue = value.toExponential( this$1.legend.labels.decimal );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvalue = value.toFixed( this$1.legend.labels.decimal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar canvasTick = document.createElement( 'canvas' );\r\n\t\t\t\tvar contextTick = canvasTick.getContext( '2d' );\r\n\r\n\t\t\t\tcontextTick.font = 'Normal ' + this$1.legend.labels.fontsize + 'px ' + this$1.legend.labels.fontface;\r\n\r\n\t\t\t\tcontextTick.fillStyle = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + backgroundColor.a + ')';\r\n\r\n\t\t\t\tcontextTick.strokeStyle = 'rgba(' + borderColor.r + ',' + borderColor.g + ',' + borderColor.b + ',' + borderColor.a + ')';\r\n\r\n\t\t\t\tcontextTick.lineWidth = borderThickness;\r\n\r\n\t\t\t\tcontextTick.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\r\n\r\n\t\t\t\tcontextTick.fillText( value.toString(), borderThickness, this$1.legend.labels.fontsize + borderThickness );\r\n\r\n\t\t\t\tvar txtTick = new CanvasTexture( canvasTick );\r\n\t\t\t\ttxtTick.minFilter = LinearFilter;\r\n\r\n\t\t\t\tvar spriteMaterialTick = new SpriteMaterial( { map: txtTick } );\r\n\r\n\t\t\t\tvar spriteTick = new Sprite( spriteMaterialTick );\r\n\r\n\t\t\t\tspriteTick.scale.set( 2, 1, 1.0 );\r\n\r\n\t\t\t\tif ( this$1.legend.layout == 'vertical' ) {\r\n\r\n\t\t\t\t\tvar position = bottomPositionY + ( topPositionY - bottomPositionY ) * ( ( value - this$1.minV ) / ( this$1.maxV - this$1.minV ) );\r\n\r\n\t\t\t\t\tspriteTick.position.set( this$1.legend.position.x + ( this$1.legend.dimensions.width * 2.7 ), position, this$1.legend.position.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( this$1.legend.layout == 'horizontal' ) {\r\n\r\n\t\t\t\t\tvar position = bottomPositionX + ( topPositionX - bottomPositionX ) * ( ( value - this$1.minV ) / ( this$1.maxV - this$1.minV ) );\r\n\r\n\t\t\t\t\tif ( this$1.legend.labels.ticks > 5 ) {\r\n\r\n\t\t\t\t\t\tif ( i % 2 === 0 ) {\r\n\r\n\t\t\t\t\t\t\tvar offset = 1.7;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar offset = 2.1;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar offset = 1.7;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tspriteTick.position.set( position, this$1.legend.position.y - this$1.legend.dimensions.width * offset, this$1.legend.position.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar material = new LineBasicMaterial( { color: 0x000000, linewidth: 2 } );\r\n\r\n\t\t\t\tvar points = [];\r\n\r\n\t\t\t\tif ( this$1.legend.layout == 'vertical' ) {\r\n\r\n\t\t\t\t\tvar linePosition = ( this$1.legend.position.y - ( this$1.legend.dimensions.height * 0.5 ) + 0.01 ) + ( this$1.legend.dimensions.height ) * ( ( value - this$1.minV ) / ( this$1.maxV - this$1.minV ) * 0.99 );\r\n\r\n\t\t\t\t\tpoints.push( new Vector3( this$1.legend.position.x + this$1.legend.dimensions.width * 0.55, linePosition, this$1.legend.position.z ) );\r\n\r\n\t\t\t\t\tpoints.push( new Vector3( this$1.legend.position.x + this$1.legend.dimensions.width * 0.7, linePosition, this$1.legend.position.z ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( this$1.legend.layout == 'horizontal' ) {\r\n\r\n\t\t\t\t\tvar linePosition = ( this$1.legend.position.x - ( this$1.legend.dimensions.height * 0.5 ) + 0.01 ) + ( this$1.legend.dimensions.height ) * ( ( value - this$1.minV ) / ( this$1.maxV - this$1.minV ) * 0.99 );\r\n\r\n\t\t\t\t\tpoints.push( new Vector3( linePosition, this$1.legend.position.y - this$1.legend.dimensions.width * 0.55, this$1.legend.position.z ) );\r\n\r\n\t\t\t\t\tpoints.push( new Vector3( linePosition, this$1.legend.position.y - this$1.legend.dimensions.width * 0.7, this$1.legend.position.z ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar geometry = new BufferGeometry().setFromPoints( points );\r\n\r\n\t\t\t\tvar line = new Line( geometry, material );\r\n\r\n\t\t\t\tlines[ i ] = line;\r\n\t\t\t\tticks[ i ] = spriteTick;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn { 'title': spriteTitle, 'ticks': ticks, 'lines': lines };\r\n\r\n\t}\r\n\r\n};\r\n\r\nvar ColorMapKeywords = {\r\n\r\n\t\"rainbow\": [[ 0.0, '0x0000FF' ], [ 0.2, '0x00FFFF' ], [ 0.5, '0x00FF00' ], [ 0.8, '0xFFFF00' ], [ 1.0, '0xFF0000' ]],\r\n\t\"cooltowarm\": [[ 0.0, '0x3C4EC2' ], [ 0.2, '0x9BBCFF' ], [ 0.5, '0xDCDCDC' ], [ 0.8, '0xF6A385' ], [ 1.0, '0xB40426' ]],\r\n\t\"blackbody\": [[ 0.0, '0x000000' ], [ 0.2, '0x780000' ], [ 0.5, '0xE63200' ], [ 0.8, '0xFFFF00' ], [ 1.0, '0xFFFFFF' ]],\r\n\t\"grayscale\": [[ 0.0, '0x000000' ], [ 0.2, '0x404040' ], [ 0.5, '0x7F7F80' ], [ 0.8, '0xBFBFBF' ], [ 1.0, '0xFFFFFF' ]]\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MD2Character = function () {\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.scale = 1;\r\n\tthis.animationFPS = 6;\r\n\r\n\tthis.root = new Object3D();\r\n\r\n\tthis.meshBody = null;\r\n\tthis.meshWeapon = null;\r\n\r\n\tthis.skinsBody = [];\r\n\tthis.skinsWeapon = [];\r\n\r\n\tthis.weapons = [];\r\n\r\n\tthis.activeAnimation = null;\r\n\r\n\tthis.mixer = null;\r\n\r\n\tthis.onLoadComplete = function () {};\r\n\r\n\tthis.loadCounter = 0;\r\n\r\n\tthis.loadParts = function ( config ) {\r\n\r\n\t\tthis.loadCounter = config.weapons.length * 2 + config.skins.length + 1;\r\n\r\n\t\tvar weaponsTextures = [];\r\n\t\tfor ( var i = 0; i < config.weapons.length; i ++ ) { weaponsTextures[ i ] = config.weapons[ i ][ 1 ]; }\r\n\t\t// SKINS\r\n\r\n\t\tthis.skinsBody = loadTextures( config.baseUrl + \"skins/\", config.skins );\r\n\t\tthis.skinsWeapon = loadTextures( config.baseUrl + \"skins/\", weaponsTextures );\r\n\r\n\t\t// BODY\r\n\r\n\t\tvar loader = new MD2Loader();\r\n\r\n\t\tloader.load( config.baseUrl + config.body, function ( geo ) {\r\n\r\n\t\t\tgeo.computeBoundingBox();\r\n\t\t\tscope.root.position.y = - scope.scale * geo.boundingBox.min.y;\r\n\r\n\t\t\tvar mesh = createPart( geo, scope.skinsBody[ 0 ] );\r\n\t\t\tmesh.scale.set( scope.scale, scope.scale, scope.scale );\r\n\r\n\t\t\tscope.root.add( mesh );\r\n\r\n\t\t\tscope.meshBody = mesh;\r\n\r\n\t\t\tscope.meshBody.clipOffset = 0;\r\n\t\t\tscope.activeAnimationClipName = mesh.geometry.animations[ 0 ].name;\r\n\r\n\t\t\tscope.mixer = new AnimationMixer( mesh );\r\n\r\n\t\t\tcheckLoadingComplete();\r\n\r\n\t\t} );\r\n\r\n\t\t// WEAPONS\r\n\r\n\t\tvar generateCallback = function ( index, name ) {\r\n\r\n\t\t\treturn function ( geo ) {\r\n\r\n\t\t\t\tvar mesh = createPart( geo, scope.skinsWeapon[ index ] );\r\n\t\t\t\tmesh.scale.set( scope.scale, scope.scale, scope.scale );\r\n\t\t\t\tmesh.visible = false;\r\n\r\n\t\t\t\tmesh.name = name;\r\n\r\n\t\t\t\tscope.root.add( mesh );\r\n\r\n\t\t\t\tscope.weapons[ index ] = mesh;\r\n\t\t\t\tscope.meshWeapon = mesh;\r\n\r\n\t\t\t\tcheckLoadingComplete();\r\n\r\n\t\t\t};\r\n\r\n\t\t};\r\n\r\n\t\tfor ( var i = 0; i < config.weapons.length; i ++ ) {\r\n\r\n\t\t\tloader.load( config.baseUrl + config.weapons[ i ][ 0 ], generateCallback( i, config.weapons[ i ][ 0 ] ) );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setPlaybackRate = function ( rate ) {\r\n\r\n\t\tif ( rate !== 0 ) {\r\n\r\n\t\t\tthis.mixer.timeScale = 1 / rate;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.mixer.timeScale = 0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setWireframe = function ( wireframeEnabled ) {\r\n\r\n\t\tif ( wireframeEnabled ) {\r\n\r\n\t\t\tif ( this.meshBody ) { this.meshBody.material = this.meshBody.materialWireframe; }\r\n\t\t\tif ( this.meshWeapon ) { this.meshWeapon.material = this.meshWeapon.materialWireframe; }\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( this.meshBody ) { this.meshBody.material = this.meshBody.materialTexture; }\r\n\t\t\tif ( this.meshWeapon ) { this.meshWeapon.material = this.meshWeapon.materialTexture; }\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setSkin = function ( index ) {\r\n\r\n\t\tif ( this.meshBody && this.meshBody.material.wireframe === false ) {\r\n\r\n\t\t\tthis.meshBody.material.map = this.skinsBody[ index ];\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setWeapon = function ( index ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.weapons.length; i ++ ) { this$1.weapons[ i ].visible = false; }\r\n\r\n\t\tvar activeWeapon = this.weapons[ index ];\r\n\r\n\t\tif ( activeWeapon ) {\r\n\r\n\t\t\tactiveWeapon.visible = true;\r\n\t\t\tthis.meshWeapon = activeWeapon;\r\n\r\n\t\t\tscope.syncWeaponAnimation();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setAnimation = function ( clipName ) {\r\n\r\n\t\tif ( this.meshBody ) {\r\n\r\n\t\t\tif ( this.meshBody.activeAction ) {\r\n\r\n\t\t\t\tthis.meshBody.activeAction.stop();\r\n\t\t\t\tthis.meshBody.activeAction = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar action = this.mixer.clipAction( clipName, this.meshBody );\r\n\r\n\t\t\tif ( action ) {\r\n\r\n\t\t\t\tthis.meshBody.activeAction = action.play();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tscope.activeClipName = clipName;\r\n\r\n\t\tscope.syncWeaponAnimation();\r\n\r\n\t};\r\n\r\n\tthis.syncWeaponAnimation = function () {\r\n\r\n\t\tvar clipName = scope.activeClipName;\r\n\r\n\t\tif ( scope.meshWeapon ) {\r\n\r\n\t\t\tif ( this.meshWeapon.activeAction ) {\r\n\r\n\t\t\t\tthis.meshWeapon.activeAction.stop();\r\n\t\t\t\tthis.meshWeapon.activeAction = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar action = this.mixer.clipAction( clipName, this.meshWeapon );\r\n\r\n\t\t\tif ( action ) {\r\n\r\n\t\t\t\tthis.meshWeapon.activeAction = action.syncWith( this.meshBody.activeAction ).play();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.update = function ( delta ) {\r\n\r\n\t\tif ( this.mixer ) { this.mixer.update( delta ); }\r\n\r\n\t};\r\n\r\n\tfunction loadTextures( baseUrl, textureUrls ) {\r\n\r\n\t\tvar textureLoader = new TextureLoader();\r\n\t\tvar textures = [];\r\n\r\n\t\tfor ( var i = 0; i < textureUrls.length; i ++ ) {\r\n\r\n\t\t\ttextures[ i ] = textureLoader.load( baseUrl + textureUrls[ i ], checkLoadingComplete );\r\n\t\t\ttextures[ i ].mapping = UVMapping;\r\n\t\t\ttextures[ i ].name = textureUrls[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn textures;\r\n\r\n\t}\r\n\r\n\tfunction createPart( geometry, skinMap ) {\r\n\r\n\t\tvar materialWireframe = new MeshLambertMaterial( { color: 0xffaa00, wireframe: true, morphTargets: true, morphNormals: true } );\r\n\t\tvar materialTexture = new MeshLambertMaterial( { color: 0xffffff, wireframe: false, map: skinMap, morphTargets: true, morphNormals: true } );\r\n\r\n\t\t//\r\n\r\n\t\tvar mesh = new Mesh( geometry, materialTexture );\r\n\t\tmesh.rotation.y = - Math.PI / 2;\r\n\r\n\t\tmesh.castShadow = true;\r\n\t\tmesh.receiveShadow = true;\r\n\r\n\t\t//\r\n\r\n\t\tmesh.materialTexture = materialTexture;\r\n\t\tmesh.materialWireframe = materialWireframe;\r\n\r\n\t\treturn mesh;\r\n\r\n\t}\r\n\r\n\tfunction checkLoadingComplete() {\r\n\r\n\t\tscope.loadCounter -= 1;\r\n\r\n\t\tif ( scope.loadCounter === 0 ) { scope.onLoadComplete(); }\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MorphBlendMesh = function ( geometry, material ) {\r\n\r\n\tMesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = Object.keys( this.morphTargetDictionary ).length;\r\n\r\n\tvar name = '__default';\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nMorphBlendMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\r\n\r\n\tconstructor: MorphBlendMesh,\r\n\r\n\tcreateAnimation: function ( name, start, end, fps ) {\r\n\r\n\t\tvar animation = {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tend: end,\r\n\r\n\t\t\tlength: end - start + 1,\r\n\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\r\n\t\t\tactive: false,\r\n\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\r\n\t\t};\r\n\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\r\n\t},\r\n\r\n\tautoCreateAnimations: function ( fps ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\r\n\t\tvar i = 0;\r\n\r\n\t\tfor ( var key in this$1.morphTargetDictionary ) {\r\n\r\n\t\t\tvar chunks = key.match( pattern );\r\n\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\t\tif ( ! frameRanges[ name ] ) { frameRanges[ name ] = { start: Infinity, end: - Infinity }; }\r\n\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\t\tif ( i < range.start ) { range.start = i; }\r\n\t\t\t\tif ( i > range.end ) { range.end = i; }\r\n\r\n\t\t\t\tif ( ! firstAnimation ) { firstAnimation = name; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\ti ++;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in frameRanges ) {\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis$1.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t\t}\r\n\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\r\n\t},\r\n\r\n\tsetAnimationDirectionForward: function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetAnimationDirectionBackward: function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetAnimationFPS: function ( name, fps ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetAnimationDuration: function ( name, duration ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetAnimationWeight: function ( name, weight ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.weight = weight;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetAnimationTime: function ( name, time ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = time;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetAnimationTime: function ( name ) {\r\n\r\n\t\tvar time = 0;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\ttime = animation.time;\r\n\r\n\t\t}\r\n\r\n\t\treturn time;\r\n\r\n\t},\r\n\r\n\tgetAnimationDuration: function ( name ) {\r\n\r\n\t\tvar duration = - 1;\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tduration = animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\treturn duration;\r\n\r\n\t},\r\n\r\n\tplayAnimation: function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( \"MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tstopAnimation: function ( name ) {\r\n\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\r\n\t\tif ( animation ) {\r\n\r\n\t\t\tanimation.active = false;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdate: function ( delta ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar animation = this$1.animationsList[ i ];\r\n\r\n\t\t\tif ( ! animation.active ) { continue; }\r\n\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\t\tif ( animation.time < 0 ) { animation.time += animation.duration; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\t\tthis$1.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis$1.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\t\tthis$1.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\t\tif ( animation.directionBackwards ) { mix = 1 - mix; }\r\n\r\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n\t\t\t\tthis$1.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\tthis$1.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis$1.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MD2CharacterComplex = function () {\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.scale = 1;\r\n\r\n\t// animation parameters\r\n\r\n\tthis.animationFPS = 6;\r\n\tthis.transitionFrames = 15;\r\n\r\n\t// movement model parameters\r\n\r\n\tthis.maxSpeed = 275;\r\n\tthis.maxReverseSpeed = - 275;\r\n\r\n\tthis.frontAcceleration = 600;\r\n\tthis.backAcceleration = 600;\r\n\r\n\tthis.frontDecceleration = 600;\r\n\r\n\tthis.angularSpeed = 2.5;\r\n\r\n\t// rig\r\n\r\n\tthis.root = new Object3D();\r\n\r\n\tthis.meshBody = null;\r\n\tthis.meshWeapon = null;\r\n\r\n\tthis.controls = null;\r\n\r\n\t// skins\r\n\r\n\tthis.skinsBody = [];\r\n\tthis.skinsWeapon = [];\r\n\r\n\tthis.weapons = [];\r\n\r\n\tthis.currentSkin = undefined;\r\n\r\n\t//\r\n\r\n\tthis.onLoadComplete = function () {};\r\n\r\n\t// internals\r\n\r\n\tthis.meshes = [];\r\n\tthis.animations = {};\r\n\r\n\tthis.loadCounter = 0;\r\n\r\n\t// internal movement control variables\r\n\r\n\tthis.speed = 0;\r\n\tthis.bodyOrientation = 0;\r\n\r\n\tthis.walkSpeed = this.maxSpeed;\r\n\tthis.crouchSpeed = this.maxSpeed * 0.5;\r\n\r\n\t// internal animation parameters\r\n\r\n\tthis.activeAnimation = null;\r\n\tthis.oldAnimation = null;\r\n\r\n\t// API\r\n\r\n\tthis.enableShadows = function ( enable ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\r\n\r\n\t\t\tthis$1.meshes[ i ].castShadow = enable;\r\n\t\t\tthis$1.meshes[ i ].receiveShadow = enable;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setVisible = function ( enable ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\r\n\r\n\t\t\tthis$1.meshes[ i ].visible = enable;\r\n\t\t\tthis$1.meshes[ i ].visible = enable;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.shareParts = function ( original ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.animations = original.animations;\r\n\t\tthis.walkSpeed = original.walkSpeed;\r\n\t\tthis.crouchSpeed = original.crouchSpeed;\r\n\r\n\t\tthis.skinsBody = original.skinsBody;\r\n\t\tthis.skinsWeapon = original.skinsWeapon;\r\n\r\n\t\t// BODY\r\n\r\n\t\tvar mesh = createPart( original.meshBody.geometry, this.skinsBody[ 0 ] );\r\n\t\tmesh.scale.set( this.scale, this.scale, this.scale );\r\n\r\n\t\tthis.root.position.y = original.root.position.y;\r\n\t\tthis.root.add( mesh );\r\n\r\n\t\tthis.meshBody = mesh;\r\n\r\n\t\tthis.meshes.push( mesh );\r\n\r\n\t\t// WEAPONS\r\n\r\n\t\tfor ( var i = 0; i < original.weapons.length; i ++ ) {\r\n\r\n\t\t\tvar meshWeapon = createPart( original.weapons[ i ].geometry, this$1.skinsWeapon[ i ] );\r\n\t\t\tmeshWeapon.scale.set( this$1.scale, this$1.scale, this$1.scale );\r\n\t\t\tmeshWeapon.visible = false;\r\n\r\n\t\t\tmeshWeapon.name = original.weapons[ i ].name;\r\n\r\n\t\t\tthis$1.root.add( meshWeapon );\r\n\r\n\t\t\tthis$1.weapons[ i ] = meshWeapon;\r\n\t\t\tthis$1.meshWeapon = meshWeapon;\r\n\r\n\t\t\tthis$1.meshes.push( meshWeapon );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.loadParts = function ( config ) {\r\n\r\n\t\tthis.animations = config.animations;\r\n\t\tthis.walkSpeed = config.walkSpeed;\r\n\t\tthis.crouchSpeed = config.crouchSpeed;\r\n\r\n\t\tthis.loadCounter = config.weapons.length * 2 + config.skins.length + 1;\r\n\r\n\t\tvar weaponsTextures = [];\r\n\t\tfor ( var i = 0; i < config.weapons.length; i ++ ) { weaponsTextures[ i ] = config.weapons[ i ][ 1 ]; }\r\n\r\n\t\t// SKINS\r\n\r\n\t\tthis.skinsBody = loadTextures( config.baseUrl + \"skins/\", config.skins );\r\n\t\tthis.skinsWeapon = loadTextures( config.baseUrl + \"skins/\", weaponsTextures );\r\n\r\n\t\t// BODY\r\n\r\n\t\tvar loader = new MD2Loader();\r\n\r\n\t\tloader.load( config.baseUrl + config.body, function( geo ) {\r\n\r\n\t\t\tgeo.computeBoundingBox();\r\n\t\t\tscope.root.position.y = - scope.scale * geo.boundingBox.min.y;\r\n\r\n\t\t\tvar mesh = createPart( geo, scope.skinsBody[ 0 ] );\r\n\t\t\tmesh.scale.set( scope.scale, scope.scale, scope.scale );\r\n\r\n\t\t\tscope.root.add( mesh );\r\n\r\n\t\t\tscope.meshBody = mesh;\r\n\t\t\tscope.meshes.push( mesh );\r\n\r\n\t\t\tcheckLoadingComplete();\r\n\r\n\t\t} );\r\n\r\n\t\t// WEAPONS\r\n\r\n\t\tvar generateCallback = function ( index, name ) {\r\n\r\n\t\t\treturn function( geo ) {\r\n\r\n\t\t\t\tvar mesh = createPart( geo, scope.skinsWeapon[ index ] );\r\n\t\t\t\tmesh.scale.set( scope.scale, scope.scale, scope.scale );\r\n\t\t\t\tmesh.visible = false;\r\n\r\n\t\t\t\tmesh.name = name;\r\n\r\n\t\t\t\tscope.root.add( mesh );\r\n\r\n\t\t\t\tscope.weapons[ index ] = mesh;\r\n\t\t\t\tscope.meshWeapon = mesh;\r\n\t\t\t\tscope.meshes.push( mesh );\r\n\r\n\t\t\t\tcheckLoadingComplete();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfor ( var i = 0; i < config.weapons.length; i ++ ) {\r\n\r\n\t\t\tloader.load( config.baseUrl + config.weapons[ i ][ 0 ], generateCallback( i, config.weapons[ i ][ 0 ] ) );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setPlaybackRate = function ( rate ) {\r\n\r\n\t\tif ( this.meshBody ) { this.meshBody.duration = this.meshBody.baseDuration / rate; }\r\n\t\tif ( this.meshWeapon ) { this.meshWeapon.duration = this.meshWeapon.baseDuration / rate; }\r\n\r\n\t};\r\n\r\n\tthis.setWireframe = function ( wireframeEnabled ) {\r\n\r\n\t\tif ( wireframeEnabled ) {\r\n\r\n\t\t\tif ( this.meshBody ) { this.meshBody.material = this.meshBody.materialWireframe; }\r\n\t\t\tif ( this.meshWeapon ) { this.meshWeapon.material = this.meshWeapon.materialWireframe; }\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( this.meshBody ) { this.meshBody.material = this.meshBody.materialTexture; }\r\n\t\t\tif ( this.meshWeapon ) { this.meshWeapon.material = this.meshWeapon.materialTexture; }\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setSkin = function( index ) {\r\n\r\n\t\tif ( this.meshBody && this.meshBody.material.wireframe === false ) {\r\n\r\n\t\t\tthis.meshBody.material.map = this.skinsBody[ index ];\r\n\t\t\tthis.currentSkin = index;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setWeapon = function ( index ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.weapons.length; i ++ ) { this$1.weapons[ i ].visible = false; }\r\n\r\n\t\tvar activeWeapon = this.weapons[ index ];\r\n\r\n\t\tif ( activeWeapon ) {\r\n\r\n\t\t\tactiveWeapon.visible = true;\r\n\t\t\tthis.meshWeapon = activeWeapon;\r\n\r\n\t\t\tif ( this.activeAnimation ) {\r\n\r\n\t\t\t\tactiveWeapon.playAnimation( this.activeAnimation );\r\n\t\t\t\tthis.meshWeapon.setAnimationTime( this.activeAnimation, this.meshBody.getAnimationTime( this.activeAnimation ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setAnimation = function ( animationName ) {\r\n\r\n\t\tif ( animationName === this.activeAnimation || ! animationName ) { return; }\r\n\r\n\t\tif ( this.meshBody ) {\r\n\r\n\t\t\tthis.meshBody.setAnimationWeight( animationName, 0 );\r\n\t\t\tthis.meshBody.playAnimation( animationName );\r\n\r\n\t\t\tthis.oldAnimation = this.activeAnimation;\r\n\t\t\tthis.activeAnimation = animationName;\r\n\r\n\t\t\tthis.blendCounter = this.transitionFrames;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.meshWeapon ) {\r\n\r\n\t\t\tthis.meshWeapon.setAnimationWeight( animationName, 0 );\r\n\t\t\tthis.meshWeapon.playAnimation( animationName );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.update = function ( delta ) {\r\n\r\n\t\tif ( this.controls ) { this.updateMovementModel( delta ); }\r\n\r\n\t\tif ( this.animations ) {\r\n\r\n\t\t\tthis.updateBehaviors( delta );\r\n\t\t\tthis.updateAnimations( delta );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.updateAnimations = function ( delta ) {\r\n\r\n\t\tvar mix = 1;\r\n\r\n\t\tif ( this.blendCounter > 0 ) {\r\n\r\n\t\t\tmix = ( this.transitionFrames - this.blendCounter ) / this.transitionFrames;\r\n\t\t\tthis.blendCounter -= 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.meshBody ) {\r\n\r\n\t\t\tthis.meshBody.update( delta );\r\n\r\n\t\t\tthis.meshBody.setAnimationWeight( this.activeAnimation, mix );\r\n\t\t\tthis.meshBody.setAnimationWeight( this.oldAnimation,  1 - mix );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.meshWeapon ) {\r\n\r\n\t\t\tthis.meshWeapon.update( delta );\r\n\r\n\t\t\tthis.meshWeapon.setAnimationWeight( this.activeAnimation, mix );\r\n\t\t\tthis.meshWeapon.setAnimationWeight( this.oldAnimation,  1 - mix );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.updateBehaviors = function ( delta ) {\r\n\r\n\t\tvar controls = this.controls;\r\n\t\tvar animations = this.animations;\r\n\r\n\t\tvar moveAnimation, idleAnimation;\r\n\r\n\t\t// crouch vs stand\r\n\r\n\t\tif ( controls.crouch ) {\r\n\r\n\t\t\tmoveAnimation = animations[ \"crouchMove\" ];\r\n\t\t\tidleAnimation = animations[ \"crouchIdle\" ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmoveAnimation = animations[ \"move\" ];\r\n\t\t\tidleAnimation = animations[ \"idle\" ];\r\n\r\n\t\t}\r\n\r\n\t\t// actions\r\n\r\n\t\tif ( controls.jump ) {\r\n\r\n\t\t\tmoveAnimation = animations[ \"jump\" ];\r\n\t\t\tidleAnimation = animations[ \"jump\" ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( controls.attack ) {\r\n\r\n\t\t\tif ( controls.crouch ) {\r\n\r\n\t\t\t\tmoveAnimation = animations[ \"crouchAttack\" ];\r\n\t\t\t\tidleAnimation = animations[ \"crouchAttack\" ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmoveAnimation = animations[ \"attack\" ];\r\n\t\t\t\tidleAnimation = animations[ \"attack\" ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// set animations\r\n\r\n\t\tif ( controls.moveForward || controls.moveBackward || controls.moveLeft || controls.moveRight ) {\r\n\r\n\t\t\tif ( this.activeAnimation !== moveAnimation ) {\r\n\r\n\t\t\t\tthis.setAnimation( moveAnimation );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( Math.abs( this.speed ) < 0.2 * this.maxSpeed && ! ( controls.moveLeft || controls.moveRight || controls.moveForward || controls.moveBackward ) ) {\r\n\r\n\t\t\tif ( this.activeAnimation !== idleAnimation ) {\r\n\r\n\t\t\t\tthis.setAnimation( idleAnimation );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// set animation direction\r\n\r\n\t\tif ( controls.moveForward ) {\r\n\r\n\t\t\tif ( this.meshBody ) {\r\n\r\n\t\t\t\tthis.meshBody.setAnimationDirectionForward( this.activeAnimation );\r\n\t\t\t\tthis.meshBody.setAnimationDirectionForward( this.oldAnimation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.meshWeapon ) {\r\n\r\n\t\t\t\tthis.meshWeapon.setAnimationDirectionForward( this.activeAnimation );\r\n\t\t\t\tthis.meshWeapon.setAnimationDirectionForward( this.oldAnimation );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( controls.moveBackward ) {\r\n\r\n\t\t\tif ( this.meshBody ) {\r\n\r\n\t\t\t\tthis.meshBody.setAnimationDirectionBackward( this.activeAnimation );\r\n\t\t\t\tthis.meshBody.setAnimationDirectionBackward( this.oldAnimation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.meshWeapon ) {\r\n\r\n\t\t\t\tthis.meshWeapon.setAnimationDirectionBackward( this.activeAnimation );\r\n\t\t\t\tthis.meshWeapon.setAnimationDirectionBackward( this.oldAnimation );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.updateMovementModel = function ( delta ) {\r\n\r\n\t\tvar controls = this.controls;\r\n\r\n\t\t// speed based on controls\r\n\r\n\t\tif ( controls.crouch ) \t{ this.maxSpeed = this.crouchSpeed; }\r\n\t\telse { this.maxSpeed = this.walkSpeed; }\r\n\r\n\t\tthis.maxReverseSpeed = - this.maxSpeed;\r\n\r\n\t\tif ( controls.moveForward )  { this.speed = _Math.clamp( this.speed + delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed ); }\r\n\t\tif ( controls.moveBackward ) { this.speed = _Math.clamp( this.speed - delta * this.backAcceleration, this.maxReverseSpeed, this.maxSpeed ); }\r\n\r\n\t\t// orientation based on controls\r\n\t\t// (don't just stand while turning)\r\n\r\n\t\tvar dir = 1;\r\n\r\n\t\tif ( controls.moveLeft ) {\r\n\r\n\t\t\tthis.bodyOrientation += delta * this.angularSpeed;\r\n\t\t\tthis.speed = _Math.clamp( this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed );\r\n\r\n\t\t}\r\n\r\n\t\tif ( controls.moveRight ) {\r\n\r\n\t\t\tthis.bodyOrientation -= delta * this.angularSpeed;\r\n\t\t\tthis.speed = _Math.clamp( this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed );\r\n\r\n\t\t}\r\n\r\n\t\t// speed decay\r\n\r\n\t\tif ( ! ( controls.moveForward || controls.moveBackward ) ) {\r\n\r\n\t\t\tif ( this.speed > 0 ) {\r\n\r\n\t\t\t\tvar k = exponentialEaseOut( this.speed / this.maxSpeed );\r\n\t\t\t\tthis.speed = _Math.clamp( this.speed - k * delta * this.frontDecceleration, 0, this.maxSpeed );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar k = exponentialEaseOut( this.speed / this.maxReverseSpeed );\r\n\t\t\t\tthis.speed = _Math.clamp( this.speed + k * delta * this.backAcceleration, this.maxReverseSpeed, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// displacement\r\n\r\n\t\tvar forwardDelta = this.speed * delta;\r\n\r\n\t\tthis.root.position.x += Math.sin( this.bodyOrientation ) * forwardDelta;\r\n\t\tthis.root.position.z += Math.cos( this.bodyOrientation ) * forwardDelta;\r\n\r\n\t\t// steering\r\n\r\n\t\tthis.root.rotation.y = this.bodyOrientation;\r\n\r\n\t};\r\n\r\n\t// internal helpers\r\n\r\n\tfunction loadTextures( baseUrl, textureUrls ) {\r\n\r\n\t\tvar textureLoader = new TextureLoader();\r\n\t\tvar textures = [];\r\n\r\n\t\tfor ( var i = 0; i < textureUrls.length; i ++ ) {\r\n\r\n\t\t\ttextures[ i ] = textureLoader.load( baseUrl + textureUrls[ i ], checkLoadingComplete );\r\n\t\t\ttextures[ i ].mapping = UVMapping;\r\n\t\t\ttextures[ i ].name = textureUrls[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn textures;\r\n\r\n\t}\r\n\r\n\tfunction createPart( geometry, skinMap ) {\r\n\r\n\t\tvar materialWireframe = new MeshLambertMaterial( { color: 0xffaa00, wireframe: true, morphTargets: true, morphNormals: true } );\r\n\t\tvar materialTexture = new MeshLambertMaterial( { color: 0xffffff, wireframe: false, map: skinMap, morphTargets: true, morphNormals: true } );\r\n\r\n\t\t//\r\n\r\n\t\tvar mesh = new MorphBlendMesh( geometry, materialTexture );\r\n\t\tmesh.rotation.y = - Math.PI / 2;\r\n\r\n\t\t//\r\n\r\n\t\tmesh.materialTexture = materialTexture;\r\n\t\tmesh.materialWireframe = materialWireframe;\r\n\r\n\t\t//\r\n\r\n\t\tmesh.autoCreateAnimations( scope.animationFPS );\r\n\r\n\t\treturn mesh;\r\n\r\n\t}\r\n\r\n\tfunction checkLoadingComplete() {\r\n\r\n\t\tscope.loadCounter -= 1;\r\n\t\tif ( scope.loadCounter === 0 ) \t{ scope.onLoadComplete(); }\r\n\r\n\t}\r\n\r\n\tfunction exponentialEaseOut( k ) {\r\n\r\n\t\treturn k === 1 ? 1 : - Math.pow( 2, - 10 * k ) + 1;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ExplodeModifier = function () {\r\n\r\n};\r\n\r\nExplodeModifier.prototype.modify = function ( geometry ) {\r\n\r\n\tvar vertices = [];\r\n\r\n\tfor ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\tvar n = vertices.length;\r\n\r\n\t\tvar face = geometry.faces[ i ];\r\n\r\n\t\tvar a = face.a;\r\n\t\tvar b = face.b;\r\n\t\tvar c = face.c;\r\n\r\n\t\tvar va = geometry.vertices[ a ];\r\n\t\tvar vb = geometry.vertices[ b ];\r\n\t\tvar vc = geometry.vertices[ c ];\r\n\r\n\t\tvertices.push( va.clone() );\r\n\t\tvertices.push( vb.clone() );\r\n\t\tvertices.push( vc.clone() );\r\n\r\n\t\tface.a = n;\r\n\t\tface.b = n + 1;\r\n\t\tface.c = n + 2;\r\n\r\n\t}\r\n\r\n\tgeometry.vertices = vertices;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SimplifyModifier = function () {};\r\n\r\n( function () {\r\n\r\n\tvar cb = new Vector3(), ab = new Vector3();\r\n\r\n\tfunction pushIfUnique( array, object ) {\r\n\r\n\t\tif ( array.indexOf( object ) === - 1 ) { array.push( object ); }\r\n\r\n\t}\r\n\r\n\tfunction removeFromArray( array, object ) {\r\n\r\n\t\tvar k = array.indexOf( object );\r\n\t\tif ( k > - 1 ) { array.splice( k, 1 ); }\r\n\r\n\t}\r\n\r\n\tfunction computeEdgeCollapseCost( u, v ) {\r\n\r\n\t\t// if we collapse edge uv by moving u to v then how\r\n\t\t// much different will the model change, i.e. the \"error\".\r\n\r\n\t\tvar edgelength = v.position.distanceTo( u.position );\r\n\t\tvar curvature = 0;\r\n\r\n\t\tvar sideFaces = [];\r\n\t\tvar i, il = u.faces.length, face, sideFace;\r\n\r\n\t\t// find the \"sides\" triangles that are on the edge uv\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tface = u.faces[ i ];\r\n\r\n\t\t\tif ( face.hasVertex( v ) ) {\r\n\r\n\t\t\t\tsideFaces.push( face );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use the triangle facing most away from the sides\r\n\t\t// to determine our curvature term\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tvar minCurvature = 1;\r\n\t\t\tface = u.faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0; j < sideFaces.length; j ++ ) {\r\n\r\n\t\t\t\tsideFace = sideFaces[ j ];\r\n\t\t\t\t// use dot product of face normals.\r\n\t\t\t\tvar dotProd = face.normal.dot( sideFace.normal );\r\n\t\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurvature = Math.max( curvature, minCurvature );\r\n\r\n\t\t}\r\n\r\n\t\t// crude approach in attempt to preserve borders\r\n\t\t// though it seems not to be totally correct\r\n\t\tvar borders = 0;\r\n\t\tif ( sideFaces.length < 2 ) {\r\n\r\n\t\t\t// we add some arbitrary cost for borders,\r\n\t\t\t// borders += 10;\r\n\t\t\tcurvature = 1;\r\n\r\n\t\t}\r\n\r\n\t\tvar amt = edgelength * curvature + borders;\r\n\r\n\t\treturn amt;\r\n\r\n\t}\r\n\r\n\tfunction computeEdgeCostAtVertex( v ) {\r\n\r\n\t\t// compute the edge collapse cost for all edges that start\r\n\t\t// from vertex v.  Since we are only interested in reducing\r\n\t\t// the object by selecting the min cost edge at each step, we\r\n\t\t// only cache the cost of the least cost edge at this vertex\r\n\t\t// (in member variable collapse) as well as the value of the\r\n\t\t// cost (in member variable collapseCost).\r\n\r\n\t\tif ( v.neighbors.length === 0 ) {\r\n\r\n\t\t\t// collapse if no neighbors.\r\n\t\t\tv.collapseNeighbor = null;\r\n\t\t\tv.collapseCost = - 0.01;\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tv.collapseCost = 100000;\r\n\t\tv.collapseNeighbor = null;\r\n\r\n\t\t// search all neighboring edges for \"least cost\" edge\r\n\t\tfor ( var i = 0; i < v.neighbors.length; i ++ ) {\r\n\r\n\t\t\tvar collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\r\n\r\n\t\t\tif ( ! v.collapseNeighbor ) {\r\n\r\n\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\r\n\t\t\t\tv.collapseCost = collapseCost;\r\n\t\t\t\tv.minCost = collapseCost;\r\n\t\t\t\tv.totalCost = 0;\r\n\t\t\t\tv.costCount = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv.costCount ++;\r\n\t\t\tv.totalCost += collapseCost;\r\n\r\n\t\t\tif ( collapseCost < v.minCost ) {\r\n\r\n\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\r\n\t\t\t\tv.minCost = collapseCost;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// we average the cost of collapsing at this vertex\r\n\t\tv.collapseCost = v.totalCost / v.costCount;\r\n\t\t// v.collapseCost = v.minCost;\r\n\r\n\t}\r\n\r\n\tfunction removeVertex( v, vertices ) {\r\n\r\n\t\tconsole.assert( v.faces.length === 0 );\r\n\r\n\t\twhile ( v.neighbors.length ) {\r\n\r\n\t\t\tvar n = v.neighbors.pop();\r\n\t\t\tremoveFromArray( n.neighbors, v );\r\n\r\n\t\t}\r\n\r\n\t\tremoveFromArray( vertices, v );\r\n\r\n\t}\r\n\r\n\tfunction removeFace( f, faces ) {\r\n\r\n\t\tremoveFromArray( faces, f );\r\n\r\n\t\tif ( f.v1 ) { removeFromArray( f.v1.faces, f ); }\r\n\t\tif ( f.v2 ) { removeFromArray( f.v2.faces, f ); }\r\n\t\tif ( f.v3 ) { removeFromArray( f.v3.faces, f ); }\r\n\r\n\t\t// TODO optimize this!\r\n\t\tvar vs = [ f.v1, f.v2, f.v3 ];\r\n\t\tvar v1, v2;\r\n\r\n\t\tfor ( var i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tv1 = vs[ i ];\r\n\t\t\tv2 = vs[ ( i + 1 ) % 3 ];\r\n\r\n\t\t\tif ( ! v1 || ! v2 ) { continue; }\r\n\r\n\t\t\tv1.removeIfNonNeighbor( v2 );\r\n\t\t\tv2.removeIfNonNeighbor( v1 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction collapse( vertices, faces, u, v ) { // u and v are pointers to vertices of an edge\r\n\r\n\t\t// Collapse the edge uv by moving vertex u onto v\r\n\r\n\t\tif ( ! v ) {\r\n\r\n\t\t\t// u is a vertex all by itself so just delete it..\r\n\t\t\tremoveVertex( u, vertices );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar i;\r\n\t\tvar tmpVertices = [];\r\n\r\n\t\tfor ( i = 0; i < u.neighbors.length; i ++ ) {\r\n\r\n\t\t\ttmpVertices.push( u.neighbors[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// delete triangles on edge uv:\r\n\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\tif ( u.faces[ i ].hasVertex( v ) ) {\r\n\r\n\t\t\t\tremoveFace( u.faces[ i ], faces );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// update remaining triangles to have v instead of u\r\n\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\tu.faces[ i ].replaceVertex( u, v );\r\n\r\n\t\t}\r\n\r\n\t\tremoveVertex( u, vertices );\r\n\r\n\t\t// recompute the edge collapse costs in neighborhood\r\n\t\tfor ( i = 0; i < tmpVertices.length; i ++ ) {\r\n\r\n\t\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction minimumCostEdge( vertices ) {\r\n\r\n\t\t// O(n * n) approach. TODO optimize this\r\n\r\n\t\tvar least = vertices[ 0 ];\r\n\r\n\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\r\n\r\n\t\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\r\n\r\n\t\t\t\tleast = vertices[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn least;\r\n\r\n\t}\r\n\r\n\t// we use a triangle class to represent structure of face slightly differently\r\n\r\n\tfunction Triangle( v1, v2, v3, a, b, c ) {\r\n\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tthis.c = c;\r\n\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\r\n\t\tthis.normal = new Vector3();\r\n\r\n\t\tthis.computeNormal();\r\n\r\n\t\tv1.faces.push( this );\r\n\t\tv1.addUniqueNeighbor( v2 );\r\n\t\tv1.addUniqueNeighbor( v3 );\r\n\r\n\t\tv2.faces.push( this );\r\n\t\tv2.addUniqueNeighbor( v1 );\r\n\t\tv2.addUniqueNeighbor( v3 );\r\n\r\n\t\tv3.faces.push( this );\r\n\t\tv3.addUniqueNeighbor( v1 );\r\n\t\tv3.addUniqueNeighbor( v2 );\r\n\r\n\t}\r\n\r\n\tTriangle.prototype.computeNormal = function () {\r\n\r\n\t\tvar vA = this.v1.position;\r\n\t\tvar vB = this.v2.position;\r\n\t\tvar vC = this.v3.position;\r\n\r\n\t\tcb.subVectors( vC, vB );\r\n\t\tab.subVectors( vA, vB );\r\n\t\tcb.cross( ab ).normalize();\r\n\r\n\t\tthis.normal.copy( cb );\r\n\r\n\t};\r\n\r\n\tTriangle.prototype.hasVertex = function ( v ) {\r\n\r\n\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\r\n\r\n\t};\r\n\r\n\tTriangle.prototype.replaceVertex = function ( oldv, newv ) {\r\n\r\n\t\tif ( oldv === this.v1 ) { this.v1 = newv; }\r\n\t\telse if ( oldv === this.v2 ) { this.v2 = newv; }\r\n\t\telse if ( oldv === this.v3 ) { this.v3 = newv; }\r\n\r\n\t\tremoveFromArray( oldv.faces, this );\r\n\t\tnewv.faces.push( this );\r\n\r\n\t\toldv.removeIfNonNeighbor( this.v1 );\r\n\t\tthis.v1.removeIfNonNeighbor( oldv );\r\n\r\n\t\toldv.removeIfNonNeighbor( this.v2 );\r\n\t\tthis.v2.removeIfNonNeighbor( oldv );\r\n\r\n\t\toldv.removeIfNonNeighbor( this.v3 );\r\n\t\tthis.v3.removeIfNonNeighbor( oldv );\r\n\r\n\t\tthis.v1.addUniqueNeighbor( this.v2 );\r\n\t\tthis.v1.addUniqueNeighbor( this.v3 );\r\n\r\n\t\tthis.v2.addUniqueNeighbor( this.v1 );\r\n\t\tthis.v2.addUniqueNeighbor( this.v3 );\r\n\r\n\t\tthis.v3.addUniqueNeighbor( this.v1 );\r\n\t\tthis.v3.addUniqueNeighbor( this.v2 );\r\n\r\n\t\tthis.computeNormal();\r\n\r\n\t};\r\n\r\n\tfunction Vertex( v, id ) {\r\n\r\n\t\tthis.position = v;\r\n\r\n\t\tthis.id = id; // old index id\r\n\r\n\t\tthis.faces = []; // faces vertex is connected\r\n\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\r\n\r\n\t\t// these will be computed in computeEdgeCostAtVertex()\r\n\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\r\n\t\tthis.collapseNeighbor = null; // best candinate for collapsing\r\n\r\n\t}\r\n\r\n\tVertex.prototype.addUniqueNeighbor = function ( vertex ) {\r\n\r\n\t\tpushIfUnique( this.neighbors, vertex );\r\n\r\n\t};\r\n\r\n\tVertex.prototype.removeIfNonNeighbor = function ( n ) {\r\n\r\n\t\tvar neighbors = this.neighbors;\r\n\t\tvar faces = this.faces;\r\n\r\n\t\tvar offset = neighbors.indexOf( n );\r\n\t\tif ( offset === - 1 ) { return; }\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tif ( faces[ i ].hasVertex( n ) ) { return; }\r\n\r\n\t\t}\r\n\r\n\t\tneighbors.splice( offset, 1 );\r\n\r\n\t};\r\n\r\n\tSimplifyModifier.prototype.modify = function ( geometry, count ) {\r\n\r\n\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tgeometry = new Geometry().fromBufferGeometry( geometry );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.mergeVertices();\r\n\r\n\t\tvar oldVertices = geometry.vertices; // Three Position\r\n\t\tvar oldFaces = geometry.faces; // Three Face\r\n\r\n\t\t// conversion\r\n\t\tvar vertices = [];\r\n\t\tvar faces = [];\r\n\r\n\t\tvar i, il;\r\n\r\n\t\t//\r\n\t\t// put data of original geometry in different data structures\r\n\t\t//\r\n\r\n\t\t// add vertices\r\n\r\n\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = new Vertex( oldVertices[ i ], i );\r\n\t\t\tvertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t\t// add faces\r\n\r\n\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = oldFaces[ i ];\r\n\r\n\t\t\tvar a = face.a;\r\n\t\t\tvar b = face.b;\r\n\t\t\tvar c = face.c;\r\n\r\n\t\t\tvar triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\r\n\t\t\tfaces.push( triangle );\r\n\r\n\t\t}\r\n\r\n\t\t// compute all edge collapse costs\r\n\r\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tvar nextVertex;\r\n\r\n\t\tvar z = count;\r\n\r\n\t\twhile ( z -- ) {\r\n\r\n\t\t\tnextVertex = minimumCostEdge( vertices );\r\n\r\n\t\t\tif ( ! nextVertex ) {\r\n\r\n\t\t\t\tconsole.log( 'SimplifyModifier: No next vertex' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar simplifiedGeometry = new BufferGeometry();\r\n\t\tvar position = [];\r\n\t\tvar index = [];\r\n\r\n\t\t//\r\n\r\n\t\tfor ( i = 0; i < vertices.length; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices[ i ].position;\r\n\t\t\tposition.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfor ( i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tvar a = vertices.indexOf( face.v1 );\r\n\t\t\tvar b = vertices.indexOf( face.v2 );\r\n\t\t\tvar c = vertices.indexOf( face.v3 );\r\n\r\n\t\t\tindex.push( a, b, c );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tsimplifiedGeometry.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\r\n\t\tsimplifiedGeometry.setIndex( index );\r\n\r\n\t\treturn simplifiedGeometry;\r\n\r\n\t};\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SubdivisionModifier = function ( subdivisions ) {\r\n\r\n\tthis.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;\r\n\r\n};\r\n\r\n// Applies the \"modify\" pattern\r\nSubdivisionModifier.prototype.modify = function ( geometry ) {\n\tvar this$1 = this;\n\r\n\r\n\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\tgeometry = new Geometry().fromBufferGeometry( geometry );\r\n\r\n\t} else {\r\n\r\n\t\tgeometry = geometry.clone();\r\n\r\n\t}\r\n\r\n\tgeometry.mergeVertices();\r\n\r\n\tvar repeats = this.subdivisions;\r\n\r\n\twhile ( repeats -- > 0 ) {\r\n\r\n\t\tthis$1.smooth( geometry );\r\n\r\n\t}\r\n\r\n\tgeometry.computeFaceNormals();\r\n\tgeometry.computeVertexNormals();\r\n\r\n\treturn geometry;\r\n\r\n};\r\n\r\n( function () {\r\n\tvar ABC = [ 'a', 'b', 'c' ];\r\n\r\n\tfunction getEdge( a, b, map ) {\r\n\r\n\t\tvar vertexIndexA = Math.min( a, b );\r\n\t\tvar vertexIndexB = Math.max( a, b );\r\n\r\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\r\n\r\n\t\treturn map[ key ];\r\n\r\n\t}\r\n\r\n\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\r\n\r\n\t\tvar vertexIndexA = Math.min( a, b );\r\n\t\tvar vertexIndexB = Math.max( a, b );\r\n\r\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\r\n\r\n\t\tvar edge;\r\n\r\n\t\tif ( key in map ) {\r\n\r\n\t\t\tedge = map[ key ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar vertexA = vertices[ vertexIndexA ];\r\n\t\t\tvar vertexB = vertices[ vertexIndexB ];\r\n\r\n\t\t\tedge = {\r\n\r\n\t\t\t\ta: vertexA, // pointer reference\r\n\t\t\t\tb: vertexB,\r\n\t\t\t\tnewEdge: null,\r\n\t\t\t\t// aIndex: a, // numbered reference\r\n\t\t\t\t// bIndex: b,\r\n\t\t\t\tfaces: [] // pointers to face\r\n\r\n\t\t\t};\r\n\r\n\t\t\tmap[ key ] = edge;\r\n\r\n\t\t}\r\n\r\n\t\tedge.faces.push( face );\r\n\r\n\t\tmetaVertices[ a ].edges.push( edge );\r\n\t\tmetaVertices[ b ].edges.push( edge );\r\n\r\n\t}\r\n\r\n\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\r\n\r\n\t\tvar i, il, face;\r\n\r\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tmetaVertices[ i ] = { edges: [] };\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = faces[ i ];\r\n\r\n\t\t\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\r\n\t\t\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\r\n\t\t\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction newFace( newFaces, a, b, c, materialIndex ) {\r\n\r\n\t\tnewFaces.push( new Face3( a, b, c, undefined, undefined, materialIndex ) );\r\n\r\n\t}\r\n\r\n\tfunction midpoint( a, b ) {\r\n\r\n\t\treturn ( Math.abs( b - a ) / 2 ) + Math.min( a, b );\r\n\r\n\t}\r\n\r\n\tfunction newUv( newUvs, a, b, c ) {\r\n\r\n\t\tnewUvs.push( [ a.clone(), b.clone(), c.clone() ] );\r\n\r\n\t}\r\n\r\n\t/////////////////////////////\r\n\r\n\t// Performs one iteration of Subdivision\r\n\tSubdivisionModifier.prototype.smooth = function ( geometry ) {\r\n\r\n\t\tvar tmp = new Vector3();\r\n\r\n\t\tvar oldVertices, oldFaces, oldUvs;\r\n\t\tvar newVertices, newFaces, newUVs = [];\r\n\r\n\t\tvar n, i, il, j, k;\r\n\t\tvar metaVertices, sourceEdges;\r\n\r\n\t\t// new stuff.\r\n\t\tvar sourceEdges, newEdgeVertices, newSourceVertices;\r\n\r\n\t\toldVertices = geometry.vertices; // { x, y, z}\r\n\t\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\r\n\t\toldUvs = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\tvar hasUvs = oldUvs !== undefined && oldUvs.length > 0;\r\n\r\n\t\tmetaVertices = new Array( oldVertices.length );\r\n\t\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\r\n\r\n\t\tgenerateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );\r\n\r\n\t\tnewEdgeVertices = [];\r\n\t\tvar other, currentEdge, newEdge, face;\r\n\t\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\r\n\r\n\t\tfor ( i in sourceEdges ) {\r\n\r\n\t\t\tcurrentEdge = sourceEdges[ i ];\r\n\t\t\tnewEdge = new Vector3();\r\n\r\n\t\t\tedgeVertexWeight = 3 / 8;\r\n\t\t\tadjacentVertexWeight = 1 / 8;\r\n\r\n\t\t\tconnectedFaces = currentEdge.faces.length;\r\n\r\n\t\t\t// check how many linked faces. 2 should be correct.\r\n\t\t\tif ( connectedFaces != 2 ) {\r\n\r\n\t\t\t\t// if length is not 2, handle condition\r\n\t\t\t\tedgeVertexWeight = 0.5;\r\n\t\t\t\tadjacentVertexWeight = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\r\n\r\n\t\t\ttmp.set( 0, 0, 0 );\r\n\r\n\t\t\tfor ( j = 0; j < connectedFaces; j ++ ) {\r\n\r\n\t\t\t\tface = currentEdge.faces[ j ];\r\n\r\n\t\t\t\tfor ( k = 0; k < 3; k ++ ) {\r\n\r\n\t\t\t\t\tother = oldVertices[ face[ ABC[ k ] ] ];\r\n\t\t\t\t\tif ( other !== currentEdge.a && other !== currentEdge.b ) { break; }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttmp.add( other );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttmp.multiplyScalar( adjacentVertexWeight );\r\n\t\t\tnewEdge.add( tmp );\r\n\r\n\t\t\tcurrentEdge.newEdge = newEdgeVertices.length;\r\n\t\t\tnewEdgeVertices.push( newEdge );\r\n\r\n\t\t\t// console.log(currentEdge, newEdge);\r\n\r\n\t\t}\r\n\r\n\t\tvar beta, sourceVertexWeight, connectingVertexWeight;\r\n\t\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\r\n\t\tnewSourceVertices = [];\r\n\r\n\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\r\n\r\n\t\t\toldVertex = oldVertices[ i ];\r\n\r\n\t\t\t// find all connecting edges (using lookupTable)\r\n\t\t\tconnectingEdges = metaVertices[ i ].edges;\r\n\t\t\tn = connectingEdges.length;\r\n\r\n\t\t\tif ( n == 3 ) {\r\n\r\n\t\t\t\tbeta = 3 / 16;\r\n\r\n\t\t\t} else if ( n > 3 ) {\r\n\r\n\t\t\t\tbeta = 3 / ( 8 * n ); // Warren's modified formula\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Loop's original beta formula\r\n\t\t\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\r\n\r\n\t\t\tsourceVertexWeight = 1 - n * beta;\r\n\t\t\tconnectingVertexWeight = beta;\r\n\r\n\t\t\tif ( n <= 2 ) {\r\n\r\n\t\t\t\t// crease and boundary rules\r\n\t\t\t\t// console.warn('crease and boundary rules');\r\n\r\n\t\t\t\tif ( n == 2 ) {\r\n\t\t\t\t\tsourceVertexWeight = 3 / 4;\r\n\t\t\t\t\tconnectingVertexWeight = 1 / 8;\r\n\r\n\t\t\t\t\t// sourceVertexWeight = 1;\r\n\t\t\t\t\t// connectingVertexWeight = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\r\n\r\n\t\t\ttmp.set( 0, 0, 0 );\r\n\r\n\t\t\tfor ( j = 0; j < n; j ++ ) {\r\n\r\n\t\t\t\tconnectingEdge = connectingEdges[ j ];\r\n\t\t\t\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\r\n\t\t\t\ttmp.add( other );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttmp.multiplyScalar( connectingVertexWeight );\r\n\t\t\tnewSourceVertex.add( tmp );\r\n\r\n\t\t\tnewSourceVertices.push( newSourceVertex );\r\n\r\n\t\t}\r\n\r\n\t\tnewVertices = newSourceVertices.concat( newEdgeVertices );\r\n\t\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\r\n\t\tnewFaces = [];\r\n\r\n\t\tvar uv, x0, x1, x2;\r\n\t\tvar x3 = new Vector2();\r\n\t\tvar x4 = new Vector2();\r\n\t\tvar x5 = new Vector2();\r\n\r\n\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = oldFaces[ i ];\r\n\r\n\t\t\t// find the 3 new edges vertex of each old face\r\n\r\n\t\t\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\r\n\t\t\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\r\n\t\t\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\r\n\r\n\t\t\t// create 4 faces.\r\n\r\n\t\t\tnewFace( newFaces, edge1, edge2, edge3, face.materialIndex );\r\n\t\t\tnewFace( newFaces, face.a, edge1, edge3, face.materialIndex );\r\n\t\t\tnewFace( newFaces, face.b, edge2, edge1, face.materialIndex );\r\n\t\t\tnewFace( newFaces, face.c, edge3, edge2, face.materialIndex );\r\n\r\n\t\t\t// create 4 new uv's\r\n\r\n\t\t\tif ( hasUvs ) {\r\n\r\n\t\t\t\tuv = oldUvs[ i ];\r\n\r\n\t\t\t\tx0 = uv[ 0 ];\r\n\t\t\t\tx1 = uv[ 1 ];\r\n\t\t\t\tx2 = uv[ 2 ];\r\n\r\n\t\t\t\tx3.set( midpoint( x0.x, x1.x ), midpoint( x0.y, x1.y ) );\r\n\t\t\t\tx4.set( midpoint( x1.x, x2.x ), midpoint( x1.y, x2.y ) );\r\n\t\t\t\tx5.set( midpoint( x0.x, x2.x ), midpoint( x0.y, x2.y ) );\r\n\r\n\t\t\t\tnewUv( newUVs, x3, x4, x5 );\r\n\t\t\t\tnewUv( newUVs, x0, x3, x5 );\r\n\r\n\t\t\t\tnewUv( newUVs, x1, x4, x3 );\r\n\t\t\t\tnewUv( newUVs, x2, x5, x4 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Overwrite old arrays\r\n\t\tgeometry.vertices = newVertices;\r\n\t\tgeometry.faces = newFaces;\r\n\t\tif ( hasUvs ) { geometry.faceVertexUvs[ 0 ] = newUVs; }\r\n\r\n\t\t// console.log('done');\r\n\r\n\t};\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TessellateModifier = function ( maxEdgeLength ) {\r\n\r\n\tthis.maxEdgeLength = maxEdgeLength;\r\n\r\n};\r\n\r\nTessellateModifier.prototype.modify = function ( geometry ) {\r\n\r\n\tvar edge;\r\n\r\n\tvar faces = [];\r\n\tvar faceVertexUvs = [];\r\n\tvar maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength;\r\n\r\n\tfor ( var i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\tfaceVertexUvs[ i ] = [];\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\tvar face = geometry.faces[ i ];\r\n\r\n\t\tif ( face instanceof Face3 ) {\r\n\r\n\t\t\tvar a = face.a;\r\n\t\t\tvar b = face.b;\r\n\t\t\tvar c = face.c;\r\n\r\n\t\t\tvar va = geometry.vertices[ a ];\r\n\t\t\tvar vb = geometry.vertices[ b ];\r\n\t\t\tvar vc = geometry.vertices[ c ];\r\n\r\n\t\t\tvar dab = va.distanceToSquared( vb );\r\n\t\t\tvar dbc = vb.distanceToSquared( vc );\r\n\t\t\tvar dac = va.distanceToSquared( vc );\r\n\r\n\t\t\tif ( dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared ) {\r\n\r\n\t\t\t\tvar m = geometry.vertices.length;\r\n\r\n\t\t\t\tvar triA = face.clone();\r\n\t\t\t\tvar triB = face.clone();\r\n\r\n\t\t\t\tif ( dab >= dbc && dab >= dac ) {\r\n\r\n\t\t\t\t\tvar vm = va.clone();\r\n\t\t\t\t\tvm.lerp( vb, 0.5 );\r\n\r\n\t\t\t\t\ttriA.a = a;\r\n\t\t\t\t\ttriA.b = m;\r\n\t\t\t\t\ttriA.c = c;\r\n\r\n\t\t\t\t\ttriB.a = m;\r\n\t\t\t\t\ttriB.b = b;\r\n\t\t\t\t\ttriB.c = c;\r\n\r\n\t\t\t\t\tif ( face.vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\t\t\tvar vnm = face.vertexNormals[ 0 ].clone();\r\n\t\t\t\t\t\tvnm.lerp( face.vertexNormals[ 1 ], 0.5 );\r\n\r\n\t\t\t\t\t\ttriA.vertexNormals[ 1 ].copy( vnm );\r\n\t\t\t\t\t\ttriB.vertexNormals[ 0 ].copy( vnm );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( face.vertexColors.length === 3 ) {\r\n\r\n\t\t\t\t\t\tvar vcm = face.vertexColors[ 0 ].clone();\r\n\t\t\t\t\t\tvcm.lerp( face.vertexColors[ 1 ], 0.5 );\r\n\r\n\t\t\t\t\t\ttriA.vertexColors[ 1 ].copy( vcm );\r\n\t\t\t\t\t\ttriB.vertexColors[ 0 ].copy( vcm );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tedge = 0;\r\n\r\n\t\t\t\t} else if ( dbc >= dab && dbc >= dac ) {\r\n\r\n\t\t\t\t\tvar vm = vb.clone();\r\n\t\t\t\t\tvm.lerp( vc, 0.5 );\r\n\r\n\t\t\t\t\ttriA.a = a;\r\n\t\t\t\t\ttriA.b = b;\r\n\t\t\t\t\ttriA.c = m;\r\n\r\n\t\t\t\t\ttriB.a = m;\r\n\t\t\t\t\ttriB.b = c;\r\n\t\t\t\t\ttriB.c = a;\r\n\r\n\t\t\t\t\tif ( face.vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\t\t\tvar vnm = face.vertexNormals[ 1 ].clone();\r\n\t\t\t\t\t\tvnm.lerp( face.vertexNormals[ 2 ], 0.5 );\r\n\r\n\t\t\t\t\t\ttriA.vertexNormals[ 2 ].copy( vnm );\r\n\r\n\t\t\t\t\t\ttriB.vertexNormals[ 0 ].copy( vnm );\r\n\t\t\t\t\t\ttriB.vertexNormals[ 1 ].copy( face.vertexNormals[ 2 ] );\r\n\t\t\t\t\t\ttriB.vertexNormals[ 2 ].copy( face.vertexNormals[ 0 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( face.vertexColors.length === 3 ) {\r\n\r\n\t\t\t\t\t\tvar vcm = face.vertexColors[ 1 ].clone();\r\n\t\t\t\t\t\tvcm.lerp( face.vertexColors[ 2 ], 0.5 );\r\n\r\n\t\t\t\t\t\ttriA.vertexColors[ 2 ].copy( vcm );\r\n\r\n\t\t\t\t\t\ttriB.vertexColors[ 0 ].copy( vcm );\r\n\t\t\t\t\t\ttriB.vertexColors[ 1 ].copy( face.vertexColors[ 2 ] );\r\n\t\t\t\t\t\ttriB.vertexColors[ 2 ].copy( face.vertexColors[ 0 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tedge = 1;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvar vm = va.clone();\r\n\t\t\t\t\tvm.lerp( vc, 0.5 );\r\n\r\n\t\t\t\t\ttriA.a = a;\r\n\t\t\t\t\ttriA.b = b;\r\n\t\t\t\t\ttriA.c = m;\r\n\r\n\t\t\t\t\ttriB.a = m;\r\n\t\t\t\t\ttriB.b = b;\r\n\t\t\t\t\ttriB.c = c;\r\n\r\n\t\t\t\t\tif ( face.vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\t\t\tvar vnm = face.vertexNormals[ 0 ].clone();\r\n\t\t\t\t\t\tvnm.lerp( face.vertexNormals[ 2 ], 0.5 );\r\n\r\n\t\t\t\t\t\ttriA.vertexNormals[ 2 ].copy( vnm );\r\n\t\t\t\t\t\ttriB.vertexNormals[ 0 ].copy( vnm );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( face.vertexColors.length === 3 ) {\r\n\r\n\t\t\t\t\t\tvar vcm = face.vertexColors[ 0 ].clone();\r\n\t\t\t\t\t\tvcm.lerp( face.vertexColors[ 2 ], 0.5 );\r\n\r\n\t\t\t\t\t\ttriA.vertexColors[ 2 ].copy( vcm );\r\n\t\t\t\t\t\ttriB.vertexColors[ 0 ].copy( vcm );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tedge = 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaces.push( triA, triB );\r\n\t\t\t\tgeometry.vertices.push( vm );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tif ( geometry.faceVertexUvs[ j ].length ) {\r\n\r\n\t\t\t\t\t\tvar uvs = geometry.faceVertexUvs[ j ][ i ];\r\n\r\n\t\t\t\t\t\tvar uvA = uvs[ 0 ];\r\n\t\t\t\t\t\tvar uvB = uvs[ 1 ];\r\n\t\t\t\t\t\tvar uvC = uvs[ 2 ];\r\n\r\n\t\t\t\t\t\t// AB\r\n\r\n\t\t\t\t\t\tif ( edge === 0 ) {\r\n\r\n\t\t\t\t\t\t\tvar uvM = uvA.clone();\r\n\t\t\t\t\t\t\tuvM.lerp( uvB, 0.5 );\r\n\r\n\t\t\t\t\t\t\tvar uvsTriA = [ uvA.clone(), uvM.clone(), uvC.clone() ];\r\n\t\t\t\t\t\t\tvar uvsTriB = [ uvM.clone(), uvB.clone(), uvC.clone() ];\r\n\r\n\t\t\t\t\t\t// BC\r\n\r\n\t\t\t\t\t\t} else if ( edge === 1 ) {\r\n\r\n\t\t\t\t\t\t\tvar uvM = uvB.clone();\r\n\t\t\t\t\t\t\tuvM.lerp( uvC, 0.5 );\r\n\r\n\t\t\t\t\t\t\tvar uvsTriA = [ uvA.clone(), uvB.clone(), uvM.clone() ];\r\n\t\t\t\t\t\t\tvar uvsTriB = [ uvM.clone(), uvC.clone(), uvA.clone() ];\r\n\r\n\t\t\t\t\t\t// AC\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar uvM = uvA.clone();\r\n\t\t\t\t\t\t\tuvM.lerp( uvC, 0.5 );\r\n\r\n\t\t\t\t\t\t\tvar uvsTriA = [ uvA.clone(), uvB.clone(), uvM.clone() ];\r\n\t\t\t\t\t\t\tvar uvsTriB = [ uvM.clone(), uvB.clone(), uvC.clone() ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfaceVertexUvs[ j ].push( uvsTriA, uvsTriB );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfaces.push( face );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.faces = faces;\r\n\tgeometry.faceVertexUvs = faceVertexUvs;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MorphAnimMesh = function ( geometry, material ) {\r\n\r\n\tMesh.call( this, geometry, material );\r\n\r\n\tthis.type = 'MorphAnimMesh';\r\n\r\n\tthis.mixer = new AnimationMixer( this );\r\n\tthis.activeAction = null;\r\n};\r\n\r\nMorphAnimMesh.prototype = Object.create( Mesh.prototype );\r\nMorphAnimMesh.prototype.constructor = MorphAnimMesh;\r\n\r\nMorphAnimMesh.prototype.setDirectionForward = function () {\r\n\r\n\tthis.mixer.timeScale = 1.0;\r\n\r\n};\r\n\r\nMorphAnimMesh.prototype.setDirectionBackward = function () {\r\n\r\n\tthis.mixer.timeScale = -1.0;\r\n\r\n};\r\n\r\nMorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\r\n\r\n\tif( this.activeAction ) {\r\n\r\n\t\tthis.activeAction.stop();\r\n\t\tthis.activeAction = null;\r\n\t\t\r\n\t}\r\n\r\n\tvar clip = AnimationClip.findByName( this, label );\r\n\r\n\tif ( clip ) {\r\n\r\n\t\tvar action = this.mixer.clipAction( clip );\r\n\t\taction.timeScale = ( clip.tracks.length * fps ) / clip.duration;\r\n\t\tthis.activeAction = action.play();\r\n\r\n\t} else {\r\n\r\n\t\tthrow new Error( 'MorphAnimMesh: animations[' + label + '] undefined in .playAnimation()' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nMorphAnimMesh.prototype.updateAnimation = function ( delta ) {\r\n\r\n\tthis.mixer.update( delta );\r\n\r\n};\r\n\r\nMorphAnimMesh.prototype.copy = function ( source ) {\r\n\r\n\tMesh.prototype.copy.call( this, source );\r\n\r\n\tthis.mixer = new AnimationMixer( this );\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar vertexDict$1 = [ 'color', 'color2' ],\r\n\tfragmentDict$1 = [ 'vColor', 'vColor2' ];\r\n\r\nfunction ColorsNode( index ) {\r\n\r\n\tTempNode.call( this, 'v4', { shared: false } );\r\n\r\n\tthis.index = index || 0;\r\n\r\n}\r\n\r\nColorsNode.prototype = Object.create( TempNode.prototype );\r\nColorsNode.prototype.constructor = ColorsNode;\r\n\r\nColorsNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tbuilder.requires.color[ this.index ] = true;\r\n\r\n\tvar result = builder.isShader( 'vertex' ) ? vertexDict$1[ this.index ] : fragmentDict$1[ this.index ];\r\n\r\n\treturn builder.format( result, this.getType( builder ), output );\r\n\r\n};\r\n\r\nColorsNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.index = source.index;\r\n\r\n};\r\n\r\nColorsNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.index = this.index;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LightNode( scope ) {\r\n\r\n\tTempNode.call( this, 'v3', { shared: false } );\r\n\r\n\tthis.scope = scope || LightNode.TOTAL;\r\n\r\n}\r\n\r\nLightNode.TOTAL = 'total';\r\n\r\nLightNode.prototype = Object.create( TempNode.prototype );\r\nLightNode.prototype.constructor = LightNode;\r\nLightNode.prototype.nodeType = \"Light\";\r\n\r\nLightNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( builder.isCache( 'light' ) ) {\r\n\r\n\t\treturn builder.format( 'reflectedLight.directDiffuse', this.type, output );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"LightNode is only compatible in \\\"light\\\" channel.\" );\r\n\r\n\t\treturn builder.format( 'vec3( 0.0 )', this.type, output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nLightNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.scope = source.scope;\r\n\r\n};\r\n\r\nLightNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.scope = this.scope;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ReflectNode( scope ) {\r\n\r\n\tTempNode.call( this, 'v3', { unique: true } );\r\n\r\n\tthis.scope = scope || ReflectNode.CUBE;\r\n\r\n}\r\n\r\nReflectNode.CUBE = 'cube';\r\nReflectNode.SPHERE = 'sphere';\r\nReflectNode.VECTOR = 'vector';\r\n\r\nReflectNode.prototype = Object.create( TempNode.prototype );\r\nReflectNode.prototype.constructor = ReflectNode;\r\nReflectNode.prototype.nodeType = \"Reflect\";\r\n\r\nReflectNode.prototype.getType = function ( builder ) {\r\n\r\n\tswitch ( this.scope ) {\r\n\r\n\t\tcase ReflectNode.SPHERE:\r\n\r\n\t\t\treturn 'v2';\r\n\r\n\t}\r\n\r\n\treturn this.type;\r\n\r\n};\r\n\r\nReflectNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\tvar result;\r\n\r\n\t\tswitch ( this.scope ) {\r\n\r\n\t\t\tcase ReflectNode.VECTOR:\r\n\r\n\t\t\t\tbuilder.addNodeCode( 'vec3 reflectVec = inverseTransformDirection( reflect( -normalize( vViewPosition ), normal ), viewMatrix );' );\r\n\r\n\t\t\t\tresult = 'reflectVec';\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase ReflectNode.CUBE:\r\n\r\n\t\t\t\tvar reflectVec = new ReflectNode( ReflectNode.VECTOR ).build( builder, 'v3' );\r\n\r\n\t\t\t\tbuilder.addNodeCode( 'vec3 reflectCubeVec = vec3( -1.0 * ' + reflectVec + '.x, ' + reflectVec + '.yz );' );\r\n\r\n\t\t\t\tresult = 'reflectCubeVec';\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase ReflectNode.SPHERE:\r\n\r\n\t\t\t\tvar reflectVec = new ReflectNode( ReflectNode.VECTOR ).build( builder, 'v3' );\r\n\r\n\t\t\t\tbuilder.addNodeCode( 'vec2 reflectSphereVec = normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5;' );\r\n\r\n\t\t\t\tresult = 'reflectSphereVec';\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\treturn builder.format( result, this.getType( builder ), output );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"ReflectNode is not compatible with \" + builder.shader + \" shader.\" );\r\n\r\n\t\treturn builder.format( 'vec3( 0.0 )', this.type, output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nReflectNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.scope = this.scope;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar NodeUtils = {\r\n\r\n\telements: [ 'x', 'y', 'z', 'w' ],\r\n\r\n\taddShortcuts: function () {\r\n\r\n\t\tfunction applyShortcut( proxy, property, subProperty ) {\r\n\r\n\t\t\tif ( subProperty ) {\r\n\r\n\t\t\t\treturn {\r\n\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this[ proxy ][ property ][ subProperty ];\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tset: function ( val ) {\r\n\r\n\t\t\t\t\t\tthis[ proxy ][ property ][ subProperty ] = val;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn {\r\n\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this[ proxy ][ property ];\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tset: function ( val ) {\r\n\r\n\t\t\t\t\t\tthis[ proxy ][ property ] = val;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn function addShortcuts( proto, proxy, list ) {\r\n\r\n\t\t\tvar shortcuts = {};\r\n\r\n\t\t\tfor ( var i = 0; i < list.length; ++ i ) {\r\n\r\n\t\t\t\tvar data = list[ i ].split( \".\" ),\r\n\t\t\t\t\tproperty = data[ 0 ],\r\n\t\t\t\t\tsubProperty = data[ 1 ];\r\n\r\n\t\t\t\tshortcuts[ property ] = applyShortcut( proxy, property, subProperty );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tObject.defineProperties( proto, shortcuts );\r\n\r\n\t\t};\r\n\r\n\t}()\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction NodeUniform( params ) {\r\n\r\n\tparams = params || {};\r\n\r\n\tthis.name = params.name;\r\n\tthis.type = params.type;\r\n\tthis.node = params.node;\r\n\tthis.needsUpdate = params.needsUpdate;\r\n\r\n}\r\n\r\nObject.defineProperties( NodeUniform.prototype, {\r\n\r\n\tvalue: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.node.value;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( val ) {\r\n\r\n\t\t\tthis.node.value = val;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar declarationRegexp$1 = /^struct\\s*([a-z_0-9]+)\\s*{\\s*((.|\\n)*?)}/img,\r\n\tpropertiesRegexp = /\\s*(\\w*?)\\s*(\\w*?)(\\=|\\;)/img;\r\n\r\nfunction StructNode( src ) {\r\n\r\n\tTempNode.call( this );\r\n\r\n\tthis.eval( src );\r\n\r\n}\r\n\r\nStructNode.prototype = Object.create( TempNode.prototype );\r\nStructNode.prototype.constructor = StructNode;\r\nStructNode.prototype.nodeType = \"Struct\";\r\n\r\nStructNode.prototype.getType = function ( builder ) {\r\n\r\n\treturn builder.getTypeByFormat( this.name );\r\n\r\n};\r\n\r\nStructNode.prototype.getInputByName = function ( name ) {\n\tvar this$1 = this;\n\r\n\r\n\tvar i = this.inputs.length;\r\n\r\n\twhile ( i -- ) {\r\n\r\n\t\tif ( this$1.inputs[ i ].name === name ) {\r\n\r\n\t\t\treturn this$1.inputs[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nStructNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( output === 'source' ) {\r\n\r\n\t\treturn this.src + ';';\r\n\r\n\t} else {\r\n\r\n\t\treturn builder.format( '( ' + src + ' )', this.getType( builder ), output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nStructNode.prototype.eval = function ( src ) {\n\tvar this$1 = this;\n\r\n\r\n\tthis.src = src || '';\r\n\r\n\tthis.inputs = [];\r\n\r\n\tvar declaration = declarationRegexp$1.exec( this.src );\r\n\r\n\tif ( declaration ) {\r\n\r\n\t\tvar properties = declaration[ 2 ], match;\r\n\r\n\t\twhile ( match = propertiesRegexp.exec( properties ) ) {\r\n\r\n\t\t\tthis$1.inputs.push( {\r\n\t\t\t\ttype: match[ 1 ],\r\n\t\t\t\tname: match[ 2 ]\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tthis.name = declaration[ 1 ];\r\n\r\n\t} else {\r\n\r\n\t\tthis.name = '';\r\n\r\n\t}\r\n\r\n\tthis.type = this.name;\r\n\r\n};\r\n\r\nStructNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.src = this.src;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Vector3Node( x, y, z ) {\r\n\r\n\tInputNode$1.call( this, 'v3' );\r\n\r\n\tthis.value = x instanceof Vector3 ? x : new Vector3( x, y, z );\r\n\r\n}\r\n\r\nVector3Node.prototype = Object.create( InputNode$1.prototype );\r\nVector3Node.prototype.constructor = Vector3Node;\r\nVector3Node.prototype.nodeType = \"Vector3\";\r\n\r\nNodeUtils.addShortcuts( Vector3Node.prototype, 'value', [ 'x', 'y', 'z' ] );\r\n\r\nVector3Node.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {\r\n\r\n\treturn builder.format( \"vec3( \" + this.x + \", \" + this.y + \", \" + this.z + \" )\", type, output );\r\n\r\n};\r\n\r\nVector3Node.prototype.copy = function ( source ) {\r\n\r\n\tInputNode$1.prototype.copy.call( this, source );\r\n\r\n\tthis.value.copy( source );\r\n\r\n};\r\n\r\nVector3Node.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.x = this.x;\r\n\t\tdata.y = this.y;\r\n\t\tdata.z = this.z;\r\n\r\n\t\tif ( this.readonly === true ) { data.readonly = true; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Vector4Node( x, y, z, w ) {\r\n\r\n\tInputNode$1.call( this, 'v4' );\r\n\r\n\tthis.value = x instanceof Vector4 ? x : new Vector4( x, y, z, w );\r\n\r\n}\r\n\r\nVector4Node.prototype = Object.create( InputNode$1.prototype );\r\nVector4Node.prototype.constructor = Vector4Node;\r\nVector4Node.prototype.nodeType = \"Vector4\";\r\n\r\nNodeUtils.addShortcuts( Vector4Node.prototype, 'value', [ 'x', 'y', 'z', 'w' ] );\r\n\r\nVector4Node.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {\r\n\r\n\treturn builder.format( \"vec4( \" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \" )\", type, output );\r\n\r\n};\r\n\r\nVector4Node.prototype.copy = function ( source ) {\r\n\r\n\tInputNode$1.prototype.copy.call( this, source );\r\n\r\n\tthis.value.copy( source );\r\n\r\n};\r\n\r\nVector4Node.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.x = this.x;\r\n\t\tdata.y = this.y;\r\n\t\tdata.z = this.z;\r\n\t\tdata.w = this.w;\r\n\r\n\t\tif ( this.readonly === true ) { data.readonly = true; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ColorSpaceNode( input, method ) {\r\n\r\n\tTempNode.call( this, 'v4' );\r\n\r\n\tthis.input = input;\r\n\r\n\tthis.method = method || ColorSpaceNode.LINEAR;\r\n\r\n}\r\n\r\nColorSpaceNode.Nodes = ( function () {\r\n\r\n\t// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\r\n\r\n\tvar LinearToLinear = new FunctionNode( [\r\n\t\t\"vec4 LinearToLinear( in vec4 value ) {\",\r\n\r\n\t\t\"\treturn value;\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar GammaToLinear = new FunctionNode( [\r\n\t\t\"vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\",\r\n\r\n\t\t\"\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar LinearToGamma = new FunctionNode( [\r\n\t\t\"vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\",\r\n\r\n\t\t\"\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar sRGBToLinear = new FunctionNode( [\r\n\t\t\"vec4 sRGBToLinear( in vec4 value ) {\",\r\n\r\n\t\t\"\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar LinearTosRGB = new FunctionNode( [\r\n\t\t\"vec4 LinearTosRGB( in vec4 value ) {\",\r\n\r\n\t\t\"\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar RGBEToLinear = new FunctionNode( [\r\n\t\t\"vec4 RGBEToLinear( in vec4 value ) {\",\r\n\r\n\t\t\"\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar LinearToRGBE = new FunctionNode( [\r\n\t\t\"vec4 LinearToRGBE( in vec4 value ) {\",\r\n\r\n\t\t\"\tfloat maxComponent = max( max( value.r, value.g ), value.b );\",\r\n\t\t\"\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\",\r\n\t\t\"\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\",\r\n\t\t//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\t// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\r\n\r\n\tvar RGBMToLinear = new FunctionNode( [\r\n\t\t\"vec3 RGBMToLinear( in vec4 value, in float maxRange ) {\",\r\n\r\n\t\t\"\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar LinearToRGBM = new FunctionNode( [\r\n\t\t\"vec3 LinearToRGBM( in vec4 value, in float maxRange ) {\",\r\n\r\n\t\t\"\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\",\r\n\t\t\"\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\",\r\n\t\t\"\tM            = ceil( M * 255.0 ) / 255.0;\",\r\n\t\t\"\treturn vec4( value.rgb / ( M * maxRange ), M );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\t// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\r\n\r\n\tvar RGBDToLinear = new FunctionNode( [\r\n\t\t\"vec3 RGBDToLinear( in vec4 value, in float maxRange ) {\",\r\n\r\n\t\t\"\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar LinearToRGBD = new FunctionNode( [\r\n\t\t\"vec3 LinearToRGBD( in vec4 value, in float maxRange ) {\",\r\n\r\n\t\t\"\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\",\r\n\t\t\"\tfloat D      = max( maxRange / maxRGB, 1.0 );\",\r\n\t\t\"\tD            = min( floor( D ) / 255.0, 1.0 );\",\r\n\t\t\"\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\t// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\r\n\r\n\t// M matrix, for encoding\r\n\r\n\tvar cLogLuvM = new ConstNode( \"const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\" );\r\n\r\n\tvar LinearToLogLuv = new FunctionNode( [\r\n\t\t\"vec4 LinearToLogLuv( in vec4 value ) {\",\r\n\r\n\t\t\"\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\",\r\n\t\t\"\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\",\r\n\t\t\"\tvec4 vResult;\",\r\n\t\t\"\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\",\r\n\t\t\"\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\",\r\n\t\t\"\tvResult.w = fract(Le);\",\r\n\t\t\"\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\",\r\n\t\t\"\treturn vResult;\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ), [ cLogLuvM ] );\r\n\r\n\t// Inverse M matrix, for decoding\r\n\r\n\tvar cLogLuvInverseM = new ConstNode( \"const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\" );\r\n\r\n\tvar LogLuvToLinear = new FunctionNode( [\r\n\t\t\"vec4 LogLuvToLinear( in vec4 value ) {\",\r\n\r\n\t\t\"\tfloat Le = value.z * 255.0 + value.w;\",\r\n\t\t\"\tvec3 Xp_Y_XYZp;\",\r\n\t\t\"\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\",\r\n\t\t\"\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\",\r\n\t\t\"\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\",\r\n\t\t\"\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\",\r\n\t\t\"\treturn vec4( max(vRGB, 0.0), 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ), [ cLogLuvInverseM ] );\r\n\r\n\treturn {\r\n\t\tLinearToLinear: LinearToLinear,\r\n\t\tGammaToLinear: GammaToLinear,\r\n\t\tLinearToGamma: LinearToGamma,\r\n\t\tsRGBToLinear: sRGBToLinear,\r\n\t\tLinearTosRGB: LinearTosRGB,\r\n\t\tRGBEToLinear: RGBEToLinear,\r\n\t\tLinearToRGBE: LinearToRGBE,\r\n\t\tRGBMToLinear: RGBMToLinear,\r\n\t\tLinearToRGBM: LinearToRGBM,\r\n\t\tRGBDToLinear: RGBDToLinear,\r\n\t\tLinearToRGBD: LinearToRGBD,\r\n\t\tcLogLuvM: cLogLuvM,\r\n\t\tLinearToLogLuv: LinearToLogLuv,\r\n\t\tcLogLuvInverseM: cLogLuvInverseM,\r\n\t\tLogLuvToLinear: LogLuvToLinear\r\n\t};\r\n\r\n} )();\r\n\r\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\r\n\r\nColorSpaceNode.GAMMA_TO_LINEAR = 'GammaToLinear';\r\nColorSpaceNode.LINEAR_TO_GAMMA = 'LinearToGamma';\r\n\r\nColorSpaceNode.SRGB_TO_LINEAR = 'sRGBToLinear';\r\nColorSpaceNode.LINEAR_TO_SRGB = 'LinearTosRGB';\r\n\r\nColorSpaceNode.RGBE_TO_LINEAR = 'RGBEToLinear';\r\nColorSpaceNode.LINEAR_TO_RGBE = 'LinearToRGBE';\r\n\r\nColorSpaceNode.RGBM_TO_LINEAR = 'RGBMToLinear';\r\nColorSpaceNode.LINEAR_TO_RGBM = 'LinearToRGBM';\r\n\r\nColorSpaceNode.RGBD_TO_LINEAR = 'RGBDToLinear';\r\nColorSpaceNode.LINEAR_TO_RGBD = 'LinearToRGBD';\r\n\r\nColorSpaceNode.LINEAR_TO_LOG_LUV = 'LinearToLogLuv';\r\nColorSpaceNode.LOG_LUV_TO_LINEAR = 'LogLuvToLinear';\r\n\r\nColorSpaceNode.prototype = Object.create( TempNode.prototype );\r\nColorSpaceNode.prototype.constructor = ColorSpaceNode;\r\nColorSpaceNode.prototype.nodeType = \"ColorAdjustment\";\r\n\r\nColorSpaceNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar input = builder.context.input || this.input.build( builder, 'v4' ),\r\n\t\tencodingMethod = builder.context.encoding !== undefined ? this.getEncodingMethod( builder.context.encoding ) : [ this.method ],\r\n\t\tfactor = this.factor ? this.factor.build( builder, 'f' ) : encodingMethod[ 1 ];\r\n\r\n\tvar method = builder.include( ColorSpaceNode.Nodes[ encodingMethod[ 0 ] ] );\r\n\r\n\tif ( factor ) {\r\n\r\n\t\treturn builder.format( method + '( ' + input + ', ' + factor + ' )', this.getType( builder ), output );\r\n\r\n\t} else {\r\n\r\n\t\treturn builder.format( method + '( ' + input + ' )', this.getType( builder ), output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nColorSpaceNode.prototype.getDecodingMethod = function ( encoding ) {\r\n\r\n\tvar components = this.getEncodingComponents( encoding );\r\n\r\n\tcomponents[ 0 ] += 'ToLinear';\r\n\r\n\treturn components;\r\n\r\n};\r\n\r\nColorSpaceNode.prototype.getEncodingMethod = function ( encoding ) {\r\n\r\n\tvar components = this.getEncodingComponents( encoding );\r\n\r\n\tcomponents[ 0 ] = 'LinearTo' + components[ 0 ];\r\n\r\n\treturn components;\r\n\r\n};\r\n\r\nColorSpaceNode.prototype.getEncodingComponents = function ( encoding ) {\r\n\r\n\tswitch ( encoding ) {\r\n\r\n\t\tcase LinearEncoding:\r\n\t\t\treturn [ 'Linear' ];\r\n\t\tcase sRGBEncoding:\r\n\t\t\treturn [ 'sRGB' ];\r\n\t\tcase RGBEEncoding:\r\n\t\t\treturn [ 'RGBE' ];\r\n\t\tcase RGBM7Encoding:\r\n\t\t\treturn [ 'RGBM', '7.0' ];\r\n\t\tcase RGBM16Encoding:\r\n\t\t\treturn [ 'RGBM', '16.0' ];\r\n\t\tcase RGBDEncoding:\r\n\t\t\treturn [ 'RGBD', '256.0' ];\r\n\t\tcase GammaEncoding:\r\n\t\t\treturn [ 'Gamma', 'float( GAMMA_FACTOR )' ];\r\n\r\n\t}\r\n\r\n};\r\n\r\nColorSpaceNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.input = source.input;\r\n\tthis.method = source.method;\r\n\r\n};\r\n\r\nColorSpaceNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.input = this.input.toJSON( meta ).uuid;\r\n\t\tdata.method = this.method;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction TextureNode( value, uv, bias, project ) {\r\n\r\n\tInputNode$1.call( this, 'v4', { shared: true } );\r\n\r\n\tthis.value = value;\r\n\tthis.uv = uv || new UVNode();\r\n\tthis.bias = bias;\r\n\tthis.project = project !== undefined ? project : false;\r\n\r\n}\r\n\r\nTextureNode.prototype = Object.create( InputNode$1.prototype );\r\nTextureNode.prototype.constructor = TextureNode;\r\nTextureNode.prototype.nodeType = \"Texture\";\r\n\r\nTextureNode.prototype.getTexture = function ( builder, output ) {\r\n\r\n\treturn InputNode$1.prototype.generate.call( this, builder, output, this.value.uuid, 't' );\r\n\r\n};\r\n\r\nTextureNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( output === 'sampler2D' ) {\r\n\r\n\t\treturn this.getTexture( builder, output );\r\n\r\n\t}\r\n\r\n\tvar tex = this.getTexture( builder, output ),\r\n\t\tuv = this.uv.build( builder, this.project ? 'v4' : 'v2' ),\r\n\t\tbias = this.bias ? this.bias.build( builder, 'f' ) : undefined;\r\n\r\n\tif ( bias == undefined && builder.context.bias ) {\r\n\r\n\t\tbias = new builder.context.bias( this ).build( builder, 'f' );\r\n\r\n\t}\r\n\r\n\tvar method, code;\r\n\r\n\tif ( this.project ) { method = 'texture2DProj'; }\r\n\telse { method = bias ? 'tex2DBias' : 'tex2D'; }\r\n\r\n\tif ( bias ) { code = method + '( ' + tex + ', ' + uv + ', ' + bias + ' )'; }\r\n\telse { code = method + '( ' + tex + ', ' + uv + ' )'; }\r\n\r\n\t// add this context to replace ColorSpaceNode.input to code\r\n\r\n\tbuilder.addContext( { input: code, encoding: builder.getTextureEncodingFromMap( this.value ), include: builder.isShader( 'vertex' ) } );\r\n\r\n\tthis.colorSpace = this.colorSpace || new ColorSpaceNode( this );\r\n\tcode = this.colorSpace.build( builder, this.type );\r\n\r\n\tbuilder.removeContext();\r\n\r\n\treturn builder.format( code, this.type, output );\r\n\r\n};\r\n\r\nTextureNode.prototype.copy = function ( source ) {\r\n\r\n\tInputNode$1.prototype.copy.call( this, source );\r\n\r\n\tif ( source.value ) { this.value = source.value; }\r\n\r\n\tthis.uv = source.uv;\r\n\r\n\tif ( source.bias ) { this.bias = source.bias; }\r\n\tif ( source.project !== undefined ) { this.project = source.project; }\r\n\r\n};\r\n\r\nTextureNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tif ( this.value ) { data.value = this.value.uuid; }\r\n\r\n\t\tdata.uv = this.uv.toJSON( meta ).uuid;\r\n\t\tdata.project = this.project;\r\n\r\n\t\tif ( this.bias ) { data.bias = this.bias.toJSON( meta ).uuid; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CubeTextureNode( value, uv, bias ) {\r\n\r\n\tInputNode$1.call( this, 'v4', { shared: true } );\r\n\r\n\tthis.value = value;\r\n\tthis.uv = uv || new ReflectNode();\r\n\tthis.bias = bias;\r\n\r\n}\r\n\r\nCubeTextureNode.prototype = Object.create( InputNode$1.prototype );\r\nCubeTextureNode.prototype.constructor = CubeTextureNode;\r\nCubeTextureNode.prototype.nodeType = \"CubeTexture\";\r\n\r\nCubeTextureNode.prototype.getTexture = function ( builder, output ) {\r\n\r\n\treturn InputNode$1.prototype.generate.call( this, builder, output, this.value.uuid, 'tc' );\r\n\r\n};\r\n\r\nCubeTextureNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( output === 'samplerCube' ) {\r\n\r\n\t\treturn this.getTexture( builder, output );\r\n\r\n\t}\r\n\r\n\tvar cubetex = this.getTexture( builder, output );\r\n\tvar uv = this.uv.build( builder, 'v3' );\r\n\tvar bias = this.bias ? this.bias.build( builder, 'f' ) : undefined;\r\n\r\n\tif ( bias === undefined && builder.context.bias ) {\r\n\r\n\t\tbias = new builder.context.bias( this ).build( builder, 'f' );\r\n\r\n\t}\r\n\r\n\tvar code;\r\n\r\n\tif ( bias ) { code = 'texCubeBias( ' + cubetex + ', ' + uv + ', ' + bias + ' )'; }\r\n\telse { code = 'texCube( ' + cubetex + ', ' + uv + ' )'; }\r\n\r\n\t// add this context to replace ColorSpaceNode.input to code\r\n\r\n\tbuilder.addContext( { input: code, encoding: builder.getTextureEncodingFromMap( this.value ), include: builder.isShader( 'vertex' ) } );\r\n\r\n\tthis.colorSpace = this.colorSpace || new ColorSpaceNode( this );\r\n\tcode = this.colorSpace.build( builder, this.type );\r\n\r\n\tbuilder.removeContext();\r\n\r\n\treturn builder.format( code, this.type, output );\r\n\r\n};\r\n\r\nCubeTextureNode.prototype.copy = function ( source ) {\r\n\r\n\tInputNode$1.prototype.copy.call( this, source );\r\n\r\n\tif ( source.value ) { this.value = source.value; }\r\n\r\n\tthis.uv = source.uv;\r\n\r\n\tif ( source.bias ) { this.bias = source.bias; }\r\n\r\n};\r\n\r\nCubeTextureNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.value = this.value.uuid;\r\n\t\tdata.uv = this.uv.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.bias ) { data.bias = this.bias.toJSON( meta ).uuid; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction BlinnShininessExponentNode() {\r\n\r\n\tTempNode.call( this, 'f' );\r\n\r\n}\r\n\r\nBlinnShininessExponentNode.prototype = Object.create( TempNode.prototype );\r\nBlinnShininessExponentNode.prototype.constructor = BlinnShininessExponentNode;\r\nBlinnShininessExponentNode.prototype.nodeType = \"BlinnShininessExponent\";\r\n\r\nBlinnShininessExponentNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( builder.isCache( 'clearCoat' ) ) {\r\n\r\n\t\treturn builder.format( 'Material_ClearCoat_BlinnShininessExponent( material )', this.type, output );\r\n\r\n\t} else {\r\n\r\n\t\treturn builder.format( 'Material_BlinnShininessExponent( material )', this.type, output );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction BlinnExponentToRoughnessNode( blinnExponent ) {\r\n\r\n\tTempNode.call( this, 'f' );\r\n\r\n\tthis.blinnExponent = blinnExponent || new BlinnShininessExponentNode();\r\n\r\n}\r\n\r\nBlinnExponentToRoughnessNode.prototype = Object.create( TempNode.prototype );\r\nBlinnExponentToRoughnessNode.prototype.constructor = BlinnExponentToRoughnessNode;\r\nBlinnExponentToRoughnessNode.prototype.nodeType = \"BlinnExponentToRoughness\";\r\n\r\nBlinnExponentToRoughnessNode.prototype.generate = function ( builder, output ) {\r\n\r\n\treturn builder.format( 'BlinnExponentToGGXRoughness( ' + this.blinnExponent.build( builder, 'f' ) + ' )', this.type, output );\r\n\r\n};\r\n\r\nBlinnExponentToRoughnessNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.blinnExponent = source.blinnExponent;\r\n\r\n};\r\n\r\nBlinnExponentToRoughnessNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.blinnExponent = this.blinnExponent;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction TextureCubeUVNode( uv, textureSize, blinnExponentToRoughness ) {\r\n\r\n\tTempNode.call( this, 'TextureCubeUVData' ); // TextureCubeUVData is type as StructNode\r\n\r\n\tthis.uv = uv || new ReflectNode( ReflectNode.VECTOR );\r\n\tthis.textureSize = textureSize || new FloatNode( 1024 );\r\n\tthis.blinnExponentToRoughness = blinnExponentToRoughness || new BlinnExponentToRoughnessNode();\r\n\r\n}\r\n\r\nTextureCubeUVNode.Nodes = ( function () {\r\n\r\n\tvar TextureCubeUVData = new StructNode( [\r\n\t\t\"struct TextureCubeUVData {\",\r\n\t\t\"\tvec2 uv_10;\",\r\n\t\t\"\tvec2 uv_20;\",\r\n\t\t\"\tfloat t;\",\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar getFaceFromDirection = new FunctionNode( [\r\n\t\t\"int getFaceFromDirection(vec3 direction) {\",\r\n\t\t\"\tvec3 absDirection = abs(direction);\",\r\n\t\t\"\tint face = -1;\",\r\n\t\t\"\tif( absDirection.x > absDirection.z ) {\",\r\n\t\t\"\t\tif(absDirection.x > absDirection.y )\",\r\n\t\t\"\t\t\tface = direction.x > 0.0 ? 0 : 3;\",\r\n\t\t\"\t\telse\",\r\n\t\t\"\t\t\tface = direction.y > 0.0 ? 1 : 4;\",\r\n\t\t\"\t}\",\r\n\t\t\"\telse {\",\r\n\t\t\"\t\tif(absDirection.z > absDirection.y )\",\r\n\t\t\"\t\t\tface = direction.z > 0.0 ? 2 : 5;\",\r\n\t\t\"\t\telse\",\r\n\t\t\"\t\t\tface = direction.y > 0.0 ? 1 : 4;\",\r\n\t\t\"\t}\",\r\n\t\t\"\treturn face;\",\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar cubeUV_maxLods1 = new ConstNode( \"#define cubeUV_maxLods1 ( log2( cubeUV_textureSize * 0.25 ) - 1.0 )\" );\r\n\tvar cubeUV_rangeClamp = new ConstNode( \"#define cubeUV_rangeClamp ( exp2( ( 6.0 - 1.0 ) * 2.0 ) )\" );\r\n\r\n\tvar MipLevelInfo = new FunctionNode( [\r\n\t\t\"vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness, in float cubeUV_textureSize ) {\",\r\n\t\t\"\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\",\r\n\t\t\"\tfloat dxRoughness = dFdx(roughness);\",\r\n\t\t\"\tfloat dyRoughness = dFdy(roughness);\",\r\n\t\t\"\tvec3 dx = dFdx( vec * scale * dxRoughness );\",\r\n\t\t\"\tvec3 dy = dFdy( vec * scale * dyRoughness );\",\r\n\t\t\"\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\",\r\n\t\t// Clamp the value to the max mip level counts. hard coded to 6 mips\"\r\n\t\t\"\td = clamp(d, 1.0, cubeUV_rangeClamp);\",\r\n\t\t\"\tfloat mipLevel = 0.5 * log2(d);\",\r\n\t\t\"\treturn vec2(floor(mipLevel), fract(mipLevel));\",\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ), [ cubeUV_maxLods1, cubeUV_rangeClamp ], { derivatives: true } );\r\n\r\n\tvar cubeUV_maxLods2 = new ConstNode( \"#define cubeUV_maxLods2 ( log2( cubeUV_textureSize * 0.25 ) - 2.0 )\" );\r\n\tvar cubeUV_rcpTextureSize = new ConstNode( \"#define cubeUV_rcpTextureSize ( 1.0 / cubeUV_textureSize )\" );\r\n\r\n\tvar getCubeUV = new FunctionNode( [\r\n\t\t\"vec2 getCubeUV( vec3 direction, float roughnessLevel, float mipLevel, in float cubeUV_textureSize ) {\",\r\n\t\t\"\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\",\r\n\t\t\"\tfloat a = 16.0 * cubeUV_rcpTextureSize;\",\r\n\t\t\"\",\r\n\t\t\"\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\",\r\n\t\t\"\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\",\r\n\t\t// float powScale = exp2(roughnessLevel + mipLevel);\"\r\n\t\t\"\tfloat powScale = exp2_packed.x * exp2_packed.y;\",\r\n\t\t// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\"\r\n\t\t\"\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\",\r\n\t\t// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\"\r\n\t\t\"\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\",\r\n\t\t\"\",\r\n\t\t\"\tbool bRes = mipLevel == 0.0;\",\r\n\t\t\"\tscale =  bRes && (scale < a) ? a : scale;\",\r\n\t\t\"\",\r\n\t\t\"\tvec3 r;\",\r\n\t\t\"\tvec2 offset;\",\r\n\t\t\"\tint face = getFaceFromDirection(direction);\",\r\n\t\t\"\",\r\n\t\t\"\tfloat rcpPowScale = 1.0 / powScale;\",\r\n\t\t\"\",\r\n\t\t\"\tif( face == 0) {\",\r\n\t\t\"\t\tr = vec3(direction.x, -direction.z, direction.y);\",\r\n\t\t\"\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\",\r\n\t\t\"\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\",\r\n\t\t\"\t}\",\r\n\t\t\"\telse if( face == 1) {\",\r\n\t\t\"\t\tr = vec3(direction.y, direction.x, direction.z);\",\r\n\t\t\"\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\",\r\n\t\t\"\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\",\r\n\t\t\"\t}\",\r\n\t\t\"\telse if( face == 2) {\",\r\n\t\t\"\t\tr = vec3(direction.z, direction.x, direction.y);\",\r\n\t\t\"\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\",\r\n\t\t\"\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\",\r\n\t\t\"\t}\",\r\n\t\t\"\telse if( face == 3) {\",\r\n\t\t\"\t\tr = vec3(direction.x, direction.z, direction.y);\",\r\n\t\t\"\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\",\r\n\t\t\"\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\",\r\n\t\t\"\t}\",\r\n\t\t\"\telse if( face == 4) {\",\r\n\t\t\"\t\tr = vec3(direction.y, direction.x, -direction.z);\",\r\n\t\t\"\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\",\r\n\t\t\"\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\",\r\n\t\t\"\t}\",\r\n\t\t\"\telse {\",\r\n\t\t\"\t\tr = vec3(direction.z, -direction.x, direction.y);\",\r\n\t\t\"\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\",\r\n\t\t\"\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\",\r\n\t\t\"\t}\",\r\n\t\t\"\tr = normalize(r);\",\r\n\t\t\"\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\",\r\n\t\t\"\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\",\r\n\t\t\"\tvec2 base = offset + vec2( texelOffset );\",\r\n\t\t\"\treturn base + s * ( scale - 2.0 * texelOffset );\",\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ), [ cubeUV_maxLods2, cubeUV_rcpTextureSize, getFaceFromDirection ] );\r\n\r\n\tvar cubeUV_maxLods3 = new ConstNode( \"#define cubeUV_maxLods3 ( log2( cubeUV_textureSize * 0.25 ) - 3.0 )\" );\r\n\r\n\tvar textureCubeUV = new FunctionNode( [\r\n\t\t\"TextureCubeUVData textureCubeUV( vec3 reflectedDirection, float roughness, in float cubeUV_textureSize ) {\",\r\n\t\t\"\tfloat roughnessVal = roughness * cubeUV_maxLods3;\",\r\n\t\t\"\tfloat r1 = floor(roughnessVal);\",\r\n\t\t\"\tfloat r2 = r1 + 1.0;\",\r\n\t\t\"\tfloat t = fract(roughnessVal);\",\r\n\t\t\"\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness, cubeUV_textureSize);\",\r\n\t\t\"\tfloat s = mipInfo.y;\",\r\n\t\t\"\tfloat level0 = mipInfo.x;\",\r\n\t\t\"\tfloat level1 = level0 + 1.0;\",\r\n\t\t\"\tlevel1 = level1 > 5.0 ? 5.0 : level1;\",\r\n\t\t\"\",\r\n\t\t// round to nearest mipmap if we are not interpolating.\"\r\n\t\t\"\tlevel0 += min( floor( s + 0.5 ), 5.0 );\",\r\n\t\t\"\",\r\n\t\t// Tri linear interpolation.\"\r\n\t\t\"\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0, cubeUV_textureSize);\",\r\n\t\t\"\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0, cubeUV_textureSize);\",\r\n\t\t\"\",\r\n\t\t\"\treturn TextureCubeUVData(uv_10, uv_20, t);\",\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ), [ TextureCubeUVData, cubeUV_maxLods3, MipLevelInfo, getCubeUV ] );\r\n\r\n\treturn {\r\n\t\tTextureCubeUVData: TextureCubeUVData,\r\n\t\ttextureCubeUV: textureCubeUV\r\n\t};\r\n\r\n} )();\r\n\r\nTextureCubeUVNode.prototype = Object.create( TempNode.prototype );\r\nTextureCubeUVNode.prototype.constructor = TextureCubeUVNode;\r\nTextureCubeUVNode.prototype.nodeType = \"TextureCubeUV\";\r\n\r\nTextureCubeUVNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\tvar textureCubeUV = builder.include( TextureCubeUVNode.Nodes.textureCubeUV );\r\n\r\n\t\treturn builder.format( textureCubeUV + '( ' + this.uv.build( builder, 'v3' ) + ', ' +\r\n\t\t\tthis.blinnExponentToRoughness.build( builder, 'f' ) + ', ' +\r\n\t\t\tthis.textureSize.build( builder, 'f' ) + ' )', this.getType( builder ), output );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"TextureCubeUVNode is not compatible with \" + builder.shader + \" shader.\" );\r\n\r\n\t\treturn builder.format( 'vec4( 0.0 )', this.getType( builder ), output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTextureCubeUVNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.uv = this.uv.toJSON( meta ).uuid;\r\n\t\tdata.textureSize = this.textureSize.toJSON( meta ).uuid;\r\n\t\tdata.blinnExponentToRoughness = this.blinnExponentToRoughness.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction TextureCubeNode( value, uv ) {\r\n\r\n\tTempNode.call( this, 'v4' );\r\n\r\n\tthis.value = value;\r\n\tthis.uv = uv || new TextureCubeUVNode();\r\n\r\n}\r\n\r\nTextureCubeNode.prototype = Object.create( TempNode.prototype );\r\nTextureCubeNode.prototype.constructor = TextureCubeNode;\r\nTextureCubeNode.prototype.nodeType = \"TextureCube\";\r\n\r\nTextureCubeNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\tvar uv_10 = this.uv.build( builder ) + '.uv_10',\r\n\t\t\tuv_20 = this.uv.build( builder ) + '.uv_20',\r\n\t\t\tt = this.uv.build( builder ) + '.t';\r\n\r\n\t\tvar color10 = builder.getTexelDecodingFunctionFromTexture( 'texture2D( ' + this.value.build( builder, 'sampler2D' ) + ', ' + uv_10 + ' )', this.value.value ),\r\n\t\t\tcolor20 = builder.getTexelDecodingFunctionFromTexture( 'texture2D( ' + this.value.build( builder, 'sampler2D' ) + ', ' + uv_20 + ' )', this.value.value );\r\n\r\n\t\treturn builder.format( 'vec4( mix( ' + color10 + ', ' + color20 + ', ' + t + ' ).rgb, 1.0 )', this.getType( builder ), output );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"TextureCubeNode is not compatible with \" + builder.shader + \" shader.\" );\r\n\r\n\t\treturn builder.format( 'vec4( 0.0 )', this.getType( builder ), output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTextureCubeNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.uv = this.uv.toJSON( meta ).uuid;\r\n\t\tdata.textureSize = this.textureSize.toJSON( meta ).uuid;\r\n\t\tdata.blinnExponentToRoughness = this.blinnExponentToRoughness.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.roughness ) { data.roughness = this.roughness.toJSON( meta ).uuid; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar elements = NodeUtils.elements,\r\n\tconstructors = [ 'float', 'vec2', 'vec3', 'vec4' ],\r\n\tconvertFormatToType = {\r\n\t\tfloat: 'f',\r\n\t\tvec2: 'v2',\r\n\t\tvec3: 'v3',\r\n\t\tvec4: 'v4',\r\n\t\tmat4: 'v4',\r\n\t\tint: 'i'\r\n\t},\r\n\tconvertTypeToFormat = {\r\n\t\tt: 'sampler2D',\r\n\t\ttc: 'samplerCube',\r\n\t\tb: 'bool',\r\n\t\ti: 'int',\r\n\t\tf: 'float',\r\n\t\tc: 'vec3',\r\n\t\tv2: 'vec2',\r\n\t\tv3: 'vec3',\r\n\t\tv4: 'vec4',\r\n\t\tm3: 'mat3',\r\n\t\tm4: 'mat4'\r\n\t};\r\n\r\nfunction NodeBuilder() {\r\n\r\n\tthis.slots = [];\r\n\tthis.caches = [];\r\n\tthis.contexts = [];\r\n\r\n\tthis.keywords = {};\r\n\r\n\tthis.nodeData = {};\r\n\r\n\tthis.requires = {\r\n\t\tuv: [],\r\n\t\tcolor: [],\r\n\t\tlights: false,\r\n\t\tfog: false\r\n\t};\r\n\r\n\tthis.includes = {\r\n\t\tconsts: [],\r\n\t\tfunctions: [],\r\n\t\tstructs: []\r\n\t};\r\n\r\n\tthis.attributes = {};\r\n\r\n\tthis.prefixCode = [\r\n\t\t\"#ifdef TEXTURE_LOD_EXT\",\r\n\r\n\t\t\"\t#define texCube(a, b) textureCube(a, b)\",\r\n\t\t\"\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)\",\r\n\r\n\t\t\"\t#define tex2D(a, b) texture2D(a, b)\",\r\n\t\t\"\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)\",\r\n\r\n\t\t\"#else\",\r\n\r\n\t\t\"\t#define texCube(a, b) textureCube(a, b)\",\r\n\t\t\"\t#define texCubeBias(a, b, c) textureCube(a, b, c)\",\r\n\r\n\t\t\"\t#define tex2D(a, b) texture2D(a, b)\",\r\n\t\t\"\t#define tex2DBias(a, b, c) texture2D(a, b, c)\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#include <packing>\",\r\n\t\t\"#include <common>\"\r\n\r\n\t].join( \"\\n\" );\r\n\r\n\tthis.parsCode = {\r\n\t\tvertex: '',\r\n\t\tfragment: ''\r\n\t};\r\n\r\n\tthis.code = {\r\n\t\tvertex: '',\r\n\t\tfragment: ''\r\n\t};\r\n\r\n\tthis.nodeCode = {\r\n\t\tvertex: '',\r\n\t\tfragment: ''\r\n\t};\r\n\r\n\tthis.resultCode = {\r\n\t\tvertex: '',\r\n\t\tfragment: ''\r\n\t};\r\n\r\n\tthis.finalCode = {\r\n\t\tvertex: '',\r\n\t\tfragment: ''\r\n\t};\r\n\r\n\tthis.inputs = {\r\n\t\tuniforms: {\r\n\t\t\tlist: [],\r\n\t\t\tvertex: [],\r\n\t\t\tfragment: []\r\n\t\t},\r\n\t\tvars: {\r\n\t\t\tvarying: [],\r\n\t\t\tvertex: [],\r\n\t\t\tfragment: []\r\n\t\t}\r\n\t};\r\n\r\n\t// send to material\r\n\r\n\tthis.defines = {};\r\n\r\n\tthis.uniforms = {};\r\n\r\n\tthis.extensions = {};\r\n\r\n\tthis.updaters = [];\r\n\r\n\tthis.nodes = [];\r\n\r\n\t// --\r\n\r\n\tthis.parsing = false;\r\n\tthis.optimize = true;\r\n\r\n}\r\n\r\nNodeBuilder.prototype = {\r\n\r\n\tconstructor: NodeBuilder,\r\n\r\n\tbuild: function ( vertex, fragment ) {\r\n\r\n\t\tthis.buildShader( 'vertex', vertex );\r\n\t\tthis.buildShader( 'fragment', fragment );\r\n\r\n\t\tif ( this.requires.uv[ 0 ] ) {\r\n\r\n\t\t\tthis.addVaryCode( 'varying vec2 vUv;' );\r\n\r\n\t\t\tthis.addVertexFinalCode( 'vUv = uv;' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.requires.uv[ 1 ] ) {\r\n\r\n\t\t\tthis.addVaryCode( 'varying vec2 vUv2;' );\r\n\t\t\tthis.addVertexParsCode( 'attribute vec2 uv2;' );\r\n\r\n\t\t\tthis.addVertexFinalCode( 'vUv2 = uv2;' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.requires.color[ 0 ] ) {\r\n\r\n\t\t\tthis.addVaryCode( 'varying vec4 vColor;' );\r\n\t\t\tthis.addVertexParsCode( 'attribute vec4 color;' );\r\n\r\n\t\t\tthis.addVertexFinalCode( 'vColor = color;' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.requires.color[ 1 ] ) {\r\n\r\n\t\t\tthis.addVaryCode( 'varying vec4 vColor2;' );\r\n\t\t\tthis.addVertexParsCode( 'attribute vec4 color2;' );\r\n\r\n\t\t\tthis.addVertexFinalCode( 'vColor2 = color2;' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.requires.position ) {\r\n\r\n\t\t\tthis.addVaryCode( 'varying vec3 vPosition;' );\r\n\r\n\t\t\tthis.addVertexFinalCode( 'vPosition = transformed;' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.requires.worldPosition ) {\r\n\r\n\t\t\tthis.addVaryCode( 'varying vec3 vWPosition;' );\r\n\r\n\t\t\tthis.addVertexFinalCode( 'vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.requires.normal ) {\r\n\r\n\t\t\tthis.addVaryCode( 'varying vec3 vObjectNormal;' );\r\n\r\n\t\t\tthis.addVertexFinalCode( 'vObjectNormal = normal;' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.requires.worldNormal ) {\r\n\r\n\t\t\tthis.addVaryCode( 'varying vec3 vWNormal;' );\r\n\r\n\t\t\tthis.addVertexFinalCode( 'vWNormal = ( modelMatrix * vec4( objectNormal, 0.0 ) ).xyz;' );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tbuildShader: function ( shader, node ) {\r\n\r\n\t\tthis.resultCode[ shader ] = node.build( this.setShader( shader ), 'v4' );\r\n\r\n\t},\r\n\r\n\tsetMaterial: function ( material, renderer ) {\r\n\r\n\t\tthis.material = material;\r\n\t\tthis.renderer = renderer;\r\n\r\n\t\tthis.requires.lights = material.lights;\r\n\t\tthis.requires.fog = material.fog;\r\n\r\n\t\tthis.mergeDefines( material.defines );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddFlow: function ( slot, cache, context ) {\r\n\r\n\t\treturn this.addSlot( slot ).addCache( cache ).addContext( context );\r\n\r\n\t},\r\n\r\n\tremoveFlow: function () {\r\n\r\n\t\treturn this.removeSlot().removeCache().removeContext();\r\n\r\n\t},\r\n\r\n\taddCache: function ( name ) {\r\n\r\n\t\tthis.cache = name || '';\r\n\t\tthis.caches.push( this.cache );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremoveCache: function () {\r\n\r\n\t\tthis.caches.pop();\r\n\t\tthis.cache = this.caches[ this.caches.length - 1 ] || '';\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddContext: function ( context ) {\r\n\r\n\t\tthis.context = Object.assign( {}, this.context, context );\r\n\t\tthis.contexts.push( this.context );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremoveContext: function () {\r\n\r\n\t\tthis.contexts.pop();\r\n\t\tthis.context = this.contexts[ this.contexts.length - 1 ] || {};\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddSlot: function ( name ) {\r\n\r\n\t\tthis.slot = name || '';\r\n\t\tthis.slots.push( this.slot );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremoveSlot: function () {\r\n\r\n\t\tthis.slots.pop();\r\n\t\tthis.slot = this.slots[ this.slots.length - 1 ] || '';\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVertexCode: function ( code ) {\r\n\r\n\t\tthis.addCode( code, 'vertex' );\r\n\r\n\t},\r\n\r\n\taddFragmentCode: function ( code ) {\r\n\r\n\t\tthis.addCode( code, 'fragment' );\r\n\r\n\t},\r\n\r\n\taddCode: function ( code, shader ) {\r\n\r\n\t\tthis.code[ shader || this.shader ] += code + '\\n';\r\n\r\n\t},\r\n\r\n\taddVertexNodeCode: function ( code ) {\r\n\r\n\t\tthis.addNodeCode( code, 'vertex' );\r\n\r\n\t},\r\n\r\n\taddFragmentNodeCode: function ( code ) {\r\n\r\n\t\tthis.addNodeCode( code, 'fragment' );\r\n\r\n\t},\r\n\r\n\taddNodeCode: function ( code, shader ) {\r\n\r\n\t\tthis.nodeCode[ shader || this.shader ] += code + '\\n';\r\n\r\n\t},\r\n\r\n\tclearNodeCode: function ( shader ) {\r\n\r\n\t\tshader = shader || this.shader;\r\n\r\n\t\tvar code = this.nodeCode[ shader ];\r\n\r\n\t\tthis.nodeCode[ shader ] = '';\r\n\r\n\t\treturn code;\r\n\r\n\t},\r\n\r\n\tclearVertexNodeCode: function ( ) {\r\n\r\n\t\treturn this.clearNodeCode( 'vertex' );\r\n\r\n\t},\r\n\r\n\tclearFragmentNodeCode: function ( ) {\r\n\r\n\t\treturn this.clearNodeCode( 'fragment' );\r\n\r\n\t},\r\n\r\n\taddVertexFinalCode: function ( code ) {\r\n\r\n\t\tthis.addFinalCode( code, 'vertex' );\r\n\r\n\t},\r\n\r\n\taddFragmentFinalCode: function ( code ) {\r\n\r\n\t\tthis.addFinalCode( code, 'fragment' );\r\n\r\n\t},\r\n\r\n\taddFinalCode: function ( code, shader ) {\r\n\r\n\t\tthis.finalCode[ shader || this.shader ] += code + '\\n';\r\n\r\n\t},\r\n\r\n\taddVertexParsCode: function ( code ) {\r\n\r\n\t\tthis.addParsCode( code, 'vertex' );\r\n\r\n\t},\r\n\r\n\taddFragmentParsCode: function ( code ) {\r\n\r\n\t\tthis.addParsCode( code, 'fragment' );\r\n\r\n\t},\r\n\r\n\taddParsCode: function ( code, shader ) {\r\n\r\n\t\tthis.parsCode[ shader || this.shader ] += code + '\\n';\r\n\r\n\t},\r\n\r\n\taddVaryCode: function ( code ) {\r\n\r\n\t\tthis.addVertexParsCode( code );\r\n\t\tthis.addFragmentParsCode( code );\r\n\r\n\t},\r\n\r\n\tisCache: function ( name ) {\r\n\r\n\t\treturn this.caches.indexOf( name ) !== - 1;\r\n\r\n\t},\r\n\r\n\tisSlot: function ( name ) {\r\n\r\n\t\treturn this.slots.indexOf( name ) !== - 1;\r\n\r\n\t},\r\n\r\n\tdefine: function ( name, value ) {\r\n\r\n\t\tthis.defines[ name ] = value === undefined ? 1 : value;\r\n\r\n\t},\r\n\r\n\tisDefined: function ( name ) {\r\n\r\n\t\treturn this.defines[ name ] !== undefined;\r\n\r\n\t},\r\n\r\n\tgetVar: function ( uuid, type, ns, shader ) {\r\n\r\n\t\tshader = shader || 'varying';\r\n\r\n\t\tvar vars = this.getVars( shader ),\r\n\t\t\tdata = vars[ uuid ];\r\n\r\n\t\tif ( ! data ) {\r\n\r\n\t\t\tvar index = vars.length,\r\n\t\t\t\tname = ns ? ns : 'nVv' + index;\r\n\r\n\t\t\tdata = { name: name, type: type };\r\n\r\n\t\t\tvars.push( data );\r\n\t\t\tvars[ uuid ] = data;\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tgetTempVar: function ( uuid, type, ns ) {\r\n\r\n\t\treturn this.getVar( uuid, type, ns, this.shader );\r\n\r\n\t},\r\n\r\n\tgetAttribute: function ( name, type ) {\r\n\r\n\t\tif ( ! this.attributes[ name ] ) {\r\n\r\n\t\t\tvar varying = this.getVar( name, type );\r\n\r\n\t\t\tthis.addVertexParsCode( 'attribute ' + type + ' ' + name + ';' );\r\n\t\t\tthis.addVertexFinalCode( varying.name + ' = ' + name + ';' );\r\n\r\n\t\t\tthis.attributes[ name ] = { varying: varying, name: name, type: type };\r\n\r\n\t\t}\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t},\r\n\r\n\tgetCode: function ( shader ) {\r\n\r\n\t\treturn [\r\n\t\t\tthis.prefixCode,\r\n\t\t\tthis.parsCode[ shader ],\r\n\t\t\tthis.getVarListCode( this.getVars( 'varying' ), 'varying' ),\r\n\t\t\tthis.getVarListCode( this.inputs.uniforms[ shader ], 'uniform' ),\r\n\t\t\tthis.getIncludesCode( 'consts', shader ),\r\n\t\t\tthis.getIncludesCode( 'structs', shader ),\r\n\t\t\tthis.getIncludesCode( 'functions', shader ),\r\n\t\t\t'void main() {',\r\n\t\t\tthis.getVarListCode( this.getVars( shader ) ),\r\n\t\t\tthis.code[ shader ],\r\n\t\t\tthis.resultCode[ shader ],\r\n\t\t\tthis.finalCode[ shader ],\r\n\t\t\t'}'\r\n\t\t].join( \"\\n\" );\r\n\r\n\t},\r\n\r\n\tgetVarListCode: function ( vars, prefix ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tprefix = prefix || '';\r\n\r\n\t\tvar code = '';\r\n\r\n\t\tfor ( var i = 0, l = vars.length; i < l; ++ i ) {\r\n\r\n\t\t\tvar nVar = vars[ i ],\r\n\t\t\t\ttype = nVar.type,\r\n\t\t\t\tname = nVar.name;\r\n\r\n\t\t\tvar formatType = this$1.getFormatByType( type );\r\n\r\n\t\t\tif ( formatType === undefined ) {\r\n\r\n\t\t\t\tthrow new Error( \"Node pars \" + formatType + \" not found.\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcode += prefix + ' ' + formatType + ' ' + name + ';\\n';\r\n\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\r\n\t},\r\n\r\n\tgetVars: function ( shader ) {\r\n\r\n\t\treturn this.inputs.vars[ shader || this.shader ];\r\n\r\n\t},\r\n\r\n\tgetNodeData: function ( node ) {\r\n\r\n\t\tvar uuid = node.isNode ? node.uuid : node;\r\n\r\n\t\treturn this.nodeData[ uuid ] = this.nodeData[ uuid ] || {};\r\n\r\n\t},\r\n\r\n\tcreateUniform: function ( shader, type, node, ns, needsUpdate ) {\r\n\r\n\t\tvar uniforms = this.inputs.uniforms,\r\n\t\t\tindex = uniforms.list.length;\r\n\r\n\t\tvar uniform = new NodeUniform( {\r\n\t\t\ttype: type,\r\n\t\t\tname: ns ? ns : 'nVu' + index,\r\n\t\t\tnode: node,\r\n\t\t\tneedsUpdate: needsUpdate\r\n\t\t} );\r\n\r\n\t\tuniforms.list.push( uniform );\r\n\r\n\t\tuniforms[ shader ].push( uniform );\r\n\t\tuniforms[ shader ][ uniform.name ] = uniform;\r\n\r\n\t\tthis.uniforms[ uniform.name ] = uniform;\r\n\r\n\t\treturn uniform;\r\n\r\n\t},\r\n\r\n\tcreateVertexUniform: function ( type, node, ns, needsUpdate ) {\r\n\r\n\t\treturn this.createUniform( 'vertex', type, node, ns, needsUpdate );\r\n\r\n\t},\r\n\r\n\tcreateFragmentUniform: function ( type, node, ns, needsUpdate ) {\r\n\r\n\t\treturn this.createUniform( 'fragment', type, node, ns, needsUpdate );\r\n\r\n\t},\r\n\r\n\tinclude: function ( node, parent, source ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar includesStruct;\r\n\r\n\t\tnode = typeof node === 'string' ? NodeLib.get( node ) : node;\r\n\r\n\t\tif ( this.context.include === false ) {\r\n\r\n\t\t\treturn node.name;\r\n\r\n\t\t}\r\n\r\n\t\tif ( node instanceof FunctionNode ) {\r\n\r\n\t\t\tincludesStruct = this.includes.functions;\r\n\r\n\t\t} else if ( node instanceof ConstNode ) {\r\n\r\n\t\t\tincludesStruct = this.includes.consts;\r\n\r\n\t\t} else if ( node instanceof StructNode ) {\r\n\r\n\t\t\tincludesStruct = this.includes.structs;\r\n\r\n\t\t}\r\n\r\n\t\tvar includes = includesStruct[ this.shader ] = includesStruct[ this.shader ] || [];\r\n\r\n\t\tif ( node ) {\r\n\r\n\t\t\tvar included = includes[ node.name ];\r\n\r\n\t\t\tif ( ! included ) {\r\n\r\n\t\t\t\tincluded = includes[ node.name ] = {\r\n\t\t\t\t\tnode: node,\r\n\t\t\t\t\tdeps: []\r\n\t\t\t\t};\r\n\r\n\t\t\t\tincludes.push( included );\r\n\r\n\t\t\t\tincluded.src = node.build( this, 'source' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node instanceof FunctionNode && parent && includes[ parent.name ] && includes[ parent.name ].deps.indexOf( node ) == - 1 ) {\r\n\r\n\t\t\t\tincludes[ parent.name ].deps.push( node );\r\n\r\n\t\t\t\tif ( node.includes && node.includes.length ) {\r\n\r\n\t\t\t\t\tvar i = 0;\r\n\r\n\t\t\t\t\tdo {\r\n\r\n\t\t\t\t\t\tthis$1.include( node.includes[ i ++ ], parent );\r\n\r\n\t\t\t\t\t} while ( i < node.includes.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( source ) {\r\n\r\n\t\t\t\tincluded.src = source;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn node.name;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthrow new Error( \"Include not found.\" );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcolorToVectorProperties: function ( color ) {\r\n\r\n\t\treturn color.replace( 'r', 'x' ).replace( 'g', 'y' ).replace( 'b', 'z' ).replace( 'a', 'w' );\r\n\r\n\t},\r\n\r\n\tcolorToVector: function ( color ) {\r\n\r\n\t\treturn color.replace( /c/g, 'v3' );\r\n\r\n\t},\r\n\r\n\tgetIncludes: function ( type, shader ) {\r\n\r\n\t\treturn this.includes[ type ][ shader || this.shader ];\r\n\r\n\t},\r\n\r\n\tgetIncludesCode: function () {\r\n\r\n\t\tfunction sortByPosition( a, b ) {\r\n\r\n\t\t\treturn a.deps.length - b.deps.length;\r\n\r\n\t\t}\r\n\r\n\t\treturn function getIncludesCode( type, shader ) {\r\n\r\n\t\t\tvar includes = this.getIncludes( type, shader );\r\n\r\n\t\t\tif ( ! includes ) { return ''; }\r\n\r\n\t\t\tvar code = '',\r\n\t\t\t\tincludes = includes.sort( sortByPosition );\r\n\r\n\t\t\tfor ( var i = 0; i < includes.length; i ++ ) {\r\n\r\n\t\t\t\tif ( includes[ i ].src ) { code += includes[ i ].src + '\\n'; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn code;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetConstructorFromLength: function ( len ) {\r\n\r\n\t\treturn constructors[ len - 1 ];\r\n\r\n\t},\r\n\r\n\tisTypeMatrix: function ( format ) {\r\n\r\n\t\treturn /^m/.test( format );\r\n\r\n\t},\r\n\r\n\tgetTypeLength: function ( type ) {\r\n\r\n\t\tif ( type === 'f' ) { return 1; }\r\n\r\n\t\treturn parseInt( this.colorToVector( type ).substr( 1 ) );\r\n\r\n\t},\r\n\r\n\tgetTypeFromLength: function ( len ) {\r\n\r\n\t\tif ( len === 1 ) { return 'f'; }\r\n\r\n\t\treturn 'v' + len;\r\n\r\n\t},\r\n\r\n\tfindNode: function () {\n\t\tvar arguments$1 = arguments;\n\r\n\r\n\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\tvar nodeCandidate = arguments$1[ i ];\r\n\r\n\t\t\tif ( nodeCandidate !== undefined && nodeCandidate.isNode ) {\r\n\r\n\t\t\t\treturn nodeCandidate;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tresolve: function () {\n\t\tvar arguments$1 = arguments;\n\r\n\r\n\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\tvar nodeCandidate = arguments$1[ i ];\r\n\r\n\t\t\tif ( nodeCandidate !== undefined ) {\r\n\r\n\t\t\t\tif ( nodeCandidate.isNode ) {\r\n\r\n\t\t\t\t\treturn nodeCandidate;\r\n\r\n\t\t\t\t} else if ( nodeCandidate.isTexture ) {\r\n\r\n\t\t\t\t\tswitch ( nodeCandidate.mapping ) {\r\n\r\n\t\t\t\t\t\tcase CubeReflectionMapping:\r\n\t\t\t\t\t\tcase CubeRefractionMapping:\r\n\r\n\t\t\t\t\t\t\treturn new CubeTextureNode( nodeCandidate );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase CubeUVReflectionMapping:\r\n\t\t\t\t\t\tcase CubeUVRefractionMapping:\r\n\r\n\t\t\t\t\t\t\treturn new TextureCubeNode( new TextureNode( nodeCandidate ) );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\treturn new TextureNode( nodeCandidate );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( nodeCandidate.isVector2 ) {\r\n\r\n\t\t\t\t\treturn new Vector2Node( nodeCandidate );\r\n\r\n\t\t\t\t} else if ( nodeCandidate.isVector3 ) {\r\n\r\n\t\t\t\t\treturn new Vector3Node( nodeCandidate );\r\n\r\n\t\t\t\t} else if ( nodeCandidate.isVector4 ) {\r\n\r\n\t\t\t\t\treturn new Vector4Node( nodeCandidate );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tformat: function ( code, from, to ) {\r\n\r\n\t\tvar typeToType = this.colorToVector( to + ' <- ' + from );\r\n\r\n\t\tswitch ( typeToType ) {\r\n\r\n\t\t\tcase 'f <- v2' : return code + '.x';\r\n\t\t\tcase 'f <- v3' : return code + '.x';\r\n\t\t\tcase 'f <- v4' : return code + '.x';\r\n\t\t\tcase 'f <- i' : return 'float( ' + code + ' )';\r\n\r\n\t\t\tcase 'v2 <- f' : return 'vec2( ' + code + ' )';\r\n\t\t\tcase 'v2 <- v3': return code + '.xy';\r\n\t\t\tcase 'v2 <- v4': return code + '.xy';\r\n\t\t\tcase 'v2 <- i' : return 'vec2( float( ' + code + ' ) )';\r\n\r\n\t\t\tcase 'v3 <- f' : return 'vec3( ' + code + ' )';\r\n\t\t\tcase 'v3 <- v2': return 'vec3( ' + code + ', 0.0 )';\r\n\t\t\tcase 'v3 <- v4': return code + '.xyz';\r\n\t\t\tcase 'v3 <- i' : return 'vec2( float( ' + code + ' ) )';\r\n\r\n\t\t\tcase 'v4 <- f' : return 'vec4( ' + code + ' )';\r\n\t\t\tcase 'v4 <- v2': return 'vec4( ' + code + ', 0.0, 1.0 )';\r\n\t\t\tcase 'v4 <- v3': return 'vec4( ' + code + ', 1.0 )';\r\n\t\t\tcase 'v4 <- i' : return 'vec4( float( ' + code + ' ) )';\r\n\r\n\t\t\tcase 'i <- f' : return 'int( ' + code + ' )';\r\n\t\t\tcase 'i <- v2' : return 'int( ' + code + '.x )';\r\n\t\t\tcase 'i <- v3' : return 'int( ' + code + '.x )';\r\n\t\t\tcase 'i <- v4' : return 'int( ' + code + '.x )';\r\n\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\r\n\t},\r\n\r\n\tgetTypeByFormat: function ( format ) {\r\n\r\n\t\treturn convertFormatToType[ format ] || format;\r\n\r\n\t},\r\n\r\n\tgetFormatByType: function ( type ) {\r\n\r\n\t\treturn convertTypeToFormat[ type ] || type;\r\n\r\n\t},\r\n\r\n\tgetUuid: function ( uuid, useCache ) {\r\n\r\n\t\tuseCache = useCache !== undefined ? useCache : true;\r\n\r\n\t\tif ( useCache && this.cache ) { uuid = this.cache + '-' + uuid; }\r\n\r\n\t\treturn uuid;\r\n\r\n\t},\r\n\r\n\tgetElementByIndex: function ( index ) {\r\n\r\n\t\treturn elements[ index ];\r\n\r\n\t},\r\n\r\n\tgetIndexByElement: function ( elm ) {\r\n\r\n\t\treturn elements.indexOf( elm );\r\n\r\n\t},\r\n\r\n\tisShader: function ( shader ) {\r\n\r\n\t\treturn this.shader === shader;\r\n\r\n\t},\r\n\r\n\tsetShader: function ( shader ) {\r\n\r\n\t\tthis.shader = shader;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmergeDefines: function ( defines ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var name in defines ) {\r\n\r\n\t\t\tthis$1.defines[ name ] = defines[ name ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this.defines;\r\n\r\n\t},\r\n\r\n\tmergeUniform: function ( uniforms ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var name in uniforms ) {\r\n\r\n\t\t\tthis$1.uniforms[ name ] = uniforms[ name ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this.uniforms;\r\n\r\n\t},\r\n\r\n\tgetTextureEncodingFromMap: function ( map, gammaOverrideLinear ) {\r\n\r\n\t\tgammaOverrideLinear = gammaOverrideLinear !== undefined ? gammaOverrideLinear : this.context.gamma && ( this.renderer ? this.renderer.gammaInput : false );\r\n\r\n\t\tvar encoding;\r\n\r\n\t\tif ( ! map ) {\r\n\r\n\t\t\tencoding = LinearEncoding;\r\n\r\n\t\t} else if ( map.isTexture ) {\r\n\r\n\t\t\tencoding = map.encoding;\r\n\r\n\t\t} else if ( map.isWebGLRenderTarget ) {\r\n\r\n\t\t\tconsole.warn( \"WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\r\n\t\t\tencoding = map.texture.encoding;\r\n\r\n\t\t}\r\n\r\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\r\n\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\r\n\r\n\t\t\tencoding = GammaEncoding;\r\n\r\n\t\t}\r\n\r\n\t\treturn encoding;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ColorNode( color, g, b ) {\r\n\r\n\tInputNode$1.call( this, 'c' );\r\n\r\n\tthis.value = color instanceof Color ? color : new Color( color || 0, g, b );\r\n\r\n}\r\n\r\nColorNode.prototype = Object.create( InputNode$1.prototype );\r\nColorNode.prototype.constructor = ColorNode;\r\nColorNode.prototype.nodeType = \"Color\";\r\n\r\nNodeUtils.addShortcuts( ColorNode.prototype, 'value', [ 'r', 'g', 'b' ] );\r\n\r\nColorNode.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {\r\n\r\n\treturn builder.format( \"vec3( \" + this.r + \", \" + this.g + \", \" + this.b + \" )\", type, output );\r\n\r\n};\r\n\r\nColorNode.prototype.copy = function ( source ) {\r\n\r\n\tInputNode$1.prototype.copy.call( this, source );\r\n\r\n\tthis.value.copy( source );\r\n\r\n};\r\n\r\nColorNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.r = this.r;\r\n\t\tdata.g = this.g;\r\n\t\tdata.b = this.b;\r\n\r\n\t\tif ( this.readonly === true ) { data.readonly = true; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction RawNode( value ) {\r\n\r\n\tNode.call( this, 'v4' );\r\n\r\n\tthis.value = value;\r\n\r\n}\r\n\r\nRawNode.prototype = Object.create( Node.prototype );\r\nRawNode.prototype.constructor = RawNode;\r\nRawNode.prototype.nodeType = \"Raw\";\r\n\r\nRawNode.prototype.generate = function ( builder ) {\r\n\r\n\tvar data = this.value.parseAndBuildCode( builder, this.type ),\r\n\t\tcode = data.code + '\\n';\r\n\r\n\tif ( builder.isShader( 'vertex' ) ) {\r\n\r\n\t\tcode += 'gl_Position = ' + data.result + ';';\r\n\r\n\t} else {\r\n\r\n\t\tcode += 'gl_FragColor = ' + data.result + ';';\r\n\r\n\t}\r\n\r\n\treturn code;\r\n\r\n};\r\n\r\nRawNode.prototype.copy = function ( source ) {\r\n\r\n\tNode.prototype.copy.call( this, source );\r\n\r\n\tthis.value = source.value;\r\n\r\n};\r\n\r\nRawNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.value = this.value.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction NodeMaterial( vertex, fragment ) {\r\n\r\n\tShaderMaterial.call( this );\r\n\r\n\tthis.vertex = vertex || new RawNode( new PositionNode( PositionNode.PROJECTION ) );\r\n\tthis.fragment = fragment || new RawNode( new ColorNode( 0xFF0000 ) );\r\n\r\n\tthis.updaters = [];\r\n\r\n}\r\n\r\nNodeMaterial.prototype = Object.create( ShaderMaterial.prototype );\r\nNodeMaterial.prototype.constructor = NodeMaterial;\r\nNodeMaterial.prototype.type = \"NodeMaterial\";\r\n\r\nNodeMaterial.prototype.isNodeMaterial = true;\r\n\r\nObject.defineProperties( NodeMaterial.prototype, {\r\n\r\n\tproperties: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.fragment.properties;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nNodeMaterial.prototype.updateFrame = function ( frame ) {\n\tvar this$1 = this;\n\r\n\r\n\tfor ( var i = 0; i < this.updaters.length; ++ i ) {\r\n\r\n\t\tframe.updateNode( this$1.updaters[ i ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nNodeMaterial.prototype.onBeforeCompile = function ( shader, renderer ) {\r\n\r\n\tif ( this.needsUpdate ) {\r\n\r\n\t\tthis.build( { renderer: renderer } );\r\n\r\n\t\tshader.uniforms = this.uniforms;\r\n\t\tshader.vertexShader = this.vertexShader;\r\n\t\tshader.fragmentShader = this.fragmentShader;\r\n\r\n\t}\r\n\r\n};\r\n\r\nNodeMaterial.prototype.build = function ( params ) {\r\n\r\n\tparams = params || {};\r\n\r\n\tvar builder = params.builder || new NodeBuilder();\r\n\r\n\tbuilder.setMaterial( this, params.renderer );\r\n\tbuilder.build( this.vertex, this.fragment );\r\n\r\n\tthis.vertexShader = builder.getCode( 'vertex' );\r\n\tthis.fragmentShader = builder.getCode( 'fragment' );\r\n\r\n\tthis.defines = builder.defines;\r\n\tthis.uniforms = builder.uniforms;\r\n\tthis.extensions = builder.extensions;\r\n\tthis.updaters = builder.updaters;\r\n\r\n\tthis.fog = builder.requires.fog;\r\n\tthis.lights = builder.requires.lights;\r\n\r\n\tthis.transparent = builder.requires.transparent || this.blending > NormalBlending;\r\n\r\n\tthis.needsUpdate = false;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nNodeMaterial.prototype.copy = function ( source ) {\n\tvar this$1 = this;\n\r\n\r\n\tvar uuid = this.uuid;\r\n\r\n\tfor ( var name in source ) {\r\n\r\n\t\tthis$1[ name ] = source[ name ];\r\n\r\n\t}\r\n\r\n\tthis.uuid = uuid;\r\n\r\n\tif ( source.userData !== undefined ) {\r\n\r\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\nNodeMaterial.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\tif ( isRootObject ) {\r\n\r\n\t\tmeta = {\r\n\t\t\tnodes: {}\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tif ( meta && ! meta.materials ) { meta.materials = {}; }\r\n\r\n\tif ( ! meta.materials[ this.uuid ] ) {\r\n\r\n\t\tvar data = {};\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\r\n\t\tmeta.materials[ data.uuid ] = data;\r\n\r\n\t\tif ( this.name !== \"\" ) { data.name = this.name; }\r\n\r\n\t\tif ( this.size !== undefined ) { data.size = this.size; }\r\n\t\tif ( this.sizeAttenuation !== undefined ) { data.sizeAttenuation = this.sizeAttenuation; }\r\n\r\n\t\tif ( this.blending !== NormalBlending ) { data.blending = this.blending; }\r\n\t\tif ( this.flatShading === true ) { data.flatShading = this.flatShading; }\r\n\t\tif ( this.side !== FrontSide ) { data.side = this.side; }\r\n\t\tif ( this.vertexColors !== NoColors ) { data.vertexColors = this.vertexColors; }\r\n\r\n\t\tif ( this.depthFunc !== LessEqualDepth ) { data.depthFunc = this.depthFunc; }\r\n\t\tif ( this.depthTest === false ) { data.depthTest = this.depthTest; }\r\n\t\tif ( this.depthWrite === false ) { data.depthWrite = this.depthWrite; }\r\n\r\n\t\tif ( this.linewidth !== 1 ) { data.linewidth = this.linewidth; }\r\n\t\tif ( this.dashSize !== undefined ) { data.dashSize = this.dashSize; }\r\n\t\tif ( this.gapSize !== undefined ) { data.gapSize = this.gapSize; }\r\n\t\tif ( this.scale !== undefined ) { data.scale = this.scale; }\r\n\r\n\t\tif ( this.dithering === true ) { data.dithering = true; }\r\n\r\n\t\tif ( this.wireframe === true ) { data.wireframe = this.wireframe; }\r\n\t\tif ( this.wireframeLinewidth > 1 ) { data.wireframeLinewidth = this.wireframeLinewidth; }\r\n\t\tif ( this.wireframeLinecap !== 'round' ) { data.wireframeLinecap = this.wireframeLinecap; }\r\n\t\tif ( this.wireframeLinejoin !== 'round' ) { data.wireframeLinejoin = this.wireframeLinejoin; }\r\n\r\n\t\tif ( this.alphaTest > 0 ) { data.alphaTest = this.alphaTest; }\r\n\t\tif ( this.premultipliedAlpha === true ) { data.premultipliedAlpha = this.premultipliedAlpha; }\r\n\r\n\t\tif ( this.morphTargets === true ) { data.morphTargets = true; }\r\n\t\tif ( this.skinning === true ) { data.skinning = true; }\r\n\r\n\t\tif ( this.visible === false ) { data.visible = false; }\r\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }\r\n\r\n\t\tdata.fog = this.fog;\r\n\t\tdata.lights = this.lights;\r\n\r\n\t\tdata.vertex = this.vertex.toJSON( meta ).uuid;\r\n\t\tdata.fragment = this.fragment.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\tmeta.material = this.uuid;\r\n\r\n\treturn meta;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Vector2Node( x, y ) {\r\n\r\n\tInputNode$1.call( this, 'v2' );\r\n\r\n\tthis.value = x instanceof Vector2 ? x : new Vector2( x, y );\r\n\r\n}\r\n\r\nVector2Node.prototype = Object.create( InputNode$1.prototype );\r\nVector2Node.prototype.constructor = Vector2Node;\r\nVector2Node.prototype.nodeType = \"Vector2\";\r\n\r\nNodeUtils.addShortcuts( Vector2Node.prototype, 'value', [ 'x', 'y' ] );\r\n\r\nVector2Node.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {\r\n\r\n\treturn builder.format( \"vec2( \" + this.x + \", \" + this.y + \" )\", type, output );\r\n\r\n};\r\n\r\nVector2Node.prototype.copy = function ( source ) {\r\n\r\n\tInputNode$1.prototype.copy.call( this, source );\r\n\r\n\tthis.value.copy( source );\r\n\r\n};\r\n\r\nVector2Node.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.x = this.x;\r\n\t\tdata.y = this.y;\r\n\r\n\t\tif ( this.readonly === true ) { data.readonly = true; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ResolutionNode() {\r\n\r\n\tVector2Node.call( this );\r\n\r\n}\r\n\r\nResolutionNode.prototype = Object.create( Vector2Node.prototype );\r\nResolutionNode.prototype.constructor = ResolutionNode;\r\nResolutionNode.prototype.nodeType = \"Resolution\";\r\n\r\nResolutionNode.prototype.updateFrame = function ( frame ) {\r\n\r\n\tif ( frame.renderer ) {\r\n\r\n\t\tvar size = frame.renderer.getSize(),\r\n\t\t\tpixelRatio = frame.renderer.getPixelRatio();\r\n\r\n\t\tthis.x = size.width * pixelRatio;\r\n\t\tthis.y = size.height * pixelRatio;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"ResolutionNode need a renderer in NodeFrame\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nResolutionNode.prototype.copy = function ( source ) {\r\n\r\n\tVector2Node.prototype.copy.call( this, source );\r\n\r\n\tthis.renderer = source.renderer;\r\n\r\n};\r\n\r\nResolutionNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.renderer = this.renderer.uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ScreenUVNode( resolution ) {\r\n\r\n\tTempNode.call( this, 'v2' );\r\n\r\n\tthis.resolution = resolution || new ResolutionNode();\r\n\r\n}\r\n\r\nScreenUVNode.prototype = Object.create( TempNode.prototype );\r\nScreenUVNode.prototype.constructor = ScreenUVNode;\r\nScreenUVNode.prototype.nodeType = \"ScreenUV\";\r\n\r\nScreenUVNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar result;\r\n\r\n\tif ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\tresult = '( gl_FragCoord.xy / ' + this.resolution.build( builder, 'v2' ) + ')';\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"ScreenUVNode is not compatible with \" + builder.shader + \" shader.\" );\r\n\r\n\t\tresult = 'vec2( 0.0 )';\r\n\r\n\t}\r\n\r\n\treturn builder.format( result, this.getType( builder ), output );\r\n\r\n};\r\n\r\nScreenUVNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.resolution = source.resolution;\r\n\r\n};\r\n\r\nScreenUVNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.resolution = this.resolution.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MaxMIPLevelNode( texture ) {\r\n\r\n\tFloatNode.call( this );\r\n\r\n\tthis.texture = texture;\r\n\r\n\tthis.maxMIPLevel = 0;\r\n\r\n}\r\n\r\nMaxMIPLevelNode.prototype = Object.create( FloatNode.prototype );\r\nMaxMIPLevelNode.prototype.constructor = MaxMIPLevelNode;\r\nMaxMIPLevelNode.prototype.nodeType = \"MaxMIPLevel\";\r\n\r\nObject.defineProperties( MaxMIPLevelNode.prototype, {\r\n\r\n\tvalue: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\tif ( this.maxMIPLevel === 0 ) {\r\n\r\n\t\t\t\tvar image = this.texture.value.image ? this.texture.value.image[ 0 ] : undefined;\r\n\r\n\t\t\t\tthis.maxMIPLevel = image !== undefined ? Math.log( Math.max( image.width, image.height ) ) * Math.LOG2E : 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.maxMIPLevel;\r\n\r\n\t\t},\r\n\r\n\t\tset: function () { }\r\n\r\n\t}\r\n\r\n} );\r\n\r\nMaxMIPLevelNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.texture = this.texture.uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction RoughnessToBlinnExponentNode( texture ) {\r\n\r\n\tTempNode.call( this, 'f' );\r\n\r\n\tthis.texture = texture;\r\n\r\n\tthis.maxMIPLevel = new MaxMIPLevelNode( texture );\r\n\tthis.blinnShininessExponent = new BlinnShininessExponentNode();\r\n\r\n}\r\n\r\nRoughnessToBlinnExponentNode.Nodes = ( function () {\r\n\r\n\tvar getSpecularMIPLevel = new FunctionNode( [\r\n\t\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\r\n\t\t\"float getSpecularMIPLevel( const in float blinnShininessExponent, const in float maxMIPLevelScalar ) {\",\r\n\r\n\t\t//\tfloat envMapWidth = pow( 2.0, maxMIPLevelScalar );\r\n\t\t//\tfloat desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\r\n\t\t\"\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\",\r\n\r\n\t\t// clamp to allowable LOD ranges.\r\n\t\t\"\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\treturn {\r\n\t\tgetSpecularMIPLevel: getSpecularMIPLevel\r\n\t};\r\n\r\n} )();\r\n\r\nRoughnessToBlinnExponentNode.prototype = Object.create( TempNode.prototype );\r\nRoughnessToBlinnExponentNode.prototype.constructor = RoughnessToBlinnExponentNode;\r\nRoughnessToBlinnExponentNode.prototype.nodeType = \"RoughnessToBlinnExponent\";\r\n\r\nRoughnessToBlinnExponentNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\tthis.maxMIPLevel.texture = this.texture;\r\n\r\n\t\tvar getSpecularMIPLevel = builder.include( RoughnessToBlinnExponentNode.Nodes.getSpecularMIPLevel );\r\n\r\n\t\treturn builder.format( getSpecularMIPLevel + '( ' + this.blinnShininessExponent.build( builder, 'f' ) + ', ' + this.maxMIPLevel.build( builder, 'f' ) + ' )', this.type, output );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"RoughnessToBlinnExponentNode is not compatible with \" + builder.shader + \" shader.\" );\r\n\r\n\t\treturn builder.format( '0.0', this.type, output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nRoughnessToBlinnExponentNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.texture = source.texture;\r\n\r\n};\r\n\r\nRoughnessToBlinnExponentNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.texture = this.texture;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AttributeNode( name, type ) {\r\n\r\n\tNode.call( this, type );\r\n\r\n\tthis.name = name;\r\n\r\n}\r\n\r\nAttributeNode.prototype = Object.create( Node.prototype );\r\nAttributeNode.prototype.constructor = AttributeNode;\r\nAttributeNode.prototype.nodeType = \"Attribute\";\r\n\r\nAttributeNode.prototype.getAttributeType = function ( builder ) {\r\n\r\n\treturn typeof this.type === 'number' ? builder.getConstructorFromLength( this.type ) : this.type;\r\n\r\n};\r\n\r\nAttributeNode.prototype.getType = function ( builder ) {\r\n\r\n\tvar type = this.getAttributeType( builder );\r\n\r\n\treturn builder.getTypeByFormat( type );\r\n\r\n};\r\n\r\nAttributeNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar type = this.getAttributeType( builder );\r\n\r\n\tvar attribute = builder.getAttribute( this.name, type ),\r\n\t\tname = builder.isShader( 'vertex' ) ? this.name : attribute.varying.name;\r\n\r\n\tconsole.log( attribute );\r\n\r\n\treturn builder.format( name, this.getType( builder ), output );\r\n\r\n};\r\n\r\nAttributeNode.prototype.copy = function ( source ) {\r\n\r\n\tNode.prototype.copy.call( this, source );\r\n\r\n\tthis.type = source.type;\r\n\r\n};\r\n\r\nAttributeNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.type = this.type;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ExpressionNode( src, type, keywords, extensions, includes ) {\r\n\r\n\tFunctionNode.call( this, src, includes, extensions, keywords, type );\r\n\r\n}\r\n\r\nExpressionNode.prototype = Object.create( FunctionNode.prototype );\r\nExpressionNode.prototype.constructor = ExpressionNode;\r\nExpressionNode.prototype.nodeType = \"Expression\";\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction FunctionCallNode( func, inputs ) {\r\n\r\n\tTempNode.call( this );\r\n\r\n\tthis.setFunction( func, inputs );\r\n\r\n}\r\n\r\nFunctionCallNode.prototype = Object.create( TempNode.prototype );\r\nFunctionCallNode.prototype.constructor = FunctionCallNode;\r\nFunctionCallNode.prototype.nodeType = \"FunctionCall\";\r\n\r\nFunctionCallNode.prototype.setFunction = function ( func, inputs ) {\r\n\r\n\tthis.value = func;\r\n\tthis.inputs = inputs || [];\r\n\r\n};\r\n\r\nFunctionCallNode.prototype.getFunction = function () {\r\n\r\n\treturn this.value;\r\n\r\n};\r\n\r\nFunctionCallNode.prototype.getType = function ( builder ) {\r\n\r\n\treturn this.value.getType( builder );\r\n\r\n};\r\n\r\nFunctionCallNode.prototype.generate = function ( builder, output ) {\n\tvar this$1 = this;\n\r\n\r\n\tvar type = this.getType( builder ),\r\n\t\tfunc = this.value;\r\n\r\n\tvar code = func.build( builder, output ) + '( ',\r\n\t\tparams = [];\r\n\r\n\tfor ( var i = 0; i < func.inputs.length; i ++ ) {\r\n\r\n\t\tvar inpt = func.inputs[ i ],\r\n\t\t\tparam = this$1.inputs[ i ] || this$1.inputs[ inpt.name ];\r\n\r\n\t\tparams.push( param.build( builder, builder.getTypeByFormat( inpt.type ) ) );\r\n\r\n\t}\r\n\r\n\tcode += params.join( ', ' ) + ' )';\r\n\r\n\treturn builder.format( code, type, output );\r\n\r\n};\r\n\r\nFunctionCallNode.prototype.copy = function ( source ) {\n\tvar this$1 = this;\n\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tfor ( var prop in source.inputs ) {\r\n\r\n\t\tthis$1.inputs[ prop ] = source.inputs[ prop ];\r\n\r\n\t}\r\n\r\n\tthis.value = source.value;\r\n\r\n};\r\n\r\nFunctionCallNode.prototype.toJSON = function ( meta ) {\n\tvar this$1 = this;\n\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tvar func = this.value;\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.value = this.value.toJSON( meta ).uuid;\r\n\r\n\t\tif ( func.inputs.length ) {\r\n\r\n\t\t\tdata.inputs = {};\r\n\r\n\t\t\tfor ( var i = 0; i < func.inputs.length; i ++ ) {\r\n\r\n\t\t\t\tvar inpt = func.inputs[ i ],\r\n\t\t\t\t\tnode = this$1.inputs[ i ] || this$1.inputs[ inpt.name ];\r\n\r\n\t\t\t\tdata.inputs[ inpt.name ] = node.toJSON( meta ).uuid;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction NodeFrame( time ) {\r\n\r\n\tthis.time = time !== undefined ? time : 0;\r\n\r\n\tthis.id = 0;\r\n\r\n}\r\n\r\nNodeFrame.prototype = {\r\n\r\n\tconstructor: NodeFrame,\r\n\r\n\tupdate: function ( delta ) {\r\n\r\n\t\t++ this.id;\r\n\r\n\t\tthis.time += delta;\r\n\t\tthis.delta = delta;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRenderer: function ( renderer ) {\r\n\r\n\t\tthis.renderer = renderer;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRenderTexture: function ( renderTexture ) {\r\n\r\n\t\tthis.renderTexture = renderTexture;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateNode: function ( node ) {\r\n\r\n\t\tif ( node.frameId === this.id ) { return this; }\r\n\r\n\t\tnode.updateFrame( this );\r\n\r\n\t\tnode.frameId = this.id;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction VarNode( type, value ) {\r\n\r\n\tNode.call( this, type );\r\n\r\n\tthis.value = value;\r\n\r\n}\r\n\r\nVarNode.prototype = Object.create( Node.prototype );\r\nVarNode.prototype.constructor = VarNode;\r\nVarNode.prototype.nodeType = \"Var\";\r\n\r\nVarNode.prototype.getType = function ( builder ) {\r\n\r\n\treturn builder.getTypeByFormat( this.type );\r\n\r\n};\r\n\r\nVarNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar varying = builder.getVar( this.uuid, this.type );\r\n\r\n\tif ( this.value && builder.isShader( 'vertex' ) ) {\r\n\r\n\t\tbuilder.addNodeCode( varying.name + ' = ' + this.value.build( builder, this.getType( builder ) ) + ';' );\r\n\r\n\t}\r\n\r\n\treturn builder.format( varying.name, this.getType( builder ), output );\r\n\r\n};\r\n\r\nVarNode.prototype.copy = function ( source ) {\r\n\r\n\tNode.prototype.copy.call( this, source );\r\n\r\n\tthis.type = source.type;\r\n\tthis.value = source.value;\r\n\r\n};\r\n\r\nVarNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.type = this.type;\r\n\r\n\t\tif ( this.value ) { data.value = this.value.toJSON( meta ).uuid; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction BlurNode( value, uv, radius, size ) {\r\n\r\n\tTempNode.call( this, 'v4' );\r\n\r\n\tthis.value = value;\r\n\tthis.uv = uv || new UVNode();\r\n\tthis.radius = new Vector2Node( 1, 1 );\r\n\r\n\tthis.size = size;\r\n\r\n\tthis.blurX = true;\r\n\tthis.blurY = true;\r\n\r\n\tthis.horizontal = new FloatNode( 1 / 64 );\r\n\tthis.vertical = new FloatNode( 1 / 64 );\r\n\r\n}\r\n\r\nBlurNode.Nodes = ( function () {\r\n\r\n\tvar blurX = new FunctionNode( [\r\n\t\t\"vec4 blurX( sampler2D texture, vec2 uv, float s ) {\",\r\n\t\t\"\tvec4 sum = vec4( 0.0 );\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x - 4.0 * s, uv.y ) ) * 0.051;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x - 3.0 * s, uv.y ) ) * 0.0918;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x - 2.0 * s, uv.y ) ) * 0.12245;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x - 1.0 * s, uv.y ) ) * 0.1531;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x, uv.y ) ) * 0.1633;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x + 1.0 * s, uv.y ) ) * 0.1531;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x + 2.0 * s, uv.y ) ) * 0.12245;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x + 3.0 * s, uv.y ) ) * 0.0918;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x + 4.0 * s, uv.y ) ) * 0.051;\",\r\n\t\t\"\treturn sum * .667;\",\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar blurY = new FunctionNode( [\r\n\t\t\"vec4 blurY( sampler2D texture, vec2 uv, float s ) {\",\r\n\t\t\"\tvec4 sum = vec4( 0.0 );\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x, uv.y - 4.0 * s ) ) * 0.051;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x, uv.y - 3.0 * s ) ) * 0.0918;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x, uv.y - 2.0 * s ) ) * 0.12245;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x, uv.y - 1.0 * s ) ) * 0.1531;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x, uv.y ) ) * 0.1633;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x, uv.y + 1.0 * s ) ) * 0.1531;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x, uv.y + 2.0 * s ) ) * 0.12245;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x, uv.y + 3.0 * s ) ) * 0.0918;\",\r\n\t\t\"\tsum += texture2D( texture, vec2( uv.x, uv.y + 4.0 * s ) ) * 0.051;\",\r\n\t\t\"\treturn sum * .667;\",\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\treturn {\r\n\t\tblurX: blurX,\r\n\t\tblurY: blurY\r\n\t};\r\n\r\n} )();\r\n\r\nBlurNode.prototype = Object.create( TempNode.prototype );\r\nBlurNode.prototype.constructor = BlurNode;\r\nBlurNode.prototype.nodeType = \"Blur\";\r\n\r\nBlurNode.prototype.updateFrame = function ( frame ) {\r\n\r\n\tif ( this.size ) {\r\n\r\n\t\tthis.horizontal.value = this.radius.x / this.size.x;\r\n\t\tthis.vertical.value = this.radius.y / this.size.y;\r\n\r\n\t} else if ( this.value.value && this.value.value.image ) {\r\n\r\n\t\tvar image = this.value.value.image;\r\n\r\n\t\tthis.horizontal.value = this.radius.x / image.width;\r\n\t\tthis.vertical.value = this.radius.y / image.height;\r\n\r\n\t}\r\n\r\n};\r\n\r\nBlurNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\tvar blurCode = [], code;\r\n\r\n\t\tvar blurX = builder.include( BlurNode.Nodes.blurX ),\r\n\t\t\tblurY = builder.include( BlurNode.Nodes.blurY );\r\n\r\n\t\tif ( this.blurX ) {\r\n\r\n\t\t\tblurCode.push( blurX + '( ' + this.value.build( builder, 'sampler2D' ) + ', ' + this.uv.build( builder, 'v2' ) + ', ' + this.horizontal.build( builder, 'f' ) + ' )' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.blurY ) {\r\n\r\n\t\t\tblurCode.push( blurY + '( ' + this.value.build( builder, 'sampler2D' ) + ', ' + this.uv.build( builder, 'v2' ) + ', ' + this.vertical.build( builder, 'f' ) + ' )' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( blurCode.length == 2 ) { code = '( ' + blurCode.join( ' + ' ) + ' / 2.0 )'; }\r\n\t\telse if ( blurCode.length ) { code = '( ' + blurCode[ 0 ] + ' )'; }\r\n\t\telse { code = 'vec4( 0.0 )'; }\r\n\r\n\t\treturn builder.format( code, this.getType( builder ), output );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"BlurNode is not compatible with \" + builder.shader + \" shader.\" );\r\n\r\n\t\treturn builder.format( 'vec4( 0.0 )', this.getType( builder ), output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nBlurNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.value = source.value;\r\n\tthis.uv = source.uv;\r\n\tthis.radius = source.radius;\r\n\r\n\tif ( source.size !== undefined ) { this.size = new Vector2( source.size.x, source.size.y ); }\r\n\r\n\tthis.blurX = source.blurX;\r\n\tthis.blurY = source.blurY;\r\n\r\n};\r\n\r\nBlurNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.value = this.value.toJSON( meta ).uuid;\r\n\t\tdata.uv = this.uv.toJSON( meta ).uuid;\r\n\t\tdata.radius = this.radius.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.size ) { data.size = { x: this.size.x, y: this.size.y }; }\r\n\r\n\t\tdata.blurX = this.blurX;\r\n\t\tdata.blurY = this.blurY;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LuminanceNode( rgb ) {\r\n\r\n\tTempNode.call( this, 'f' );\r\n\r\n\tthis.rgb = rgb;\r\n\r\n}\r\n\r\nLuminanceNode.Nodes = ( function () {\r\n\r\n\tvar LUMA = new ConstNode( \"vec3 LUMA vec3( 0.2125, 0.7154, 0.0721 )\" );\r\n\r\n\tvar luminance = new FunctionNode( [\r\n\t\t// Algorithm from Chapter 10 of Graphics Shaders\r\n\t\t\"float luminance( vec3 rgb ) {\",\r\n\r\n\t\t\"\treturn dot( rgb, LUMA );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ), [ LUMA ] );\r\n\r\n\treturn {\r\n\t\tLUMA: LUMA,\r\n\t\tluminance: luminance\r\n\t};\r\n\r\n} )();\r\n\r\nLuminanceNode.prototype = Object.create( TempNode.prototype );\r\nLuminanceNode.prototype.constructor = LuminanceNode;\r\nLuminanceNode.prototype.nodeType = \"Luminance\";\r\n\r\nLuminanceNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar luminance = builder.include( LuminanceNode.Nodes.luminance );\r\n\r\n\treturn builder.format( luminance + '( ' + this.rgb.build( builder, 'v3' ) + ' )', this.getType( builder ), output );\r\n\r\n};\r\n\r\nLuminanceNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.rgb = source.rgb;\r\n\r\n};\r\n\r\nLuminanceNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.rgb = this.rgb.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ColorAdjustmentNode( rgb, adjustment, method ) {\r\n\r\n\tTempNode.call( this, 'v3' );\r\n\r\n\tthis.rgb = rgb;\r\n\tthis.adjustment = adjustment;\r\n\r\n\tthis.method = method || ColorAdjustmentNode.SATURATION;\r\n\r\n}\r\n\r\nColorAdjustmentNode.Nodes = ( function () {\r\n\r\n\tvar hue = new FunctionNode( [\r\n\t\t\"vec3 hue(vec3 rgb, float adjustment) {\",\r\n\r\n\t\t\"\tconst mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);\",\r\n\t\t\"\tconst mat3 YIQtoRGB = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.107, 1.7046);\",\r\n\r\n\t\t\"\tvec3 yiq = RGBtoYIQ * rgb;\",\r\n\r\n\t\t\"\tfloat hue = atan(yiq.z, yiq.y) + adjustment;\",\r\n\t\t\"\tfloat chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\",\r\n\r\n\t\t\"\treturn YIQtoRGB * vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\tvar saturation = new FunctionNode( [\r\n\t\t// Algorithm from Chapter 16 of OpenGL Shading Language\r\n\t\t\"vec3 saturation(vec3 rgb, float adjustment) {\",\r\n\r\n\t\t\"\tvec3 intensity = vec3( luminance( rgb ) );\",\r\n\r\n\t\t\"\treturn mix( intensity, rgb, adjustment );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ), [ LuminanceNode.Nodes.luminance ] ); // include LuminanceNode function\r\n\r\n\tvar vibrance = new FunctionNode( [\r\n\t\t// Shader by Evan Wallace adapted by @lo-th\r\n\t\t\"vec3 vibrance(vec3 rgb, float adjustment) {\",\r\n\r\n\t\t\"\tfloat average = (rgb.r + rgb.g + rgb.b) / 3.0;\",\r\n\r\n\t\t\"\tfloat mx = max(rgb.r, max(rgb.g, rgb.b));\",\r\n\t\t\"\tfloat amt = (mx - average) * (-3.0 * adjustment);\",\r\n\r\n\t\t\"\treturn mix(rgb.rgb, vec3(mx), amt);\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\treturn {\r\n\t\thue: hue,\r\n\t\tsaturation: saturation,\r\n\t\tvibrance: vibrance\r\n\t};\r\n\r\n} )();\r\n\r\nColorAdjustmentNode.SATURATION = 'saturation';\r\nColorAdjustmentNode.HUE = 'hue';\r\nColorAdjustmentNode.VIBRANCE = 'vibrance';\r\nColorAdjustmentNode.BRIGHTNESS = 'brightness';\r\nColorAdjustmentNode.CONTRAST = 'contrast';\r\n\r\nColorAdjustmentNode.prototype = Object.create( TempNode.prototype );\r\nColorAdjustmentNode.prototype.constructor = ColorAdjustmentNode;\r\nColorAdjustmentNode.prototype.nodeType = \"ColorAdjustment\";\r\n\r\nColorAdjustmentNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar rgb = this.rgb.build( builder, 'v3' ),\r\n\t\tadjustment = this.adjustment.build( builder, 'f' );\r\n\r\n\tswitch ( this.method ) {\r\n\r\n\t\tcase ColorAdjustmentNode.BRIGHTNESS:\r\n\r\n\t\t\treturn builder.format( '( ' + rgb + ' + ' + adjustment + ' )', this.getType( builder ), output );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase ColorAdjustmentNode.CONTRAST:\r\n\r\n\t\t\treturn builder.format( '( ' + rgb + ' * ' + adjustment + ' )', this.getType( builder ), output );\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n\tvar method = builder.include( ColorAdjustmentNode.Nodes[ this.method ] );\r\n\r\n\treturn builder.format( method + '( ' + rgb + ', ' + adjustment + ' )', this.getType( builder ), output );\r\n\r\n};\r\n\r\nColorAdjustmentNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.rgb = source.rgb;\r\n\tthis.adjustment = source.adjustment;\r\n\tthis.method = source.method;\r\n\r\n};\r\n\r\nColorAdjustmentNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.rgb = this.rgb.toJSON( meta ).uuid;\r\n\t\tdata.adjustment = this.adjustment.toJSON( meta ).uuid;\r\n\t\tdata.method = this.method;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction IntNode( value ) {\r\n\r\n\tInputNode$1.call( this, 'i' );\r\n\r\n\tthis.value = Math.floor( value || 0 );\r\n\r\n}\r\n\r\nIntNode.prototype = Object.create( InputNode$1.prototype );\r\nIntNode.prototype.constructor = IntNode;\r\nIntNode.prototype.nodeType = \"Int\";\r\n\r\nIntNode.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {\r\n\r\n\treturn builder.format( this.value, type, output );\r\n\r\n};\r\n\r\nIntNode.prototype.copy = function ( source ) {\r\n\r\n\tInputNode$1.prototype.copy.call( this, source );\r\n\r\n\tthis.value = source.value;\r\n\r\n};\r\n\r\nIntNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.value = this.value;\r\n\r\n\t\tif ( this.readonly === true ) { data.readonly = true; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Matrix3Node( matrix ) {\r\n\r\n\tInputNode$1.call( this, 'm3' );\r\n\r\n\tthis.value = matrix || new Matrix3();\r\n\r\n}\r\n\r\nMatrix3Node.prototype = Object.create( InputNode$1.prototype );\r\nMatrix3Node.prototype.constructor = Matrix3Node;\r\nMatrix3Node.prototype.nodeType = \"Matrix3\";\r\n\r\nObject.defineProperties( Matrix3Node.prototype, {\r\n\r\n\telements: {\r\n\r\n\t\tset: function ( val ) {\r\n\r\n\t\t\tthis.value.elements = val;\r\n\r\n\t\t},\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.value.elements;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nMatrix3Node.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {\r\n\r\n\treturn builder.format( \"mat3( \" + this.value.elements.join( \", \" ) + \" )\", type, output );\r\n\r\n};\r\n\r\nMatrix3Node.prototype.copy = function ( source ) {\r\n\r\n\tInputNode$1.prototype.copy.call( this, source );\r\n\r\n\tthis.value.fromArray( source.elements );\r\n\r\n};\r\n\r\nMatrix3Node.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.elements = this.value.elements.concat();\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Matrix4Node( matrix ) {\r\n\r\n\tInputNode$1.call( this, 'm4' );\r\n\r\n\tthis.value = matrix || new Matrix4();\r\n\r\n}\r\n\r\nMatrix4Node.prototype = Object.create( InputNode$1.prototype );\r\nMatrix4Node.prototype.constructor = Matrix4Node;\r\nMatrix4Node.prototype.nodeType = \"Matrix4\";\r\n\r\nObject.defineProperties( Matrix4Node.prototype, {\r\n\r\n\telements: {\r\n\r\n\t\tset: function ( val ) {\r\n\r\n\t\t\tthis.value.elements = val;\r\n\r\n\t\t},\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.value.elements;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nMatrix4Node.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {\r\n\r\n\treturn builder.format( \"mat4( \" + this.value.elements.join( \", \" ) + \" )\", type, output );\r\n\r\n};\r\n\r\nMatrix4Node.prototype.copy = function ( source ) {\r\n\r\n\tInputNode$1.prototype.copy.call( this, source );\r\n\r\n\tthis.scope.value.fromArray( source.elements );\r\n\r\n};\r\n\r\nMatrix4Node.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.elements = this.value.elements.concat();\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PropertyNode( object, property, type ) {\r\n\r\n\tInputNode$1.call( this, type );\r\n\r\n\tthis.object = object;\r\n\tthis.property = property;\r\n\r\n}\r\n\r\nPropertyNode.prototype = Object.create( InputNode$1.prototype );\r\nPropertyNode.prototype.constructor = PropertyNode;\r\nPropertyNode.prototype.nodeType = \"Property\";\r\n\r\nObject.defineProperties( PropertyNode.prototype, {\r\n\r\n\tvalue: {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.object[ this.property ];\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( val ) {\r\n\r\n\t\t\tthis.object[ this.property ] = val;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nPropertyNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.value = this.value;\r\n\t\tdata.property = this.property;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction OperatorNode( a, b, op ) {\r\n\r\n\tTempNode.call( this );\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.op = op;\r\n\r\n}\r\n\r\nOperatorNode.ADD = '+';\r\nOperatorNode.SUB = '-';\r\nOperatorNode.MUL = '*';\r\nOperatorNode.DIV = '/';\r\n\r\nOperatorNode.prototype = Object.create( TempNode.prototype );\r\nOperatorNode.prototype.constructor = OperatorNode;\r\nOperatorNode.prototype.nodeType = \"Operator\";\r\n\r\nOperatorNode.prototype.getType = function ( builder ) {\r\n\r\n\tvar a = this.a.getType( builder ),\r\n\t\tb = this.b.getType( builder );\r\n\r\n\tif ( builder.isTypeMatrix( a ) ) {\r\n\r\n\t\treturn 'v4';\r\n\r\n\t} else if ( builder.getTypeLength( b ) > builder.getTypeLength( a ) ) {\r\n\r\n\t\t// use the greater length vector\r\n\r\n\t\treturn b;\r\n\r\n\t}\r\n\r\n\treturn a;\r\n\r\n};\r\n\r\nOperatorNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar data = builder.getNodeData( this ),\r\n\t\ttype = this.getType( builder );\r\n\r\n\tvar a = this.a.build( builder, type ),\r\n\t\tb = this.b.build( builder, type );\r\n\r\n\treturn builder.format( '( ' + a + ' ' + this.op + ' ' + b + ' )', type, output );\r\n\r\n};\r\n\r\nOperatorNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.a = source.a;\r\n\tthis.b = source.b;\r\n\tthis.op = source.op;\r\n\r\n};\r\n\r\nOperatorNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.a = this.a.toJSON( meta ).uuid;\r\n\t\tdata.b = this.b.toJSON( meta ).uuid;\r\n\t\tdata.op = this.op;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ReflectorNode( mirror ) {\r\n\r\n\tTempNode.call( this, 'v4' );\r\n\r\n\tif ( mirror ) { this.setMirror( mirror ); }\r\n\r\n}\r\n\r\nReflectorNode.prototype = Object.create( TempNode.prototype );\r\nReflectorNode.prototype.constructor = ReflectorNode;\r\nReflectorNode.prototype.nodeType = \"Reflector\";\r\n\r\nReflectorNode.prototype.setMirror = function ( mirror ) {\r\n\r\n\tthis.mirror = mirror;\r\n\r\n\tthis.textureMatrix = new Matrix4Node( this.mirror.material.uniforms.textureMatrix.value );\r\n\r\n\tthis.localPosition = new PositionNode( PositionNode.LOCAL );\r\n\r\n\tthis.uv = new OperatorNode( this.textureMatrix, this.localPosition, OperatorNode.MUL );\r\n\tthis.uvResult = new OperatorNode( null, this.uv, OperatorNode.ADD );\r\n\r\n\tthis.texture = new TextureNode( this.mirror.material.uniforms.tDiffuse.value, this.uv, null, true );\r\n\r\n};\r\n\r\nReflectorNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\tthis.uvResult.a = this.offset;\r\n\t\tthis.texture.uv = this.offset ? this.uvResult : this.uv;\r\n\r\n\t\tif ( output === 'sampler2D' ) {\r\n\r\n\t\t\treturn this.texture.build( builder, output );\r\n\r\n\t\t}\r\n\r\n\t\treturn builder.format( this.texture.build( builder, this.type ), this.type, output );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"ReflectorNode is not compatible with \" + builder.shader + \" shader.\" );\r\n\r\n\t\treturn builder.format( 'vec4( 0.0 )', this.type, output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nReflectorNode.prototype.copy = function ( source ) {\r\n\r\n\tInputNode.prototype.copy.call( this, source );\r\n\r\n\tthis.scope.mirror = source.mirror;\r\n\r\n};\r\n\r\nReflectorNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.mirror = this.mirror.uuid;\r\n\r\n\t\tif ( this.offset ) { data.offset = this.offset.toJSON( meta ).uuid; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction RTTNode( width, height, input, options ) {\r\n\r\n\toptions = options || {};\r\n\r\n\tthis.input = input;\r\n\r\n\tthis.clear = options.clear !== undefined ? options.clear : true;\r\n\r\n\tthis.renderTarget = new WebGLRenderTarget( width, height, options );\r\n\r\n\tthis.material = new NodeMaterial();\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), this.material );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n\tthis.render = true;\r\n\r\n\tTextureNode.call( this, this.renderTarget.texture );\r\n\r\n}\r\n\r\nRTTNode.prototype = Object.create( TextureNode.prototype );\r\nRTTNode.prototype.constructor = RTTNode;\r\nRTTNode.prototype.nodeType = \"RTT\";\r\n\r\nRTTNode.prototype.build = function ( builder, output, uuid ) {\r\n\r\n\tvar rttBuilder = new NodeBuilder();\r\n\trttBuilder.nodes = builder.nodes;\r\n\trttBuilder.updaters = builder.updaters;\r\n\r\n\tthis.material.fragment.value = this.input;\r\n\tthis.material.build( { builder: rttBuilder } );\r\n\r\n\treturn TextureNode.prototype.build.call( this, builder, output, uuid );\r\n\r\n};\r\n\r\nRTTNode.prototype.updateFramesaveTo = function ( frame ) {\r\n\r\n\tthis.saveTo.render = false;\r\n\r\n\tif ( this.saveTo !== this.saveToCurrent ) {\r\n\r\n\t\tif ( this.saveToMaterial ) { this.saveToMaterial.dispose(); }\r\n\r\n\t\tvar material = new NodeMaterial();\r\n\t\tmaterial.fragment.value = this;\r\n\t\tmaterial.build();\r\n\r\n\t\tvar scene = new Scene();\r\n\r\n\t\tvar quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), material );\r\n\t\tquad.frustumCulled = false; // Avoid getting clipped\r\n\t\tscene.add( quad );\r\n\r\n\t\tthis.saveToScene = scene;\r\n\t\tthis.saveToMaterial = material;\r\n\r\n\t}\r\n\r\n\tthis.saveToCurrent = this.saveTo;\r\n\r\n\tframe.renderer.render( this.saveToScene, this.camera, this.saveTo.renderTarget, this.saveTo.clear );\r\n\r\n};\r\n\r\nRTTNode.prototype.updateFrame = function ( frame ) {\r\n\r\n\tif ( frame.renderer ) {\r\n\r\n\t\t// from the second frame\r\n\r\n\t\tif ( this.saveTo && this.saveTo.render === false ) {\r\n\r\n\t\t\tthis.updateFramesaveTo( frame );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.render ) {\r\n\r\n\t\t\tif ( this.material.uniforms.renderTexture ) {\r\n\r\n\t\t\t\tthis.material.uniforms.renderTexture.value = frame.renderTexture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tframe.renderer.render( this.scene, this.camera, this.renderTarget, this.clear );\r\n\r\n\t\t}\r\n\r\n\t\t// first frame\r\n\r\n\t\tif ( this.saveTo && this.saveTo.render === true ) {\r\n\r\n\t\t\tthis.updateFramesaveTo( frame );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"RTTNode need a renderer in NodeFrame\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nRTTNode.prototype.copy = function ( source ) {\r\n\r\n\tTextureNode.prototype.copy.call( this, source );\r\n\r\n\tthis.saveTo = source.saveTo;\r\n\r\n};\r\n\r\nRTTNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = TextureNode.prototype.toJSON.call( this, meta );\r\n\r\n\t\tif ( this.saveTo ) { data.saveTo = this.saveTo.toJSON( meta ).uuid; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ScreenNode( uv ) {\r\n\r\n\tTextureNode.call( this, undefined, uv );\r\n\r\n}\r\n\r\nScreenNode.prototype = Object.create( TextureNode.prototype );\r\nScreenNode.prototype.constructor = ScreenNode;\r\nScreenNode.prototype.nodeType = \"Screen\";\r\n\r\nScreenNode.prototype.isUnique = function () {\r\n\r\n\treturn true;\r\n\r\n};\r\n\r\nScreenNode.prototype.getTexture = function ( builder, output ) {\r\n\r\n\treturn InputNode$1.prototype.generate.call( this, builder, output, this.getUuid(), 't', 'renderTexture' );\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction StandardNode() {\r\n\r\n\tNode.call( this );\r\n\r\n\tthis.color = new ColorNode( 0xEEEEEE );\r\n\tthis.roughness = new FloatNode( 0.5 );\r\n\tthis.metalness = new FloatNode( 0.5 );\r\n\r\n}\r\n\r\nStandardNode.prototype = Object.create( Node.prototype );\r\nStandardNode.prototype.constructor = StandardNode;\r\nStandardNode.prototype.nodeType = \"Standard\";\r\n\r\nStandardNode.prototype.build = function ( builder ) {\r\n\r\n\tvar code;\r\n\r\n\tbuilder.define( this.clearCoat || this.clearCoatRoughness ? 'PHYSICAL' : 'STANDARD' );\r\n\r\n\tbuilder.requires.lights = true;\r\n\r\n\tbuilder.extensions.shaderTextureLOD = true;\r\n\r\n\tif ( builder.isShader( 'vertex' ) ) {\r\n\r\n\t\tvar position = this.position ? this.position.parseAndBuildCode( builder, 'v3', { cache: 'position' } ) : undefined;\r\n\r\n\t\tbuilder.mergeUniform( UniformsUtils.merge( [\r\n\r\n\t\t\tUniformsLib.fog,\r\n\t\t\tUniformsLib.lights\r\n\r\n\t\t] ) );\r\n\r\n\t\tbuilder.addParsCode( [\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\t\"#ifndef FLAT_SHADED\",\r\n\r\n\t\t\t\"\tvarying vec3 vNormal;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t//\"#include <encodings_pars_fragment>\", // encoding functions\r\n\t\t\t\"#include <fog_pars_vertex>\",\r\n\t\t\t\"#include <morphtarget_pars_vertex>\",\r\n\t\t\t\"#include <skinning_pars_vertex>\",\r\n\t\t\t\"#include <shadowmap_pars_vertex>\",\r\n\t\t\t\"#include <logdepthbuf_pars_vertex>\",\r\n\t\t\t\"#include <clipping_planes_pars_vertex>\"\r\n\r\n\t\t].join( \"\\n\" ) );\r\n\r\n\t\tvar output = [\r\n\t\t\t\"#include <beginnormal_vertex>\",\r\n\t\t\t\"#include <morphnormal_vertex>\",\r\n\t\t\t\"#include <skinbase_vertex>\",\r\n\t\t\t\"#include <skinnormal_vertex>\",\r\n\t\t\t\"#include <defaultnormal_vertex>\",\r\n\r\n\t\t\t\"#ifndef FLAT_SHADED\", // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\t\t\t\"\tvNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#include <begin_vertex>\"\r\n\t\t];\r\n\r\n\t\tif ( position ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tposition.code,\r\n\t\t\t\tposition.result ? \"transformed = \" + position.result + \";\" : ''\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toutput.push(\r\n\t\t\t\"#include <morphtarget_vertex>\",\r\n\t\t\t\"#include <skinning_vertex>\",\r\n\t\t\t\"#include <project_vertex>\",\r\n\t\t\t\"#include <fog_vertex>\",\r\n\t\t\t\"#include <logdepthbuf_vertex>\",\r\n\t\t\t\"#include <clipping_planes_vertex>\",\r\n\r\n\t\t\t\"\tvViewPosition = - mvPosition.xyz;\",\r\n\r\n\t\t\t\"#include <worldpos_vertex>\",\r\n\t\t\t\"#include <shadowmap_vertex>\"\r\n\t\t);\r\n\r\n\t\tcode = output.join( \"\\n\" );\r\n\r\n\t} else {\r\n\r\n\t\tvar contextEnvironment = {\r\n\t\t\tbias: RoughnessToBlinnExponentNode,\r\n\t\t\tgamma: true\r\n\t\t};\r\n\r\n\t\tvar contextGammaOnly = {\r\n\t\t\tgamma: true\r\n\t\t};\r\n\r\n\t\tvar useClearCoat = ! builder.isDefined( 'STANDARD' );\r\n\r\n\t\t// parse all nodes to reuse generate codes\r\n\r\n\t\tthis.color.parse( builder, { slot: 'color', context: contextGammaOnly } );\r\n\t\tthis.roughness.parse( builder );\r\n\t\tthis.metalness.parse( builder );\r\n\r\n\t\tif ( this.alpha ) { this.alpha.parse( builder ); }\r\n\r\n\t\tif ( this.normal ) { this.normal.parse( builder ); }\r\n\r\n\t\tif ( this.clearCoat ) { this.clearCoat.parse( builder ); }\r\n\t\tif ( this.clearCoatRoughness ) { this.clearCoatRoughness.parse( builder ); }\r\n\r\n\t\tif ( this.reflectivity ) { this.reflectivity.parse( builder ); }\r\n\r\n\t\tif ( this.light ) { this.light.parse( builder, { cache: 'light' } ); }\r\n\r\n\t\tif ( this.ao ) { this.ao.parse( builder ); }\r\n\t\tif ( this.ambient ) { this.ambient.parse( builder ); }\r\n\t\tif ( this.shadow ) { this.shadow.parse( builder ); }\r\n\t\tif ( this.emissive ) { this.emissive.parse( builder, { slot: 'emissive' } ); }\r\n\r\n\t\tif ( this.environment ) { this.environment.parse( builder, { cache: 'env', context: contextEnvironment, slot: 'environment' } ); } // isolate environment from others inputs ( see TextureNode, CubeTextureNode )\r\n\r\n\t\t// build code\r\n\r\n\t\tvar color = this.color.buildCode( builder, 'c', { slot: 'color', context: contextGammaOnly } );\r\n\t\tvar roughness = this.roughness.buildCode( builder, 'f' );\r\n\t\tvar metalness = this.metalness.buildCode( builder, 'f' );\r\n\r\n\t\tvar alpha = this.alpha ? this.alpha.buildCode( builder, 'f' ) : undefined;\r\n\r\n\t\tvar normal = this.normal ? this.normal.buildCode( builder, 'v3' ) : undefined;\r\n\r\n\t\tvar clearCoat = this.clearCoat ? this.clearCoat.buildCode( builder, 'f' ) : undefined;\r\n\t\tvar clearCoatRoughness = this.clearCoatRoughness ? this.clearCoatRoughness.buildCode( builder, 'f' ) : undefined;\r\n\r\n\t\tvar reflectivity = this.reflectivity ? this.reflectivity.buildCode( builder, 'f' ) : undefined;\r\n\r\n\t\tvar light = this.light ? this.light.buildCode( builder, 'v3', { cache: 'light' } ) : undefined;\r\n\r\n\t\tvar ao = this.ao ? this.ao.buildCode( builder, 'f' ) : undefined;\r\n\t\tvar ambient = this.ambient ? this.ambient.buildCode( builder, 'c' ) : undefined;\r\n\t\tvar shadow = this.shadow ? this.shadow.buildCode( builder, 'c' ) : undefined;\r\n\t\tvar emissive = this.emissive ? this.emissive.buildCode( builder, 'c', { slot: 'emissive' } ) : undefined;\r\n\r\n\t\tvar environment = this.environment ? this.environment.buildCode( builder, 'c', { cache: 'env', context: contextEnvironment, slot: 'environment' } ) : undefined;\r\n\r\n\t\tvar clearCoatEnv = useClearCoat && environment ? this.environment.buildCode( builder, 'c', { cache: 'clearCoat', context: contextEnvironment, slot: 'environment' } ) : undefined;\r\n\r\n\t\tbuilder.requires.transparent = alpha !== undefined;\r\n\r\n\t\tbuilder.addParsCode( [\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\t\"#ifndef FLAT_SHADED\",\r\n\r\n\t\t\t\"\tvarying vec3 vNormal;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#include <dithering_pars_fragment>\",\r\n\t\t\t\"#include <fog_pars_fragment>\",\r\n\t\t\t\"#include <bsdfs>\",\r\n\t\t\t\"#include <lights_pars_begin>\",\r\n\t\t\t\"#include <lights_physical_pars_fragment>\",\r\n\t\t\t\"#include <shadowmap_pars_fragment>\",\r\n\t\t\t\"#include <logdepthbuf_pars_fragment>\",\r\n\t\t\t\"#include <logdepthbuf_vertex>\"\r\n\t\t].join( \"\\n\" ) );\r\n\r\n\t\tvar output = [\r\n\t\t\t\"#include <clipping_planes_fragment>\",\r\n\r\n\t\t\t// add before: prevent undeclared normal\r\n\t\t\t\"\t#include <normal_fragment_begin>\",\r\n\r\n\t\t\t// add before: prevent undeclared material\r\n\t\t\t\"\tPhysicalMaterial material;\",\r\n\t\t\t\"\tmaterial.diffuseColor = vec3( 1.0 );\",\r\n\r\n\t\t\tcolor.code,\r\n\t\t\t\"\tvec3 diffuseColor = \" + color.result + \";\",\r\n\t\t\t\"\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\",\r\n\r\n\t\t\t\"#include <logdepthbuf_fragment>\",\r\n\r\n\t\t\troughness.code,\r\n\t\t\t\"\tfloat roughnessFactor = \" + roughness.result + \";\",\r\n\r\n\t\t\tmetalness.code,\r\n\t\t\t\"\tfloat metalnessFactor = \" + metalness.result + \";\"\r\n\t\t];\r\n\r\n\t\tif ( alpha ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\talpha.code,\r\n\t\t\t\t'#ifdef ALPHATEST',\r\n\r\n\t\t\t\t'if ( ' + alpha.result + ' <= ALPHATEST ) discard;',\r\n\r\n\t\t\t\t'#endif'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( normal ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tnormal.code,\r\n\t\t\t\t'normal = ' + normal.result + ';'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t// optimization for now\r\n\r\n\t\toutput.push(\r\n\t\t\t'material.diffuseColor = ' + ( light ? 'vec3( 1.0 )' : 'diffuseColor * (1.0 - metalnessFactor)' ) + ';',\r\n\t\t\t'material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );'\r\n\t\t);\r\n\r\n\t\tif ( clearCoat ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tclearCoat.code,\r\n\t\t\t\t'material.clearCoat = saturate( ' + clearCoat.result + ' );'\r\n\t\t\t);\r\n\r\n\t\t} else if ( useClearCoat ) {\r\n\r\n\t\t\toutput.push( 'material.clearCoat = 0.0;' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( clearCoatRoughness ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tclearCoatRoughness.code,\r\n\t\t\t\t'material.clearCoatRoughness = clamp( ' + clearCoatRoughness.result + ', 0.04, 1.0 );'\r\n\t\t\t);\r\n\r\n\t\t} else if ( useClearCoat ) {\r\n\r\n\t\t\toutput.push( 'material.clearCoatRoughness = 0.0;' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( reflectivity ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\treflectivity.code,\r\n\t\t\t\t'material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( ' + reflectivity.result + ' ) ), diffuseColor, metalnessFactor );'\r\n\t\t\t);\r\n\r\n\t\t} else {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\t'material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor, metalnessFactor );'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toutput.push(\r\n\t\t\t\"#include <lights_fragment_begin>\"\r\n\t\t);\r\n\r\n\t\tif ( light ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tlight.code,\r\n\t\t\t\t\"reflectedLight.directDiffuse = \" + light.result + \";\"\r\n\t\t\t);\r\n\r\n\t\t\t// apply color\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\t\"diffuseColor *= 1.0 - metalnessFactor;\",\r\n\r\n\t\t\t\t\"reflectedLight.directDiffuse *= diffuseColor;\",\r\n\t\t\t\t\"reflectedLight.indirectDiffuse *= diffuseColor;\"\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( ao ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tao.code,\r\n\t\t\t\t\"reflectedLight.indirectDiffuse *= \" + ao.result + \";\",\r\n\t\t\t\t\"float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\",\r\n\t\t\t\t\"reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, \" + ao.result + \", material.specularRoughness );\"\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( ambient ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tambient.code,\r\n\t\t\t\t\"reflectedLight.indirectDiffuse += \" + ambient.result + \";\"\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( shadow ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tshadow.code,\r\n\t\t\t\t\"reflectedLight.directDiffuse *= \" + shadow.result + \";\",\r\n\t\t\t\t\"reflectedLight.directSpecular *= \" + shadow.result + \";\"\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( emissive ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\temissive.code,\r\n\t\t\t\t\"reflectedLight.directDiffuse += \" + emissive.result + \";\"\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( environment ) {\r\n\r\n\t\t\toutput.push( environment.code );\r\n\r\n\t\t\tif ( clearCoatEnv ) {\r\n\r\n\t\t\t\toutput.push(\r\n\t\t\t\t\tclearCoatEnv.code,\r\n\t\t\t\t\t\"clearCoatRadiance += \" + clearCoatEnv.result + \";\"\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutput.push( \"radiance += \" + environment.result + \";\" );\r\n\r\n\t\t}\r\n\r\n\t\toutput.push(\r\n\t\t\t\"#include <lights_fragment_end>\"\r\n\t\t);\r\n\r\n\t\toutput.push( \"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\" );\r\n\r\n\t\tif ( alpha ) {\r\n\r\n\t\t\toutput.push( \"gl_FragColor = vec4( outgoingLight, \" + alpha.result + \" );\" );\r\n\r\n\t\t} else {\r\n\r\n\t\t\toutput.push( \"gl_FragColor = vec4( outgoingLight, 1.0 );\" );\r\n\r\n\t\t}\r\n\r\n\t\toutput.push(\r\n\t\t\t\"#include <tonemapping_fragment>\",\r\n\t\t\t\"#include <encodings_fragment>\",\r\n\t\t\t\"#include <fog_fragment>\",\r\n\t\t\t\"#include <premultiplied_alpha_fragment>\",\r\n\t\t\t\"#include <dithering_fragment>\"\r\n\t\t);\r\n\r\n\t\tcode = output.join( \"\\n\" );\r\n\r\n\t}\r\n\r\n\treturn code;\r\n\r\n};\r\n\r\nStandardNode.prototype.copy = function ( source ) {\r\n\r\n\tNode.prototype.copy.call( this, source );\r\n\r\n\t// vertex\r\n\r\n\tif ( source.position ) { this.position = source.position; }\r\n\r\n\t// fragment\r\n\r\n\tthis.color = source.color;\r\n\tthis.roughness = source.roughness;\r\n\tthis.metalness = source.metalness;\r\n\r\n\tif ( source.alpha ) { this.alpha = source.alpha; }\r\n\r\n\tif ( source.normal ) { this.normal = source.normal; }\r\n\r\n\tif ( source.clearCoat ) { this.clearCoat = source.clearCoat; }\r\n\tif ( source.clearCoatRoughness ) { this.clearCoatRoughness = source.clearCoatRoughness; }\r\n\r\n\tif ( source.reflectivity ) { this.reflectivity = source.reflectivity; }\r\n\r\n\tif ( source.light ) { this.light = source.light; }\r\n\tif ( source.shadow ) { this.shadow = source.shadow; }\r\n\r\n\tif ( source.ao ) { this.ao = source.ao; }\r\n\r\n\tif ( source.emissive ) { this.emissive = source.emissive; }\r\n\tif ( source.ambient ) { this.ambient = source.ambient; }\r\n\r\n\tif ( source.environment ) { this.environment = source.environment; }\r\n\r\n};\r\n\r\nStandardNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\t// vertex\r\n\r\n\t\tif ( this.position ) { data.position = this.position.toJSON( meta ).uuid; }\r\n\r\n\t\t// fragment\r\n\r\n\t\tdata.color = this.color.toJSON( meta ).uuid;\r\n\t\tdata.roughness = this.roughness.toJSON( meta ).uuid;\r\n\t\tdata.metalness = this.metalness.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.alpha ) { data.alpha = this.alpha.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.normal ) { data.normal = this.normal.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.clearCoat ) { data.clearCoat = this.clearCoat.toJSON( meta ).uuid; }\r\n\t\tif ( this.clearCoatRoughness ) { data.clearCoatRoughness = this.clearCoatRoughness.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.reflectivity ) { data.reflectivity = this.reflectivity.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.light ) { data.light = this.light.toJSON( meta ).uuid; }\r\n\t\tif ( this.shadow ) { data.shadow = this.shadow.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.ao ) { data.ao = this.ao.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.emissive ) { data.emissive = this.emissive.toJSON( meta ).uuid; }\r\n\t\tif ( this.ambient ) { data.ambient = this.ambient.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.environment ) { data.environment = this.environment.toJSON( meta ).uuid; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction SwitchNode( node, components ) {\r\n\r\n\tNode.call( this );\r\n\r\n\tthis.node = node;\r\n\tthis.components = components || 'x';\r\n\r\n}\r\n\r\nSwitchNode.prototype = Object.create( Node.prototype );\r\nSwitchNode.prototype.constructor = SwitchNode;\r\nSwitchNode.prototype.nodeType = \"Switch\";\r\n\r\nSwitchNode.prototype.getType = function ( builder ) {\r\n\r\n\treturn builder.getTypeFromLength( this.components.length );\r\n\r\n};\r\n\r\nSwitchNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar type = this.node.getType( builder ),\r\n\t\tnode = this.node.build( builder, type ),\r\n\t\tinputLength = builder.getTypeLength( type ) - 1;\r\n\r\n\tif ( inputLength > 0 ) {\r\n\r\n\t\t// get max length\r\n\r\n\t\tvar outputLength = 0,\r\n\t\t\tcomponents = builder.colorToVectorProperties( this.components );\r\n\r\n\t\tvar i, len = components.length;\r\n\r\n\t\tfor ( i = 0; i < len; i ++ ) {\r\n\r\n\t\t\toutputLength = Math.max( outputLength, builder.getIndexByElement( components.charAt( i ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( outputLength > inputLength ) { outputLength = inputLength; }\r\n\r\n\t\t// split\r\n\r\n\t\tnode += '.';\r\n\r\n\t\tfor ( i = 0; i < len; i ++ ) {\r\n\r\n\t\t\tvar elm = components.charAt( i );\r\n\t\t\tvar idx = builder.getIndexByElement( components.charAt( i ) );\r\n\r\n\t\t\tif ( idx > outputLength ) { idx = outputLength; }\r\n\r\n\t\t\tnode += builder.getElementByIndex( idx );\r\n\r\n\t\t}\r\n\r\n\t\treturn builder.format( node, this.getType( builder ), output );\r\n\r\n\t} else {\r\n\r\n\t\t// join\r\n\r\n\t\treturn builder.format( node, type, output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nSwitchNode.prototype.copy = function ( source ) {\r\n\r\n\tNode.prototype.copy.call( this, source );\r\n\r\n\tthis.node = source.node;\r\n\tthis.components = source.components;\r\n\r\n};\r\n\r\nSwitchNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.node = this.node.toJSON( meta ).uuid;\r\n\t\tdata.components = this.components;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction NormalMapNode( value, scale ) {\r\n\r\n\tTempNode.call( this, 'v3' );\r\n\r\n\tthis.value = value;\r\n\tthis.scale = scale || new Vector2Node( 1, 1 );\r\n\r\n}\r\n\r\nNormalMapNode.Nodes = ( function () {\r\n\r\n\tvar perturbNormal2Arb = new FunctionNode( [\r\n\r\n\t\t// Per-Pixel Tangent Space Normal Mapping\r\n\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\r\n\r\n\t\t\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 mUv, vec2 normalScale ) {\",\r\n\r\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\r\n\r\n\t\t\"\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\",\r\n\t\t\"\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\",\r\n\t\t\"\tvec2 st0 = dFdx( mUv.st );\",\r\n\t\t\"\tvec2 st1 = dFdy( mUv.st );\",\r\n\r\n\t\t\"\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\", // we do not care about the magnitude\r\n\r\n\t\t\"\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\",\r\n\t\t\"\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\",\r\n\t\t\"\tvec3 N = normalize( surf_norm );\",\r\n\t\t\"\tmat3 tsn = mat3( S, T, N );\",\r\n\r\n\t\t\"\tvec3 mapN = map * 2.0 - 1.0;\",\r\n\r\n\t\t\"\tmapN.xy *= normalScale;\",\r\n\t\t\"\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\",\r\n\r\n\t\t\"\treturn normalize( tsn * mapN );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ), null, { derivatives: true } );\r\n\r\n\treturn {\r\n\t\tperturbNormal2Arb: perturbNormal2Arb\r\n\t};\r\n\r\n} )();\r\n\r\nNormalMapNode.prototype = Object.create( TempNode.prototype );\r\nNormalMapNode.prototype.constructor = NormalMapNode;\r\nNormalMapNode.prototype.nodeType = \"NormalMap\";\r\n\r\nNormalMapNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\tvar perturbNormal2Arb = builder.include( NormalMapNode.Nodes.perturbNormal2Arb );\r\n\r\n\t\tthis.normal = this.normal || new NormalNode$1();\r\n\t\tthis.position = this.position || new PositionNode( PositionNode.VIEW );\r\n\t\tthis.uv = this.uv || new UVNode();\r\n\r\n\t\treturn builder.format( perturbNormal2Arb + '( -' + this.position.build( builder, 'v3' ) + ', ' +\r\n\t\t\tthis.normal.build( builder, 'v3' ) + ', ' +\r\n\t\t\tthis.value.build( builder, 'v3' ) + ', ' +\r\n\t\t\tthis.uv.build( builder, 'v2' ) + ', ' +\r\n\t\t\tthis.scale.build( builder, 'v2' ) + ' )', this.getType( builder ), output );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"NormalMapNode is not compatible with \" + builder.shader + \" shader.\" );\r\n\r\n\t\treturn builder.format( 'vec3( 0.0 )', this.getType( builder ), output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nNormalMapNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.value = source.value;\r\n\tthis.scale = source.scale;\r\n\r\n};\r\n\r\nNormalMapNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.value = this.value.toJSON( meta ).uuid;\r\n\t\tdata.scale = this.scale.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshStandardNode() {\r\n\r\n\tStandardNode.call( this );\r\n\r\n\tthis.properties = {\r\n\t\tcolor: new Color( 0xffffff ),\r\n\t\troughness: 0.5,\r\n\t\tmetalness: 0.5,\r\n\t\tnormalScale: new Vector2( 1, 1 )\r\n\t};\r\n\r\n\tthis.inputs = {\r\n\t\tcolor: new PropertyNode( this.properties, 'color', 'c' ),\r\n\t\troughness: new PropertyNode( this.properties, 'roughness', 'f' ),\r\n\t\tmetalness: new PropertyNode( this.properties, 'metalness', 'f' ),\r\n\t\tnormalScale: new PropertyNode( this.properties, 'normalScale', 'v2' )\r\n\t};\r\n\r\n}\r\n\r\nMeshStandardNode.prototype = Object.create( StandardNode.prototype );\r\nMeshStandardNode.prototype.constructor = MeshStandardNode;\r\nMeshStandardNode.prototype.nodeType = \"MeshStandard\";\r\n\r\nMeshStandardNode.prototype.build = function ( builder ) {\r\n\r\n\tvar props = this.properties,\r\n\t\tinputs = this.inputs;\r\n\r\n\tif ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\t// slots\r\n\t\t// * color\r\n\t\t// * map\r\n\r\n\t\tvar color = builder.findNode( props.color, inputs.color ),\r\n\t\t\tmap = builder.resolve( props.map );\r\n\r\n\t\tthis.color = map ? new OperatorNode( color, map, OperatorNode.MUL ) : color;\r\n\r\n\t\t// slots\r\n\t\t// * roughness\r\n\t\t// * roughnessMap\r\n\r\n\t\tvar roughness = builder.findNode( props.roughness, inputs.roughness ),\r\n\t\t\troughnessMap = builder.resolve( props.roughnessMap );\r\n\r\n\t\tthis.roughness = roughnessMap ? new OperatorNode( roughness, new SwitchNode( roughnessMap, \"g\" ), OperatorNode.MUL ) : roughness;\r\n\r\n\t\t// slots\r\n\t\t// * metalness\r\n\t\t// * metalnessMap\r\n\r\n\t\tvar metalness = builder.findNode( props.metalness, inputs.metalness ),\r\n\t\t\tmetalnessMap = builder.resolve( props.metalnessMap );\r\n\r\n\t\tthis.metalness = metalnessMap ? new OperatorNode( metalness, new SwitchNode( metalnessMap, \"b\" ), OperatorNode.MUL ) : metalness;\r\n\r\n\t\t// slots\r\n\t\t// * normalMap\r\n\t\t// * normalScale\r\n\r\n\t\tif ( props.normalMap ) {\r\n\r\n\t\t\tthis.normal = new NormalMapNode( builder.resolve( props.normalMap ) );\r\n\t\t\tthis.normal.scale = builder.findNode( props.normalScale, inputs.normalScale );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.normal = undefined;\r\n\r\n\t\t}\r\n\r\n\t\t// slots\r\n\t\t// * envMap\r\n\r\n\t\tthis.environment = builder.resolve( props.envMap );\r\n\r\n\t}\r\n\r\n\t// build code\r\n\r\n\treturn StandardNode.prototype.build.call( this, builder );\r\n\r\n};\r\n\r\nMeshStandardNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tconsole.warn( \".toJSON not implemented in\", this );\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction MeshStandardNodeMaterial() {\r\n\r\n\tvar node = new MeshStandardNode();\r\n\r\n\tNodeMaterial.call( this, node, node );\r\n\r\n\tthis.type = \"MeshStandardNodeMaterial\";\r\n\r\n}\r\n\r\nMeshStandardNodeMaterial.prototype = Object.create( NodeMaterial.prototype );\r\nMeshStandardNodeMaterial.prototype.constructor = MeshStandardNodeMaterial;\r\n\r\nNodeUtils.addShortcuts( MeshStandardNodeMaterial.prototype, 'properties', [\r\n\t\"color\",\r\n\t\"roughness\",\r\n\t\"metalness\",\r\n\t\"map\",\r\n\t\"normalMap\",\r\n\t\"normalScale\",\r\n\t\"metalnessMap\",\r\n\t\"roughnessMap\",\r\n\t\"envMap\"\r\n] );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PhongNode() {\r\n\r\n\tNode.call( this );\r\n\r\n\tthis.color = new ColorNode( 0xEEEEEE );\r\n\tthis.specular = new ColorNode( 0x111111 );\r\n\tthis.shininess = new FloatNode( 30 );\r\n\r\n}\r\n\r\nPhongNode.prototype = Object.create( Node.prototype );\r\nPhongNode.prototype.constructor = PhongNode;\r\nPhongNode.prototype.nodeType = \"Phong\";\r\n\r\nPhongNode.prototype.build = function ( builder ) {\r\n\r\n\tvar code;\r\n\r\n\tbuilder.define( 'PHONG' );\r\n\r\n\tbuilder.requires.lights = true;\r\n\r\n\tif ( builder.isShader( 'vertex' ) ) {\r\n\r\n\t\tvar position = this.position ? this.position.parseAndBuildCode( builder, 'v3', { cache: 'position' } ) : undefined;\r\n\r\n\t\tbuilder.mergeUniform( UniformsUtils.merge( [\r\n\r\n\t\t\tUniformsLib.fog,\r\n\t\t\tUniformsLib.lights\r\n\r\n\t\t] ) );\r\n\r\n\t\tbuilder.addParsCode( [\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\t\"#ifndef FLAT_SHADED\",\r\n\r\n\t\t\t\"\tvarying vec3 vNormal;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t//\"#include <encodings_pars_fragment>\", // encoding functions\r\n\t\t\t\"#include <fog_pars_vertex>\",\r\n\t\t\t\"#include <morphtarget_pars_vertex>\",\r\n\t\t\t\"#include <skinning_pars_vertex>\",\r\n\t\t\t\"#include <shadowmap_pars_vertex>\",\r\n\t\t\t\"#include <logdepthbuf_pars_vertex>\",\r\n\t\t\t\"#include <clipping_planes_pars_vertex>\"\r\n\t\t].join( \"\\n\" ) );\r\n\r\n\t\tvar output = [\r\n\t\t\t\"#include <beginnormal_vertex>\",\r\n\t\t\t\"#include <morphnormal_vertex>\",\r\n\t\t\t\"#include <skinbase_vertex>\",\r\n\t\t\t\"#include <skinnormal_vertex>\",\r\n\t\t\t\"#include <defaultnormal_vertex>\",\r\n\r\n\t\t\t\"#ifndef FLAT_SHADED\", // normal computed with derivatives when FLAT_SHADED\r\n\r\n\t\t\t\"\tvNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#include <begin_vertex>\"\r\n\t\t];\r\n\r\n\t\tif ( position ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tposition.code,\r\n\t\t\t\tposition.result ? \"transformed = \" + position.result + \";\" : ''\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toutput.push(\r\n\t\t\t\"\t#include <morphtarget_vertex>\",\r\n\t\t\t\"\t#include <skinning_vertex>\",\r\n\t\t\t\"\t#include <project_vertex>\",\r\n\t\t\t\"\t#include <fog_vertex>\",\r\n\t\t\t\"\t#include <logdepthbuf_vertex>\",\r\n\t\t\t\"\t#include <clipping_planes_vertex>\",\r\n\r\n\t\t\t\"\tvViewPosition = - mvPosition.xyz;\",\r\n\r\n\t\t\t\"\t#include <worldpos_vertex>\",\r\n\t\t\t\"\t#include <shadowmap_vertex>\",\r\n\t\t\t\"\t#include <fog_vertex>\"\r\n\t\t);\r\n\r\n\t\tcode = output.join( \"\\n\" );\r\n\r\n\t} else {\r\n\r\n\t\t// parse all nodes to reuse generate codes\r\n\r\n\t\tthis.color.parse( builder, { slot: 'color' } );\r\n\t\tthis.specular.parse( builder );\r\n\t\tthis.shininess.parse( builder );\r\n\r\n\t\tif ( this.alpha ) { this.alpha.parse( builder ); }\r\n\r\n\t\tif ( this.normal ) { this.normal.parse( builder ); }\r\n\r\n\t\tif ( this.light ) { this.light.parse( builder, { cache: 'light' } ); }\r\n\r\n\t\tif ( this.ao ) { this.ao.parse( builder ); }\r\n\t\tif ( this.ambient ) { this.ambient.parse( builder ); }\r\n\t\tif ( this.shadow ) { this.shadow.parse( builder ); }\r\n\t\tif ( this.emissive ) { this.emissive.parse( builder, { slot: 'emissive' } ); }\r\n\r\n\t\tif ( this.environment ) { this.environment.parse( builder, { slot: 'environment' } ); }\r\n\t\tif ( this.environmentAlpha && this.environment ) { this.environmentAlpha.parse( builder ); }\r\n\r\n\t\t// build code\r\n\r\n\t\tvar color = this.color.buildCode( builder, 'c', { slot: 'color' } );\r\n\t\tvar specular = this.specular.buildCode( builder, 'c' );\r\n\t\tvar shininess = this.shininess.buildCode( builder, 'f' );\r\n\r\n\t\tvar alpha = this.alpha ? this.alpha.buildCode( builder, 'f' ) : undefined;\r\n\r\n\t\tvar normal = this.normal ? this.normal.buildCode( builder, 'v3' ) : undefined;\r\n\r\n\t\tvar light = this.light ? this.light.buildCode( builder, 'v3', { cache: 'light' } ) : undefined;\r\n\r\n\t\tvar ao = this.ao ? this.ao.buildCode( builder, 'f' ) : undefined;\r\n\t\tvar ambient = this.ambient ? this.ambient.buildCode( builder, 'c' ) : undefined;\r\n\t\tvar shadow = this.shadow ? this.shadow.buildCode( builder, 'c' ) : undefined;\r\n\t\tvar emissive = this.emissive ? this.emissive.buildCode( builder, 'c', { slot: 'emissive' } ) : undefined;\r\n\r\n\t\tvar environment = this.environment ? this.environment.buildCode( builder, 'c', { slot: 'environment' } ) : undefined;\r\n\t\tvar environmentAlpha = this.environmentAlpha && this.environment ? this.environmentAlpha.buildCode( builder, 'f' ) : undefined;\r\n\r\n\t\tbuilder.requires.transparent = alpha != undefined;\r\n\r\n\t\tbuilder.addParsCode( [\r\n\t\t\t\"#include <fog_pars_fragment>\",\r\n\t\t\t\"#include <bsdfs>\",\r\n\t\t\t\"#include <lights_pars_begin>\",\r\n\t\t\t\"#include <lights_phong_pars_fragment>\",\r\n\t\t\t\"#include <shadowmap_pars_fragment>\",\r\n\t\t\t\"#include <logdepthbuf_pars_fragment>\"\r\n\t\t].join( \"\\n\" ) );\r\n\r\n\t\tvar output = [\r\n\t\t\t// prevent undeclared normal\r\n\t\t\t\"#include <normal_fragment_begin>\",\r\n\r\n\t\t\t// prevent undeclared material\r\n\t\t\t\"\tBlinnPhongMaterial material;\",\r\n\r\n\t\t\tcolor.code,\r\n\t\t\t\"\tvec3 diffuseColor = \" + color.result + \";\",\r\n\t\t\t\"\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\",\r\n\r\n\t\t\t\"#include <logdepthbuf_fragment>\",\r\n\r\n\t\t\tspecular.code,\r\n\t\t\t\"\tvec3 specular = \" + specular.result + \";\",\r\n\r\n\t\t\tshininess.code,\r\n\t\t\t\"\tfloat shininess = max( 0.0001, \" + shininess.result + \" );\",\r\n\r\n\t\t\t\"\tfloat specularStrength = 1.0;\" // Ignored in MaterialNode ( replace to specular )\r\n\t\t];\r\n\r\n\t\tif ( alpha ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\talpha.code,\r\n\t\t\t\t'#ifdef ALPHATEST',\r\n\r\n\t\t\t\t'if ( ' + alpha.result + ' <= ALPHATEST ) discard;',\r\n\r\n\t\t\t\t'#endif'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( normal ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tnormal.code,\r\n\t\t\t\t'normal = ' + normal.result + ';'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t// optimization for now\r\n\r\n\t\toutput.push( 'material.diffuseColor = ' + ( light ? 'vec3( 1.0 )' : 'diffuseColor' ) + ';' );\r\n\r\n\t\toutput.push(\r\n\t\t\t// accumulation\r\n\t\t\t'material.specularColor = specular;',\r\n\t\t\t'material.specularShininess = shininess;',\r\n\t\t\t'material.specularStrength = specularStrength;',\r\n\r\n\t\t\t\"#include <lights_fragment_begin>\",\r\n\t\t\t\"#include <lights_fragment_end>\"\r\n\t\t);\r\n\r\n\t\tif ( light ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tlight.code,\r\n\t\t\t\t\"reflectedLight.directDiffuse = \" + light.result + \";\"\r\n\t\t\t);\r\n\r\n\t\t\t// apply color\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\t\"reflectedLight.directDiffuse *= diffuseColor;\",\r\n\t\t\t\t\"reflectedLight.indirectDiffuse *= diffuseColor;\"\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( ao ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tao.code,\r\n\t\t\t\t\"reflectedLight.indirectDiffuse *= \" + ao.result + \";\"\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( ambient ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tambient.code,\r\n\t\t\t\t\"reflectedLight.indirectDiffuse += \" + ambient.result + \";\"\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( shadow ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tshadow.code,\r\n\t\t\t\t\"reflectedLight.directDiffuse *= \" + shadow.result + \";\",\r\n\t\t\t\t\"reflectedLight.directSpecular *= \" + shadow.result + \";\"\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( emissive ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\temissive.code,\r\n\t\t\t\t\"reflectedLight.directDiffuse += \" + emissive.result + \";\"\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toutput.push( \"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;\" );\r\n\r\n\t\tif ( environment ) {\r\n\r\n\t\t\toutput.push( environment.code );\r\n\r\n\t\t\tif ( environmentAlpha ) {\r\n\r\n\t\t\t\toutput.push(\r\n\t\t\t\t\tenvironmentAlpha.code,\r\n\t\t\t\t\t\"outgoingLight = mix( outgoingLight, \" + environment.result + \", \" + environmentAlpha.result + \" );\"\r\n\t\t\t\t);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\toutput.push( \"outgoingLight = \" + environment.result + \";\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\t\tif ( alpha ) {\r\n\r\n\t\t\toutput.push( \"gl_FragColor = vec4( outgoingLight, \" + alpha.result + \" );\" );\r\n\r\n\t\t} else {\r\n\r\n\t\t\toutput.push( \"gl_FragColor = vec4( outgoingLight, 1.0 );\" );\r\n\r\n\t\t}\r\n\r\n\t\toutput.push(\r\n\t\t\t\"#include <premultiplied_alpha_fragment>\",\r\n\t\t\t\"#include <tonemapping_fragment>\",\r\n\t\t\t\"#include <encodings_fragment>\",\r\n\t\t\t\"#include <fog_fragment>\"\r\n\t\t);\r\n\r\n\t\tcode = output.join( \"\\n\" );\r\n\r\n\t}\r\n\r\n\treturn code;\r\n\r\n};\r\n\r\nPhongNode.prototype.copy = function ( source ) {\r\n\r\n\tNode.prototype.copy.call( this, source );\r\n\r\n\t// vertex\r\n\r\n\tif ( source.position ) { this.position = source.position; }\r\n\r\n\t// fragment\r\n\r\n\tthis.color = source.color;\r\n\tthis.specular = source.specular;\r\n\tthis.shininess = source.shininess;\r\n\r\n\tif ( source.alpha ) { this.alpha = source.alpha; }\r\n\r\n\tif ( source.normal ) { this.normal = source.normal; }\r\n\r\n\tif ( source.light ) { this.light = source.light; }\r\n\tif ( source.shadow ) { this.shadow = source.shadow; }\r\n\r\n\tif ( source.ao ) { this.ao = source.ao; }\r\n\r\n\tif ( source.emissive ) { this.emissive = source.emissive; }\r\n\tif ( source.ambient ) { this.ambient = source.ambient; }\r\n\r\n\tif ( source.environment ) { this.environment = source.environment; }\r\n\tif ( source.environmentAlpha ) { this.environmentAlpha = source.environmentAlpha; }\r\n\r\n};\r\n\r\nPhongNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\t// vertex\r\n\r\n\t\tif ( this.position ) { data.position = this.position.toJSON( meta ).uuid; }\r\n\r\n\t\t// fragment\r\n\r\n\t\tdata.color = this.color.toJSON( meta ).uuid;\r\n\t\tdata.specular = this.specular.toJSON( meta ).uuid;\r\n\t\tdata.shininess = this.shininess.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.alpha ) { data.alpha = this.alpha.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.normal ) { data.normal = this.normal.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.light ) { data.light = this.light.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.ao ) { data.ao = this.ao.toJSON( meta ).uuid; }\r\n\t\tif ( this.ambient ) { data.ambient = this.ambient.toJSON( meta ).uuid; }\r\n\t\tif ( this.shadow ) { data.shadow = this.shadow.toJSON( meta ).uuid; }\r\n\t\tif ( this.emissive ) { data.emissive = this.emissive.toJSON( meta ).uuid; }\r\n\r\n\t\tif ( this.environment ) { data.environment = this.environment.toJSON( meta ).uuid; }\r\n\t\tif ( this.environmentAlpha ) { data.environmentAlpha = this.environmentAlpha.toJSON( meta ).uuid; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction SpriteNode() {\r\n\r\n\tNode.call( this );\r\n\r\n\tthis.color = new ColorNode( 0xEEEEEE );\r\n\tthis.spherical = true;\r\n\r\n}\r\n\r\nSpriteNode.prototype = Object.create( Node.prototype );\r\nSpriteNode.prototype.constructor = SpriteNode;\r\nSpriteNode.prototype.nodeType = \"Sprite\";\r\n\r\nSpriteNode.prototype.build = function ( builder ) {\r\n\r\n\tvar output;\r\n\r\n\tbuilder.define( 'SPRITE' );\r\n\r\n\tbuilder.requires.lights = false;\r\n\tbuilder.requires.transparent = this.alpha !== undefined;\r\n\r\n\tif ( builder.isShader( 'vertex' ) ) {\r\n\r\n\t\tvar position = this.position ? this.position.parseAndBuildCode( builder, 'v3', { cache: 'position' } ) : undefined;\r\n\r\n\t\tbuilder.mergeUniform( UniformsUtils.merge( [\r\n\t\t\tUniformsLib.fog\r\n\t\t] ) );\r\n\r\n\t\tbuilder.addParsCode( [\r\n\t\t\t\"#include <fog_pars_vertex>\",\r\n\t\t\t\"#include <logdepthbuf_pars_vertex>\",\r\n\t\t\t\"#include <clipping_planes_pars_vertex>\"\r\n\t\t].join( \"\\n\" ) );\r\n\r\n\t\toutput = [\r\n\t\t\t\"#include <clipping_planes_fragment>\",\r\n\t\t\t\"#include <begin_vertex>\"\r\n\t\t];\r\n\r\n\t\tif ( position ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\tposition.code,\r\n\t\t\t\tposition.result ? \"transformed = \" + position.result + \";\" : ''\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toutput.push(\r\n\t\t\t\"#include <project_vertex>\",\r\n\t\t\t\"#include <fog_vertex>\",\r\n\r\n\t\t\t'mat4 modelViewMtx = modelViewMatrix;',\r\n\t\t\t'mat4 modelMtx = modelMatrix;',\r\n\r\n\t\t\t// ignore position from modelMatrix (use vary position)\r\n\t\t\t'modelMtx[3][0] = 0.0;',\r\n\t\t\t'modelMtx[3][1] = 0.0;',\r\n\t\t\t'modelMtx[3][2] = 0.0;'\r\n\t\t);\r\n\r\n\t\tif ( ! this.spherical ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\t'modelMtx[1][1] = 1.0;'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toutput.push(\r\n\t\t\t// http://www.geeks3d.com/20140807/billboarding-vertex-shader-glsl/\r\n\t\t\t// First colunm.\r\n\t\t\t'modelViewMtx[0][0] = 1.0;',\r\n\t\t\t'modelViewMtx[0][1] = 0.0;',\r\n\t\t\t'modelViewMtx[0][2] = 0.0;'\r\n\t\t);\r\n\r\n\t\tif ( this.spherical ) {\r\n\r\n\t\t\toutput.push(\r\n\t\t\t\t// Second colunm.\r\n\t\t\t\t'modelViewMtx[1][0] = 0.0;',\r\n\t\t\t\t'modelViewMtx[1][1] = 1.0;',\r\n\t\t\t\t'modelViewMtx[1][2] = 0.0;'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toutput.push(\r\n\t\t\t// Thrid colunm.\r\n\t\t\t'modelViewMtx[2][0] = 0.0;',\r\n\t\t\t'modelViewMtx[2][1] = 0.0;',\r\n\t\t\t'modelViewMtx[2][2] = 1.0;',\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );\",\r\n\r\n\t\t\t\"#include <logdepthbuf_vertex>\",\r\n\t\t\t\"#include <clipping_planes_vertex>\",\r\n\t\t\t\"#include <fog_vertex>\"\r\n\t\t);\r\n\r\n\t} else {\r\n\r\n\t\tbuilder.addParsCode( [\r\n\t\t\t\"#include <fog_pars_fragment>\",\r\n\t\t\t\"#include <logdepthbuf_pars_fragment>\",\r\n\t\t\t\"#include <clipping_planes_pars_fragment>\"\r\n\t\t].join( \"\\n\" ) );\r\n\r\n\t\tbuilder.addCode( [\r\n\t\t\t\"#include <clipping_planes_fragment>\",\r\n\t\t\t\"#include <logdepthbuf_fragment>\"\r\n\t\t].join( \"\\n\" ) );\r\n\r\n\t\t// parse all nodes to reuse generate codes\r\n\r\n\t\tif ( this.alpha ) { this.alpha.parse( builder ); }\r\n\r\n\t\tthis.color.parse( builder, { slot: 'color' } );\r\n\r\n\t\t// build code\r\n\r\n\t\tvar alpha = this.alpha ? this.alpha.buildCode( builder, 'f' ) : undefined,\r\n\t\t\tcolor = this.color.buildCode( builder, 'c', { slot: 'color' } );\r\n\r\n\t\tif ( alpha ) {\r\n\r\n\t\t\toutput = [\r\n\t\t\t\talpha.code,\r\n\t\t\t\t'#ifdef ALPHATEST',\r\n\r\n\t\t\t\t'if ( ' + alpha.result + ' <= ALPHATEST ) discard;',\r\n\r\n\t\t\t\t'#endif',\r\n\t\t\t\tcolor.code,\r\n\t\t\t\t\"gl_FragColor = vec4( \" + color.result + \", \" + alpha.result + \" );\"\r\n\t\t\t];\r\n\r\n\t\t} else {\r\n\r\n\t\t\toutput = [\r\n\t\t\t\tcolor.code,\r\n\t\t\t\t\"gl_FragColor = vec4( \" + color.result + \", 1.0 );\"\r\n\t\t\t];\r\n\r\n\t\t}\r\n\r\n\t\toutput.push(\r\n\t\t\t\"#include <tonemapping_fragment>\",\r\n\t\t\t\"#include <encodings_fragment>\",\r\n\t\t\t\"#include <fog_fragment>\"\r\n\t\t);\r\n\r\n\t}\r\n\r\n\treturn output.join( \"\\n\" );\r\n\r\n};\r\n\r\nSpriteNode.prototype.copy = function ( source ) {\r\n\r\n\tNode.prototype.copy.call( this, source );\r\n\r\n\t// vertex\r\n\r\n\tif ( source.position ) { this.position = source.position; }\r\n\r\n\t// fragment\r\n\r\n\tthis.color = source.color;\r\n\r\n\tif ( source.spherical !== undefined ) { this.spherical = source.spherical; }\r\n\r\n\tif ( source.alpha ) { this.alpha = source.alpha; }\r\n\r\n};\r\n\r\nSpriteNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\t// vertex\r\n\r\n\t\tif ( this.position ) { data.position = this.position.toJSON( meta ).uuid; }\r\n\r\n\t\t// fragment\r\n\r\n\t\tdata.color = this.color.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.spherical === false ) { data.spherical = false; }\r\n\r\n\t\tif ( this.alpha ) { data.alpha = this.alpha.toJSON( meta ).uuid; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PhongNodeMaterial() {\r\n\r\n\tvar node = new PhongNode();\r\n\r\n\tNodeMaterial.call( this, node, node );\r\n\r\n\tthis.type = \"PhongNodeMaterial\";\r\n\r\n}\r\n\r\nPhongNodeMaterial.prototype = Object.create( NodeMaterial.prototype );\r\nPhongNodeMaterial.prototype.constructor = PhongNodeMaterial;\r\n\r\nNodeUtils.addShortcuts( PhongNodeMaterial.prototype, 'fragment', [\r\n\t'color',\r\n\t'alpha',\r\n\t'specular',\r\n\t'shininess',\r\n\t'normal',\r\n\t'emissive',\r\n\t'ambient',\r\n\t'light',\r\n\t'shadow',\r\n\t'ao',\r\n\t'environment',\r\n\t'environmentAlpha',\r\n\t'position'\r\n] );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction SpriteNodeMaterial() {\r\n\r\n\tvar node = new SpriteNode();\r\n\r\n\tNodeMaterial.call( this, node, node );\r\n\r\n\tthis.type = \"SpriteNodeMaterial\";\r\n\r\n}\r\n\r\nSpriteNodeMaterial.prototype = Object.create( NodeMaterial.prototype );\r\nSpriteNodeMaterial.prototype.constructor = SpriteNodeMaterial;\r\n\r\nNodeUtils.addShortcuts( SpriteNodeMaterial.prototype, 'fragment', [\r\n\t'color',\r\n\t'alpha',\r\n\t'position',\r\n\t'spherical'\r\n] );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction StandardNodeMaterial() {\r\n\r\n\tvar node = new StandardNode();\r\n\r\n\tNodeMaterial.call( this, node, node );\r\n\r\n\tthis.type = \"StandardNodeMaterial\";\r\n\r\n}\r\n\r\nStandardNodeMaterial.prototype = Object.create( NodeMaterial.prototype );\r\nStandardNodeMaterial.prototype.constructor = StandardNodeMaterial;\r\n\r\nNodeUtils.addShortcuts( StandardNodeMaterial.prototype, 'fragment', [\r\n\t'color',\r\n\t'alpha',\r\n\t'roughness',\r\n\t'metalness',\r\n\t'reflectivity',\r\n\t'clearCoat',\r\n\t'clearCoatRoughness',\r\n\t'normal',\r\n\t'emissive',\r\n\t'ambient',\r\n\t'light',\r\n\t'shadow',\r\n\t'ao',\r\n\t'environment',\r\n\t'position'\r\n] );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CondNode( a, b, ifNode, elseNode, op ) {\r\n\r\n\tTempNode.call( this );\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\r\n\tthis.ifNode = ifNode;\r\n\tthis.elseNode = elseNode;\r\n\r\n\tthis.op = op;\r\n\r\n}\r\n\r\nCondNode.EQUAL = '==';\r\nCondNode.NOT_EQUAL = '!=';\r\nCondNode.GREATER = '>';\r\nCondNode.GREATER_EQUAL = '>=';\r\nCondNode.LESS = '<';\r\nCondNode.LESS_EQUAL = '<=';\r\n\r\nCondNode.prototype = Object.create( TempNode.prototype );\r\nCondNode.prototype.constructor = CondNode;\r\nCondNode.prototype.nodeType = \"Cond\";\r\n\r\nCondNode.prototype.getType = function ( builder ) {\r\n\r\n\tif ( builder.getTypeLength( this.elseNode.getType( builder ) ) > builder.getTypeLength( this.ifNode.getType( builder ) ) ) {\r\n\r\n\t\treturn this.elseNode.getType( builder );\r\n\r\n\t}\r\n\r\n\treturn this.ifNode.getType( builder );\r\n\r\n};\r\n\r\nCondNode.prototype.getCondType = function ( builder ) {\r\n\r\n\tif ( builder.getTypeLength( this.b.getType( builder ) ) > builder.getTypeLength( this.a.getType( builder ) ) ) {\r\n\r\n\t\treturn this.b.getType( builder );\r\n\r\n\t}\r\n\r\n\treturn this.a.getType( builder );\r\n\r\n};\r\n\r\nCondNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar type = this.getType( builder ),\r\n\t\tcondType = this.getCondType( builder ),\r\n\t\ta = this.a.build( builder, condType ),\r\n\t\tb = this.b.build( builder, condType ),\r\n\t\tifNode = this.ifNode.build( builder, type ),\r\n\t\telseNode = this.elseNode.build( builder, type );\r\n\r\n\tvar code = '( ' + [ a, this.op, b, '?', ifNode, ':', elseNode ].join( ' ' ) + ' )';\r\n\r\n\treturn builder.format( code, this.getType( builder ), output );\r\n\r\n};\r\n\r\nCondNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.a = source.a;\r\n\tthis.b = source.b;\r\n\r\n\tthis.ifNode = source.ifNode;\r\n\tthis.elseNode = source.elseNode;\r\n\r\n\tthis.op = source.op;\r\n\r\n};\r\n\r\nCondNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.a = this.a.toJSON( meta ).uuid;\r\n\t\tdata.b = this.b.toJSON( meta ).uuid;\r\n\r\n\t\tdata.ifNode = this.ifNode.toJSON( meta ).uuid;\r\n\t\tdata.elseNode = this.elseNode.toJSON( meta ).uuid;\r\n\r\n\t\tdata.op = this.op;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Math1Node( a, method ) {\r\n\r\n\tTempNode.call( this );\r\n\r\n\tthis.a = a;\r\n\r\n\tthis.method = method;\r\n\r\n}\r\n\r\nMath1Node.RAD = 'radians';\r\nMath1Node.DEG = 'degrees';\r\nMath1Node.EXP = 'exp';\r\nMath1Node.EXP2 = 'exp2';\r\nMath1Node.LOG = 'log';\r\nMath1Node.LOG2 = 'log2';\r\nMath1Node.SQRT = 'sqrt';\r\nMath1Node.INV_SQRT = 'inversesqrt';\r\nMath1Node.FLOOR = 'floor';\r\nMath1Node.CEIL = 'ceil';\r\nMath1Node.NORMALIZE = 'normalize';\r\nMath1Node.FRACT = 'fract';\r\nMath1Node.SAT = 'saturate';\r\nMath1Node.SIN = 'sin';\r\nMath1Node.COS = 'cos';\r\nMath1Node.TAN = 'tan';\r\nMath1Node.ASIN = 'asin';\r\nMath1Node.ACOS = 'acos';\r\nMath1Node.ARCTAN = 'atan';\r\nMath1Node.ABS = 'abs';\r\nMath1Node.SIGN = 'sign';\r\nMath1Node.LENGTH = 'length';\r\nMath1Node.NEGATE = 'negate';\r\nMath1Node.INVERT = 'invert';\r\n\r\nMath1Node.prototype = Object.create( TempNode.prototype );\r\nMath1Node.prototype.constructor = Math1Node;\r\nMath1Node.prototype.nodeType = \"Math1\";\r\n\r\nMath1Node.prototype.getType = function ( builder ) {\r\n\r\n\tswitch ( this.method ) {\r\n\r\n\t\tcase Math1Node.LENGTH:\r\n\r\n\t\t\treturn 'f';\r\n\r\n\t}\r\n\r\n\treturn this.a.getType( builder );\r\n\r\n};\r\n\r\nMath1Node.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar type = this.getType( builder ),\r\n\t\tresult = this.a.build( builder, type );\r\n\r\n\tswitch ( this.method ) {\r\n\r\n\t\tcase Math1Node.NEGATE:\r\n\r\n\t\t\tresult = '( -' + result + ' )';\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase Math1Node.INVERT:\r\n\r\n\t\t\tresult = '( 1.0 - ' + result + ' )';\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\r\n\t\t\tresult = this.method + '( ' + result + ' )';\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n\treturn builder.format( result, type, output );\r\n\r\n};\r\n\r\nMath1Node.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.a = source.a;\r\n\tthis.method = source.method;\r\n\r\n};\r\n\r\nMath1Node.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.a = this.a.toJSON( meta ).uuid;\r\n\t\tdata.method = this.method;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Math2Node( a, b, method ) {\r\n\r\n\tTempNode.call( this );\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\r\n\tthis.method = method;\r\n\r\n}\r\n\r\nMath2Node.MIN = 'min';\r\nMath2Node.MAX = 'max';\r\nMath2Node.MOD = 'mod';\r\nMath2Node.STEP = 'step';\r\nMath2Node.REFLECT = 'reflect';\r\nMath2Node.DISTANCE = 'distance';\r\nMath2Node.DOT = 'dot';\r\nMath2Node.CROSS = 'cross';\r\nMath2Node.POW = 'pow';\r\n\r\nMath2Node.prototype = Object.create( TempNode.prototype );\r\nMath2Node.prototype.constructor = Math2Node;\r\nMath2Node.prototype.nodeType = \"Math2\";\r\n\r\nMath2Node.prototype.getInputType = function ( builder ) {\r\n\r\n\t// use the greater length vector\r\n\r\n\tif ( builder.getTypeLength( this.b.getType( builder ) ) > builder.getTypeLength( this.a.getType( builder ) ) ) {\r\n\r\n\t\treturn this.b.getType( builder );\r\n\r\n\t}\r\n\r\n\treturn this.a.getType( builder );\r\n\r\n};\r\n\r\nMath2Node.prototype.getType = function ( builder ) {\r\n\r\n\tswitch ( this.method ) {\r\n\r\n\t\tcase Math2Node.DISTANCE:\r\n\t\tcase Math2Node.DOT:\r\n\r\n\t\t\treturn 'f';\r\n\r\n\t\tcase Math2Node.CROSS:\r\n\r\n\t\t\treturn 'v3';\r\n\r\n\t}\r\n\r\n\treturn this.getInputType( builder );\r\n\r\n};\r\n\r\nMath2Node.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar a, b,\r\n\t\ttype = this.getInputType( builder ),\r\n\t\tal = builder.getTypeLength( this.a.getType( builder ) ),\r\n\t\tbl = builder.getTypeLength( this.b.getType( builder ) );\r\n\r\n\t// optimzer\r\n\r\n\tswitch ( this.method ) {\r\n\r\n\t\tcase Math2Node.CROSS:\r\n\r\n\t\t\ta = this.a.build( builder, 'v3' );\r\n\t\t\tb = this.b.build( builder, 'v3' );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase Math2Node.STEP:\r\n\r\n\t\t\ta = this.a.build( builder, al === 1 ? 'f' : type );\r\n\t\t\tb = this.b.build( builder, type );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase Math2Node.MIN:\r\n\t\tcase Math2Node.MAX:\r\n\t\tcase Math2Node.MOD:\r\n\r\n\t\t\ta = this.a.build( builder, type );\r\n\t\t\tb = this.b.build( builder, bl === 1 ? 'f' : type );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\r\n\t\t\ta = this.a.build( builder, type );\r\n\t\t\tb = this.b.build( builder, type );\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n\treturn builder.format( this.method + '( ' + a + ', ' + b + ' )', this.getType( builder ), output );\r\n\r\n};\r\n\r\nMath2Node.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.a = source.a;\r\n\tthis.b = source.b;\r\n\tthis.method = source.method;\r\n\r\n};\r\n\r\nMath2Node.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.a = this.a.toJSON( meta ).uuid;\r\n\t\tdata.b = this.b.toJSON( meta ).uuid;\r\n\t\tdata.method = this.method;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Math3Node( a, b, c, method ) {\r\n\r\n\tTempNode.call( this );\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.method = method;\r\n\r\n}\r\n\r\nMath3Node.MIX = 'mix';\r\nMath3Node.REFRACT = 'refract';\r\nMath3Node.SMOOTHSTEP = 'smoothstep';\r\nMath3Node.FACEFORWARD = 'faceforward';\r\n\r\nMath3Node.prototype = Object.create( TempNode.prototype );\r\nMath3Node.prototype.constructor = Math3Node;\r\nMath3Node.prototype.nodeType = \"Math3\";\r\n\r\nMath3Node.prototype.getType = function ( builder ) {\r\n\r\n\tvar a = builder.getTypeLength( this.a.getType( builder ) );\r\n\tvar b = builder.getTypeLength( this.b.getType( builder ) );\r\n\tvar c = builder.getTypeLength( this.c.getType( builder ) );\r\n\r\n\tif ( a > b && a > c ) {\r\n\r\n\t\treturn this.a.getType( builder );\r\n\r\n\t} else if ( b > c ) {\r\n\r\n\t\treturn this.b.getType( builder );\r\n\r\n\t}\r\n\r\n\treturn this.c.getType( builder );\r\n\r\n};\r\n\r\nMath3Node.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar a, b, c,\r\n\t\tal = builder.getTypeLength( this.a.getType( builder ) ),\r\n\t\tbl = builder.getTypeLength( this.b.getType( builder ) ),\r\n\t\tcl = builder.getTypeLength( this.c.getType( builder ) ),\r\n\t\ttype = this.getType( builder );\r\n\r\n\t// optimzer\r\n\r\n\tswitch ( this.method ) {\r\n\r\n\t\tcase Math3Node.REFRACT:\r\n\r\n\t\t\ta = this.a.build( builder, type );\r\n\t\t\tb = this.b.build( builder, type );\r\n\t\t\tc = this.c.build( builder, 'f' );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase Math3Node.MIX:\r\n\r\n\t\t\ta = this.a.build( builder, type );\r\n\t\t\tb = this.b.build( builder, type );\r\n\t\t\tc = this.c.build( builder, cl === 1 ? 'f' : type );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\r\n\t\t\ta = this.a.build( builder, type );\r\n\t\t\tb = this.b.build( builder, type );\r\n\t\t\tc = this.c.build( builder, type );\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n\treturn builder.format( this.method + '( ' + a + ', ' + b + ', ' + c + ' )', type, output );\r\n\r\n};\r\n\r\nMath3Node.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.a = source.a;\r\n\tthis.b = source.b;\r\n\tthis.c = source.c;\r\n\tthis.method = source.method;\r\n\r\n};\r\n\r\nMath3Node.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.a = this.a.toJSON( meta ).uuid;\r\n\t\tdata.b = this.b.toJSON( meta ).uuid;\r\n\t\tdata.c = this.c.toJSON( meta ).uuid;\r\n\t\tdata.method = this.method;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction BumpMapNode( value, scale ) {\r\n\r\n\tTempNode.call( this, 'v3' );\r\n\r\n\tthis.value = value;\r\n\tthis.scale = scale || new FloatNode( 1 );\r\n\r\n\tthis.toNormalMap = false;\r\n\r\n}\r\n\r\nBumpMapNode.Nodes = ( function () {\r\n\r\n\tvar dHdxy_fwd = new FunctionNode( [\r\n\r\n\t\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\r\n\t\t// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\r\n\r\n\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\r\n\r\n\t\t\"vec2 dHdxy_fwd( sampler2D bumpMap, vec2 vUv, float bumpScale ) {\",\r\n\r\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\r\n\r\n\t\t\"\tvec2 dSTdx = dFdx( vUv );\",\r\n\t\t\"\tvec2 dSTdy = dFdy( vUv );\",\r\n\r\n\t\t\"\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\",\r\n\t\t\"\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\",\r\n\t\t\"\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\",\r\n\r\n\t\t\"\treturn vec2( dBx, dBy );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ), null, { derivatives: true } );\r\n\r\n\tvar perturbNormalArb = new FunctionNode( [\r\n\r\n\t\t\"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\",\r\n\r\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\r\n\r\n\t\t\"\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\",\r\n\t\t\"\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\",\r\n\t\t\"\tvec3 vN = surf_norm;\", // normalized\r\n\r\n\t\t\"\tvec3 R1 = cross( vSigmaY, vN );\",\r\n\t\t\"\tvec3 R2 = cross( vN, vSigmaX );\",\r\n\r\n\t\t\"\tfloat fDet = dot( vSigmaX, R1 );\",\r\n\r\n\t\t\"\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\",\r\n\r\n\t\t\"\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\",\r\n\r\n\t\t\"\treturn normalize( abs( fDet ) * surf_norm - vGrad );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ), [ dHdxy_fwd ], { derivatives: true } );\r\n\r\n\tvar bumpToNormal = new FunctionNode( [\r\n\t\t\"vec3 bumpToNormal( sampler2D bumpMap, vec2 uv, float scale ) {\",\r\n\r\n\t\t\"\tvec2 dSTdx = dFdx( uv );\",\r\n\t\t\"\tvec2 dSTdy = dFdy( uv );\",\r\n\r\n\t\t\"\tfloat Hll = texture2D( bumpMap, uv ).x;\",\r\n\t\t\"\tfloat dBx = texture2D( bumpMap, uv + dSTdx ).x - Hll;\",\r\n\t\t\"\tfloat dBy = texture2D( bumpMap, uv + dSTdy ).x - Hll;\",\r\n\r\n\t\t\"\treturn vec3( .5 - ( dBx * scale ), .5 - ( dBy * scale ), 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ), null, { derivatives: true } );\r\n\r\n\treturn {\r\n\t\tdHdxy_fwd: dHdxy_fwd,\r\n\t\tperturbNormalArb: perturbNormalArb,\r\n\t\tbumpToNormal: bumpToNormal\r\n\t};\r\n\r\n} )();\r\n\r\nBumpMapNode.prototype = Object.create( TempNode.prototype );\r\nBumpMapNode.prototype.constructor = BumpMapNode;\r\nBumpMapNode.prototype.nodeType = \"BumpMap\";\r\n\r\nBumpMapNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tif ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\tif ( this.toNormalMap ) {\r\n\r\n\t\t\tvar bumpToNormal = builder.include( BumpMapNode.Nodes.bumpToNormal );\r\n\r\n\t\t\treturn builder.format( bumpToNormal + '( ' + this.value.build( builder, 'sampler2D' ) + ', ' +\r\n\t\t\t\tthis.value.uv.build( builder, 'v2' ) + ', ' +\r\n\t\t\t\tthis.scale.build( builder, 'f' ) + ' )', this.getType( builder ), output );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar derivativeHeight = builder.include( BumpMapNode.Nodes.dHdxy_fwd ),\r\n\t\t\t\tperturbNormalArb = builder.include( BumpMapNode.Nodes.perturbNormalArb );\r\n\r\n\t\t\tthis.normal = this.normal || new NormalNode$1();\r\n\t\t\tthis.position = this.position || new PositionNode( PositionNode.VIEW );\r\n\r\n\t\t\tvar derivativeHeightCode = derivativeHeight + '( ' + this.value.build( builder, 'sampler2D' ) + ', ' +\r\n\t\t\t\tthis.value.uv.build( builder, 'v2' ) + ', ' +\r\n\t\t\t\tthis.scale.build( builder, 'f' ) + ' )';\r\n\r\n\t\t\treturn builder.format( perturbNormalArb + '( -' + this.position.build( builder, 'v3' ) + ', ' +\r\n\t\t\t\tthis.normal.build( builder, 'v3' ) + ', ' +\r\n\t\t\t\tderivativeHeightCode + ' )', this.getType( builder ), output );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"BumpMapNode is not compatible with \" + builder.shader + \" shader.\" );\r\n\r\n\t\treturn builder.format( 'vec3( 0.0 )', this.getType( builder ), output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nBumpMapNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.value = source.value;\r\n\tthis.scale = source.scale;\r\n\r\n};\r\n\r\nBumpMapNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.value = this.value.toJSON( meta ).uuid;\r\n\t\tdata.scale = this.scale.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Pass = function () {\r\n\tthis.enabled = true;\r\n\tthis.needsSwap = true;\r\n\tthis.clear = false;\r\n\tthis.renderToScreen = false;\r\n};\r\n\r\nObject.assign( Pass.prototype, {\r\n\tsetSize: function( width, height ) {},\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\t\tconsole.error( 'Pass: .render() must be implemented in derived pass.' );\r\n\t}\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ShaderPass = function ( shader, textureID ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\r\n\r\n\tif ( shader instanceof ShaderMaterial ) {\r\n\r\n\t\tthis.uniforms = shader.uniforms;\r\n\r\n\t\tthis.material = shader;\r\n\r\n\t} else if ( shader ) {\r\n\r\n\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\tthis.material = new ShaderMaterial( {\r\n\r\n\t\t\tdefines: Object.assign( {}, shader.defines ),\r\n\t\t\tuniforms: this.uniforms,\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nShaderPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: ShaderPass,\r\n\r\n\trender: function( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( this.uniforms[ this.textureID ] ) {\r\n\r\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\r\n\r\n\t\t}\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction NodePass() {\r\n\r\n\tShaderPass.call( this );\r\n\r\n\tthis.name = \"\";\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\tthis.userData = {};\r\n\r\n\tthis.textureID = 'renderTexture';\r\n\r\n\tthis.input = new ScreenNode();\r\n\r\n\tthis.material = new NodeMaterial();\r\n\r\n\tthis.needsUpdate = true;\r\n\r\n}\r\n\r\nNodePass.prototype = Object.create( ShaderPass.prototype );\r\nNodePass.prototype.constructor = NodePass;\r\n\r\nNodePass.prototype.render = function () {\r\n\r\n\tif ( this.needsUpdate ) {\r\n\r\n\t\tthis.material.dispose();\r\n\r\n\t\tthis.material.fragment.value = this.input;\r\n\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t}\r\n\r\n\tthis.uniforms = this.material.uniforms;\r\n\r\n\tShaderPass.prototype.render.apply( this, arguments );\r\n\r\n};\r\n\r\nNodePass.prototype.copy = function ( source ) {\r\n\r\n\tthis.input = source.input;\r\n\r\n};\r\n\r\nNodePass.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\tif ( isRootObject ) {\r\n\r\n\t\tmeta = {\r\n\t\t\tnodes: {}\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tif ( meta && ! meta.passes ) { meta.passes = {}; }\r\n\r\n\tif ( ! meta.passes[ this.uuid ] ) {\r\n\r\n\t\tvar data = {};\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = \"NodePass\";\r\n\r\n\t\tmeta.passes[ this.uuid ] = data;\r\n\r\n\t\tif ( this.name !== \"\" ) { data.name = this.name; }\r\n\r\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }\r\n\r\n\t\tdata.input = this.input.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\tmeta.pass = this.uuid;\r\n\r\n\treturn meta;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction NodePostProcessing( renderer, renderTarget ) {\r\n\r\n\tif ( renderTarget === undefined ) {\r\n\r\n\t\tvar parameters = {\r\n\t\t\tminFilter: LinearFilter,\r\n\t\t\tmagFilter: LinearFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\tstencilBuffer: false\r\n\t\t};\r\n\r\n\t\tvar size = renderer.getDrawingBufferSize();\r\n\t\trenderTarget = new WebGLRenderTarget( size.width, size.height, parameters );\r\n\r\n\t}\r\n\r\n\tthis.renderer = renderer;\r\n\tthis.renderTarget = renderTarget;\r\n\r\n\tthis.output = new ScreenNode();\r\n\tthis.material = new NodeMaterial();\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), this.material );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n\tthis.needsUpdate = true;\r\n\r\n}\r\n\r\nNodePostProcessing.prototype = {\r\n\r\n\tconstructor: NodePostProcessing,\r\n\r\n\trender: function ( scene, camera, frame ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.material.dispose();\r\n\r\n\t\t\tthis.material.fragment.value = this.output;\r\n\t\t\tthis.material.build();\r\n\r\n\t\t\tif ( this.material.uniforms.renderTexture ) {\r\n\r\n\t\t\t\tthis.material.uniforms.renderTexture.value = this.renderTarget.texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tframe.setRenderer( this.renderer )\r\n\t\t\t.setRenderTexture( this.renderTarget.texture );\r\n\r\n\t\tthis.renderer.render( scene, camera, this.renderTarget );\r\n\r\n\t\tframe.updateNode( this.material );\r\n\r\n\t\tthis.renderer.render( this.scene, this.camera );\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tthis.renderTarget.setSize( width, height );\r\n\r\n\t\tthis.renderer.setSize( width, height );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.output = source.output;\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\r\n\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\tmeta = {\r\n\t\t\t\tnodes: {}\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tif ( meta && ! meta.post ) { meta.post = {}; }\r\n\r\n\t\tif ( ! meta.post[ this.uuid ] ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tdata.uuid = this.uuid;\r\n\t\t\tdata.type = \"NodePostProcessing\";\r\n\r\n\t\t\tmeta.post[ this.uuid ] = data;\r\n\r\n\t\t\tif ( this.name !== \"\" ) { data.name = this.name; }\r\n\r\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }\r\n\r\n\t\t\tdata.output = this.output.toJSON( meta ).uuid;\r\n\r\n\t\t}\r\n\r\n\t\tmeta.post = this.uuid;\r\n\r\n\t\treturn meta;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CheckerNode( uv ) {\r\n\r\n\tTempNode.call( this, 'f' );\r\n\r\n\tthis.uv = uv || new UVNode();\r\n\r\n}\r\n\r\nCheckerNode.prototype = Object.create( TempNode.prototype );\r\nCheckerNode.prototype.constructor = CheckerNode;\r\nCheckerNode.prototype.nodeType = \"Noise\";\r\n\r\nCheckerNode.Nodes = ( function () {\r\n\r\n\t// https://github.com/mattdesl/glsl-checker/blob/master/index.glsl\r\n\r\n\tvar checker = new FunctionNode( [\r\n\t\t\"float checker( vec2 uv ) {\",\r\n\r\n\t\t\"\tfloat cx = floor( uv.x );\",\r\n\t\t\"\tfloat cy = floor( uv.y ); \",\r\n\t\t\"\tfloat result = mod( cx + cy, 2.0 );\",\r\n\r\n\t\t\"\treturn sign( result );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\treturn {\r\n\t\tchecker: checker\r\n\t};\r\n\r\n} )();\r\n\r\nCheckerNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar snoise = builder.include( CheckerNode.Nodes.checker );\r\n\r\n\treturn builder.format( snoise + '( ' + this.uv.build( builder, 'v2' ) + ' )', this.getType( builder ), output );\r\n\r\n};\r\n\r\nCheckerNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.uv = source.uv;\r\n\r\n};\r\n\r\nCheckerNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.uv = this.uv.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction NoiseNode( uv ) {\r\n\r\n\tTempNode.call( this, 'f' );\r\n\r\n\tthis.uv = uv || new UVNode();\r\n\r\n}\r\n\r\nNoiseNode.prototype = Object.create( TempNode.prototype );\r\nNoiseNode.prototype.constructor = NoiseNode;\r\nNoiseNode.prototype.nodeType = \"Noise\";\r\n\r\nNoiseNode.Nodes = ( function () {\r\n\r\n\tvar snoise = new FunctionNode( [\r\n\t\t\"float snoise(vec2 co) {\",\r\n\r\n\t\t\"\treturn fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\",\r\n\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ) );\r\n\r\n\treturn {\r\n\t\tsnoise: snoise\r\n\t};\r\n\r\n} )();\r\n\r\nNoiseNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar snoise = builder.include( NoiseNode.Nodes.snoise );\r\n\r\n\treturn builder.format( snoise + '( ' + this.uv.build( builder, 'v2' ) + ' )', this.getType( builder ), output );\r\n\r\n};\r\n\r\nNoiseNode.prototype.copy = function ( source ) {\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tthis.uv = source.uv;\r\n\r\n};\r\n\r\nNoiseNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.uv = this.uv.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction BypassNode( code, value ) {\r\n\r\n\tNode.call( this );\r\n\r\n\tthis.code = code;\r\n\tthis.value = value;\r\n\r\n}\r\n\r\nBypassNode.prototype = Object.create( Node.prototype );\r\nBypassNode.prototype.constructor = BypassNode;\r\nBypassNode.prototype.nodeType = \"Bypass\";\r\n\r\nBypassNode.prototype.getType = function ( builder ) {\r\n\r\n\tif ( this.value ) {\r\n\r\n\t\treturn this.value.getType( builder );\r\n\r\n\t} else if ( builder.isShader( 'fragment' ) ) {\r\n\r\n\t\treturn 'f';\r\n\r\n\t}\r\n\r\n\treturn 'void';\r\n\r\n};\r\n\r\nBypassNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tvar code = this.code.build( builder, output ) + ';';\r\n\r\n\tbuilder.addNodeCode( code );\r\n\r\n\tif ( builder.isShader( 'vertex' ) ) {\r\n\r\n\t\tif ( this.value ) {\r\n\r\n\t\t\treturn this.value.build( builder, output );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\treturn this.value ? this.value.build( builder, output ) : builder.format( '0.0', 'f', output );\r\n\r\n\t}\r\n\r\n};\r\n\r\nBypassNode.prototype.copy = function ( source ) {\r\n\r\n\tNode.prototype.copy.call( this, source );\r\n\r\n\tthis.code = source.code;\r\n\tthis.value = source.value;\r\n\r\n};\r\n\r\nBypassNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.code = this.code.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.value ) { data.value = this.value.toJSON( meta ).uuid; }\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar inputs = NodeUtils.elements;\r\n\r\nfunction JoinNode( x, y, z, w ) {\r\n\r\n\tTempNode.call( this, 'f' );\r\n\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\tthis.z = z;\r\n\tthis.w = w;\r\n\r\n}\r\n\r\nJoinNode.prototype = Object.create( TempNode.prototype );\r\nJoinNode.prototype.constructor = JoinNode;\r\nJoinNode.prototype.nodeType = \"Join\";\r\n\r\nJoinNode.prototype.getNumElements = function () {\n\tvar this$1 = this;\n\r\n\r\n\tvar i = inputs.length;\r\n\r\n\twhile ( i -- ) {\r\n\r\n\t\tif ( this$1[ inputs[ i ] ] !== undefined ) {\r\n\r\n\t\t\t++ i;\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn Math.max( i, 2 );\r\n\r\n};\r\n\r\nJoinNode.prototype.getType = function ( builder ) {\r\n\r\n\treturn builder.getTypeFromLength( this.getNumElements() );\r\n\r\n};\r\n\r\nJoinNode.prototype.generate = function ( builder, output ) {\n\tvar this$1 = this;\n\r\n\r\n\tvar type = this.getType( builder ),\r\n\t\tlength = this.getNumElements(),\r\n\t\toutputs = [];\r\n\r\n\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\tvar elm = this$1[ inputs[ i ] ];\r\n\r\n\t\toutputs.push( elm ? elm.build( builder, 'f' ) : '0.0' );\r\n\r\n\t}\r\n\r\n\tvar code = ( length > 1 ? builder.getConstructorFromLength( length ) : '' ) + '( ' + outputs.join( ', ' ) + ' )';\r\n\r\n\treturn builder.format( code, type, output );\r\n\r\n};\r\n\r\nJoinNode.prototype.copy = function ( source ) {\n\tvar this$1 = this;\n\r\n\r\n\tTempNode.prototype.copy.call( this, source );\r\n\r\n\tfor ( var prop in source.inputs ) {\r\n\r\n\t\tthis$1[ prop ] = source.inputs[ prop ];\r\n\r\n\t}\r\n\r\n};\r\n\r\nJoinNode.prototype.toJSON = function ( meta ) {\n\tvar this$1 = this;\n\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.inputs = {};\r\n\r\n\t\tvar length = this.getNumElements();\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar elm = this$1[ inputs[ i ] ];\r\n\r\n\t\t\tif ( elm ) {\r\n\r\n\t\t\t\tdata.inputs[ inputs[ i ] ] = elm.toJSON( meta ).uuid;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction UVTransformNode( uv, position ) {\r\n\r\n\tExpressionNode.call( this, \"( uvTransform * vec3( uvNode, 1 ) ).xy\", \"vec2\" );\r\n\r\n\tthis.uv = uv || new UVNode();\r\n\tthis.position = position || new Matrix3Node();\r\n\r\n}\r\n\r\nUVTransformNode.prototype = Object.create( ExpressionNode.prototype );\r\nUVTransformNode.prototype.constructor = UVTransformNode;\r\nUVTransformNode.prototype.nodeType = \"UVTransform\";\r\n\r\nUVTransformNode.prototype.generate = function ( builder, output ) {\r\n\r\n\tthis.keywords[ \"uvNode\" ] = this.uv;\r\n\tthis.keywords[ \"uvTransform\" ] = this.position;\r\n\r\n\treturn ExpressionNode.prototype.generate.call( this, builder, output );\r\n\r\n};\r\n\r\nUVTransformNode.prototype.setUvTransform = function ( tx, ty, sx, sy, rotation, cx, cy ) {\r\n\r\n\tcx = cx !== undefined ? cx : .5;\r\n\tcy = cy !== undefined ? cy : .5;\r\n\r\n\tthis.position.value.setUvTransform( tx, ty, sx, sy, rotation, cx, cy );\r\n\r\n};\r\n\r\nUVTransformNode.prototype.copy = function ( source ) {\r\n\r\n\tExpressionNode.prototype.copy.call( this, source );\r\n\r\n\tthis.uv = source.uv;\r\n\tthis.position = source.position;\r\n\r\n};\r\n\r\nUVTransformNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tdata.uv = this.uv.toJSON( meta ).uuid;\r\n\t\tdata.position = this.position.toJSON( meta ).uuid;\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction VelocityNode( target, params ) {\r\n\r\n\tVector3Node.call( this );\r\n\r\n\tthis.params = {};\r\n\r\n\tthis.velocity = new Vector3();\r\n\r\n\tthis.setTarget( target );\r\n\tthis.setParams( params );\r\n\r\n}\r\n\r\nVelocityNode.prototype = Object.create( Vector3Node.prototype );\r\nVelocityNode.prototype.constructor = VelocityNode;\r\nVelocityNode.prototype.nodeType = \"Velocity\";\r\n\r\nVelocityNode.prototype.isReadonly = function ( builder ) {\r\n\r\n\treturn false;\r\n\r\n};\r\n\r\nVelocityNode.prototype.setParams = function ( params ) {\r\n\r\n\tswitch ( this.params.type ) {\r\n\r\n\t\tcase \"elastic\":\r\n\r\n\t\t\tdelete this.moment;\r\n\r\n\t\t\tdelete this.speed;\r\n\t\t\tdelete this.springVelocity;\r\n\r\n\t\t\tdelete this.lastVelocity;\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n\tthis.params = params || {};\r\n\r\n\tswitch ( this.params.type ) {\r\n\r\n\t\tcase \"elastic\":\r\n\r\n\t\t\tthis.moment = new Vector3();\r\n\r\n\t\t\tthis.speed = new Vector3();\r\n\t\t\tthis.springVelocity = new Vector3();\r\n\r\n\t\t\tthis.lastVelocity = new Vector3();\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n};\r\n\r\nVelocityNode.prototype.setTarget = function ( target ) {\r\n\r\n\tif ( this.target ) {\r\n\r\n\t\tdelete this.position;\r\n\t\tdelete this.oldPosition;\r\n\r\n\t}\r\n\r\n\tthis.target = target;\r\n\r\n\tif ( target ) {\r\n\r\n\t\tthis.position = target.getWorldPosition( this.position || new Vector3() );\r\n\t\tthis.oldPosition = this.position.clone();\r\n\r\n\t}\r\n\r\n};\r\n\r\nVelocityNode.prototype.updateFrameVelocity = function ( frame ) {\r\n\r\n\tif ( this.target ) {\r\n\r\n\t\tthis.position = this.target.getWorldPosition( this.position || new Vector3() );\r\n\t\tthis.velocity.subVectors( this.position, this.oldPosition );\r\n\t\tthis.oldPosition.copy( this.position );\r\n\r\n\t}\r\n\r\n};\r\n\r\nVelocityNode.prototype.updateFrame = function ( frame ) {\r\n\r\n\tthis.updateFrameVelocity( frame );\r\n\r\n\tswitch ( this.params.type ) {\r\n\r\n\t\tcase \"elastic\":\r\n\r\n\t\t\t// convert to real scale: 0 at 1 values\r\n\t\t\tvar deltaFps = frame.delta * ( this.params.fps || 60 );\r\n\r\n\t\t\tvar spring = Math.pow( this.params.spring, deltaFps ),\r\n\t\t\t\tdamping = Math.pow( this.params.damping, deltaFps );\r\n\r\n\t\t\t// fix relative frame-rate\r\n\t\t\tthis.velocity.multiplyScalar( Math.exp( - this.params.damping * deltaFps ) );\r\n\r\n\t\t\t// elastic\r\n\t\t\tthis.velocity.add( this.springVelocity );\r\n\t\t\tthis.velocity.add( this.speed.multiplyScalar( damping ).multiplyScalar( 1 - spring ) );\r\n\r\n\t\t\t// speed\r\n\t\t\tthis.speed.subVectors( this.velocity, this.lastVelocity );\r\n\r\n\t\t\t// spring velocity\r\n\t\t\tthis.springVelocity.add( this.speed );\r\n\t\t\tthis.springVelocity.multiplyScalar( spring );\r\n\r\n\t\t\t// moment\r\n\t\t\tthis.moment.add( this.springVelocity );\r\n\r\n\t\t\t// damping\r\n\t\t\tthis.moment.multiplyScalar( damping );\r\n\r\n\t\t\tthis.lastVelocity.copy( this.velocity );\r\n\t\t\tthis.value.copy( this.moment );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\r\n\t\t\tthis.value.copy( this.velocity );\r\n\r\n\t}\r\n\r\n};\r\n\r\nVelocityNode.prototype.copy = function ( source ) {\r\n\r\n\tVector3Node.prototype.copy.call( this, source );\r\n\r\n\tif ( source.target ) { object.setTarget( source.target ); }\r\n\r\n\tobject.setParams( source.params );\r\n\r\n};\r\n\r\nVelocityNode.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = this.getJSONNode( meta );\r\n\r\n\tif ( ! data ) {\r\n\r\n\t\tdata = this.createJSONNode( meta );\r\n\r\n\t\tif ( this.target ) { data.target = this.target.uuid; }\r\n\r\n\t\t// clone params\r\n\t\tdata.params = JSON.parse( JSON.stringify( this.params ) );\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Box2( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\r\n\r\n}\r\n\r\nObject.assign( Box2.prototype, {\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis$1.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new Vector2();\r\n\r\n\t\treturn function setFromCenterAndSize( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = + Infinity;\r\n\t\tthis.max.x = this.max.y = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tisEmpty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n\t},\r\n\r\n\tgetCenter: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Box2: .getCenter() target is now required' );\r\n\t\t\ttarget = new Vector2();\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tgetSize: function ( target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Box2: .getSize() target is now required' );\r\n\t\t\ttarget = new Vector2();\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\r\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, target ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Box2: .getParameter() target is now required' );\r\n\t\t\ttarget = new Vector2();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\t// using 4 splitting planes to rule out intersections\r\n\r\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, target ) {\r\n\r\n\t\tif ( target === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'Box2: .clampPoint() target is now required' );\r\n\t\t\ttarget = new Vector2();\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new Vector2();\r\n\r\n\t\treturn function distanceToPoint( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Lensflare = function () {\r\n\r\n\tMesh.call( this, Lensflare.Geometry, new MeshBasicMaterial( { opacity: 0, transparent: true } ) );\r\n\r\n\tthis.type = 'Lensflare';\r\n\tthis.frustumCulled = false;\r\n\tthis.renderOrder = Infinity;\r\n\r\n\t//\r\n\r\n\tvar positionScreen = new Vector3();\r\n\r\n\t// textures\r\n\r\n\tvar tempMap = new DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, RGBFormat );\r\n\ttempMap.minFilter = NearestFilter;\r\n\ttempMap.magFilter = NearestFilter;\r\n\ttempMap.wrapS = ClampToEdgeWrapping;\r\n\ttempMap.wrapT = ClampToEdgeWrapping;\r\n\ttempMap.needsUpdate = true;\r\n\r\n\tvar occlusionMap = new DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, RGBFormat );\r\n\tocclusionMap.minFilter = NearestFilter;\r\n\tocclusionMap.magFilter = NearestFilter;\r\n\tocclusionMap.wrapS = ClampToEdgeWrapping;\r\n\tocclusionMap.wrapT = ClampToEdgeWrapping;\r\n\tocclusionMap.needsUpdate = true;\r\n\r\n\t// material\r\n\r\n\tvar geometry = Lensflare.Geometry;\r\n\r\n\tvar material1a = new RawShaderMaterial( {\r\n\t\tuniforms: {\r\n\t\t\t'scale': { value: null },\r\n\t\t\t'screenPosition': { value: null }\r\n\t\t},\r\n\t\tvertexShader: [\r\n\r\n\t\t\t'precision highp float;',\r\n\r\n\t\t\t'uniform vec3 screenPosition;',\r\n\t\t\t'uniform vec2 scale;',\r\n\r\n\t\t\t'attribute vec3 position;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ),\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t'precision highp float;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ),\r\n\t\tdepthTest: true,\r\n\t\tdepthWrite: false,\r\n\t\ttransparent: false\r\n\t} );\r\n\r\n\tvar material1b = new RawShaderMaterial( {\r\n\t\tuniforms: {\r\n\t\t\t'map': { value: tempMap },\r\n\t\t\t'scale': { value: null },\r\n\t\t\t'screenPosition': { value: null }\r\n\t\t},\r\n\t\tvertexShader: [\r\n\r\n\t\t\t'precision highp float;',\r\n\r\n\t\t\t'uniform vec3 screenPosition;',\r\n\t\t\t'uniform vec2 scale;',\r\n\r\n\t\t\t'attribute vec3 position;',\r\n\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\tvUV = uv;',\r\n\r\n\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ),\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t'precision highp float;',\r\n\r\n\t\t\t'uniform sampler2D map;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\tgl_FragColor = texture2D( map, vUV );',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ),\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false,\r\n\t\ttransparent: false\r\n\t} );\r\n\r\n\t// the following object is used for occlusionMap generation\r\n\r\n\tvar mesh1 = new Mesh( geometry, material1a );\r\n\r\n\t//\r\n\r\n\tvar elements = [];\r\n\r\n\tvar shader = LensflareElement.Shader;\r\n\r\n\tvar material2 = new RawShaderMaterial( {\r\n\t\tuniforms: {\r\n\t\t\t'map': { value: null },\r\n\t\t\t'occlusionMap': { value: occlusionMap },\r\n\t\t\t'color': { value: new Color( 0xffffff ) },\r\n\t\t\t'scale': { value: new Vector2() },\r\n\t\t\t'screenPosition': { value: new Vector3() }\r\n\t\t},\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader,\r\n\t\tblending: AdditiveBlending,\r\n\t\ttransparent: true,\r\n\t\tdepthWrite: false\r\n\t} );\r\n\r\n\tvar mesh2 = new Mesh( geometry, material2 );\r\n\r\n\tthis.addElement = function ( element ) {\r\n\r\n\t\telements.push( element );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tvar scale = new Vector2();\r\n\tvar screenPositionPixels = new Vector2();\r\n\tvar validArea = new Box2();\r\n\tvar viewport = new Vector4();\r\n\r\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\tviewport.copy( renderer.getCurrentViewport() );\r\n\r\n\t\tvar invAspect = viewport.w / viewport.z;\r\n\t\tvar halfViewportWidth = viewport.z / 2.0;\r\n\t\tvar halfViewportHeight = viewport.w / 2.0;\r\n\r\n\t\tvar size = 16 / viewport.w;\r\n\t\tscale.set( size * invAspect, size );\r\n\r\n\t\tvalidArea.min.set( viewport.x, viewport.y );\r\n\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\r\n\r\n\t\t// calculate position in screen space\r\n\r\n\t\tpositionScreen.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tpositionScreen.applyMatrix4( camera.matrixWorldInverse );\r\n\t\tpositionScreen.applyMatrix4( camera.projectionMatrix );\r\n\r\n\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\r\n\r\n\t\tscreenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;\r\n\t\tscreenPositionPixels.y = viewport.y + ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;\r\n\r\n\t\t// screen cull\r\n\r\n\t\tif ( validArea.containsPoint( screenPositionPixels ) ) {\r\n\r\n\t\t\t// save current RGB to temp texture\r\n\r\n\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, tempMap );\r\n\r\n\t\t\t// render pink quad\r\n\r\n\t\t\tvar uniforms = material1a.uniforms;\r\n\t\t\tuniforms.scale.value = scale;\r\n\t\t\tuniforms.screenPosition.value = positionScreen;\r\n\r\n\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null );\r\n\r\n\t\t\t// copy result to occlusionMap\r\n\r\n\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, occlusionMap );\r\n\r\n\t\t\t// restore graphics\r\n\r\n\t\t\tvar uniforms = material1b.uniforms;\r\n\t\t\tuniforms.scale.value = scale;\r\n\t\t\tuniforms.screenPosition.value = positionScreen;\r\n\r\n\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null );\r\n\r\n\t\t\t// render elements\r\n\r\n\t\t\tvar vecX = - positionScreen.x * 2;\r\n\t\t\tvar vecY = - positionScreen.y * 2;\r\n\r\n\t\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar element = elements[ i ];\r\n\r\n\t\t\t\tvar uniforms = material2.uniforms;\r\n\r\n\t\t\t\tuniforms.color.value.copy( element.color );\r\n\t\t\t\tuniforms.map.value = element.texture;\r\n\t\t\t\tuniforms.screenPosition.value.x = positionScreen.x + vecX * element.distance;\r\n\t\t\t\tuniforms.screenPosition.value.y = positionScreen.y + vecY * element.distance;\r\n\r\n\t\t\t\tvar size = element.size / viewport.w;\r\n\t\t\t\tvar invAspect = viewport.w / viewport.z;\r\n\r\n\t\t\t\tuniforms.scale.value.set( size * invAspect, size );\r\n\r\n\t\t\t\tmaterial2.uniformsNeedUpdate = true;\r\n\r\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tmaterial1a.dispose();\r\n\t\tmaterial1b.dispose();\r\n\t\tmaterial2.dispose();\r\n\r\n\t\ttempMap.dispose();\r\n\t\tocclusionMap.dispose();\r\n\r\n\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\r\n\r\n\t\t\telements[ i ].texture.dispose();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\nLensflare.prototype = Object.create( Mesh.prototype );\r\nLensflare.prototype.constructor = Lensflare;\r\nLensflare.prototype.isLensflare = true;\r\n\r\n//\r\n\r\nvar LensflareElement = function ( texture, size, distance, color ) {\r\n\r\n\tthis.texture = texture;\r\n\tthis.size = size || 1;\r\n\tthis.distance = distance || 0;\r\n\tthis.color = color || new Color( 0xffffff );\r\n\r\n};\r\n\r\nLensflareElement.Shader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'map': { value: null },\r\n\t\t'occlusionMap': { value: null },\r\n\t\t'color': { value: null },\r\n\t\t'scale': { value: null },\r\n\t\t'screenPosition': { value: null }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t'precision highp float;',\r\n\r\n\t\t'uniform vec3 screenPosition;',\r\n\t\t'uniform vec2 scale;',\r\n\r\n\t\t'uniform sampler2D occlusionMap;',\r\n\r\n\t\t'attribute vec3 position;',\r\n\t\t'attribute vec2 uv;',\r\n\r\n\t\t'varying vec2 vUV;',\r\n\t\t'varying float vVisibility;',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvUV = uv;',\r\n\r\n\t\t'\tvec2 pos = position.xy;',\r\n\r\n\t\t'\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',\r\n\r\n\t\t'\tvVisibility =        visibility.r / 9.0;',\r\n\t\t'\tvVisibility *= 1.0 - visibility.g / 9.0;',\r\n\t\t'\tvVisibility *=       visibility.b / 9.0;',\r\n\r\n\t\t'\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',\r\n\r\n\t\t'}'\r\n\r\n\t].join( '\\n' ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t'precision highp float;',\r\n\r\n\t\t'uniform sampler2D map;',\r\n\t\t'uniform vec3 color;',\r\n\r\n\t\t'varying vec2 vUV;',\r\n\t\t'varying float vVisibility;',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvec4 texture = texture2D( map, vUV );',\r\n\t\t'\ttexture.a *= vVisibility;',\r\n\t\t'\tgl_FragColor = texture;',\r\n\t\t'\tgl_FragColor.rgb *= color;',\r\n\r\n\t\t'}'\r\n\r\n\t].join( '\\n' )\r\n\r\n};\r\n\r\nLensflare.Geometry = ( function () {\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\r\n\tvar float32Array = new Float32Array( [\r\n\t\t- 1, - 1, 0, 0, 0,\r\n\t\t1, - 1, 0, 1, 0,\r\n\t\t1, 1, 0, 1, 1,\r\n\t\t- 1, 1, 0, 0, 1\r\n\t] );\r\n\r\n\tvar interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\r\n\r\n\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\r\n\tgeometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\r\n\tgeometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\r\n\r\n\treturn geometry;\r\n\r\n} )();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Reflector = function ( geometry, options ) {\r\n\r\n\tMesh.call( this, geometry );\r\n\r\n\tthis.type = 'Reflector';\r\n\r\n\tvar scope = this;\r\n\r\n\toptions = options || {};\r\n\r\n\tvar color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\r\n\tvar textureWidth = options.textureWidth || 512;\r\n\tvar textureHeight = options.textureHeight || 512;\r\n\tvar clipBias = options.clipBias || 0;\r\n\tvar shader = options.shader || Reflector.ReflectorShader;\r\n\tvar recursion = options.recursion !== undefined ? options.recursion : 0;\r\n\r\n\t//\r\n\r\n\tvar reflectorPlane = new Plane();\r\n\tvar normal = new Vector3();\r\n\tvar reflectorWorldPosition = new Vector3();\r\n\tvar cameraWorldPosition = new Vector3();\r\n\tvar rotationMatrix = new Matrix4();\r\n\tvar lookAtPosition = new Vector3( 0, 0, - 1 );\r\n\tvar clipPlane = new Vector4();\r\n\tvar viewport = new Vector4();\r\n\r\n\tvar view = new Vector3();\r\n\tvar target = new Vector3();\r\n\tvar q = new Vector4();\r\n\r\n\tvar textureMatrix = new Matrix4();\r\n\tvar virtualCamera = new PerspectiveCamera();\r\n\r\n\tvar parameters = {\r\n\t\tminFilter: LinearFilter,\r\n\t\tmagFilter: LinearFilter,\r\n\t\tformat: RGBFormat,\r\n\t\tstencilBuffer: false\r\n\t};\r\n\r\n\tvar renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );\r\n\r\n\tif ( ! _Math.isPowerOfTwo( textureWidth ) || ! _Math.isPowerOfTwo( textureHeight ) ) {\r\n\r\n\t\trenderTarget.texture.generateMipmaps = false;\r\n\r\n\t}\r\n\r\n\tvar material = new ShaderMaterial( {\r\n\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\r\n\t\tfragmentShader: shader.fragmentShader,\r\n\t\tvertexShader: shader.vertexShader\r\n\t} );\r\n\r\n\tmaterial.uniforms.tDiffuse.value = renderTarget.texture;\r\n\tmaterial.uniforms.color.value = color;\r\n\tmaterial.uniforms.textureMatrix.value = textureMatrix;\r\n\r\n\tthis.material = material;\r\n\tthis.renderOrder = - Infinity; // render first\r\n\r\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\tif ( 'recursion' in camera.userData ) {\r\n\r\n\t\t\tif ( camera.userData.recursion === recursion ) { return; }\r\n\r\n\t\t\tcamera.userData.recursion ++;\r\n\r\n\t\t}\r\n\r\n\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\r\n\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\r\n\r\n\t\trotationMatrix.extractRotation( scope.matrixWorld );\r\n\r\n\t\tnormal.set( 0, 0, 1 );\r\n\t\tnormal.applyMatrix4( rotationMatrix );\r\n\r\n\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\r\n\r\n\t\t// Avoid rendering when reflector is facing away\r\n\r\n\t\tif ( view.dot( normal ) > 0 ) { return; }\r\n\r\n\t\tview.reflect( normal ).negate();\r\n\t\tview.add( reflectorWorldPosition );\r\n\r\n\t\trotationMatrix.extractRotation( camera.matrixWorld );\r\n\r\n\t\tlookAtPosition.set( 0, 0, - 1 );\r\n\t\tlookAtPosition.applyMatrix4( rotationMatrix );\r\n\t\tlookAtPosition.add( cameraWorldPosition );\r\n\r\n\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\r\n\t\ttarget.reflect( normal ).negate();\r\n\t\ttarget.add( reflectorWorldPosition );\r\n\r\n\t\tvirtualCamera.position.copy( view );\r\n\t\tvirtualCamera.up.set( 0, 1, 0 );\r\n\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\r\n\t\tvirtualCamera.up.reflect( normal );\r\n\t\tvirtualCamera.lookAt( target );\r\n\r\n\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\r\n\r\n\t\tvirtualCamera.updateMatrixWorld();\r\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\r\n\r\n\t\tvirtualCamera.userData.recursion = 0;\r\n\r\n\t\t// Update the texture matrix\r\n\t\ttextureMatrix.set(\r\n\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t);\r\n\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\r\n\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\r\n\t\ttextureMatrix.multiply( scope.matrixWorld );\r\n\r\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\r\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\r\n\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\r\n\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\r\n\r\n\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\r\n\r\n\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\r\n\r\n\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\r\n\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\r\n\t\tq.z = - 1.0;\r\n\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\r\n\r\n\t\t// Calculate the scaled plane vector\r\n\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\r\n\r\n\t\t// Replacing the third row of the projection matrix\r\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\r\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\r\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\r\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\r\n\r\n\t\t// Render\r\n\r\n\t\tscope.visible = false;\r\n\r\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\tvar currentVrEnabled = renderer.vr.enabled;\r\n\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n\r\n\t\trenderer.vr.enabled = false; // Avoid camera modification and recursion\r\n\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\r\n\r\n\t\trenderer.render( scene, virtualCamera, renderTarget, true );\r\n\r\n\t\trenderer.vr.enabled = currentVrEnabled;\r\n\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n\r\n\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t\t// Restore viewport\r\n\r\n\t\tvar bounds = camera.bounds;\r\n\r\n\t\tif ( bounds !== undefined ) {\r\n\r\n\t\t\tvar size = renderer.getSize();\r\n\t\t\tvar pixelRatio = renderer.getPixelRatio();\r\n\r\n\t\t\tviewport.x = bounds.x * size.width * pixelRatio;\r\n\t\t\tviewport.y = bounds.y * size.height * pixelRatio;\r\n\t\t\tviewport.z = bounds.z * size.width * pixelRatio;\r\n\t\t\tviewport.w = bounds.w * size.height * pixelRatio;\r\n\r\n\t\t\trenderer.state.viewport( viewport );\r\n\r\n\t\t}\r\n\r\n\t\tscope.visible = true;\r\n\r\n\t};\r\n\r\n\tthis.getRenderTarget = function () {\r\n\r\n\t\treturn renderTarget;\r\n\r\n\t};\r\n\r\n};\r\n\r\nReflector.prototype = Object.create( Mesh.prototype );\r\nReflector.prototype.constructor = Reflector;\r\n\r\nReflector.ReflectorShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'color': {\r\n\t\t\ttype: 'c',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tDiffuse': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'textureMatrix': {\r\n\t\t\ttype: 'm4',\r\n\t\t\tvalue: null\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\t\t'uniform mat4 textureMatrix;',\r\n\t\t'varying vec4 vUv;',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\r\n\r\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n\r\n\t\t'}'\r\n\t].join( '\\n' ),\r\n\r\n\tfragmentShader: [\r\n\t\t'uniform vec3 color;',\r\n\t\t'uniform sampler2D tDiffuse;',\r\n\t\t'varying vec4 vUv;',\r\n\r\n\t\t'float blendOverlay( float base, float blend ) {',\r\n\r\n\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\r\n\r\n\t\t'}',\r\n\r\n\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\r\n\r\n\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\r\n\r\n\t\t'}',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\r\n\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\r\n\r\n\t\t'}'\r\n\t].join( '\\n' )\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvar ReflectorRTT = function ( geometry, options ) {\n\n\tReflector.call( this, geometry, options );\n\n\tthis.geometry.setDrawRange( 0, 0 ); // avoid rendering geometry\n\n};\n\nReflectorRTT.prototype = Object.create( Reflector.prototype );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Refractor = function ( geometry, options ) {\r\n\r\n\tMesh.call( this, geometry );\r\n\r\n\tthis.type = 'Refractor';\r\n\r\n\tvar scope = this;\r\n\r\n\toptions = options || {};\r\n\r\n\tvar color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\r\n\tvar textureWidth = options.textureWidth || 512;\r\n\tvar textureHeight = options.textureHeight || 512;\r\n\tvar clipBias = options.clipBias || 0;\r\n\tvar shader = options.shader || Refractor.RefractorShader;\r\n\r\n\t//\r\n\r\n\tvar virtualCamera = new PerspectiveCamera();\r\n\tvirtualCamera.matrixAutoUpdate = false;\r\n\tvirtualCamera.userData.refractor = true;\r\n\r\n\t//\r\n\r\n\tvar refractorPlane = new Plane();\r\n\tvar textureMatrix = new Matrix4();\r\n\r\n\t// render target\r\n\r\n\tvar parameters = {\r\n\t\tminFilter: LinearFilter,\r\n\t\tmagFilter: LinearFilter,\r\n\t\tformat: RGBFormat,\r\n\t\tstencilBuffer: false\r\n\t};\r\n\r\n\tvar renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );\r\n\r\n\tif ( ! _Math.isPowerOfTwo( textureWidth ) || ! _Math.isPowerOfTwo( textureHeight ) ) {\r\n\r\n\t\trenderTarget.texture.generateMipmaps = false;\r\n\r\n\t}\r\n\r\n\t// material\r\n\r\n\tthis.material = new ShaderMaterial( {\r\n\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader,\r\n\t\ttransparent: true // ensures, refractors are drawn from farthest to closest\r\n\t} );\r\n\r\n\tthis.material.uniforms.color.value = color;\r\n\tthis.material.uniforms.tDiffuse.value = renderTarget.texture;\r\n\tthis.material.uniforms.textureMatrix.value = textureMatrix;\r\n\r\n\t// functions\r\n\r\n\tvar visible = ( function () {\r\n\r\n\t\tvar refractorWorldPosition = new Vector3();\r\n\t\tvar cameraWorldPosition = new Vector3();\r\n\t\tvar rotationMatrix = new Matrix4();\r\n\r\n\t\tvar view = new Vector3();\r\n\t\tvar normal = new Vector3();\r\n\r\n\t\treturn function visible( camera ) {\r\n\r\n\t\t\trefractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\r\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\r\n\r\n\t\t\tview.subVectors( refractorWorldPosition, cameraWorldPosition );\r\n\r\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t\tnormal.applyMatrix4( rotationMatrix );\r\n\r\n\t\t\treturn view.dot( normal ) < 0;\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n\tvar updateRefractorPlane = ( function () {\r\n\r\n\t\tvar normal = new Vector3();\r\n\t\tvar position = new Vector3();\r\n\t\tvar quaternion = new Quaternion();\r\n\t\tvar scale = new Vector3();\r\n\r\n\t\treturn function updateRefractorPlane() {\r\n\r\n\t\t\tscope.matrixWorld.decompose( position, quaternion, scale );\r\n\t\t\tnormal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();\r\n\r\n\t\t\t// flip the normal because we want to cull everything above the plane\r\n\r\n\t\t\tnormal.negate();\r\n\r\n\t\t\trefractorPlane.setFromNormalAndCoplanarPoint( normal, position );\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n\tvar updateVirtualCamera = ( function () {\r\n\r\n\t\tvar clipPlane = new Plane();\r\n\t\tvar clipVector = new Vector4();\r\n\t\tvar q = new Vector4();\r\n\r\n\t\treturn function updateVirtualCamera( camera ) {\r\n\r\n\t\t\tvirtualCamera.matrixWorld.copy( camera.matrixWorld );\r\n\t\t\tvirtualCamera.matrixWorldInverse.getInverse( virtualCamera.matrixWorld );\r\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\r\n\t\t\tvirtualCamera.far = camera.far; // used in WebGLBackground\r\n\r\n\t\t\t// The following code creates an oblique view frustum for clipping.\r\n\t\t\t// see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\r\n\t\t\t// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\r\n\r\n\t\t\tclipPlane.copy( refractorPlane );\r\n\t\t\tclipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\r\n\r\n\t\t\tclipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );\r\n\r\n\t\t\t// calculate the clip-space corner point opposite the clipping plane and\r\n\t\t\t// transform it into camera space by multiplying it by the inverse of the projection matrix\r\n\r\n\t\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\r\n\r\n\t\t\tq.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\r\n\t\t\tq.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\r\n\t\t\tq.z = - 1.0;\r\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\r\n\r\n\t\t\t// calculate the scaled plane vector\r\n\r\n\t\t\tclipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );\r\n\r\n\t\t\t// replacing the third row of the projection matrix\r\n\r\n\t\t\tprojectionMatrix.elements[ 2 ] = clipVector.x;\r\n\t\t\tprojectionMatrix.elements[ 6 ] = clipVector.y;\r\n\t\t\tprojectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;\r\n\t\t\tprojectionMatrix.elements[ 14 ] = clipVector.w;\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n\t// This will update the texture matrix that is used for projective texture mapping in the shader.\r\n\t// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\r\n\r\n\tfunction updateTextureMatrix( camera ) {\r\n\r\n\t\t// this matrix does range mapping to [ 0, 1 ]\r\n\r\n\t\ttextureMatrix.set(\r\n\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t);\r\n\r\n\t\t// we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\r\n\t\t// (matrix above) with the projection and view matrix of the virtual camera\r\n\t\t// and the model matrix of the refractor\r\n\r\n\t\ttextureMatrix.multiply( camera.projectionMatrix );\r\n\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\r\n\t\ttextureMatrix.multiply( scope.matrixWorld );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar render = ( function () {\r\n\r\n\t\tvar viewport = new Vector4();\r\n\r\n\t\treturn function render( renderer, scene, camera ) {\r\n\r\n\t\t\tscope.visible = false;\r\n\r\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\r\n\t\t\tvar currentVrEnabled = renderer.vr.enabled;\r\n\t\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n\r\n\t\t\trenderer.vr.enabled = false; // avoid camera modification\r\n\t\t\trenderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\r\n\r\n\t\t\trenderer.render( scene, virtualCamera, renderTarget, true );\r\n\r\n\t\t\trenderer.vr.enabled = currentVrEnabled;\r\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t\t\t// restore viewport\r\n\r\n\t\t\tvar bounds = camera.bounds;\r\n\r\n\t\t\tif ( bounds !== undefined ) {\r\n\r\n\t\t\t\tvar size = renderer.getSize();\r\n\t\t\t\tvar pixelRatio = renderer.getPixelRatio();\r\n\r\n\t\t\t\tviewport.x = bounds.x * size.width * pixelRatio;\r\n\t\t\t\tviewport.y = bounds.y * size.height * pixelRatio;\r\n\t\t\t\tviewport.z = bounds.z * size.width * pixelRatio;\r\n\t\t\t\tviewport.w = bounds.w * size.height * pixelRatio;\r\n\r\n\t\t\t\trenderer.state.viewport( viewport );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.visible = true;\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n\t//\r\n\r\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\t// ensure refractors are rendered only once per frame\r\n\r\n\t\tif ( camera.userData.refractor === true ) { return; }\r\n\r\n\t\t// avoid rendering when the refractor is viewed from behind\r\n\r\n\t\tif ( ! visible( camera ) === true ) { return; }\r\n\r\n\t\t// update\r\n\r\n\t\tupdateRefractorPlane();\r\n\r\n\t\tupdateTextureMatrix( camera );\r\n\r\n\t\tupdateVirtualCamera( camera );\r\n\r\n\t\trender( renderer, scene, camera );\r\n\r\n\t};\r\n\r\n\tthis.getRenderTarget = function () {\r\n\r\n\t\treturn renderTarget;\r\n\r\n\t};\r\n\r\n};\r\n\r\nRefractor.prototype = Object.create( Mesh.prototype );\r\nRefractor.prototype.constructor = Refractor;\r\n\r\nRefractor.RefractorShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'color': {\r\n\t\t\ttype: 'c',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tDiffuse': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'textureMatrix': {\r\n\t\t\ttype: 'm4',\r\n\t\t\tvalue: null\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t'uniform mat4 textureMatrix;',\r\n\r\n\t\t'varying vec4 vUv;',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\r\n\r\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n\r\n\t\t'}'\r\n\r\n\t].join( '\\n' ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t'uniform vec3 color;',\r\n\t\t'uniform sampler2D tDiffuse;',\r\n\r\n\t\t'varying vec4 vUv;',\r\n\r\n\t\t'float blendOverlay( float base, float blend ) {',\r\n\r\n\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\r\n\r\n\t\t'}',\r\n\r\n\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\r\n\r\n\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\r\n\r\n\t\t'}',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\r\n\r\n\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\r\n\r\n\t\t'}'\r\n\r\n\t].join( '\\n' )\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ShadowMesh = function ( mesh ) {\r\n\r\n\tvar shadowMaterial = new MeshBasicMaterial( {\r\n\r\n\t\tcolor: 0x000000,\r\n\t\ttransparent: true,\r\n\t\topacity: 0.6,\r\n\t\tdepthWrite: false\r\n\r\n\t} );\r\n\r\n\tMesh.call( this, mesh.geometry, shadowMaterial );\r\n\r\n\tthis.meshMatrix = mesh.matrixWorld;\r\n\r\n\tthis.frustumCulled = false;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nShadowMesh.prototype = Object.create( Mesh.prototype );\r\nShadowMesh.prototype.constructor = ShadowMesh;\r\n\r\nShadowMesh.prototype.update = function () {\r\n\r\n\tvar shadowMatrix = new Matrix4();\r\n\r\n\treturn function ( plane, lightPosition4D ) {\r\n\r\n\t\t// based on https://www.opengl.org/archives/resources/features/StencilTalk/tsld021.htm\r\n\r\n\t\tvar dot = plane.normal.x * lightPosition4D.x +\r\n\t\t\t  plane.normal.y * lightPosition4D.y +\r\n\t\t\t  plane.normal.z * lightPosition4D.z +\r\n\t\t\t  - plane.constant * lightPosition4D.w;\r\n\r\n\t\tvar sme = shadowMatrix.elements;\r\n\r\n\t\tsme[ 0 ]  = dot - lightPosition4D.x * plane.normal.x;\r\n\t\tsme[ 4 ]  = - lightPosition4D.x * plane.normal.y;\r\n\t\tsme[ 8 ]  = - lightPosition4D.x * plane.normal.z;\r\n\t\tsme[ 12 ] = - lightPosition4D.x * - plane.constant;\r\n\r\n\t\tsme[ 1 ]  = - lightPosition4D.y * plane.normal.x;\r\n\t\tsme[ 5 ]  = dot - lightPosition4D.y * plane.normal.y;\r\n\t\tsme[ 9 ]  = - lightPosition4D.y * plane.normal.z;\r\n\t\tsme[ 13 ] = - lightPosition4D.y * - plane.constant;\r\n\r\n\t\tsme[ 2 ]  = - lightPosition4D.z * plane.normal.x;\r\n\t\tsme[ 6 ]  = - lightPosition4D.z * plane.normal.y;\r\n\t\tsme[ 10 ] = dot - lightPosition4D.z * plane.normal.z;\r\n\t\tsme[ 14 ] = - lightPosition4D.z * - plane.constant;\r\n\r\n\t\tsme[ 3 ]  = - lightPosition4D.w * plane.normal.x;\r\n\t\tsme[ 7 ]  = - lightPosition4D.w * plane.normal.y;\r\n\t\tsme[ 11 ] = - lightPosition4D.w * plane.normal.z;\r\n\t\tsme[ 15 ] = dot - lightPosition4D.w * - plane.constant;\r\n\r\n\t\tthis.matrix.multiplyMatrices( shadowMatrix, this.meshMatrix );\r\n\r\n\t};\r\n\r\n}();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Sky = function () {\r\n\r\n\tvar shader = Sky.SkyShader;\r\n\r\n\tvar material = new ShaderMaterial( {\r\n\t\tfragmentShader: shader.fragmentShader,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\r\n\t\tside: BackSide\r\n\t} );\r\n\r\n\tMesh.call( this, new BoxBufferGeometry( 1, 1, 1 ), material );\r\n\r\n};\r\n\r\nSky.prototype = Object.create( Mesh.prototype );\r\n\r\nSky.SkyShader = {\r\n\r\n\tuniforms: {\r\n\t\tluminance: { value: 1 },\r\n\t\tturbidity: { value: 2 },\r\n\t\trayleigh: { value: 1 },\r\n\t\tmieCoefficient: { value: 0.005 },\r\n\t\tmieDirectionalG: { value: 0.8 },\r\n\t\tsunPosition: { value: new Vector3() }\r\n\t},\r\n\r\n\tvertexShader: [\r\n\t\t'uniform vec3 sunPosition;',\r\n\t\t'uniform float rayleigh;',\r\n\t\t'uniform float turbidity;',\r\n\t\t'uniform float mieCoefficient;',\r\n\r\n\t\t'varying vec3 vWorldPosition;',\r\n\t\t'varying vec3 vSunDirection;',\r\n\t\t'varying float vSunfade;',\r\n\t\t'varying vec3 vBetaR;',\r\n\t\t'varying vec3 vBetaM;',\r\n\t\t'varying float vSunE;',\r\n\r\n\t\t'const vec3 up = vec3( 0.0, 1.0, 0.0 );',\r\n\r\n\t\t// constants for atmospheric scattering\r\n\t\t'const float e = 2.71828182845904523536028747135266249775724709369995957;',\r\n\t\t'const float pi = 3.141592653589793238462643383279502884197169;',\r\n\r\n\t\t// wavelength of used primaries, according to preetham\r\n\t\t'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );',\r\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\r\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\r\n\t\t'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );',\r\n\r\n\t\t// mie stuff\r\n\t\t// K coefficient for the primaries\r\n\t\t'const float v = 4.0;',\r\n\t\t'const vec3 K = vec3( 0.686, 0.678, 0.666 );',\r\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\r\n\t\t'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );',\r\n\r\n\t\t// earth shadow hack\r\n\t\t// cutoffAngle = pi / 1.95;\r\n\t\t'const float cutoffAngle = 1.6110731556870734;',\r\n\t\t'const float steepness = 1.5;',\r\n\t\t'const float EE = 1000.0;',\r\n\r\n\t\t'float sunIntensity( float zenithAngleCos ) {',\r\n\t\t'\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );',\r\n\t\t'\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );',\r\n\t\t'}',\r\n\r\n\t\t'vec3 totalMie( float T ) {',\r\n\t\t'\tfloat c = ( 0.2 * T ) * 10E-18;',\r\n\t\t'\treturn 0.434 * c * MieConst;',\r\n\t\t'}',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\r\n\t\t'\tvWorldPosition = worldPosition.xyz;',\r\n\r\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n\t\t'\tgl_Position.z = gl_Position.w;', // set z to camera.far\r\n\r\n\t\t'\tvSunDirection = normalize( sunPosition );',\r\n\r\n\t\t'\tvSunE = sunIntensity( dot( vSunDirection, up ) );',\r\n\r\n\t\t'\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );',\r\n\r\n\t\t'\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );',\r\n\r\n\t\t// extinction (absorbtion + out scattering)\r\n\t\t// rayleigh coefficients\r\n\t\t'\tvBetaR = totalRayleigh * rayleighCoefficient;',\r\n\r\n\t\t// mie coefficients\r\n\t\t'\tvBetaM = totalMie( turbidity ) * mieCoefficient;',\r\n\r\n\t\t'}'\r\n\t].join( '\\n' ),\r\n\r\n\tfragmentShader: [\r\n\t\t'varying vec3 vWorldPosition;',\r\n\t\t'varying vec3 vSunDirection;',\r\n\t\t'varying float vSunfade;',\r\n\t\t'varying vec3 vBetaR;',\r\n\t\t'varying vec3 vBetaM;',\r\n\t\t'varying float vSunE;',\r\n\r\n\t\t'uniform float luminance;',\r\n\t\t'uniform float mieDirectionalG;',\r\n\r\n\t\t'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );',\r\n\r\n\t\t// constants for atmospheric scattering\r\n\t\t'const float pi = 3.141592653589793238462643383279502884197169;',\r\n\r\n\t\t'const float n = 1.0003;', // refractive index of air\r\n\t\t'const float N = 2.545E25;', // number of molecules per unit volume for air at\r\n\t\t\t\t\t\t\t\t\t// 288.15K and 1013mb (sea level -45 celsius)\r\n\r\n\t\t// optical length at zenith for molecules\r\n\t\t'const float rayleighZenithLength = 8.4E3;',\r\n\t\t'const float mieZenithLength = 1.25E3;',\r\n\t\t'const vec3 up = vec3( 0.0, 1.0, 0.0 );',\r\n\t\t// 66 arc seconds -> degrees, and the cosine of that\r\n\t\t'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;',\r\n\r\n\t\t// 3.0 / ( 16.0 * pi )\r\n\t\t'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;',\r\n\t\t// 1.0 / ( 4.0 * pi )\r\n\t\t'const float ONE_OVER_FOURPI = 0.07957747154594767;',\r\n\r\n\t\t'float rayleighPhase( float cosTheta ) {',\r\n\t\t'\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );',\r\n\t\t'}',\r\n\r\n\t\t'float hgPhase( float cosTheta, float g ) {',\r\n\t\t'\tfloat g2 = pow( g, 2.0 );',\r\n\t\t'\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );',\r\n\t\t'\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );',\r\n\t\t'}',\r\n\r\n\t\t// Filmic ToneMapping http://filmicgames.com/archives/75\r\n\t\t'const float A = 0.15;',\r\n\t\t'const float B = 0.50;',\r\n\t\t'const float C = 0.10;',\r\n\t\t'const float D = 0.20;',\r\n\t\t'const float E = 0.02;',\r\n\t\t'const float F = 0.30;',\r\n\r\n\t\t'const float whiteScale = 1.0748724675633854;', // 1.0 / Uncharted2Tonemap(1000.0)\r\n\r\n\t\t'vec3 Uncharted2Tonemap( vec3 x ) {',\r\n\t\t'\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;',\r\n\t\t'}',\r\n\r\n\t\t'void main() {',\r\n\t\t// optical length\r\n\t\t// cutoff angle at 90 to avoid singularity in next formula.\r\n\t\t'\tfloat zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );',\r\n\t\t'\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );',\r\n\t\t'\tfloat sR = rayleighZenithLength * inverse;',\r\n\t\t'\tfloat sM = mieZenithLength * inverse;',\r\n\r\n\t\t// combined extinction factor\r\n\t\t'\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );',\r\n\r\n\t\t// in scattering\r\n\t\t'\tfloat cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );',\r\n\r\n\t\t'\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );',\r\n\t\t'\tvec3 betaRTheta = vBetaR * rPhase;',\r\n\r\n\t\t'\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );',\r\n\t\t'\tvec3 betaMTheta = vBetaM * mPhase;',\r\n\r\n\t\t'\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );',\r\n\t\t'\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );',\r\n\r\n\t\t// nightsky\r\n\t\t'\tvec3 direction = normalize( vWorldPosition - cameraPos );',\r\n\t\t'\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]',\r\n\t\t'\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]',\r\n\t\t'\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );',\r\n\t\t'\tvec3 L0 = vec3( 0.1 ) * Fex;',\r\n\r\n\t\t// composition + solar disc\r\n\t\t'\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );',\r\n\t\t'\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;',\r\n\r\n\t\t'\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );',\r\n\r\n\t\t'\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );',\r\n\t\t'\tvec3 color = curr * whiteScale;',\r\n\r\n\t\t'\tvec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );',\r\n\r\n\t\t'\tgl_FragColor = vec4( retColor, 1.0 );',\r\n\r\n\t\t'}'\r\n\t].join( '\\n' )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Water = function ( geometry, options ) {\r\n\r\n\tMesh.call( this, geometry );\r\n\r\n\tvar scope = this;\r\n\r\n\toptions = options || {};\r\n\r\n\tvar textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\r\n\tvar textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\r\n\r\n\tvar clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\r\n\tvar alpha = options.alpha !== undefined ? options.alpha : 1.0;\r\n\tvar time = options.time !== undefined ? options.time : 0.0;\r\n\tvar normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\r\n\tvar sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3( 0.70707, 0.70707, 0.0 );\r\n\tvar sunColor = new Color( options.sunColor !== undefined ? options.sunColor : 0xffffff );\r\n\tvar waterColor = new Color( options.waterColor !== undefined ? options.waterColor : 0x7F7F7F );\r\n\tvar eye = options.eye !== undefined ? options.eye : new Vector3( 0, 0, 0 );\r\n\tvar distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\r\n\tvar side = options.side !== undefined ? options.side : FrontSide;\r\n\tvar fog = options.fog !== undefined ? options.fog : false;\r\n\r\n\t//\r\n\r\n\tvar mirrorPlane = new Plane();\r\n\tvar normal = new Vector3();\r\n\tvar mirrorWorldPosition = new Vector3();\r\n\tvar cameraWorldPosition = new Vector3();\r\n\tvar rotationMatrix = new Matrix4();\r\n\tvar lookAtPosition = new Vector3( 0, 0, - 1 );\r\n\tvar clipPlane = new Vector4();\r\n\r\n\tvar view = new Vector3();\r\n\tvar target = new Vector3();\r\n\tvar q = new Vector4();\r\n\r\n\tvar textureMatrix = new Matrix4();\r\n\r\n\tvar mirrorCamera = new PerspectiveCamera();\r\n\r\n\tvar parameters = {\r\n\t\tminFilter: LinearFilter,\r\n\t\tmagFilter: LinearFilter,\r\n\t\tformat: RGBFormat,\r\n\t\tstencilBuffer: false\r\n\t};\r\n\r\n\tvar renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );\r\n\r\n\tif ( ! _Math.isPowerOfTwo( textureWidth ) || ! _Math.isPowerOfTwo( textureHeight ) ) {\r\n\r\n\t\trenderTarget.texture.generateMipmaps = false;\r\n\r\n\t}\r\n\r\n\tvar mirrorShader = {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib[ 'fog' ],\r\n\t\t\tUniformsLib[ 'lights' ],\r\n\t\t\t{\r\n\t\t\t\tnormalSampler: { value: null },\r\n\t\t\t\tmirrorSampler: { value: null },\r\n\t\t\t\talpha: { value: 1.0 },\r\n\t\t\t\ttime: { value: 0.0 },\r\n\t\t\t\tsize: { value: 1.0 },\r\n\t\t\t\tdistortionScale: { value: 20.0 },\r\n\t\t\t\ttextureMatrix: { value: new Matrix4() },\r\n\t\t\t\tsunColor: { value: new Color( 0x7F7F7F ) },\r\n\t\t\t\tsunDirection: { value: new Vector3( 0.70707, 0.70707, 0 ) },\r\n\t\t\t\teye: { value: new Vector3() },\r\n\t\t\t\twaterColor: { value: new Color( 0x555555 ) }\r\n\t\t\t}\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\t\t\t'uniform mat4 textureMatrix;',\r\n\t\t\t'uniform float time;',\r\n\r\n\t\t\t'varying vec4 mirrorCoord;',\r\n\t\t\t'varying vec4 worldPosition;',\r\n\r\n\t\t\tShaderChunk[ 'fog_pars_vertex' ],\r\n\t\t\tShaderChunk[ 'shadowmap_pars_vertex' ],\r\n\r\n\t\t\t'void main() {',\r\n\t\t\t'\tmirrorCoord = modelMatrix * vec4( position, 1.0 );',\r\n\t\t\t'\tworldPosition = mirrorCoord.xyzw;',\r\n\t\t\t'\tmirrorCoord = textureMatrix * mirrorCoord;',\r\n\t\t\t'\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );',\r\n\t\t\t'\tgl_Position = projectionMatrix * mvPosition;',\r\n\r\n\t\t\tShaderChunk[ 'fog_vertex' ],\r\n\t\t\tShaderChunk[ 'shadowmap_vertex' ],\r\n\r\n\t\t\t'}'\r\n\t\t].join( '\\n' ),\r\n\r\n\t\tfragmentShader: [\r\n\t\t\t'uniform sampler2D mirrorSampler;',\r\n\t\t\t'uniform float alpha;',\r\n\t\t\t'uniform float time;',\r\n\t\t\t'uniform float size;',\r\n\t\t\t'uniform float distortionScale;',\r\n\t\t\t'uniform sampler2D normalSampler;',\r\n\t\t\t'uniform vec3 sunColor;',\r\n\t\t\t'uniform vec3 sunDirection;',\r\n\t\t\t'uniform vec3 eye;',\r\n\t\t\t'uniform vec3 waterColor;',\r\n\r\n\t\t\t'varying vec4 mirrorCoord;',\r\n\t\t\t'varying vec4 worldPosition;',\r\n\r\n\t\t\t'vec4 getNoise( vec2 uv ) {',\r\n\t\t\t'\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);',\r\n\t\t\t'\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );',\r\n\t\t\t'\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );',\r\n\t\t\t'\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );',\r\n\t\t\t'\tvec4 noise = texture2D( normalSampler, uv0 ) +',\r\n\t\t\t'\t\ttexture2D( normalSampler, uv1 ) +',\r\n\t\t\t'\t\ttexture2D( normalSampler, uv2 ) +',\r\n\t\t\t'\t\ttexture2D( normalSampler, uv3 );',\r\n\t\t\t'\treturn noise * 0.5 - 1.0;',\r\n\t\t\t'}',\r\n\r\n\t\t\t'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {',\r\n\t\t\t'\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );',\r\n\t\t\t'\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );',\r\n\t\t\t'\tspecularColor += pow( direction, shiny ) * sunColor * spec;',\r\n\t\t\t'\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;',\r\n\t\t\t'}',\r\n\r\n\t\t\tShaderChunk[ 'common' ],\r\n\t\t\tShaderChunk[ 'packing' ],\r\n\t\t\tShaderChunk[ 'bsdfs' ],\r\n\t\t\tShaderChunk[ 'fog_pars_fragment' ],\r\n\t\t\tShaderChunk[ 'lights_pars_begin' ],\r\n\t\t\tShaderChunk[ 'shadowmap_pars_fragment' ],\r\n\t\t\tShaderChunk[ 'shadowmask_pars_fragment' ],\r\n\r\n\t\t\t'void main() {',\r\n\t\t\t'\tvec4 noise = getNoise( worldPosition.xz * size );',\r\n\t\t\t'\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );',\r\n\r\n\t\t\t'\tvec3 diffuseLight = vec3(0.0);',\r\n\t\t\t'\tvec3 specularLight = vec3(0.0);',\r\n\r\n\t\t\t'\tvec3 worldToEye = eye-worldPosition.xyz;',\r\n\t\t\t'\tvec3 eyeDirection = normalize( worldToEye );',\r\n\t\t\t'\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );',\r\n\r\n\t\t\t'\tfloat distance = length(worldToEye);',\r\n\r\n\t\t\t'\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;',\r\n\t\t\t'\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.z + distortion ) );',\r\n\r\n\t\t\t'\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );',\r\n\t\t\t'\tfloat rf0 = 0.3;',\r\n\t\t\t'\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );',\r\n\t\t\t'\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;',\r\n\t\t\t'\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);',\r\n\t\t\t'\tvec3 outgoingLight = albedo;',\r\n\t\t\t'\tgl_FragColor = vec4( outgoingLight, alpha );',\r\n\r\n\t\t\tShaderChunk[ 'tonemapping_fragment' ],\r\n\t\t\tShaderChunk[ 'fog_fragment' ],\r\n\r\n\t\t\t'}'\r\n\t\t].join( '\\n' )\r\n\r\n\t};\r\n\r\n\tvar material = new ShaderMaterial( {\r\n\t\tfragmentShader: mirrorShader.fragmentShader,\r\n\t\tvertexShader: mirrorShader.vertexShader,\r\n\t\tuniforms: UniformsUtils.clone( mirrorShader.uniforms ),\r\n\t\ttransparent: true,\r\n\t\tlights: true,\r\n\t\tside: side,\r\n\t\tfog: fog\r\n\t} );\r\n\r\n\tmaterial.uniforms.mirrorSampler.value = renderTarget.texture;\r\n\tmaterial.uniforms.textureMatrix.value = textureMatrix;\r\n\tmaterial.uniforms.alpha.value = alpha;\r\n\tmaterial.uniforms.time.value = time;\r\n\tmaterial.uniforms.normalSampler.value = normalSampler;\r\n\tmaterial.uniforms.sunColor.value = sunColor;\r\n\tmaterial.uniforms.waterColor.value = waterColor;\r\n\tmaterial.uniforms.sunDirection.value = sunDirection;\r\n\tmaterial.uniforms.distortionScale.value = distortionScale;\r\n\r\n\tmaterial.uniforms.eye.value = eye;\r\n\r\n\tscope.material = material;\r\n\r\n\tscope.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\tmirrorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\r\n\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\r\n\r\n\t\trotationMatrix.extractRotation( scope.matrixWorld );\r\n\r\n\t\tnormal.set( 0, 0, 1 );\r\n\t\tnormal.applyMatrix4( rotationMatrix );\r\n\r\n\t\tview.subVectors( mirrorWorldPosition, cameraWorldPosition );\r\n\r\n\t\t// Avoid rendering when mirror is facing away\r\n\r\n\t\tif ( view.dot( normal ) > 0 ) { return; }\r\n\r\n\t\tview.reflect( normal ).negate();\r\n\t\tview.add( mirrorWorldPosition );\r\n\r\n\t\trotationMatrix.extractRotation( camera.matrixWorld );\r\n\r\n\t\tlookAtPosition.set( 0, 0, - 1 );\r\n\t\tlookAtPosition.applyMatrix4( rotationMatrix );\r\n\t\tlookAtPosition.add( cameraWorldPosition );\r\n\r\n\t\ttarget.subVectors( mirrorWorldPosition, lookAtPosition );\r\n\t\ttarget.reflect( normal ).negate();\r\n\t\ttarget.add( mirrorWorldPosition );\r\n\r\n\t\tmirrorCamera.position.copy( view );\r\n\t\tmirrorCamera.up.set( 0, 1, 0 );\r\n\t\tmirrorCamera.up.applyMatrix4( rotationMatrix );\r\n\t\tmirrorCamera.up.reflect( normal );\r\n\t\tmirrorCamera.lookAt( target );\r\n\r\n\t\tmirrorCamera.far = camera.far; // Used in WebGLBackground\r\n\r\n\t\tmirrorCamera.updateMatrixWorld();\r\n\t\tmirrorCamera.projectionMatrix.copy( camera.projectionMatrix );\r\n\r\n\t\t// Update the texture matrix\r\n\t\ttextureMatrix.set(\r\n\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t);\r\n\t\ttextureMatrix.multiply( mirrorCamera.projectionMatrix );\r\n\t\ttextureMatrix.multiply( mirrorCamera.matrixWorldInverse );\r\n\r\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\r\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\r\n\t\tmirrorPlane.setFromNormalAndCoplanarPoint( normal, mirrorWorldPosition );\r\n\t\tmirrorPlane.applyMatrix4( mirrorCamera.matrixWorldInverse );\r\n\r\n\t\tclipPlane.set( mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant );\r\n\r\n\t\tvar projectionMatrix = mirrorCamera.projectionMatrix;\r\n\r\n\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\r\n\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\r\n\t\tq.z = - 1.0;\r\n\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\r\n\r\n\t\t// Calculate the scaled plane vector\r\n\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\r\n\r\n\t\t// Replacing the third row of the projection matrix\r\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\r\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\r\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\r\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\r\n\r\n\t\teye.setFromMatrixPosition( camera.matrixWorld );\r\n\r\n\t\t//\r\n\r\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\tvar currentVrEnabled = renderer.vr.enabled;\r\n\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n\r\n\t\tscope.visible = false;\r\n\r\n\t\trenderer.vr.enabled = false; // Avoid camera modification and recursion\r\n\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\r\n\r\n\t\trenderer.render( scene, mirrorCamera, renderTarget, true );\r\n\r\n\t\tscope.visible = true;\r\n\r\n\t\trenderer.vr.enabled = currentVrEnabled;\r\n\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n\r\n\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t};\r\n\r\n};\r\n\r\nWater.prototype = Object.create( Mesh.prototype );\r\nWater.prototype.constructor = Water;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Clock( autoStart ) {\r\n\r\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.oldTime = 0;\r\n\tthis.elapsedTime = 0;\r\n\r\n\tthis.running = false;\r\n\r\n}\r\n\r\nObject.assign( Clock.prototype, {\r\n\r\n\tstart: function () {\r\n\r\n\t\tthis.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\r\n\r\n\t\tthis.oldTime = this.startTime;\r\n\t\tthis.elapsedTime = 0;\r\n\t\tthis.running = true;\r\n\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.getElapsedTime();\r\n\t\tthis.running = false;\r\n\t\tthis.autoStart = false;\r\n\r\n\t},\r\n\r\n\tgetElapsedTime: function () {\r\n\r\n\t\tthis.getDelta();\r\n\t\treturn this.elapsedTime;\r\n\r\n\t},\r\n\r\n\tgetDelta: function () {\r\n\r\n\t\tvar diff = 0;\r\n\r\n\t\tif ( this.autoStart && ! this.running ) {\r\n\r\n\t\t\tthis.start();\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.running ) {\r\n\r\n\t\t\tvar newTime = ( typeof performance === 'undefined' ? Date : performance ).now();\r\n\r\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\r\n\t\t\tthis.oldTime = newTime;\r\n\r\n\t\t\tthis.elapsedTime += diff;\r\n\r\n\t\t}\r\n\r\n\t\treturn diff;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Water2( geometry, options ) {\r\n\r\n\tMesh.call( this, geometry );\r\n\r\n\tthis.type = 'Water2';\r\n\r\n\tvar scope = this;\r\n\r\n\toptions = options || {};\r\n\r\n\tvar color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0xFFFFFF );\r\n\tvar textureWidth = options.textureWidth || 512;\r\n\tvar textureHeight = options.textureHeight || 512;\r\n\tvar clipBias = options.clipBias || 0;\r\n\tvar flowDirection = options.flowDirection || new Vector2( 1, 0 );\r\n\tvar flowSpeed = options.flowSpeed || 0.03;\r\n\tvar reflectivity = options.reflectivity || 0.02;\r\n\tvar scale = options.scale || 1;\r\n\tvar shader = options.shader || Water2.Water2Shader;\r\n\r\n\tvar textureLoader = new TextureLoader();\r\n\r\n\tvar flowMap = options.flowMap || undefined;\r\n\tvar normalMap0 = options.normalMap0 || textureLoader.load( 'textures/water/Water2_1_M_Normal.jpg' );\r\n\tvar normalMap1 = options.normalMap1 || textureLoader.load( 'textures/water/Water2_2_M_Normal.jpg' );\r\n\r\n\tvar cycle = 0.15; // a cycle of a flow map phase\r\n\tvar halfCycle = cycle * 0.5;\r\n\tvar textureMatrix = new Matrix4();\r\n\tvar clock = new Clock();\r\n\r\n\t// internal components\r\n\r\n\tif ( Reflector === undefined ) {\r\n\r\n\t\tconsole.error( 'Water2: Required component Reflector not found.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tif ( Refractor === undefined ) {\r\n\r\n\t\tconsole.error( 'Water2: Required component Refractor not found.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvar reflector = new Reflector( geometry, {\r\n\t\ttextureWidth: textureWidth,\r\n\t\ttextureHeight: textureHeight,\r\n\t\tclipBias: clipBias\r\n\t} );\r\n\r\n\tvar refractor = new Refractor( geometry, {\r\n\t\ttextureWidth: textureWidth,\r\n\t\ttextureHeight: textureHeight,\r\n\t\tclipBias: clipBias\r\n\t} );\r\n\r\n\treflector.matrixAutoUpdate = false;\r\n\trefractor.matrixAutoUpdate = false;\r\n\r\n\t// material\r\n\r\n\tthis.material = new ShaderMaterial( {\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\tUniformsLib[ 'fog' ],\r\n\t\t\tshader.uniforms\r\n\t\t] ),\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader,\r\n\t\ttransparent: true,\r\n\t\tfog: true\r\n\t} );\r\n\r\n\tif ( flowMap !== undefined ) {\r\n\r\n\t\tthis.material.defines.USE_FLOWMAP = '';\r\n\t\tthis.material.uniforms.tFlowMap = {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: flowMap\r\n\t\t};\r\n\r\n\t} else {\r\n\r\n\t\tthis.material.uniforms.flowDirection = {\r\n\t\t\ttype: 'v2',\r\n\t\t\tvalue: flowDirection\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t// maps\r\n\r\n\tnormalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\r\n\tnormalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\r\n\r\n\tthis.material.uniforms.tReflectionMap.value = reflector.getRenderTarget().texture;\r\n\tthis.material.uniforms.tRefractionMap.value = refractor.getRenderTarget().texture;\r\n\tthis.material.uniforms.tNormalMap0.value = normalMap0;\r\n\tthis.material.uniforms.tNormalMap1.value = normalMap1;\r\n\r\n\t// water\r\n\r\n\tthis.material.uniforms.color.value = color;\r\n\tthis.material.uniforms.reflectivity.value = reflectivity;\r\n\tthis.material.uniforms.textureMatrix.value = textureMatrix;\r\n\r\n\t// inital values\r\n\r\n\tthis.material.uniforms.config.value.x = 0; // flowMapOffset0\r\n\tthis.material.uniforms.config.value.y = halfCycle; // flowMapOffset1\r\n\tthis.material.uniforms.config.value.z = halfCycle; // halfCycle\r\n\tthis.material.uniforms.config.value.w = scale; // scale\r\n\r\n\t// functions\r\n\r\n\tfunction updateTextureMatrix( camera ) {\r\n\r\n\t\ttextureMatrix.set(\r\n\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t);\r\n\r\n\t\ttextureMatrix.multiply( camera.projectionMatrix );\r\n\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\r\n\t\ttextureMatrix.multiply( scope.matrixWorld );\r\n\r\n\t}\r\n\r\n\tfunction updateFlow() {\r\n\r\n\t\tvar delta = clock.getDelta();\r\n\t\tvar config = scope.material.uniforms.config;\r\n\r\n\t\tconfig.value.x += flowSpeed * delta; // flowMapOffset0\r\n\t\tconfig.value.y = config.value.x + halfCycle; // flowMapOffset1\r\n\r\n\t\t// Important: The distance between offsets should be always the value of \"halfCycle\".\r\n\t\t// Moreover, both offsets should be in the range of [ 0, cycle ].\r\n\t\t// This approach ensures a smooth water flow and avoids \"reset\" effects.\r\n\r\n\t\tif ( config.value.x >= cycle ) {\r\n\r\n\t\t\tconfig.value.x = 0;\r\n\t\t\tconfig.value.y = halfCycle;\r\n\r\n\t\t} else if ( config.value.y >= cycle ) {\r\n\r\n\t\t\tconfig.value.y = config.value.y - cycle;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\tupdateTextureMatrix( camera );\r\n\t\tupdateFlow();\r\n\r\n\t\tscope.visible = false;\r\n\r\n\t\treflector.matrixWorld.copy( scope.matrixWorld );\r\n\t\trefractor.matrixWorld.copy( scope.matrixWorld );\r\n\r\n\t\treflector.onBeforeRender( renderer, scene, camera );\r\n\t\trefractor.onBeforeRender( renderer, scene, camera );\r\n\r\n\t\tscope.visible = true;\r\n\r\n\t};\r\n\r\n}\r\nWater2.prototype = Object.create( Mesh.prototype );\r\nWater2.prototype.constructor = Water2;\r\n\r\nWater2.Water2Shader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'color': {\r\n\t\t\ttype: 'c',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'reflectivity': {\r\n\t\t\ttype: 'f',\r\n\t\t\tvalue: 0\r\n\t\t},\r\n\r\n\t\t'tReflectionMap': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tRefractionMap': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tNormalMap0': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tNormalMap1': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'textureMatrix': {\r\n\t\t\ttype: 'm4',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'config': {\r\n\t\t\ttype: 'v4',\r\n\t\t\tvalue: new Vector4()\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t'#include <fog_pars_vertex>',\r\n\r\n\t\t'uniform mat4 textureMatrix;',\r\n\r\n\t\t'varying vec4 vCoord;',\r\n\t\t'varying vec2 vUv;',\r\n\t\t'varying vec3 vToEye;',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvUv = uv;',\r\n\t\t'\tvCoord = textureMatrix * vec4( position, 1.0 );',\r\n\r\n\t\t'\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\r\n\t\t'\tvToEye = cameraPosition - worldPosition.xyz;',\r\n\r\n\t\t'\tvec4 mvPosition =  viewMatrix * worldPosition;', // used in fog_vertex\r\n\t\t'\tgl_Position = projectionMatrix * mvPosition;',\r\n\r\n\t\t'\t#include <fog_vertex>',\r\n\r\n\t\t'}'\r\n\r\n\t].join( '\\n' ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t'#include <common>',\r\n\t\t'#include <fog_pars_fragment>',\r\n\r\n\t\t'uniform sampler2D tReflectionMap;',\r\n\t\t'uniform sampler2D tRefractionMap;',\r\n\t\t'uniform sampler2D tNormalMap0;',\r\n\t\t'uniform sampler2D tNormalMap1;',\r\n\r\n\t\t'#ifdef USE_FLOWMAP',\r\n\t\t'\tuniform sampler2D tFlowMap;',\r\n\t\t'#else',\r\n\t\t'\tuniform vec2 flowDirection;',\r\n\t\t'#endif',\r\n\r\n\t\t'uniform vec3 color;',\r\n\t\t'uniform float reflectivity;',\r\n\t\t'uniform vec4 config;',\r\n\r\n\t\t'varying vec4 vCoord;',\r\n\t\t'varying vec2 vUv;',\r\n\t\t'varying vec3 vToEye;',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tfloat flowMapOffset0 = config.x;',\r\n\t\t'\tfloat flowMapOffset1 = config.y;',\r\n\t\t'\tfloat halfCycle = config.z;',\r\n\t\t'\tfloat scale = config.w;',\r\n\r\n\t\t'\tvec3 toEye = normalize( vToEye );',\r\n\r\n\t\t// determine flow direction\r\n\t\t'\tvec2 flow;',\r\n\t\t'\t#ifdef USE_FLOWMAP',\r\n\t\t'\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;',\r\n\t\t'\t#else',\r\n\t\t'\t\tflow = flowDirection;',\r\n\t\t'\t#endif',\r\n\t\t'\tflow.x *= - 1.0;',\r\n\r\n\t\t// sample normal maps (distort uvs with flowdata)\r\n\t\t'\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );',\r\n\t\t'\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );',\r\n\r\n\t\t// linear interpolate to get the final normal color\r\n\t\t'\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;',\r\n\t\t'\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );',\r\n\r\n\t\t// calculate normal vector\r\n\t\t'\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );',\r\n\r\n\t\t// calculate the fresnel term to blend reflection and refraction maps\r\n\t\t'\tfloat theta = max( dot( toEye, normal ), 0.0 );',\r\n\t\t'\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );',\r\n\r\n\t\t// calculate final uv coords\r\n\t\t'\tvec3 coord = vCoord.xyz / vCoord.w;',\r\n\t\t'\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;',\r\n\r\n\t\t'\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );',\r\n\t\t'\tvec4 refractColor = texture2D( tRefractionMap, uv );',\r\n\r\n\t\t// multiply water color with the mix of both textures\r\n\t\t'\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );',\r\n\r\n\t\t'\t#include <tonemapping_fragment>',\r\n\t\t'\t#include <encodings_fragment>',\r\n\t\t'\t#include <fog_fragment>',\r\n\r\n\t\t'}'\r\n\r\n\t].join( '\\n' )\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvar Ocean = function ( renderer, camera, scene, options ) {\n\n\t// flag used to trigger parameter changes\n\tthis.changed = true;\n\tthis.initial = true;\n\n\t// Assign required parameters as object properties\n\tthis.oceanCamera = new OrthographicCamera(); //camera.clone();\n\tthis.oceanCamera.position.z = 1;\n\tthis.renderer = renderer;\n\tthis.renderer.clearColor( 0xffffff );\n\n\tthis.scene = new Scene();\n\n\t// Assign optional parameters as variables and object properties\n\tfunction optionalParameter( value, defaultValue ) {\n\n\t\treturn value !== undefined ? value : defaultValue;\n\n\t}\n\toptions = options || {};\n\tthis.clearColor = optionalParameter( options.CLEAR_COLOR, [ 1.0, 1.0, 1.0, 0.0 ] );\n\tthis.geometryOrigin = optionalParameter( options.GEOMETRY_ORIGIN, [ - 1000.0, - 1000.0 ] );\n\tthis.sunDirectionX = optionalParameter( options.SUN_DIRECTION[ 0 ], - 1.0 );\n\tthis.sunDirectionY = optionalParameter( options.SUN_DIRECTION[ 1 ], 1.0 );\n\tthis.sunDirectionZ = optionalParameter( options.SUN_DIRECTION[ 2 ], 1.0 );\n\tthis.oceanColor = optionalParameter( options.OCEAN_COLOR, new Vector3( 0.004, 0.016, 0.047 ) );\n\tthis.skyColor = optionalParameter( options.SKY_COLOR, new Vector3( 3.2, 9.6, 12.8 ) );\n\tthis.exposure = optionalParameter( options.EXPOSURE, 0.35 );\n\tthis.geometryResolution = optionalParameter( options.GEOMETRY_RESOLUTION, 32 );\n\tthis.geometrySize = optionalParameter( options.GEOMETRY_SIZE, 2000 );\n\tthis.resolution = optionalParameter( options.RESOLUTION, 64 );\n\tthis.floatSize = optionalParameter( options.SIZE_OF_FLOAT, 4 );\n\tthis.windX = optionalParameter( options.INITIAL_WIND[ 0 ], 10.0 );\n\tthis.windY = optionalParameter( options.INITIAL_WIND[ 1 ], 10.0 );\n\tthis.size = optionalParameter( options.INITIAL_SIZE, 250.0 );\n\tthis.choppiness = optionalParameter( options.INITIAL_CHOPPINESS, 1.5 );\n\n\t//\n\tthis.matrixNeedsUpdate = false;\n\n\t// Setup framebuffer pipeline\n\tvar renderTargetType = optionalParameter( options.USE_HALF_FLOAT, false ) ? HalfFloatType : FloatType;\n\tvar LinearClampParams = {\n\t\tminFilter: LinearFilter,\n\t\tmagFilter: LinearFilter,\n\t\twrapS: ClampToEdgeWrapping,\n\t\twrapT: ClampToEdgeWrapping,\n\t\tformat: RGBAFormat,\n\t\tstencilBuffer: false,\n\t\tdepthBuffer: false,\n\t\tpremultiplyAlpha: false,\n\t\ttype: renderTargetType\n\t};\n\tvar NearestClampParams = {\n\t\tminFilter: NearestFilter,\n\t\tmagFilter: NearestFilter,\n\t\twrapS: ClampToEdgeWrapping,\n\t\twrapT: ClampToEdgeWrapping,\n\t\tformat: RGBAFormat,\n\t\tstencilBuffer: false,\n\t\tdepthBuffer: false,\n\t\tpremultiplyAlpha: false,\n\t\ttype: renderTargetType\n\t};\n\tvar NearestRepeatParams = {\n\t\tminFilter: NearestFilter,\n\t\tmagFilter: NearestFilter,\n\t\twrapS: RepeatWrapping,\n\t\twrapT: RepeatWrapping,\n\t\tformat: RGBAFormat,\n\t\tstencilBuffer: false,\n\t\tdepthBuffer: false,\n\t\tpremultiplyAlpha: false,\n\t\ttype: renderTargetType\n\t};\n\tthis.initialSpectrumFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestRepeatParams );\n\tthis.spectrumFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\tthis.pingPhaseFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\tthis.pongPhaseFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\tthis.pingTransformFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\tthis.pongTransformFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\tthis.displacementMapFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, LinearClampParams );\n\tthis.normalMapFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, LinearClampParams );\n\n\t// Define shaders and constant uniforms\n\t////////////////////////////////////////\n\n\t// 0 - The vertex shader used in all of the simulation steps\n\tvar fullscreeenVertexShader = ShaderLib[ \"ocean_sim_vertex\" ];\n\n\t// 1 - Horizontal wave vertices used for FFT\n\tvar oceanHorizontalShader = ShaderLib[ \"ocean_subtransform\" ];\n\tvar oceanHorizontalUniforms = UniformsUtils.clone( oceanHorizontalShader.uniforms );\n\tthis.materialOceanHorizontal = new ShaderMaterial( {\n\t\tuniforms: oceanHorizontalUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: \"#define HORIZONTAL \\n\" + oceanHorizontalShader.fragmentShader\n\t} );\n\tthis.materialOceanHorizontal.uniforms.u_transformSize = { value: this.resolution };\n\tthis.materialOceanHorizontal.uniforms.u_subtransformSize = { value: null };\n\tthis.materialOceanHorizontal.uniforms.u_input = { value: null };\n\tthis.materialOceanHorizontal.depthTest = false;\n\n\t// 2 - Vertical wave vertices used for FFT\n\tvar oceanVerticalShader = ShaderLib[ \"ocean_subtransform\" ];\n\tvar oceanVerticalUniforms = UniformsUtils.clone( oceanVerticalShader.uniforms );\n\tthis.materialOceanVertical = new ShaderMaterial( {\n\t\tuniforms: oceanVerticalUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: oceanVerticalShader.fragmentShader\n\t} );\n\tthis.materialOceanVertical.uniforms.u_transformSize = { value: this.resolution };\n\tthis.materialOceanVertical.uniforms.u_subtransformSize = { value: null };\n\tthis.materialOceanVertical.uniforms.u_input = { value: null };\n\tthis.materialOceanVertical.depthTest = false;\n\n\t// 3 - Initial spectrum used to generate height map\n\tvar initialSpectrumShader = ShaderLib[ \"ocean_initial_spectrum\" ];\n\tvar initialSpectrumUniforms = UniformsUtils.clone( initialSpectrumShader.uniforms );\n\tthis.materialInitialSpectrum = new ShaderMaterial( {\n\t\tuniforms: initialSpectrumUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: initialSpectrumShader.fragmentShader\n\t} );\n\tthis.materialInitialSpectrum.uniforms.u_wind = { value: new Vector2() };\n\tthis.materialInitialSpectrum.uniforms.u_resolution = { value: this.resolution };\n\tthis.materialInitialSpectrum.depthTest = false;\n\n\t// 4 - Phases used to animate heightmap\n\tvar phaseShader = ShaderLib[ \"ocean_phase\" ];\n\tvar phaseUniforms = UniformsUtils.clone( phaseShader.uniforms );\n\tthis.materialPhase = new ShaderMaterial( {\n\t\tuniforms: phaseUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: phaseShader.fragmentShader\n\t} );\n\tthis.materialPhase.uniforms.u_resolution = { value: this.resolution };\n\tthis.materialPhase.depthTest = false;\n\n\t// 5 - Shader used to update spectrum\n\tvar spectrumShader = ShaderLib[ \"ocean_spectrum\" ];\n\tvar spectrumUniforms = UniformsUtils.clone( spectrumShader.uniforms );\n\tthis.materialSpectrum = new ShaderMaterial( {\n\t\tuniforms: spectrumUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: spectrumShader.fragmentShader\n\t} );\n\tthis.materialSpectrum.uniforms.u_initialSpectrum = { value: null };\n\tthis.materialSpectrum.uniforms.u_resolution = { value: this.resolution };\n\tthis.materialSpectrum.depthTest = false;\n\n\t// 6 - Shader used to update spectrum normals\n\tvar normalShader = ShaderLib[ \"ocean_normals\" ];\n\tvar normalUniforms = UniformsUtils.clone( normalShader.uniforms );\n\tthis.materialNormal = new ShaderMaterial( {\n\t\tuniforms: normalUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: normalShader.fragmentShader\n\t} );\n\tthis.materialNormal.uniforms.u_displacementMap = { value: null };\n\tthis.materialNormal.uniforms.u_resolution = { value: this.resolution };\n\tthis.materialNormal.depthTest = false;\n\n\t// 7 - Shader used to update normals\n\tvar oceanShader = ShaderLib[ \"ocean_main\" ];\n\tvar oceanUniforms = UniformsUtils.clone( oceanShader.uniforms );\n\tthis.materialOcean = new ShaderMaterial( {\n\t\tuniforms: oceanUniforms,\n\t\tvertexShader: oceanShader.vertexShader,\n\t\tfragmentShader: oceanShader.fragmentShader\n\t} );\n\t// this.materialOcean.wireframe = true;\n\tthis.materialOcean.uniforms.u_geometrySize = { value: this.resolution };\n\tthis.materialOcean.uniforms.u_displacementMap = { value: this.displacementMapFramebuffer.texture };\n\tthis.materialOcean.uniforms.u_normalMap = { value: this.normalMapFramebuffer.texture };\n\tthis.materialOcean.uniforms.u_oceanColor = { value: this.oceanColor };\n\tthis.materialOcean.uniforms.u_skyColor = { value: this.skyColor };\n\tthis.materialOcean.uniforms.u_sunDirection = { value: new Vector3( this.sunDirectionX, this.sunDirectionY, this.sunDirectionZ ) };\n\tthis.materialOcean.uniforms.u_exposure = { value: this.exposure };\n\n\t// Disable blending to prevent default premultiplied alpha values\n\tthis.materialOceanHorizontal.blending = 0;\n\tthis.materialOceanVertical.blending = 0;\n\tthis.materialInitialSpectrum.blending = 0;\n\tthis.materialPhase.blending = 0;\n\tthis.materialSpectrum.blending = 0;\n\tthis.materialNormal.blending = 0;\n\tthis.materialOcean.blending = 0;\n\n\t// Create the simulation plane\n\tthis.screenQuad = new Mesh( new PlaneBufferGeometry( 2, 2 ) );\n\tthis.scene.add( this.screenQuad );\n\n\t// Initialise spectrum data\n\tthis.generateSeedPhaseTexture();\n\n\t// Generate the ocean mesh\n\tthis.generateMesh();\n\n};\n\nOcean.prototype.generateMesh = function () {\n\n\tvar geometry = new PlaneBufferGeometry( this.geometrySize, this.geometrySize, this.geometryResolution, this.geometryResolution );\n\n\tgeometry.rotateX( - Math.PI / 2 );\n\n\tthis.oceanMesh = new Mesh( geometry, this.materialOcean );\n\n};\n\nOcean.prototype.render = function () {\n\n\tthis.scene.overrideMaterial = null;\n\n\tif ( this.changed )\n\t\t{ this.renderInitialSpectrum(); }\n\n\tthis.renderWavePhase();\n\tthis.renderSpectrum();\n\tthis.renderSpectrumFFT();\n\tthis.renderNormalMap();\n\tthis.scene.overrideMaterial = null;\n\n};\n\nOcean.prototype.generateSeedPhaseTexture = function() {\n\tvar this$1 = this;\n\n\n\t// Setup the seed texture\n\tthis.pingPhase = true;\n\tvar phaseArray = new window.Float32Array( this.resolution * this.resolution * 4 );\n\tfor ( var i = 0; i < this.resolution; i ++ ) {\n\n\t\tfor ( var j = 0; j < this.resolution; j ++ ) {\n\n\t\t\tphaseArray[ i * this$1.resolution * 4 + j * 4 ] =  Math.random() * 2.0 * Math.PI;\n\t\t\tphaseArray[ i * this$1.resolution * 4 + j * 4 + 1 ] = 0.0;\n\t\t\tphaseArray[ i * this$1.resolution * 4 + j * 4 + 2 ] = 0.0;\n\t\t\tphaseArray[ i * this$1.resolution * 4 + j * 4 + 3 ] = 0.0;\n\n\t\t}\n\n\t}\n\n\tthis.pingPhaseTexture = new DataTexture( phaseArray, this.resolution, this.resolution, RGBAFormat );\n\tthis.pingPhaseTexture.wrapS = ClampToEdgeWrapping;\n\tthis.pingPhaseTexture.wrapT = ClampToEdgeWrapping;\n\tthis.pingPhaseTexture.type = FloatType;\n\tthis.pingPhaseTexture.needsUpdate = true;\n\n};\n\nOcean.prototype.renderInitialSpectrum = function () {\n\n\tthis.scene.overrideMaterial = this.materialInitialSpectrum;\n\tthis.materialInitialSpectrum.uniforms.u_wind.value.set( this.windX, this.windY );\n\tthis.materialInitialSpectrum.uniforms.u_size.value = this.size;\n\tthis.renderer.render( this.scene, this.oceanCamera, this.initialSpectrumFramebuffer, true );\n\n};\n\nOcean.prototype.renderWavePhase = function () {\n\n\tthis.scene.overrideMaterial = this.materialPhase;\n\tthis.screenQuad.material = this.materialPhase;\n\tif ( this.initial ) {\n\n\t\tthis.materialPhase.uniforms.u_phases.value = this.pingPhaseTexture;\n\t\tthis.initial = false;\n\n\t}else {\n\n\t\tthis.materialPhase.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer.texture : this.pongPhaseFramebuffer.texture;\n\n\t}\n\tthis.materialPhase.uniforms.u_deltaTime.value = this.deltaTime;\n\tthis.materialPhase.uniforms.u_size.value = this.size;\n\tthis.renderer.render( this.scene, this.oceanCamera, this.pingPhase ? this.pongPhaseFramebuffer : this.pingPhaseFramebuffer );\n\tthis.pingPhase = ! this.pingPhase;\n\n};\n\nOcean.prototype.renderSpectrum = function () {\n\n\tthis.scene.overrideMaterial = this.materialSpectrum;\n\tthis.materialSpectrum.uniforms.u_initialSpectrum.value = this.initialSpectrumFramebuffer.texture;\n\tthis.materialSpectrum.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer.texture : this.pongPhaseFramebuffer.texture;\n\tthis.materialSpectrum.uniforms.u_choppiness.value = this.choppiness;\n\tthis.materialSpectrum.uniforms.u_size.value = this.size;\n\tthis.renderer.render( this.scene, this.oceanCamera, this.spectrumFramebuffer );\n\n};\n\nOcean.prototype.renderSpectrumFFT = function() {\n\tvar this$1 = this;\n\n\n\t// GPU FFT using Stockham formulation\n\tvar iterations = Math.log( this.resolution ) / Math.log( 2 ); // log2\n\n\tthis.scene.overrideMaterial = this.materialOceanHorizontal;\n\n\tfor ( var i = 0; i < iterations; i ++ ) {\n\n\t\tif ( i === 0 ) {\n\n\t\t\tthis$1.materialOceanHorizontal.uniforms.u_input.value = this$1.spectrumFramebuffer.texture;\n\t\t\tthis$1.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis$1.renderer.render( this$1.scene, this$1.oceanCamera, this$1.pingTransformFramebuffer );\n\n\t\t} else if ( i % 2 === 1 ) {\n\n\t\t\tthis$1.materialOceanHorizontal.uniforms.u_input.value = this$1.pingTransformFramebuffer.texture;\n\t\t\tthis$1.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis$1.renderer.render( this$1.scene, this$1.oceanCamera, this$1.pongTransformFramebuffer );\n\n\t\t} else {\n\n\t\t\tthis$1.materialOceanHorizontal.uniforms.u_input.value = this$1.pongTransformFramebuffer.texture;\n\t\t\tthis$1.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis$1.renderer.render( this$1.scene, this$1.oceanCamera, this$1.pingTransformFramebuffer );\n\n\t\t}\n\n\t}\n\tthis.scene.overrideMaterial = this.materialOceanVertical;\n\tfor ( var i = iterations; i < iterations * 2; i ++ ) {\n\n\t\tif ( i === iterations * 2 - 1 ) {\n\n\t\t\tthis$1.materialOceanVertical.uniforms.u_input.value = ( iterations % 2 === 0 ) ? this$1.pingTransformFramebuffer.texture : this$1.pongTransformFramebuffer.texture;\n\t\t\tthis$1.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis$1.renderer.render( this$1.scene, this$1.oceanCamera, this$1.displacementMapFramebuffer );\n\n\t\t} else if ( i % 2 === 1 ) {\n\n\t\t\tthis$1.materialOceanVertical.uniforms.u_input.value = this$1.pingTransformFramebuffer.texture;\n\t\t\tthis$1.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis$1.renderer.render( this$1.scene, this$1.oceanCamera, this$1.pongTransformFramebuffer );\n\n\t\t} else {\n\n\t\t\tthis$1.materialOceanVertical.uniforms.u_input.value = this$1.pongTransformFramebuffer.texture;\n\t\t\tthis$1.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis$1.renderer.render( this$1.scene, this$1.oceanCamera, this$1.pingTransformFramebuffer );\n\n\t\t}\n\n\t}\n\n};\n\nOcean.prototype.renderNormalMap = function () {\n\n\tthis.scene.overrideMaterial = this.materialNormal;\n\tif ( this.changed ) { this.materialNormal.uniforms.u_size.value = this.size; }\n\tthis.materialNormal.uniforms.u_displacementMap.value = this.displacementMapFramebuffer.texture;\n\tthis.renderer.render( this.scene, this.oceanCamera, this.normalMapFramebuffer, true );\n\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction BoxHelper( object, color ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tif ( color === undefined ) { color = 0xffff00; }\r\n\r\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n\tvar positions = new Float32Array( 8 * 3 );\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\r\n\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\r\n\r\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n}\r\n\r\nBoxHelper.prototype = Object.create( LineSegments.prototype );\r\nBoxHelper.prototype.constructor = BoxHelper;\r\n\r\nBoxHelper.prototype.update = ( function () {\r\n\r\n\tvar box = new Box3();\r\n\r\n\treturn function update( object ) {\r\n\r\n\t\tif ( object !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'BoxHelper: .update() has no longer arguments.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.object !== undefined ) {\r\n\r\n\t\t\tbox.setFromObject( this.object );\r\n\r\n\t\t}\r\n\r\n\t\tif ( box.isEmpty() ) { return; }\r\n\r\n\t\tvar min = box.min;\r\n\t\tvar max = box.max;\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\t\tvar array = position.array;\r\n\r\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\r\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\r\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\r\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\r\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\r\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\r\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\r\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t\tthis.geometry.computeBoundingSphere();\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nBoxHelper.prototype.setFromObject = function ( object ) {\r\n\r\n\tthis.object = object;\r\n\tthis.update();\r\n\r\n\treturn this;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\tfunction isNumber( n ) {\r\n\r\n\t\treturn ! isNaN( n ) && isFinite( n );\r\n\r\n\t}\r\n\r\n\tfunction isArray( target ) {\r\n\r\n\t\treturn Object.prototype.toString.call( target ) === '[object Array]';\r\n\r\n\t}\r\n\r\n\tfunction toArray( target ) {\r\n\r\n\t\treturn target ? ( isArray( target ) !== true ? [ target ] : target ) : [];\r\n\r\n\t}\r\n\r\n\tfunction indexOfValue( array, value ) {\r\n\r\n\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( array[ i ] === value ) {\r\n\r\n\t\t\t\treturn i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn - 1;\r\n\r\n\t}\r\n\r\n\tfunction indexOfPropertyWithValue( array, property, value ) {\r\n\r\n\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( array[ i ][ property ] === value ) {\r\n\r\n\t\t\t\treturn i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn - 1;\r\n\r\n\t}\r\n\r\n\tvar Octree = function ( parameters ) {\r\n\r\n\t\t// handle parameters\r\n\r\n\t\tparameters = parameters || {};\r\n\r\n\t\tparameters.tree = this;\r\n\r\n\t\t// static properties ( modification is not recommended )\r\n\r\n\t\tthis.nodeCount = 0;\r\n\r\n\t\tthis.INDEX_INSIDE_CROSS = - 1;\r\n\t\tthis.INDEX_OUTSIDE_OFFSET = 2;\r\n\r\n\t\tthis.INDEX_OUTSIDE_POS_X = isNumber( parameters.INDEX_OUTSIDE_POS_X ) ? parameters.INDEX_OUTSIDE_POS_X : 0;\r\n\t\tthis.INDEX_OUTSIDE_NEG_X = isNumber( parameters.INDEX_OUTSIDE_NEG_X ) ? parameters.INDEX_OUTSIDE_NEG_X : 1;\r\n\t\tthis.INDEX_OUTSIDE_POS_Y = isNumber( parameters.INDEX_OUTSIDE_POS_Y ) ? parameters.INDEX_OUTSIDE_POS_Y : 2;\r\n\t\tthis.INDEX_OUTSIDE_NEG_Y = isNumber( parameters.INDEX_OUTSIDE_NEG_Y ) ? parameters.INDEX_OUTSIDE_NEG_Y : 3;\r\n\t\tthis.INDEX_OUTSIDE_POS_Z = isNumber( parameters.INDEX_OUTSIDE_POS_Z ) ? parameters.INDEX_OUTSIDE_POS_Z : 4;\r\n\t\tthis.INDEX_OUTSIDE_NEG_Z = isNumber( parameters.INDEX_OUTSIDE_NEG_Z ) ? parameters.INDEX_OUTSIDE_NEG_Z : 5;\r\n\r\n\t\tthis.INDEX_OUTSIDE_MAP = [];\r\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_X ] = { index: this.INDEX_OUTSIDE_POS_X, count: 0, x: 1, y: 0, z: 0 };\r\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_X ] = { index: this.INDEX_OUTSIDE_NEG_X, count: 0, x: - 1, y: 0, z: 0 };\r\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_Y ] = { index: this.INDEX_OUTSIDE_POS_Y, count: 0, x: 0, y: 1, z: 0 };\r\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_Y ] = { index: this.INDEX_OUTSIDE_NEG_Y, count: 0, x: 0, y: - 1, z: 0 };\r\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_Z ] = { index: this.INDEX_OUTSIDE_POS_Z, count: 0, x: 0, y: 0, z: 1 };\r\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_Z ] = { index: this.INDEX_OUTSIDE_NEG_Z, count: 0, x: 0, y: 0, z: - 1 };\r\n\r\n\t\tthis.FLAG_POS_X = 1 << ( this.INDEX_OUTSIDE_POS_X + 1 );\r\n\t\tthis.FLAG_NEG_X = 1 << ( this.INDEX_OUTSIDE_NEG_X + 1 );\r\n\t\tthis.FLAG_POS_Y = 1 << ( this.INDEX_OUTSIDE_POS_Y + 1 );\r\n\t\tthis.FLAG_NEG_Y = 1 << ( this.INDEX_OUTSIDE_NEG_Y + 1 );\r\n\t\tthis.FLAG_POS_Z = 1 << ( this.INDEX_OUTSIDE_POS_Z + 1 );\r\n\t\tthis.FLAG_NEG_Z = 1 << ( this.INDEX_OUTSIDE_NEG_Z + 1 );\r\n\r\n\t\tthis.utilVec31Search = new Vector3();\r\n\t\tthis.utilVec32Search = new Vector3();\r\n\r\n\t\t// pass scene to see octree structure\r\n\r\n\t\tthis.scene = parameters.scene;\r\n\r\n\t\tif ( this.scene ) {\r\n\r\n\t\t\tvar helper = new BoxHelper( new Mesh( new BoxBufferGeometry( 1, 1, 1 ) ), 0xff0066 );\r\n\t\t\tthis.visualGeometry = helper.geometry;\r\n\t\t\tthis.visualMaterial = helper.material;\r\n\r\n\t\t}\r\n\r\n\t\t// properties\r\n\r\n\t\tthis.objects = [];\r\n\t\tthis.objectsMap = {};\r\n\t\tthis.objectsData = [];\r\n\t\tthis.objectsDeferred = [];\r\n\r\n\t\tthis.depthMax = isNumber( parameters.depthMax ) ? parameters.depthMax : Infinity;\r\n\t\tthis.objectsThreshold = isNumber( parameters.objectsThreshold ) ? parameters.objectsThreshold : 8;\r\n\t\tthis.overlapPct = isNumber( parameters.overlapPct ) ? parameters.overlapPct : 0.15;\r\n\t\tthis.undeferred = parameters.undeferred || false;\r\n\r\n\t\tthis.root = parameters.root instanceof OctreeNode ? parameters.root : new OctreeNode( parameters );\r\n\r\n\t};\r\n\r\n\tOctree.prototype = {\r\n\r\n\t\tupdate: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\t// add any deferred objects that were waiting for render cycle\r\n\r\n\t\t\tif ( this.objectsDeferred.length > 0 ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = this.objectsDeferred.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar deferred = this$1.objectsDeferred[ i ];\r\n\r\n\t\t\t\t\tthis$1.addDeferred( deferred.object, deferred.options );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.objectsDeferred.length = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tadd: function ( object, options ) {\r\n\r\n\t\t\t// add immediately\r\n\r\n\t\t\tif ( this.undeferred ) {\r\n\r\n\t\t\t\tthis.updateObject( object );\r\n\r\n\t\t\t\tthis.addDeferred( object, options );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// defer add until update called\r\n\r\n\t\t\t\tthis.objectsDeferred.push( { object: object, options: options } );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\taddDeferred: function ( object, options ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tgeometry,\r\n\t\t\t\tfaces,\r\n\t\t\t\tuseFaces,\r\n\t\t\t\tvertices,\r\n\t\t\t\tuseVertices;\r\r\n\r\n\t\t\t// ensure object is not object data\r\n\r\n\t\t\tif ( object instanceof OctreeObjectData ) {\r\n\r\n\t\t\t\tobject = object.object;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check uuid to avoid duplicates\r\n\r\n\t\t\tif ( ! object.uuid ) {\r\n\r\n\t\t\t\tobject.uuid = _Math.generateUUID();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! this.objectsMap[ object.uuid ] ) {\r\n\r\n\t\t\t\t// store\r\n\r\n\t\t\t\tthis.objects.push( object );\r\n\t\t\t\tthis.objectsMap[ object.uuid ] = object;\r\n\r\n\t\t\t\t// check options\r\n\r\n\t\t\t\tif ( options ) {\r\n\r\n\t\t\t\t\tuseFaces = options.useFaces;\r\n\t\t\t\t\tuseVertices = options.useVertices;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( useVertices === true ) {\r\n\r\n\t\t\t\t\tgeometry = object.geometry;\r\n\t\t\t\t\tvertices = geometry.vertices;\r\n\r\n\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tthis$1.addObjectData( object, vertices[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( useFaces === true ) {\r\n\r\n\t\t\t\t\tgeometry = object.geometry;\r\n\t\t\t\t\tfaces = geometry.faces;\r\n\r\n\t\t\t\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tthis$1.addObjectData( object, faces[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.addObjectData( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\taddObjectData: function ( object, part ) {\r\n\r\n\t\t\tvar objectData = new OctreeObjectData( object, part );\r\n\r\n\t\t\t// add to tree objects data list\r\n\r\n\t\t\tthis.objectsData.push( objectData );\r\n\r\n\t\t\t// add to nodes\r\n\r\n\t\t\tthis.root.addObject( objectData );\r\n\r\n\t\t},\r\n\r\n\t\tremove: function ( object ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tobjectData = object,\r\n\t\t\t\tindex,\r\n\t\t\t\tobjectsDataRemoved;\r\n\r\n\t\t\t// ensure object is not object data for index search\r\n\r\n\t\t\tif ( object instanceof OctreeObjectData ) {\r\n\r\n\t\t\t\tobject = object.object;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check uuid\r\n\r\n\t\t\tif ( this.objectsMap[ object.uuid ] ) {\r\n\r\n\t\t\t\tthis.objectsMap[ object.uuid ] = undefined;\r\n\r\n\t\t\t\t// check and remove from objects, nodes, and data lists\r\n\r\n\t\t\t\tindex = indexOfValue( this.objects, object );\r\n\r\n\t\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\t\tthis.objects.splice( index, 1 );\r\n\r\n\t\t\t\t\t// remove from nodes\r\n\r\n\t\t\t\t\tobjectsDataRemoved = this.root.removeObject( objectData );\r\n\r\n\t\t\t\t\t// remove from objects data list\r\n\r\n\t\t\t\t\tfor ( i = 0, l = objectsDataRemoved.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tobjectData = objectsDataRemoved[ i ];\r\n\r\n\t\t\t\t\t\tindex = indexOfValue( this$1.objectsData, objectData );\r\n\r\n\t\t\t\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\t\t\t\tthis$1.objectsData.splice( index, 1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( this.objectsDeferred.length > 0 ) {\r\n\r\n\t\t\t\t// check and remove from deferred\r\n\r\n\t\t\t\tindex = indexOfPropertyWithValue( this.objectsDeferred, 'object', object );\r\n\r\n\t\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\t\tthis.objectsDeferred.splice( index, 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\textend: function ( octree ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tobjectsData,\r\n\t\t\t\tobjectData;\r\n\r\n\t\t\tif ( octree instanceof Octree ) {\r\n\r\n\t\t\t\t// for each object data\r\n\r\n\t\t\t\tobjectsData = octree.objectsData;\r\n\r\n\t\t\t\tfor ( i = 0, l = objectsData.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tobjectData = objectsData[ i ];\r\n\r\n\t\t\t\t\tthis$1.add( objectData, { useFaces: objectData.faces, useVertices: objectData.vertices } );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\trebuild: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnode,\r\n\t\t\t\tobjectData,\r\n\t\t\t\tindexOctant,\r\n\t\t\t\tindexOctantLast,\r\n\t\t\t\tobjectsUpdate = [];\r\n\r\n\t\t\t// check all object data for changes in position\r\n\t\t\t// assumes all object matrices are up to date\r\n\r\n\t\t\tfor ( i = 0, l = this.objectsData.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tobjectData = this$1.objectsData[ i ];\r\n\r\n\t\t\t\tnode = objectData.node;\r\n\r\n\t\t\t\t// update object\r\n\r\n\t\t\t\tobjectData.update();\r\n\r\n\t\t\t\t// if position has changed since last organization of object in tree\r\n\r\n\t\t\t\tif ( node instanceof OctreeNode && ! objectData.positionLast.equals( objectData.position ) ) {\r\n\r\n\t\t\t\t\t// get octant index of object within current node\r\n\r\n\t\t\t\t\tindexOctantLast = objectData.indexOctant;\r\n\r\n\t\t\t\t\tindexOctant = node.getOctantIndex( objectData );\r\n\r\n\t\t\t\t\t// if object octant index has changed\r\n\r\n\t\t\t\t\tif ( indexOctant !== indexOctantLast ) {\r\n\r\n\t\t\t\t\t\t// add to update list\r\n\r\n\t\t\t\t\t\tobjectsUpdate.push( objectData );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update changed objects\r\n\r\n\t\t\tfor ( i = 0, l = objectsUpdate.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tobjectData = objectsUpdate[ i ];\r\n\r\n\t\t\t\t// remove object from current node\r\n\r\n\t\t\t\tobjectData.node.removeObject( objectData );\r\n\r\n\t\t\t\t// add object to tree root\r\n\r\n\t\t\t\tthis$1.root.addObject( objectData );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tupdateObject: function ( object ) {\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tparentCascade = [ object ],\r\n\t\t\t\tparent,\r\n\t\t\t\tparentUpdate;\r\n\r\n\t\t\t// search all parents between object and root for world matrix update\r\n\r\n\t\t\tparent = object.parent;\r\n\r\n\t\t\twhile ( parent ) {\r\n\r\n\t\t\t\tparentCascade.push( parent );\r\n\t\t\t\tparent = parent.parent;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0, l = parentCascade.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tparent = parentCascade[ i ];\r\n\r\n\t\t\t\tif ( parent.matrixWorldNeedsUpdate === true ) {\r\n\r\n\t\t\t\t\tparentUpdate = parent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update world matrix starting at uppermost parent that needs update\r\n\r\n\t\t\tif ( typeof parentUpdate !== 'undefined' ) {\r\n\r\n\t\t\t\tparentUpdate.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tsearch: function ( position, radius, organizeByObject, direction ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnode,\r\n\t\t\t\tobjects,\r\n\t\t\t\tobjectData,\r\n\t\t\t\tobject,\r\n\t\t\t\tresults,\r\n\t\t\t\tresultData,\r\n\t\t\t\tresultsObjectsIndices,\r\n\t\t\t\tresultObjectIndex,\r\n\t\t\t\tdirectionPct;\r\n\r\n\t\t\t// add root objects\r\n\r\n\t\t\tobjects = [].concat( this.root.objects );\r\n\r\n\t\t\t// ensure radius (i.e. distance of ray) is a number\r\n\r\n\t\t\tif ( ! ( radius > 0 ) ) {\r\n\r\n\t\t\t\tradius = Number.MAX_VALUE;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if direction passed, normalize and find pct\r\n\r\n\t\t\tif ( direction instanceof Vector3 ) {\r\n\r\n\t\t\t\tdirection = this.utilVec31Search.copy( direction ).normalize();\r\n\t\t\t\tdirectionPct = this.utilVec32Search.set( 1, 1, 1 ).divide( direction );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// search each node of root\r\n\r\n\t\t\tfor ( i = 0, l = this.root.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tnode = this$1.root.nodesByIndex[ this$1.root.nodesIndices[ i ] ];\r\n\r\n\t\t\t\tobjects = node.search( position, radius, objects, direction, directionPct );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if should organize results by object\r\n\r\n\t\t\tif ( organizeByObject === true ) {\r\n\r\n\t\t\t\tresults = [];\r\n\t\t\t\tresultsObjectsIndices = [];\r\n\r\n\t\t\t\t// for each object data found\r\n\r\n\t\t\t\tfor ( i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tobjectData = objects[ i ];\r\n\t\t\t\t\tobject = objectData.object;\r\n\r\n\t\t\t\t\tresultObjectIndex = indexOfValue( resultsObjectsIndices, object );\r\n\r\n\t\t\t\t\t// if needed, create new result data\r\n\r\n\t\t\t\t\tif ( resultObjectIndex === - 1 ) {\r\n\r\n\t\t\t\t\t\tresultData = {\r\n\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\tfaces: [],\r\n\t\t\t\t\t\t\tvertices: []\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tresults.push( resultData );\r\n\r\n\t\t\t\t\t\tresultsObjectsIndices.push( object );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tresultData = results[ resultObjectIndex ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// object data has faces or vertices, add to list\r\n\r\n\t\t\t\t\tif ( objectData.faces ) {\r\n\r\n\t\t\t\t\t\tresultData.faces.push( objectData.faces );\r\n\r\n\t\t\t\t\t} else if ( objectData.vertices ) {\r\n\r\n\t\t\t\t\t\tresultData.vertices.push( objectData.vertices );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresults = objects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn results;\r\n\r\n\t\t},\r\n\r\n\t\tsetRoot: function ( root ) {\r\n\r\n\t\t\tif ( root instanceof OctreeNode ) {\r\n\r\n\t\t\t\t// store new root\r\n\r\n\t\t\t\tthis.root = root;\r\n\r\n\t\t\t\t// update properties\r\n\r\n\t\t\t\tthis.root.updateProperties();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tgetDepthEnd: function () {\r\n\r\n\t\t\treturn this.root.getDepthEnd();\r\n\r\n\t\t},\r\n\r\n\t\tgetNodeCountEnd: function () {\r\n\r\n\t\t\treturn this.root.getNodeCountEnd();\r\n\r\n\t\t},\r\n\r\n\t\tgetObjectCountEnd: function () {\r\n\r\n\t\t\treturn this.root.getObjectCountEnd();\r\n\r\n\t\t},\r\n\r\n\t\ttoConsole: function () {\r\n\r\n\t\t\tthis.root.toConsole();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar OctreeObjectData = function ( object, part ) {\r\n\r\n\t\t// properties\r\n\r\n\t\tthis.object = object;\r\n\r\n\t\t// handle part by type\r\n\r\n\t\tif ( part instanceof Face3 ) {\r\n\r\n\t\t\tthis.faces = part;\r\n\t\t\tthis.face3 = true;\r\n\t\t\tthis.utilVec31FaceBounds = new Vector3();\r\n\r\n\t\t} else if ( part instanceof Vector3 ) {\r\n\r\n\t\t\tthis.vertices = part;\r\n\r\n\t\t}\r\n\r\n\t\tthis.radius = 0;\r\n\t\tthis.position = new Vector3();\r\n\r\n\t\t// initial update\r\n\r\n\t\tif ( this.object instanceof Object3D ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tthis.positionLast = this.position.clone();\r\n\r\n\t};\r\n\r\n\tOctreeObjectData.prototype = {\r\n\r\n\t\tupdate: function () {\r\n\r\n\t\t\tif ( this.face3 ) {\r\n\r\n\t\t\t\tthis.radius = this.getFace3BoundingRadius( this.object, this.faces );\r\n\t\t\t\tthis.position.copy( this.faces.centroid ).applyMatrix4( this.object.matrixWorld );\r\n\r\n\t\t\t} else if ( this.vertices ) {\r\n\r\n\t\t\t\tthis.radius = this.object.material.size || 1;\r\n\t\t\t\tthis.position.copy( this.vertices ).applyMatrix4( this.object.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( this.object.geometry ) {\r\n\r\n\t\t\t\t\tif ( this.object.geometry.boundingSphere === null ) {\r\n\r\n\t\t\t\t\t\tthis.object.geometry.computeBoundingSphere();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.radius = this.object.geometry.boundingSphere.radius;\r\n\t\t\t\t\tthis.position.copy( this.object.geometry.boundingSphere.center ).applyMatrix4( this.object.matrixWorld );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.radius = this.object.boundRadius;\r\n\t\t\t\t\tthis.position.setFromMatrixPosition( this.object.matrixWorld );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = this.radius * Math.max( this.object.scale.x, this.object.scale.y, this.object.scale.z );\r\n\r\n\t\t},\r\n\r\n\t\tgetFace3BoundingRadius: function ( object, face ) {\r\n\r\n\t\t\tif ( face.centroid === undefined ) { face.centroid = new Vector3(); }\r\n\r\n\t\t\tvar geometry = object.geometry || object,\r\n\t\t\t\tvertices = geometry.vertices,\r\n\t\t\t\tcentroid = face.centroid,\r\n\t\t\t\tva = vertices[ face.a ], vb = vertices[ face.b ], vc = vertices[ face.c ],\r\n\t\t\t\tcentroidToVert = this.utilVec31FaceBounds,\r\n\t\t\t\tradius;\r\n\r\n\t\t\tcentroid.addVectors( va, vb ).add( vc ).divideScalar( 3 );\r\n\t\t\tradius = Math.max( centroidToVert.subVectors( centroid, va ).length(), centroidToVert.subVectors( centroid, vb ).length(), centroidToVert.subVectors( centroid, vc ).length() );\r\n\r\n\t\t\treturn radius;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar OctreeNode = function ( parameters ) {\r\n\r\n\t\t// utility\r\n\r\n\t\tthis.utilVec31Branch = new Vector3();\r\n\t\tthis.utilVec31Expand = new Vector3();\r\n\t\tthis.utilVec31Ray = new Vector3();\r\n\r\n\t\t// handle parameters\r\n\r\n\t\tparameters = parameters || {};\r\n\r\n\t\t// store or create tree\r\n\r\n\t\tif ( parameters.tree instanceof Octree ) {\r\n\r\n\t\t\tthis.tree = parameters.tree;\r\n\r\n\t\t} else if ( parameters.parent instanceof OctreeNode !== true ) {\r\n\r\n\t\t\tparameters.root = this;\r\n\r\n\t\t\tthis.tree = new Octree( parameters );\r\n\r\n\t\t}\r\n\r\n\t\t// basic properties\r\n\r\n\t\tthis.id = this.tree.nodeCount ++;\r\n\t\tthis.position = parameters.position instanceof Vector3 ? parameters.position : new Vector3();\r\n\t\tthis.radius = parameters.radius > 0 ? parameters.radius : 1;\r\n\t\tthis.indexOctant = parameters.indexOctant;\r\n\t\tthis.depth = 0;\r\n\r\n\t\t// reset and assign parent\r\n\r\n\t\tthis.reset();\r\n\t\tthis.setParent( parameters.parent );\r\n\r\n\t\t// additional properties\r\n\r\n\t\tthis.overlap = this.radius * this.tree.overlapPct;\r\n\t\tthis.radiusOverlap = this.radius + this.overlap;\r\n\t\tthis.left = this.position.x - this.radiusOverlap;\r\n\t\tthis.right = this.position.x + this.radiusOverlap;\r\n\t\tthis.bottom = this.position.y - this.radiusOverlap;\r\n\t\tthis.top = this.position.y + this.radiusOverlap;\r\n\t\tthis.back = this.position.z - this.radiusOverlap;\r\n\t\tthis.front = this.position.z + this.radiusOverlap;\r\n\r\n\t\t// visual\r\n\r\n\t\tif ( this.tree.scene ) {\r\n\r\n\t\t\tthis.visual = new LineSegments( this.tree.visualGeometry, this.tree.visualMaterial );\r\n\t\t\tthis.visual.scale.set( this.radiusOverlap * 2, this.radiusOverlap * 2, this.radiusOverlap * 2 );\r\n\t\t\tthis.visual.position.copy( this.position );\r\n\t\t\tthis.tree.scene.add( this.visual );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tOctreeNode.prototype = {\r\n\r\n\t\tsetParent: function ( parent ) {\r\n\r\n\t\t\t// store new parent\r\n\r\n\t\t\tif ( parent !== this && this.parent !== parent ) {\r\n\r\n\t\t\t\tthis.parent = parent;\r\n\r\n\t\t\t\t// update properties\r\n\r\n\t\t\t\tthis.updateProperties();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tupdateProperties: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l;\r\n\r\n\t\t\t// properties\r\n\r\n\t\t\tif ( this.parent instanceof OctreeNode ) {\r\n\r\n\t\t\t\tthis.tree = this.parent.tree;\r\n\t\t\t\tthis.depth = this.parent.depth + 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.depth = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// cascade\r\n\r\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis$1.nodesByIndex[ this$1.nodesIndices[ i ] ].updateProperties();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\treset: function ( cascade, removeVisual ) {\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnode,\r\n\t\t\t\tnodesIndices = this.nodesIndices || [],\r\n\t\t\t\tnodesByIndex = this.nodesByIndex;\r\n\r\n\t\t\tthis.objects = [];\r\n\t\t\tthis.nodesIndices = [];\r\n\t\t\tthis.nodesByIndex = {};\r\n\r\n\t\t\t// unset parent in nodes\r\n\r\n\t\t\tfor ( i = 0, l = nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tnode = nodesByIndex[ nodesIndices[ i ] ];\r\n\r\n\t\t\t\tnode.setParent( undefined );\r\n\r\n\t\t\t\tif ( cascade === true ) {\r\n\r\n\t\t\t\t\tnode.reset( cascade, removeVisual );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// visual\r\n\r\n\t\t\tif ( removeVisual === true && this.visual && this.visual.parent ) {\r\n\r\n\t\t\t\tthis.visual.parent.remove( this.visual );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\taddNode: function ( node, indexOctant ) {\r\n\r\n\t\t\tnode.indexOctant = indexOctant;\r\n\r\n\t\t\tif ( indexOfValue( this.nodesIndices, indexOctant ) === - 1 ) {\r\n\r\n\t\t\t\tthis.nodesIndices.push( indexOctant );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.nodesByIndex[ indexOctant ] = node;\r\n\r\n\t\t\tif ( node.parent !== this ) {\r\n\r\n\t\t\t\tnode.setParent( this );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tremoveNode: function ( indexOctant ) {\r\n\r\n\t\t\tvar index,\r\n\t\t\t\tnode;\r\n\r\n\t\t\tindex = indexOfValue( this.nodesIndices, indexOctant );\r\n\r\n\t\t\tthis.nodesIndices.splice( index, 1 );\r\n\r\n\t\t\tnode = node || this.nodesByIndex[ indexOctant ];\r\n\r\n\t\t\tdelete this.nodesByIndex[ indexOctant ];\r\n\r\n\t\t\tif ( node.parent === this ) {\r\n\r\n\t\t\t\tnode.setParent( undefined );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\taddObject: function ( object ) {\r\n\r\n\t\t\tvar index,\r\n\t\t\t\tindexOctant,\r\n\t\t\t\tnode;\r\n\r\n\t\t\t// get object octant index\r\n\r\n\t\t\tindexOctant = this.getOctantIndex( object );\r\n\r\n\t\t\t// if object fully contained by an octant, add to subtree\r\n\t\t\tif ( indexOctant > - 1 && this.nodesIndices.length > 0 ) {\r\n\r\n\t\t\t\tnode = this.branch( indexOctant );\r\n\r\n\t\t\t\tnode.addObject( object );\r\n\r\n\t\t\t} else if ( indexOctant < - 1 && this.parent instanceof OctreeNode ) {\r\n\r\n\t\t\t\t// if object lies outside bounds, add to parent node\r\n\r\n\t\t\t\tthis.parent.addObject( object );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// add to this objects list\r\n\r\n\t\t\t\tindex = indexOfValue( this.objects, object );\r\n\r\n\t\t\t\tif ( index === - 1 ) {\r\n\r\n\t\t\t\t\tthis.objects.push( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// node reference\r\n\r\n\t\t\t\tobject.node = this;\r\n\r\n\t\t\t\t// check if need to expand, split, or both\r\n\r\n\t\t\t\tthis.checkGrow();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\taddObjectWithoutCheck: function ( objects ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tobject;\r\n\r\n\t\t\tfor ( i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tobject = objects[ i ];\r\n\r\n\t\t\t\tthis$1.objects.push( object );\r\n\r\n\t\t\t\tobject.node = this$1;\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tremoveObject: function ( object ) {\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnodesRemovedFrom,\r\n\t\t\t\tremoveData;\r\n\r\n\t\t\t// cascade through tree to find and remove object\r\n\r\n\t\t\tremoveData = this.removeObjectRecursive( object, { searchComplete: false, nodesRemovedFrom: [], objectsDataRemoved: [] } );\r\n\r\n\t\t\t// if object removed, try to shrink the nodes it was removed from\r\n\r\n\t\t\tnodesRemovedFrom = removeData.nodesRemovedFrom;\r\n\r\n\t\t\tif ( nodesRemovedFrom.length > 0 ) {\r\n\r\n\t\t\t\tfor ( i = 0, l = nodesRemovedFrom.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tnodesRemovedFrom[ i ].shrink();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn removeData.objectsDataRemoved;\r\n\r\n\t\t},\r\n\r\n\t\tremoveObjectRecursive: function ( object, removeData ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tindex = - 1,\r\n\t\t\t\tobjectData,\r\n\t\t\t\tnode,\r\n\t\t\t\tobjectRemoved;\r\n\r\n\t\t\t// find index of object in objects list\r\n\r\n\t\t\t// search and remove object data (fast)\r\n\t\t\tif ( object instanceof OctreeObjectData ) {\r\n\r\n\t\t\t\t// remove from this objects list\r\n\r\n\t\t\t\tindex = indexOfValue( this.objects, object );\r\n\r\n\t\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\t\tthis.objects.splice( index, 1 );\r\n\t\t\t\t\tobject.node = undefined;\r\n\r\n\t\t\t\t\tremoveData.objectsDataRemoved.push( object );\r\n\r\n\t\t\t\t\tremoveData.searchComplete = objectRemoved = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// search each object data for object and remove (slow)\r\n\r\n\t\t\t\tfor ( i = this.objects.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\t\t\tobjectData = this$1.objects[ i ];\r\n\r\n\t\t\t\t\tif ( objectData.object === object ) {\r\n\r\n\t\t\t\t\t\tthis$1.objects.splice( i, 1 );\r\n\t\t\t\t\t\tobjectData.node = undefined;\r\n\r\n\t\t\t\t\t\tremoveData.objectsDataRemoved.push( objectData );\r\n\r\n\t\t\t\t\t\tobjectRemoved = true;\r\n\r\n\t\t\t\t\t\tif ( ! objectData.faces && ! objectData.vertices ) {\r\n\r\n\t\t\t\t\t\t\tremoveData.searchComplete = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if object data removed and this is not on nodes removed from\r\n\r\n\t\t\tif ( objectRemoved === true ) {\r\n\r\n\t\t\t\tremoveData.nodesRemovedFrom.push( this );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if search not complete, search nodes\r\n\r\n\t\t\tif ( removeData.searchComplete !== true ) {\r\n\r\n\t\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tnode = this$1.nodesByIndex[ this$1.nodesIndices[ i ] ];\r\n\r\n\t\t\t\t\t// try removing object from node\r\n\r\n\t\t\t\t\tremoveData = node.removeObjectRecursive( object, removeData );\r\n\r\n\t\t\t\t\tif ( removeData.searchComplete === true ) {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn removeData;\r\n\r\n\t\t},\r\n\r\n\t\tcheckGrow: function () {\r\n\r\n\t\t\t// if object count above max\r\n\r\n\t\t\tif ( this.objects.length > this.tree.objectsThreshold && this.tree.objectsThreshold > 0 ) {\r\n\r\n\t\t\t\tthis.grow();\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tgrow: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar indexOctant,\r\n\t\t\t\tobject,\r\n\t\t\t\tobjectsExpand = [],\r\n\t\t\t\tobjectsExpandOctants = [],\r\n\t\t\t\tobjectsSplit = [],\r\n\t\t\t\tobjectsSplitOctants = [],\r\n\t\t\t\tobjectsRemaining = [],\r\n\t\t\t\ti, l;\r\n\r\n\t\t\t// for each object\r\n\r\n\t\t\tfor ( i = 0, l = this.objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tobject = this$1.objects[ i ];\r\n\r\n\t\t\t\t// get object octant index\r\n\r\n\t\t\t\tindexOctant = this$1.getOctantIndex( object );\r\n\r\n\t\t\t\t// if lies within octant\r\n\t\t\t\tif ( indexOctant > - 1 ) {\r\n\r\n\t\t\t\t\tobjectsSplit.push( object );\r\n\t\t\t\t\tobjectsSplitOctants.push( indexOctant );\r\n\r\n\t\t\t\t} else if ( indexOctant < - 1 ) {\r\n\r\n\t\t\t\t\t// lies outside radius\r\n\r\n\t\t\t\t\tobjectsExpand.push( object );\r\n\t\t\t\t\tobjectsExpandOctants.push( indexOctant );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// lies across bounds between octants\r\n\r\n\t\t\t\t\tobjectsRemaining.push( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if has objects to split\r\n\r\n\t\t\tif ( objectsSplit.length > 0 ) {\r\n\r\n\t\t\t\tobjectsRemaining = objectsRemaining.concat( this.split( objectsSplit, objectsSplitOctants ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if has objects to expand\r\n\r\n\t\t\tif ( objectsExpand.length > 0 ) {\r\n\r\n\t\t\t\tobjectsRemaining = objectsRemaining.concat( this.expand( objectsExpand, objectsExpandOctants ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// store remaining\r\n\r\n\t\t\tthis.objects = objectsRemaining;\r\n\r\n\t\t\t// merge check\r\n\r\n\t\t\tthis.checkMerge();\r\n\r\n\t\t},\r\n\r\n\t\tsplit: function ( objects, octants ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tindexOctant,\r\n\t\t\t\tobject,\r\n\t\t\t\tnode,\r\n\t\t\t\tobjectsRemaining;\r\n\r\n\t\t\t// if not at max depth\r\n\r\n\t\t\tif ( this.depth < this.tree.depthMax ) {\r\n\r\n\t\t\t\tobjects = objects || this.objects;\r\n\r\n\t\t\t\toctants = octants || [];\r\n\r\n\t\t\t\tobjectsRemaining = [];\r\n\r\n\t\t\t\t// for each object\r\n\r\n\t\t\t\tfor ( i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tobject = objects[ i ];\r\n\r\n\t\t\t\t\t// get object octant index\r\n\r\n\t\t\t\t\tindexOctant = octants[ i ];\r\n\r\n\t\t\t\t\t// if object contained by octant, branch this tree\r\n\r\n\t\t\t\t\tif ( indexOctant > - 1 ) {\r\n\r\n\t\t\t\t\t\tnode = this$1.branch( indexOctant );\r\n\r\n\t\t\t\t\t\tnode.addObject( object );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tobjectsRemaining.push( object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if all objects, set remaining as new objects\r\n\r\n\t\t\t\tif ( objects === this.objects ) {\r\n\r\n\t\t\t\t\tthis.objects = objectsRemaining;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobjectsRemaining = this.objects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn objectsRemaining;\r\n\r\n\t\t},\r\n\r\n\t\tbranch: function ( indexOctant ) {\r\n\r\n\t\t\tvar node,\r\n\t\t\t\toverlap,\r\n\t\t\t\tradius,\r\n\t\t\t\tradiusOffset,\r\n\t\t\t\toffset,\r\n\t\t\t\tposition;\r\n\r\n\t\t\t// node exists\r\n\r\n\t\t\tif ( this.nodesByIndex[ indexOctant ] instanceof OctreeNode ) {\r\n\r\n\t\t\t\tnode = this.nodesByIndex[ indexOctant ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// properties\r\n\r\n\t\t\t\tradius = ( this.radiusOverlap ) * 0.5;\r\n\t\t\t\toverlap = radius * this.tree.overlapPct;\r\n\t\t\t\tradiusOffset = radius - overlap;\r\n\t\t\t\toffset = this.utilVec31Branch.set( indexOctant & 1 ? radiusOffset : - radiusOffset, indexOctant & 2 ? radiusOffset : - radiusOffset, indexOctant & 4 ? radiusOffset : - radiusOffset );\r\n\t\t\t\tposition = new Vector3().addVectors( this.position, offset );\r\n\r\n\t\t\t\t// node\r\n\r\n\t\t\t\tnode = new OctreeNode( {\r\n\t\t\t\t\ttree: this.tree,\r\n\t\t\t\t\tparent: this,\r\n\t\t\t\t\tposition: position,\r\n\t\t\t\t\tradius: radius,\r\n\t\t\t\t\tindexOctant: indexOctant\r\n\t\t\t\t} );\r\n\r\n\t\t\t\t// store\r\n\r\n\t\t\t\tthis.addNode( node, indexOctant );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t},\r\n\r\n\t\texpand: function ( objects, octants ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tobject,\r\n\t\t\t\tobjectsRemaining,\r\n\t\t\t\tobjectsExpand,\r\n\t\t\t\tindexOctant,\r\n\t\t\t\tflagsOutside,\r\n\t\t\t\tindexOctantInverse,\r\n\t\t\t\tiom = this.tree.INDEX_OUTSIDE_MAP,\r\n\t\t\t\tindexOutsideCounts,\r\n\t\t\t\tinfoIndexOutside1,\r\n\t\t\t\tinfoIndexOutside2,\r\n\t\t\t\tinfoIndexOutside3,\r\n\t\t\t\tindexOutsideBitwise1,\r\n\t\t\t\tindexOutsideBitwise2,\r\n\t\t\t\tinfoPotential1,\r\n\t\t\t\tinfoPotential2,\r\n\t\t\t\tinfoPotential3,\r\n\t\t\t\tindexPotentialBitwise1,\r\n\t\t\t\tindexPotentialBitwise2,\r\n\t\t\t\toctantX, octantY, octantZ,\r\n\t\t\t\toverlap,\r\n\t\t\t\tradius,\r\n\t\t\t\tradiusOffset,\r\n\t\t\t\tradiusParent,\r\n\t\t\t\toverlapParent,\r\n\t\t\t\toffset = this.utilVec31Expand,\r\n\t\t\t\tposition,\r\n\t\t\t\tparent;\r\n\r\n\t\t\t// handle max depth down tree\r\n\r\n\t\t\tif ( this.tree.root.getDepthEnd() < this.tree.depthMax ) {\r\n\r\n\t\t\t\tobjects = objects || this.objects;\r\n\t\t\t\toctants = octants || [];\r\n\r\n\t\t\t\tobjectsRemaining = [];\r\n\t\t\t\tobjectsExpand = [];\r\n\r\n\t\t\t\t// reset counts\r\n\r\n\t\t\t\tfor ( i = 0, l = iom.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tiom[ i ].count = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// for all outside objects, find outside octants containing most objects\r\n\r\n\t\t\t\tfor ( i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tobject = objects[ i ];\r\n\r\n\t\t\t\t\t// get object octant index\r\n\r\n\t\t\t\t\tindexOctant = octants[ i ];\r\n\r\n\t\t\t\t\t// if object outside this, include in calculations\r\n\r\n\t\t\t\t\tif ( indexOctant < - 1 ) {\r\n\r\n\t\t\t\t\t\t// convert octant index to outside flags\r\n\r\n\t\t\t\t\t\tflagsOutside = - indexOctant - this$1.tree.INDEX_OUTSIDE_OFFSET;\r\n\r\n\t\t\t\t\t\t// check against bitwise flags\r\n\r\n\t\t\t\t\t\t// x\r\n\r\n\t\t\t\t\t\tif ( flagsOutside & this$1.tree.FLAG_POS_X ) {\r\n\r\n\t\t\t\t\t\t\tiom[ this$1.tree.INDEX_OUTSIDE_POS_X ].count ++;\r\n\r\n\t\t\t\t\t\t} else if ( flagsOutside & this$1.tree.FLAG_NEG_X ) {\r\n\r\n\t\t\t\t\t\t\tiom[ this$1.tree.INDEX_OUTSIDE_NEG_X ].count ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// y\r\n\r\n\t\t\t\t\t\tif ( flagsOutside & this$1.tree.FLAG_POS_Y ) {\r\n\r\n\t\t\t\t\t\t\tiom[ this$1.tree.INDEX_OUTSIDE_POS_Y ].count ++;\r\n\r\n\t\t\t\t\t\t} else if ( flagsOutside & this$1.tree.FLAG_NEG_Y ) {\r\n\r\n\t\t\t\t\t\t\tiom[ this$1.tree.INDEX_OUTSIDE_NEG_Y ].count ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// z\r\n\r\n\t\t\t\t\t\tif ( flagsOutside & this$1.tree.FLAG_POS_Z ) {\r\n\r\n\t\t\t\t\t\t\tiom[ this$1.tree.INDEX_OUTSIDE_POS_Z ].count ++;\r\n\r\n\t\t\t\t\t\t} else if ( flagsOutside & this$1.tree.FLAG_NEG_Z ) {\r\n\r\n\t\t\t\t\t\t\tiom[ this$1.tree.INDEX_OUTSIDE_NEG_Z ].count ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// store in expand list\r\n\r\n\t\t\t\t\t\tobjectsExpand.push( object );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tobjectsRemaining.push( object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if objects to expand\r\n\r\n\t\t\t\tif ( objectsExpand.length > 0 ) {\r\n\r\n\t\t\t\t\t// shallow copy index outside map\r\n\r\n\t\t\t\t\tindexOutsideCounts = iom.slice( 0 );\r\n\r\n\t\t\t\t\t// sort outside index count so highest is first\r\n\r\n\t\t\t\t\tindexOutsideCounts.sort( function ( a, b ) {\r\n\r\n\t\t\t\t\t\treturn b.count - a.count;\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t// get highest outside indices\r\n\r\n\t\t\t\t\t// first is first\r\n\t\t\t\t\tinfoIndexOutside1 = indexOutsideCounts[ 0 ];\r\n\t\t\t\t\tindexOutsideBitwise1 = infoIndexOutside1.index | 1;\r\n\r\n\t\t\t\t\t// second is ( one of next two bitwise OR 1 ) that is not opposite of ( first bitwise OR 1 )\r\n\r\n\t\t\t\t\tinfoPotential1 = indexOutsideCounts[ 1 ];\r\n\t\t\t\t\tinfoPotential2 = indexOutsideCounts[ 2 ];\r\n\r\n\t\t\t\t\tinfoIndexOutside2 = ( infoPotential1.index | 1 ) !== indexOutsideBitwise1 ? infoPotential1 : infoPotential2;\r\n\t\t\t\t\tindexOutsideBitwise2 = infoIndexOutside2.index | 1;\r\n\r\n\t\t\t\t\t// third is ( one of next three bitwise OR 1 ) that is not opposite of ( first or second bitwise OR 1 )\r\n\r\n\t\t\t\t\tinfoPotential1 = indexOutsideCounts[ 2 ];\r\n\t\t\t\t\tinfoPotential2 = indexOutsideCounts[ 3 ];\r\n\t\t\t\t\tinfoPotential3 = indexOutsideCounts[ 4 ];\r\n\r\n\t\t\t\t\tindexPotentialBitwise1 = infoPotential1.index | 1;\r\n\t\t\t\t\tindexPotentialBitwise2 = infoPotential2.index | 1;\r\n\r\n\t\t\t\t\tinfoIndexOutside3 = indexPotentialBitwise1 !== indexOutsideBitwise1 && indexPotentialBitwise1 !== indexOutsideBitwise2 ? infoPotential1 : indexPotentialBitwise2 !== indexOutsideBitwise1 && indexPotentialBitwise2 !== indexOutsideBitwise2 ? infoPotential2 : infoPotential3;\r\n\r\n\t\t\t\t\t// get this octant normal based on outside octant indices\r\n\r\n\t\t\t\t\toctantX = infoIndexOutside1.x + infoIndexOutside2.x + infoIndexOutside3.x;\r\n\t\t\t\t\toctantY = infoIndexOutside1.y + infoIndexOutside2.y + infoIndexOutside3.y;\r\n\t\t\t\t\toctantZ = infoIndexOutside1.z + infoIndexOutside2.z + infoIndexOutside3.z;\r\n\r\n\t\t\t\t\t// get this octant indices based on octant normal\r\n\r\n\t\t\t\t\tindexOctant = this.getOctantIndexFromPosition( octantX, octantY, octantZ );\r\n\t\t\t\t\tindexOctantInverse = this.getOctantIndexFromPosition( - octantX, - octantY, - octantZ );\r\n\r\n\t\t\t\t\t// properties\r\n\r\n\t\t\t\t\toverlap = this.overlap;\r\n\t\t\t\t\tradius = this.radius;\r\n\r\n\t\t\t\t\t// radius of parent comes from reversing overlap of this, unless overlap percent is 0\r\n\r\n\t\t\t\t\tradiusParent = this.tree.overlapPct > 0 ? overlap / ( ( 0.5 * this.tree.overlapPct ) * ( 1 + this.tree.overlapPct ) ) : radius * 2;\r\n\t\t\t\t\toverlapParent = radiusParent * this.tree.overlapPct;\r\n\r\n\t\t\t\t\t// parent offset is difference between radius + overlap of parent and child\r\n\r\n\t\t\t\t\tradiusOffset = ( radiusParent + overlapParent ) - ( radius + overlap );\r\n\t\t\t\t\toffset.set( indexOctant & 1 ? radiusOffset : - radiusOffset, indexOctant & 2 ? radiusOffset : - radiusOffset, indexOctant & 4 ? radiusOffset : - radiusOffset );\r\n\t\t\t\t\tposition = new Vector3().addVectors( this.position, offset );\r\n\r\n\t\t\t\t\t// parent\r\n\r\n\t\t\t\t\tparent = new OctreeNode( {\r\n\t\t\t\t\t\ttree: this.tree,\r\n\t\t\t\t\t\tposition: position,\r\n\t\t\t\t\t\tradius: radiusParent\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t// set self as node of parent\r\n\r\n\t\t\t\t\tparent.addNode( this, indexOctantInverse );\r\n\r\n\t\t\t\t\t// set parent as root\r\n\r\n\t\t\t\t\tthis.tree.setRoot( parent );\r\n\r\n\t\t\t\t\t// add all expand objects to parent\r\n\r\n\t\t\t\t\tfor ( i = 0, l = objectsExpand.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tthis$1.tree.root.addObject( objectsExpand[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if all objects, set remaining as new objects\r\n\r\n\t\t\t\tif ( objects === this.objects ) {\r\n\r\n\t\t\t\t\tthis.objects = objectsRemaining;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobjectsRemaining = objects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn objectsRemaining;\r\n\r\n\t\t},\r\n\r\n\t\tshrink: function () {\r\n\r\n\t\t\t// merge check\r\n\r\n\t\t\tthis.checkMerge();\r\n\r\n\t\t\t// contract check\r\n\r\n\t\t\tthis.tree.root.checkContract();\r\n\r\n\t\t},\r\n\r\n\t\tcheckMerge: function () {\r\n\r\n\t\t\tvar nodeParent = this,\r\n\t\t\t\tnodeMerge;\r\n\r\n\t\t\t// traverse up tree as long as node + entire subtree's object count is under minimum\r\n\r\n\t\t\twhile ( nodeParent.parent instanceof OctreeNode && nodeParent.getObjectCountEnd() < this.tree.objectsThreshold ) {\r\n\r\n\t\t\t\tnodeMerge = nodeParent;\r\n\t\t\t\tnodeParent = nodeParent.parent;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if parent node is not this, merge entire subtree into merge node\r\n\r\n\t\t\tif ( nodeParent !== this ) {\r\n\r\n\t\t\t\tnodeParent.merge( nodeMerge );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tmerge: function ( nodes ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnode;\r\n\r\n\t\t\t// handle nodes\r\n\r\n\t\t\tnodes = toArray( nodes );\r\n\r\n\t\t\tfor ( i = 0, l = nodes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tnode = nodes[ i ];\r\n\r\n\t\t\t\t// gather node + all subtree objects\r\n\r\n\t\t\t\tthis$1.addObjectWithoutCheck( node.getObjectsEnd() );\r\n\r\n\t\t\t\t// reset node + entire subtree\r\n\r\n\t\t\t\tnode.reset( true, true );\r\n\r\n\t\t\t\t// remove node\r\n\r\n\t\t\t\tthis$1.removeNode( node.indexOctant, node );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// merge check\r\n\r\n\t\t\tthis.checkMerge();\r\n\r\n\t\t},\r\n\r\n\t\tcheckContract: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnode,\r\n\t\t\t\tnodeObjectsCount,\r\n\t\t\t\tnodeHeaviest,\r\n\t\t\t\tnodeHeaviestObjectsCount,\r\n\t\t\t\toutsideHeaviestObjectsCount;\r\n\r\n\t\t\t// find node with highest object count\r\n\r\n\t\t\tif ( this.nodesIndices.length > 0 ) {\r\n\r\n\t\t\t\tnodeHeaviestObjectsCount = 0;\r\n\t\t\t\toutsideHeaviestObjectsCount = this.objects.length;\r\n\r\n\t\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tnode = this$1.nodesByIndex[ this$1.nodesIndices[ i ] ];\r\n\r\n\t\t\t\t\tnodeObjectsCount = node.getObjectCountEnd();\r\n\t\t\t\t\toutsideHeaviestObjectsCount += nodeObjectsCount;\r\n\r\n\t\t\t\t\tif ( nodeHeaviest instanceof OctreeNode === false || nodeObjectsCount > nodeHeaviestObjectsCount ) {\r\n\r\n\t\t\t\t\t\tnodeHeaviest = node;\r\n\t\t\t\t\t\tnodeHeaviestObjectsCount = nodeObjectsCount;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// subtract heaviest count from outside count\r\n\r\n\t\t\t\toutsideHeaviestObjectsCount -= nodeHeaviestObjectsCount;\r\n\r\n\t\t\t\t// if should contract\r\n\r\n\t\t\t\tif ( outsideHeaviestObjectsCount < this.tree.objectsThreshold && nodeHeaviest instanceof OctreeNode ) {\r\n\r\n\t\t\t\t\tthis.contract( nodeHeaviest );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tcontract: function ( nodeRoot ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnode;\r\n\r\n\t\t\t// handle all nodes\r\n\r\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tnode = this$1.nodesByIndex[ this$1.nodesIndices[ i ] ];\r\n\r\n\t\t\t\t// if node is not new root\r\n\r\n\t\t\t\tif ( node !== nodeRoot ) {\r\n\r\n\t\t\t\t\t// add node + all subtree objects to root\r\n\r\n\t\t\t\t\tnodeRoot.addObjectWithoutCheck( node.getObjectsEnd() );\r\n\r\n\t\t\t\t\t// reset node + entire subtree\r\n\r\n\t\t\t\t\tnode.reset( true, true );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// add own objects to root\r\n\r\n\t\t\tnodeRoot.addObjectWithoutCheck( this.objects );\r\n\r\n\t\t\t// reset self\r\n\r\n\t\t\tthis.reset( false, true );\r\n\r\n\t\t\t// set new root\r\n\r\n\t\t\tthis.tree.setRoot( nodeRoot );\r\n\r\n\t\t\t// contract check on new root\r\n\r\n\t\t\tnodeRoot.checkContract();\r\n\r\n\t\t},\r\n\r\n\t\tgetOctantIndex: function ( objectData ) {\r\n\r\n\t\t\tvar positionObj,\r\n\t\t\t\tradiusObj,\r\n\t\t\t\tposition = this.position,\r\n\t\t\t\tradiusOverlap = this.radiusOverlap,\r\n\t\t\t\toverlap = this.overlap,\r\n\t\t\t\tdeltaX, deltaY, deltaZ,\r\n\t\t\t\tdistX, distY, distZ,\r\n\t\t\t\tdistance,\r\n\t\t\t\tindexOctant = 0;\r\n\r\n\t\t\t// handle type\r\n\r\n\t\t\tif ( objectData instanceof OctreeObjectData ) {\r\n\r\n\t\t\t\tradiusObj = objectData.radius;\r\n\r\n\t\t\t\tpositionObj = objectData.position;\r\n\r\n\t\t\t\t// update object data position last\r\n\r\n\t\t\t\tobjectData.positionLast.copy( positionObj );\r\n\r\n\t\t\t} else if ( objectData instanceof OctreeNode ) {\r\n\r\n\t\t\t\tpositionObj = objectData.position;\r\n\r\n\t\t\t\tradiusObj = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// find delta and distance\r\n\r\n\t\t\tdeltaX = positionObj.x - position.x;\r\n\t\t\tdeltaY = positionObj.y - position.y;\r\n\t\t\tdeltaZ = positionObj.z - position.z;\r\n\r\n\t\t\tdistX = Math.abs( deltaX );\r\n\t\t\tdistY = Math.abs( deltaY );\r\n\t\t\tdistZ = Math.abs( deltaZ );\r\n\t\t\tdistance = Math.max( distX, distY, distZ );\r\n\r\n\t\t\t// if outside, use bitwise flags to indicate on which sides object is outside of\r\n\r\n\t\t\tif ( distance + radiusObj > radiusOverlap ) {\r\n\r\n\t\t\t\t// x\r\n\r\n\t\t\t\tif ( distX + radiusObj > radiusOverlap ) {\r\n\r\n\t\t\t\t\tindexOctant = indexOctant ^ ( deltaX > 0 ? this.tree.FLAG_POS_X : this.tree.FLAG_NEG_X );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// y\r\n\r\n\t\t\t\tif ( distY + radiusObj > radiusOverlap ) {\r\n\r\n\t\t\t\t\tindexOctant = indexOctant ^ ( deltaY > 0 ? this.tree.FLAG_POS_Y : this.tree.FLAG_NEG_Y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// z\r\n\r\n\t\t\t\tif ( distZ + radiusObj > radiusOverlap ) {\r\n\r\n\t\t\t\t\tindexOctant = indexOctant ^ ( deltaZ > 0 ? this.tree.FLAG_POS_Z : this.tree.FLAG_NEG_Z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobjectData.indexOctant = - indexOctant - this.tree.INDEX_OUTSIDE_OFFSET;\r\n\r\n\t\t\t\treturn objectData.indexOctant;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// return octant index from delta xyz\r\n\r\n\t\t\tif ( deltaX - radiusObj > - overlap ) {\r\n\r\n\t\t\t\t// x right\r\n\r\n\t\t\t\tindexOctant = indexOctant | 1;\r\n\r\n\t\t\t} else if ( ! ( deltaX + radiusObj < overlap ) ) {\r\n\r\n\t\t\t\t// x left\r\n\r\n\t\t\t\tobjectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;\r\n\t\t\t\treturn objectData.indexOctant;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( deltaY - radiusObj > - overlap ) {\r\n\r\n\t\t\t\t// y right\r\n\r\n\t\t\t\tindexOctant = indexOctant | 2;\r\n\r\n\t\t\t} else if ( ! ( deltaY + radiusObj < overlap ) ) {\r\n\r\n\t\t\t\t// y left\r\n\r\n\t\t\t\tobjectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;\r\n\t\t\t\treturn objectData.indexOctant;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( deltaZ - radiusObj > - overlap ) {\r\n\r\n\t\t\t\t// z right\r\n\r\n\t\t\t\tindexOctant = indexOctant | 4;\r\n\r\n\t\t\t} else if ( ! ( deltaZ + radiusObj < overlap ) ) {\r\n\r\n\t\t\t\t// z left\r\n\r\n\t\t\t\tobjectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;\r\n\t\t\t\treturn objectData.indexOctant;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobjectData.indexOctant = indexOctant;\r\n\t\t\treturn objectData.indexOctant;\r\n\r\n\t\t},\r\n\r\n\t\tgetOctantIndexFromPosition: function ( x, y, z ) {\r\n\r\n\t\t\tvar indexOctant = 0;\r\n\r\n\t\t\tif ( x > 0 ) {\r\n\r\n\t\t\t\tindexOctant = indexOctant | 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( y > 0 ) {\r\n\r\n\t\t\t\tindexOctant = indexOctant | 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( z > 0 ) {\r\n\r\n\t\t\t\tindexOctant = indexOctant | 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn indexOctant;\r\n\r\n\t\t},\r\n\r\n\t\tsearch: function ( position, radius, objects, direction, directionPct ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnode,\r\n\t\t\t\tintersects;\r\n\r\n\t\t\t// test intersects by parameters\r\n\r\n\t\t\tif ( direction ) {\r\n\r\n\t\t\t\tintersects = this.intersectRay( position, direction, radius, directionPct );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersects = this.intersectSphere( position, radius );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if intersects\r\n\r\n\t\t\tif ( intersects === true ) {\r\n\r\n\t\t\t\t// gather objects\r\n\r\n\t\t\t\tobjects = objects.concat( this.objects );\r\n\r\n\t\t\t\t// search subtree\r\n\r\n\t\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tnode = this$1.nodesByIndex[ this$1.nodesIndices[ i ] ];\r\n\r\n\t\t\t\t\tobjects = node.search( position, radius, objects, direction );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn objects;\r\n\r\n\t\t},\r\n\r\n\t\tintersectSphere: function ( position, radius ) {\r\n\r\n\t\t\tvar\tdistance = radius * radius,\r\n\t\t\t\tpx = position.x,\r\n\t\t\t\tpy = position.y,\r\n\t\t\t\tpz = position.z;\r\n\r\n\t\t\tif ( px < this.left ) {\r\n\r\n\t\t\t\tdistance -= Math.pow( px - this.left, 2 );\r\n\r\n\t\t\t} else if ( px > this.right ) {\r\n\r\n\t\t\t\tdistance -= Math.pow( px - this.right, 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( py < this.bottom ) {\r\n\r\n\t\t\t\tdistance -= Math.pow( py - this.bottom, 2 );\r\n\r\n\t\t\t} else if ( py > this.top ) {\r\n\r\n\t\t\t\tdistance -= Math.pow( py - this.top, 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( pz < this.back ) {\r\n\r\n\t\t\t\tdistance -= Math.pow( pz - this.back, 2 );\r\n\r\n\t\t\t} else if ( pz > this.front ) {\r\n\r\n\t\t\t\tdistance -= Math.pow( pz - this.front, 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn distance >= 0;\r\n\r\n\t\t},\r\n\r\n\t\tintersectRay: function ( origin, direction, distance, directionPct ) {\r\n\r\n\t\t\tif ( typeof directionPct === 'undefined' ) {\r\n\r\n\t\t\t\tdirectionPct = this.utilVec31Ray.set( 1, 1, 1 ).divide( direction );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t1 = ( this.left - origin.x ) * directionPct.x,\r\n\t\t\t\tt2 = ( this.right - origin.x ) * directionPct.x,\r\n\t\t\t\tt3 = ( this.bottom - origin.y ) * directionPct.y,\r\n\t\t\t\tt4 = ( this.top - origin.y ) * directionPct.y,\r\n\t\t\t\tt5 = ( this.back - origin.z ) * directionPct.z,\r\n\t\t\t\tt6 = ( this.front - origin.z ) * directionPct.z,\r\n\t\t\t\ttmax = Math.min( Math.min( Math.max( t1, t2 ), Math.max( t3, t4 ) ), Math.max( t5, t6 ) ),\r\n\t\t\t\ttmin;\r\n\r\n\t\t\t// ray would intersect in reverse direction, i.e. this is behind ray\r\n\t\t\tif ( tmax < 0 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttmin = Math.max( Math.max( Math.min( t1, t2 ), Math.min( t3, t4 ) ), Math.min( t5, t6 ) );\r\n\r\n\t\t\t// if tmin > tmax or tmin > ray distance, ray doesn't intersect AABB\r\n\t\t\tif ( tmin > tmax || tmin > distance ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t},\r\n\r\n\t\tgetDepthEnd: function ( depth ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnode;\r\n\r\n\t\t\tif ( this.nodesIndices.length > 0 ) {\r\n\r\n\t\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tnode = this$1.nodesByIndex[ this$1.nodesIndices[ i ] ];\r\n\r\n\t\t\t\t\tdepth = node.getDepthEnd( depth );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tdepth = ! depth || this.depth > depth ? this.depth : depth;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn depth;\r\n\r\n\t\t},\r\n\r\n\t\tgetNodeCountEnd: function () {\r\n\r\n\t\t\treturn this.tree.root.getNodeCountRecursive() + 1;\r\n\r\n\t\t},\r\n\r\n\t\tgetNodeCountRecursive: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tcount = this.nodesIndices.length;\r\n\r\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tcount += this$1.nodesByIndex[ this$1.nodesIndices[ i ] ].getNodeCountRecursive();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn count;\r\n\r\n\t\t},\r\n\r\n\t\tgetObjectsEnd: function ( objects ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnode;\r\n\r\n\t\t\tobjects = ( objects || [] ).concat( this.objects );\r\n\r\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tnode = this$1.nodesByIndex[ this$1.nodesIndices[ i ] ];\r\n\r\n\t\t\t\tobjects = node.getObjectsEnd( objects );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn objects;\r\n\r\n\t\t},\r\n\r\n\t\tgetObjectCountEnd: function () {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tcount = this.objects.length;\r\n\r\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tcount += this$1.nodesByIndex[ this$1.nodesIndices[ i ] ].getObjectCountEnd();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn count;\r\n\r\n\t\t},\r\n\r\n\t\tgetObjectCountStart: function () {\r\n\r\n\t\t\tvar count = this.objects.length,\r\n\t\t\t\tparent = this.parent;\r\n\r\n\t\t\twhile ( parent instanceof OctreeNode ) {\r\n\r\n\t\t\t\tcount += parent.objects.length;\r\n\t\t\t\tparent = parent.parent;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn count;\r\n\r\n\t\t},\r\n\r\n\t\ttoConsole: function ( space ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\tvar i, l,\r\n\t\t\t\tnode,\r\n\t\t\t\tspaceAddition = '   ';\r\n\r\n\t\t\tspace = typeof space === 'string' ? space : spaceAddition;\r\n\r\n\t\t\tconsole.log( ( this.parent ? space + ' octree NODE > ' : ' octree ROOT > ' ), this, ' // id: ', this.id, ' // indexOctant: ', this.indexOctant, ' // position: ', this.position.x, this.position.y, this.position.z, ' // radius: ', this.radius, ' // depth: ', this.depth );\r\n\t\t\tconsole.log( ( this.parent ? space + ' ' : ' ' ), '+ objects ( ', this.objects.length, ' ) ', this.objects );\r\n\t\t\tconsole.log( ( this.parent ? space + ' ' : ' ' ), '+ children ( ', this.nodesIndices.length, ' )', this.nodesIndices, this.nodesByIndex );\r\n\r\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tnode = this$1.nodesByIndex[ this$1.nodesIndices[ i ] ];\r\n\r\n\t\t\t\tnode.toConsole( space + spaceAddition );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tRaycaster.prototype.intersectOctreeObject = function ( object, recursive ) {\r\n\r\n\t\tvar intersects,\r\n\t\t\toctreeObject,\r\n\t\t\tfacesAll,\r\n\t\t\tfacesSearch;\r\n\r\n\t\tif ( object.object instanceof Object3D ) {\r\n\r\n\t\t\toctreeObject = object;\r\n\t\t\tobject = octreeObject.object;\r\n\r\n\t\t\t// temporarily replace object geometry's faces with octree object faces\r\n\r\n\t\t\tfacesSearch = octreeObject.faces;\r\n\t\t\tfacesAll = object.geometry.faces;\r\n\r\n\t\t\tif ( facesSearch.length > 0 ) {\r\n\r\n\t\t\t\tobject.geometry.faces = facesSearch;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// intersect\r\n\r\n\t\t\tintersects = this.intersectObject( object, recursive );\r\n\r\n\t\t\t// revert object geometry's faces\r\n\r\n\t\t\tif ( facesSearch.length > 0 ) {\r\n\r\n\t\t\t\tobject.geometry.faces = facesAll;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tintersects = this.intersectObject( object, recursive );\r\n\r\n\t\t}\r\n\r\n\t\treturn intersects;\r\n\r\n\t};\r\n\r\n\tRaycaster.prototype.intersectOctreeObjects = function ( objects, recursive ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar i, il,\r\n\t\t\tintersects = [];\r\n\r\n\t\tfor ( i = 0, il = objects.length; i < il; i ++ ) {\r\n\r\n\t\t\tintersects = intersects.concat( this$1.intersectOctreeObject( objects[ i ], recursive ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn intersects;\r\n\r\n\t};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PMREMCubeUVPacker = function ( cubeTextureLods ) {\n\tvar this$1 = this;\n\r\n\r\n\tthis.cubeLods = cubeTextureLods;\r\n\tvar size = cubeTextureLods[ 0 ].width * 4;\r\n\r\n\tvar sourceTexture = cubeTextureLods[ 0 ].texture;\r\n\tvar params = {\r\n\t\tformat: sourceTexture.format,\r\n\t\tmagFilter: sourceTexture.magFilter,\r\n\t\tminFilter: sourceTexture.minFilter,\r\n\t\ttype: sourceTexture.type,\r\n\t\tgenerateMipmaps: sourceTexture.generateMipmaps,\r\n\t\tanisotropy: sourceTexture.anisotropy,\r\n\t\tencoding: ( sourceTexture.encoding === RGBEEncoding ) ? RGBM16Encoding : sourceTexture.encoding\r\n\t};\r\n\r\n\tif ( params.encoding === RGBM16Encoding ) {\r\n\r\n\t\tparams.magFilter = LinearFilter;\r\n\t\tparams.minFilter = LinearFilter;\r\n\r\n\t}\r\n\r\n\tthis.CubeUVRenderTarget = new WebGLRenderTarget( size, size, params );\r\n\tthis.CubeUVRenderTarget.texture.name = \"PMREMCubeUVPacker.cubeUv\";\r\n\tthis.CubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\r\n\tthis.camera = new OrthographicCamera( - size * 0.5, size * 0.5, - size * 0.5, size * 0.5, 0, 1 ); // top and bottom are swapped for some reason?\r\n\r\n\tthis.scene = new Scene();\r\n\r\n\tthis.objects = [];\r\n\r\n\tvar geometry = new PlaneBufferGeometry( 1, 1 );\r\n\r\n\tvar faceOffsets = [];\r\n\tfaceOffsets.push( new Vector2( 0, 0 ) );\r\n\tfaceOffsets.push( new Vector2( 1, 0 ) );\r\n\tfaceOffsets.push( new Vector2( 2, 0 ) );\r\n\tfaceOffsets.push( new Vector2( 0, 1 ) );\r\n\tfaceOffsets.push( new Vector2( 1, 1 ) );\r\n\tfaceOffsets.push( new Vector2( 2, 1 ) );\r\n\r\n\tvar textureResolution = size;\r\n\tsize = cubeTextureLods[ 0 ].width;\r\n\r\n\tvar offset2 = 0;\r\n\tvar c = 4.0;\r\n\tthis.numLods = Math.log( cubeTextureLods[ 0 ].width ) / Math.log( 2 ) - 2; // IE11 doesn't support Math.log2\r\n\tfor ( var i = 0; i < this.numLods; i ++ ) {\r\n\r\n\t\tvar offset1 = ( textureResolution - textureResolution / c ) * 0.5;\r\n\t\tif ( size > 16 ) { c *= 2; }\r\n\t\tvar nMips = size > 16 ? 6 : 1;\r\n\t\tvar mipOffsetX = 0;\r\n\t\tvar mipOffsetY = 0;\r\n\t\tvar mipSize = size;\r\n\r\n\t\tfor ( var j = 0; j < nMips; j ++ ) {\r\n\r\n\t\t\t// Mip Maps\r\n\t\t\tfor ( var k = 0; k < 6; k ++ ) {\r\n\r\n\t\t\t\t// 6 Cube Faces\r\n\t\t\t\tvar material = this$1.getShader();\r\n\t\t\t\tmaterial.uniforms[ 'envMap' ].value = this$1.cubeLods[ i ].texture;\r\n\t\t\t\tmaterial.envMap = this$1.cubeLods[ i ].texture;\r\n\t\t\t\tmaterial.uniforms[ 'faceIndex' ].value = k;\r\n\t\t\t\tmaterial.uniforms[ 'mapSize' ].value = mipSize;\r\n\r\n\t\t\t\tvar planeMesh = new Mesh( geometry, material );\r\n\t\t\t\tplaneMesh.position.x = faceOffsets[ k ].x * mipSize - offset1 + mipOffsetX;\r\n\t\t\t\tplaneMesh.position.y = faceOffsets[ k ].y * mipSize - offset1 + offset2 + mipOffsetY;\r\n\t\t\t\tplaneMesh.material.side = BackSide;\r\n\t\t\t\tplaneMesh.scale.setScalar( mipSize );\r\n\t\t\t\tthis$1.scene.add( planeMesh );\r\n\t\t\t\tthis$1.objects.push( planeMesh );\r\n\r\n\t\t\t}\r\n\t\t\tmipOffsetY += 1.75 * mipSize;\r\n\t\t\tmipOffsetX += 1.25 * mipSize;\r\n\t\t\tmipSize /= 2;\r\n\r\n\t\t}\r\n\t\toffset2 += 2 * size;\r\n\t\tif ( size > 16 ) { size /= 2; }\r\n\r\n\t}\r\n\r\n};\r\n\r\nPMREMCubeUVPacker.prototype = {\r\n\r\n\tconstructor: PMREMCubeUVPacker,\r\n\r\n\tupdate: function ( renderer ) {\r\n\r\n\t\tvar gammaInput = renderer.gammaInput;\r\n\t\tvar gammaOutput = renderer.gammaOutput;\r\n\t\tvar toneMapping = renderer.toneMapping;\r\n\t\tvar toneMappingExposure = renderer.toneMappingExposure;\r\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\trenderer.gammaInput = false;\r\n\t\trenderer.gammaOutput = false;\r\n\t\trenderer.toneMapping = LinearToneMapping;\r\n\t\trenderer.toneMappingExposure = 1.0;\r\n\t\trenderer.render( this.scene, this.camera, this.CubeUVRenderTarget, false );\r\n\r\n\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\t\trenderer.toneMapping = toneMapping;\r\n\t\trenderer.toneMappingExposure = toneMappingExposure;\r\n\t\trenderer.gammaInput = gammaInput;\r\n\t\trenderer.gammaOutput = gammaOutput;\r\n\r\n\t},\r\n\r\n\tgetShader: function () {\r\n\r\n\t\tvar shaderMaterial = new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"faceIndex\": { value: 0 },\r\n\t\t\t\t\"mapSize\": { value: 0 },\r\n\t\t\t\t\"envMap\": { value: null },\r\n\t\t\t\t\"testColor\": { value: new Vector3( 1, 1, 1 ) }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t\"precision highp float;\\\r\n\t\t\t\tvarying vec2 vUv;\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tvUv = uv;\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t\"precision highp float;\\\r\n\t\t\t\tvarying vec2 vUv;\\\r\n\t\t\t\tuniform samplerCube envMap;\\\r\n\t\t\t\tuniform float mapSize;\\\r\n\t\t\t\tuniform vec3 testColor;\\\r\n\t\t\t\tuniform int faceIndex;\\\r\n\t\t\t\t\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tvec3 sampleDirection;\\\r\n\t\t\t\t\tvec2 uv = vUv;\\\r\n\t\t\t\t\tuv = uv * 2.0 - 1.0;\\\r\n\t\t\t\t\tuv.y *= -1.0;\\\r\n\t\t\t\t\tif(faceIndex == 0) {\\\r\n\t\t\t\t\t\tsampleDirection = normalize(vec3(1.0, uv.y, -uv.x));\\\r\n\t\t\t\t\t} else if(faceIndex == 1) {\\\r\n\t\t\t\t\t\tsampleDirection = normalize(vec3(uv.x, 1.0, uv.y));\\\r\n\t\t\t\t\t} else if(faceIndex == 2) {\\\r\n\t\t\t\t\t\tsampleDirection = normalize(vec3(uv.x, uv.y, 1.0));\\\r\n\t\t\t\t\t} else if(faceIndex == 3) {\\\r\n\t\t\t\t\t\tsampleDirection = normalize(vec3(-1.0, uv.y, uv.x));\\\r\n\t\t\t\t\t} else if(faceIndex == 4) {\\\r\n\t\t\t\t\t\tsampleDirection = normalize(vec3(uv.x, -1.0, -uv.y));\\\r\n\t\t\t\t\t} else {\\\r\n\t\t\t\t\t\tsampleDirection = normalize(vec3(-uv.x, uv.y, -1.0));\\\r\n\t\t\t\t\t}\\\r\n\t\t\t\t\tvec4 color = envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\\\r\n\t\t\t\t\tgl_FragColor = linearToOutputTexel( color );\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tblending: NoBlending\r\n\r\n\t\t} );\r\n\r\n\t\tshaderMaterial.type = 'PMREMCubeUVPacker';\r\n\r\n\t\treturn shaderMaterial;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0, l = this.objects.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis$1.objects[ i ].material.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.objects[ 0 ].geometry.dispose();\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PMREMGenerator = function ( sourceTexture, samplesPerLevel, resolution ) {\n\tvar this$1 = this;\n\r\n\r\n\tthis.sourceTexture = sourceTexture;\r\n\tthis.resolution = ( resolution !== undefined ) ? resolution : 256; // NODE: 256 is currently hard coded in the glsl code for performance reasons\r\n\tthis.samplesPerLevel = ( samplesPerLevel !== undefined ) ? samplesPerLevel : 16;\r\n\r\n\tvar monotonicEncoding = ( sourceTexture.encoding === LinearEncoding ) ||\r\n\t\t( sourceTexture.encoding === GammaEncoding ) || ( sourceTexture.encoding === sRGBEncoding );\r\n\r\n\tthis.sourceTexture.minFilter = ( monotonicEncoding ) ? LinearFilter : NearestFilter;\r\n\tthis.sourceTexture.magFilter = ( monotonicEncoding ) ? LinearFilter : NearestFilter;\r\n\tthis.sourceTexture.generateMipmaps = this.sourceTexture.generateMipmaps && monotonicEncoding;\r\n\r\n\tthis.cubeLods = [];\r\n\r\n\tvar size = this.resolution;\r\n\tvar params = {\r\n\t\tformat: this.sourceTexture.format,\r\n\t\tmagFilter: this.sourceTexture.magFilter,\r\n\t\tminFilter: this.sourceTexture.minFilter,\r\n\t\ttype: this.sourceTexture.type,\r\n\t\tgenerateMipmaps: this.sourceTexture.generateMipmaps,\r\n\t\tanisotropy: this.sourceTexture.anisotropy,\r\n\t\tencoding: this.sourceTexture.encoding\r\n\t };\r\n\r\n\t// how many LODs fit in the given CubeUV Texture.\r\n\tthis.numLods = Math.log( size ) / Math.log( 2 ) - 2; // IE11 doesn't support Math.log2\r\n\r\n\tfor ( var i = 0; i < this.numLods; i ++ ) {\r\n\r\n\t\tvar renderTarget = new WebGLRenderTargetCube( size, size, params );\r\n\t\trenderTarget.texture.name = \"PMREMGenerator.cube\" + i;\r\n\t\tthis$1.cubeLods.push( renderTarget );\r\n\t\tsize = Math.max( 16, size / 2 );\r\n\r\n\t}\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0.0, 1000 );\r\n\r\n\tthis.shader = this.getShader();\r\n\tthis.shader.defines[ 'SAMPLES_PER_LEVEL' ] = this.samplesPerLevel;\r\n\tthis.planeMesh = new Mesh( new PlaneBufferGeometry( 2, 2, 0 ), this.shader );\r\n\tthis.planeMesh.material.side = DoubleSide;\r\n\tthis.scene = new Scene();\r\n\tthis.scene.add( this.planeMesh );\r\n\tthis.scene.add( this.camera );\r\n\r\n\tthis.shader.uniforms[ 'envMap' ].value = this.sourceTexture;\r\n\tthis.shader.envMap = this.sourceTexture;\r\n\r\n};\r\n\r\nPMREMGenerator.prototype = {\r\n\r\n\tconstructor: PMREMGenerator,\r\n\t\r\n\tupdate: function ( renderer ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.shader.uniforms[ 'envMap' ].value = this.sourceTexture;\r\n\t\tthis.shader.envMap = this.sourceTexture;\r\n\r\n\t\tvar gammaInput = renderer.gammaInput;\r\n\t\tvar gammaOutput = renderer.gammaOutput;\r\n\t\tvar toneMapping = renderer.toneMapping;\r\n\t\tvar toneMappingExposure = renderer.toneMappingExposure;\r\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\trenderer.toneMapping = LinearToneMapping;\r\n\t\trenderer.toneMappingExposure = 1.0;\r\n\t\trenderer.gammaInput = false;\r\n\t\trenderer.gammaOutput = false;\r\n\r\n\t\tfor ( var i = 0; i < this.numLods; i ++ ) {\r\n\r\n\t\t\tvar r = i / ( this$1.numLods - 1 );\r\n\t\t\tthis$1.shader.uniforms[ 'roughness' ].value = r * 0.9; // see comment above, pragmatic choice\r\n\t\t\tthis$1.shader.uniforms[ 'queryScale' ].value.x = ( i == 0 ) ? - 1 : 1;\r\n\t\t\tvar size = this$1.cubeLods[ i ].width;\r\n\t\t\tthis$1.shader.uniforms[ 'mapSize' ].value = size;\r\n\t\t\tthis$1.renderToCubeMapTarget( renderer, this$1.cubeLods[ i ] );\r\n\r\n\t\t\tif ( i < 5 ) { this$1.shader.uniforms[ 'envMap' ].value = this$1.cubeLods[ i ].texture; }\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\t\trenderer.toneMapping = toneMapping;\r\n\t\trenderer.toneMappingExposure = toneMappingExposure;\r\n\t\trenderer.gammaInput = gammaInput;\r\n\t\trenderer.gammaOutput = gammaOutput;\r\n\r\n\t},\r\n\r\n\trenderToCubeMapTarget: function ( renderer, renderTarget ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tthis$1.renderToCubeMapTargetFace( renderer, renderTarget, i );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\trenderToCubeMapTargetFace: function ( renderer, renderTarget, faceIndex ) {\r\n\r\n\t\trenderTarget.activeCubeFace = faceIndex;\r\n\t\tthis.shader.uniforms[ 'faceIndex' ].value = faceIndex;\r\n\t\trenderer.render( this.scene, this.camera, renderTarget, true );\r\n\r\n\t},\r\n\r\n\tgetShader: function () {\r\n\r\n\t\tvar shaderMaterial = new ShaderMaterial( {\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\t\"SAMPLES_PER_LEVEL\": 20,\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"faceIndex\": { value: 0 },\r\n\t\t\t\t\"roughness\": { value: 0.5 },\r\n\t\t\t\t\"mapSize\": { value: 0.5 },\r\n\t\t\t\t\"envMap\": { value: null },\r\n\t\t\t\t\"queryScale\": { value: new Vector3( 1, 1, 1 ) },\r\n\t\t\t\t\"testColor\": { value: new Vector3( 1, 1, 1 ) },\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t\"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t\"#include <common>\\n\\\r\n\t\t\t\tvarying vec2 vUv;\\n\\\r\n\t\t\t\tuniform int faceIndex;\\n\\\r\n\t\t\t\tuniform float roughness;\\n\\\r\n\t\t\t\tuniform samplerCube envMap;\\n\\\r\n\t\t\t\tuniform float mapSize;\\n\\\r\n\t\t\t\tuniform vec3 testColor;\\n\\\r\n\t\t\t\tuniform vec3 queryScale;\\n\\\r\n\t\t\t\t\\n\\\r\n\t\t\t\tfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\\r\n\t\t\t\t\tfloat a = ggxRoughness + 0.0001;\\n\\\r\n\t\t\t\t\ta *= a;\\n\\\r\n\t\t\t\t\treturn ( 2.0 / a - 2.0 );\\n\\\r\n\t\t\t\t}\\n\\\r\n\t\t\t\tvec3 ImportanceSamplePhong(vec2 uv, mat3 vecSpace, float specPow) {\\n\\\r\n\t\t\t\t\tfloat phi = uv.y * 2.0 * PI;\\n\\\r\n\t\t\t\t\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\\n\\\r\n\t\t\t\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\r\n\t\t\t\t\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\\n\\\r\n\t\t\t\t\treturn vecSpace * sampleDir;\\n\\\r\n\t\t\t\t}\\n\\\r\n\t\t\t\tvec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace, float Roughness )\\n\\\r\n\t\t\t\t{\\n\\\r\n\t\t\t\t\tfloat a = Roughness * Roughness;\\n\\\r\n\t\t\t\t\tfloat Phi = 2.0 * PI * uv.x;\\n\\\r\n\t\t\t\t\tfloat CosTheta = sqrt( (1.0 - uv.y) / ( 1.0 + (a*a - 1.0) * uv.y ) );\\n\\\r\n\t\t\t\t\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\\n\\\r\n\t\t\t\t\treturn vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\\n\\\r\n\t\t\t\t}\\n\\\r\n\t\t\t\tmat3 matrixFromVector(vec3 n) {\\n\\\r\n\t\t\t\t\tfloat a = 1.0 / (1.0 + n.z);\\n\\\r\n\t\t\t\t\tfloat b = -n.x * n.y * a;\\n\\\r\n\t\t\t\t\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\\n\\\r\n\t\t\t\t\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\\n\\\r\n\t\t\t\t\treturn mat3(b1, b2, n);\\n\\\r\n\t\t\t\t}\\n\\\r\n\t\t\t\t\\n\\\r\n\t\t\t\tvec4 testColorMap(float Roughness) {\\n\\\r\n\t\t\t\t\tvec4 color;\\n\\\r\n\t\t\t\t\tif(faceIndex == 0)\\n\\\r\n\t\t\t\t\t\tcolor = vec4(1.0,0.0,0.0,1.0);\\n\\\r\n\t\t\t\t\telse if(faceIndex == 1)\\n\\\r\n\t\t\t\t\t\tcolor = vec4(0.0,1.0,0.0,1.0);\\n\\\r\n\t\t\t\t\telse if(faceIndex == 2)\\n\\\r\n\t\t\t\t\t\tcolor = vec4(0.0,0.0,1.0,1.0);\\n\\\r\n\t\t\t\t\telse if(faceIndex == 3)\\n\\\r\n\t\t\t\t\t\tcolor = vec4(1.0,1.0,0.0,1.0);\\n\\\r\n\t\t\t\t\telse if(faceIndex == 4)\\n\\\r\n\t\t\t\t\t\tcolor = vec4(0.0,1.0,1.0,1.0);\\n\\\r\n\t\t\t\t\telse\\n\\\r\n\t\t\t\t\t\tcolor = vec4(1.0,0.0,1.0,1.0);\\n\\\r\n\t\t\t\t\tcolor *= ( 1.0 - Roughness );\\n\\\r\n\t\t\t\t\treturn color;\\n\\\r\n\t\t\t\t}\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvec3 sampleDirection;\\n\\\r\n\t\t\t\t\tvec2 uv = vUv*2.0 - 1.0;\\n\\\r\n\t\t\t\t\tfloat offset = -1.0/mapSize;\\n\\\r\n\t\t\t\t\tconst float a = -1.0;\\n\\\r\n\t\t\t\t\tconst float b = 1.0;\\n\\\r\n\t\t\t\t\tfloat c = -1.0 + offset;\\n\\\r\n\t\t\t\t\tfloat d = 1.0 - offset;\\n\\\r\n\t\t\t\t\tfloat bminusa = b - a;\\n\\\r\n\t\t\t\t\tuv.x = (uv.x - a)/bminusa * d - (uv.x - b)/bminusa * c;\\n\\\r\n\t\t\t\t\tuv.y = (uv.y - a)/bminusa * d - (uv.y - b)/bminusa * c;\\n\\\r\n\t\t\t\t\tif (faceIndex==0) {\\n\\\r\n\t\t\t\t\t\tsampleDirection = vec3(1.0, -uv.y, -uv.x);\\n\\\r\n\t\t\t\t\t} else if (faceIndex==1) {\\n\\\r\n\t\t\t\t\t\tsampleDirection = vec3(-1.0, -uv.y, uv.x);\\n\\\r\n\t\t\t\t\t} else if (faceIndex==2) {\\n\\\r\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, 1.0, uv.y);\\n\\\r\n\t\t\t\t\t} else if (faceIndex==3) {\\n\\\r\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, -1.0, -uv.y);\\n\\\r\n\t\t\t\t\t} else if (faceIndex==4) {\\n\\\r\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, -uv.y, 1.0);\\n\\\r\n\t\t\t\t\t} else {\\n\\\r\n\t\t\t\t\t\tsampleDirection = vec3(-uv.x, -uv.y, -1.0);\\n\\\r\n\t\t\t\t\t}\\n\\\r\n\t\t\t\t\tmat3 vecSpace = matrixFromVector(normalize(sampleDirection * queryScale));\\n\\\r\n\t\t\t\t\tvec3 rgbColor = vec3(0.0);\\n\\\r\n\t\t\t\t\tconst int NumSamples = SAMPLES_PER_LEVEL;\\n\\\r\n\t\t\t\t\tvec3 vect;\\n\\\r\n\t\t\t\t\tfloat weight = 0.0;\\n\\\r\n\t\t\t\t\tfor( int i = 0; i < NumSamples; i ++ ) {\\n\\\r\n\t\t\t\t\t\tfloat sini = sin(float(i));\\n\\\r\n\t\t\t\t\t\tfloat cosi = cos(float(i));\\n\\\r\n\t\t\t\t\t\tfloat r = rand(vec2(sini, cosi));\\n\\\r\n\t\t\t\t\t\tvect = ImportanceSampleGGX(vec2(float(i) / float(NumSamples), r), vecSpace, roughness);\\n\\\r\n\t\t\t\t\t\tfloat dotProd = dot(vect, normalize(sampleDirection));\\n\\\r\n\t\t\t\t\t\tweight += dotProd;\\n\\\r\n\t\t\t\t\t\tvec3 color = envMapTexelToLinear(textureCube(envMap,vect)).rgb;\\n\\\r\n\t\t\t\t\t\trgbColor.rgb += color;\\n\\\r\n\t\t\t\t\t}\\n\\\r\n\t\t\t\t\trgbColor /= float(NumSamples);\\n\\\r\n\t\t\t\t\t//rgbColor = testColorMap( roughness ).rgb;\\n\\\r\n\t\t\t\t\tgl_FragColor = linearToOutputTexel( vec4( rgbColor, 1.0 ) );\\n\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tblending: NoBlending\r\n\r\n\t\t} );\r\n\r\n\t\tshaderMaterial.type = 'PMREMGenerator';\r\n\r\n\t\treturn shaderMaterial;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0, l = this.cubeLods.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis$1.cubeLods[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.planeMesh.geometry.dispose();\r\n\t\tthis.planeMesh.material.dispose();\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar CopyShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"opacity\":  { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float opacity;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\"gl_FragColor = opacity * texel;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar LuminosityShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"#include <common>\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\"float l = linearToRelativeLuminance( texel.rgb );\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( l, l, l, texel.w );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ToneMapShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"averageLuminance\":  { value: 1.0 },\r\n\t\t\"luminanceMap\":  { value: null },\r\n\t\t\"maxLuminance\":  { value: 16.0 },\r\n\t\t\"minLuminance\":  { value: 0.01 },\r\n\t\t\"middleGrey\":  { value: 0.6 }\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"#include <common>\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"uniform float middleGrey;\",\r\n\t\t\"uniform float minLuminance;\",\r\n\t\t\"uniform float maxLuminance;\",\r\n\t\t\"#ifdef ADAPTED_LUMINANCE\",\r\n\t\t\t\"uniform sampler2D luminanceMap;\",\r\n\t\t\"#else\",\r\n\t\t\t\"uniform float averageLuminance;\",\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vec3 ToneMap( vec3 vColor ) {\",\r\n\t\t\t\"#ifdef ADAPTED_LUMINANCE\",\r\n\t\t\t\t// Get the calculated average luminance\r\n\t\t\t\t\"float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\",\r\n\t\t\t\"#else\",\r\n\t\t\t\t\"float fLumAvg = averageLuminance;\",\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t// Calculate the luminance of the current pixel\r\n\t\t\t\"float fLumPixel = linearToRelativeLuminance( vColor );\",\r\n\r\n\t\t\t// Apply the modified operator (Eq. 4)\r\n\t\t\t\"float fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\",\r\n\r\n\t\t\t\"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\",\r\n\t\t\t\"return fLumCompressed * vColor;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar AdaptiveToneMappingPass = function ( adaptive, resolution ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.resolution = ( resolution !== undefined ) ? resolution : 256;\r\n\tthis.needsInit = true;\r\n\tthis.adaptive = adaptive !== undefined ? !! adaptive : true;\r\n\r\n\tthis.luminanceRT = null;\r\n\tthis.previousLuminanceRT = null;\r\n\tthis.currentLuminanceRT = null;\r\n\r\n\tif ( CopyShader === undefined )\r\n\t\t{ console.error( \"AdaptiveToneMappingPass relies on CopyShader\" ); }\r\n\r\n\tvar copyShader = CopyShader;\r\n\r\n\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\r\n\r\n\tthis.materialCopy = new ShaderMaterial( {\r\n\r\n\t\tuniforms: this.copyUniforms,\r\n\t\tvertexShader: copyShader.vertexShader,\r\n\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\tblending: NoBlending,\r\n\t\tdepthTest: false\r\n\r\n\t} );\r\n\r\n\tif ( LuminosityShader === undefined )\r\n\t\t{ console.error( \"AdaptiveToneMappingPass relies on LuminosityShader\" ); }\r\n\r\n\tthis.materialLuminance = new ShaderMaterial( {\r\n\r\n\t\tuniforms: UniformsUtils.clone( LuminosityShader.uniforms ),\r\n\t\tvertexShader: LuminosityShader.vertexShader,\r\n\t\tfragmentShader: LuminosityShader.fragmentShader,\r\n\t\tblending: NoBlending\r\n\t} );\r\n\r\n\tthis.adaptLuminanceShader = {\r\n\t\tdefines: {\r\n\t\t\t\"MIP_LEVEL_1X1\" : ( Math.log( this.resolution ) / Math.log( 2.0 ) ).toFixed( 1 )\r\n\t\t},\r\n\t\tuniforms: {\r\n\t\t\t\"lastLum\": { value: null },\r\n\t\t\t\"currentLum\": { value: null },\r\n\t\t\t\"minLuminance\": { value: 0.01 },\r\n\t\t\t\"delta\": { value: 0.016 },\r\n\t\t\t\"tau\": { value: 1.0 }\r\n\t\t},\r\n\t\tvertexShader: [\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\t\t].join( '\\n' ),\r\n\t\tfragmentShader: [\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"uniform sampler2D lastLum;\",\r\n\t\t\t\"uniform sampler2D currentLum;\",\r\n\t\t\t\"uniform float minLuminance;\",\r\n\t\t\t\"uniform float delta;\",\r\n\t\t\t\"uniform float tau;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\",\r\n\t\t\t\t\"vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\",\r\n\r\n\t\t\t\t\"float fLastLum = max( minLuminance, lastLum.r );\",\r\n\t\t\t\t\"float fCurrentLum = max( minLuminance, currentLum.r );\",\r\n\r\n\t\t\t\t//The adaption seems to work better in extreme lighting differences\r\n\t\t\t\t//if the input luminance is squared.\r\n\t\t\t\t\"fCurrentLum *= fCurrentLum;\",\r\n\r\n\t\t\t\t// Adapt the luminance using Pattanaik's technique\r\n\t\t\t\t\"float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\",\r\n\t\t\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\",\r\n\t\t\t\t\"gl_FragColor.r = fAdaptedLum;\",\r\n\t\t\t\"}\"\r\n\t\t].join( '\\n' )\r\n\t};\r\n\r\n\tthis.materialAdaptiveLum = new ShaderMaterial( {\r\n\r\n\t\tuniforms: UniformsUtils.clone( this.adaptLuminanceShader.uniforms ),\r\n\t\tvertexShader: this.adaptLuminanceShader.vertexShader,\r\n\t\tfragmentShader: this.adaptLuminanceShader.fragmentShader,\r\n\t\tdefines: Object.assign( {}, this.adaptLuminanceShader.defines ),\r\n\t\tblending: NoBlending\r\n\t} );\r\n\r\n\tif ( ToneMapShader === undefined )\r\n\t\t{ console.error( \"AdaptiveToneMappingPass relies on ToneMapShader\" ); }\r\n\r\n\tthis.materialToneMap = new ShaderMaterial( {\r\n\r\n\t\tuniforms: UniformsUtils.clone( ToneMapShader.uniforms ),\r\n\t\tvertexShader: ToneMapShader.vertexShader,\r\n\t\tfragmentShader: ToneMapShader.fragmentShader,\r\n\t\tblending: NoBlending\r\n\t} );\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nAdaptiveToneMappingPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: AdaptiveToneMappingPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( this.needsInit ) {\r\n\r\n\t\t\tthis.reset( renderer );\r\n\r\n\t\t\tthis.luminanceRT.texture.type = readBuffer.texture.type;\r\n\t\t\tthis.previousLuminanceRT.texture.type = readBuffer.texture.type;\r\n\t\t\tthis.currentLuminanceRT.texture.type = readBuffer.texture.type;\r\n\t\t\tthis.needsInit = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.adaptive ) {\r\n\r\n\t\t\t//Render the luminance of the current scene into a render target with mipmapping enabled\r\n\t\t\tthis.quad.material = this.materialLuminance;\r\n\t\t\tthis.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\r\n\t\t\trenderer.render( this.scene, this.camera, this.currentLuminanceRT );\r\n\r\n\t\t\t//Use the new luminance values, the previous luminance and the frame delta to\r\n\t\t\t//adapt the luminance over time.\r\n\t\t\tthis.quad.material = this.materialAdaptiveLum;\r\n\t\t\tthis.materialAdaptiveLum.uniforms.delta.value = delta;\r\n\t\t\tthis.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\r\n\t\t\tthis.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\r\n\t\t\trenderer.render( this.scene, this.camera, this.luminanceRT );\r\n\r\n\t\t\t//Copy the new adapted luminance value so that it can be used by the next frame.\r\n\t\t\tthis.quad.material = this.materialCopy;\r\n\t\t\tthis.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\r\n\t\t\trenderer.render( this.scene, this.camera, this.previousLuminanceRT );\r\n\r\n\t\t}\r\n\r\n\t\tthis.quad.material = this.materialToneMap;\r\n\t\tthis.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\treset: function( renderer ) {\r\n\r\n\t\t// render targets\r\n\t\tif ( this.luminanceRT ) {\r\n\r\n\t\t\tthis.luminanceRT.dispose();\r\n\r\n\t\t}\r\n\t\tif ( this.currentLuminanceRT ) {\r\n\r\n\t\t\tthis.currentLuminanceRT.dispose();\r\n\r\n\t\t}\r\n\t\tif ( this.previousLuminanceRT ) {\r\n\r\n\t\t\tthis.previousLuminanceRT.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tvar pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\r\n\r\n\t\tthis.luminanceRT = new WebGLRenderTarget( this.resolution, this.resolution, pars );\r\n\t\tthis.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\r\n\t\tthis.luminanceRT.texture.generateMipmaps = false;\r\n\r\n\t\tthis.previousLuminanceRT = new WebGLRenderTarget( this.resolution, this.resolution, pars );\r\n\t\tthis.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\r\n\t\tthis.previousLuminanceRT.texture.generateMipmaps = false;\r\n\r\n\t\t// We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\r\n\t\tpars.minFilter = LinearMipMapLinearFilter;\r\n\t\tthis.currentLuminanceRT = new WebGLRenderTarget( this.resolution, this.resolution, pars );\r\n\t\tthis.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\r\n\r\n\t\tif ( this.adaptive ) {\r\n\r\n\t\t\tthis.materialToneMap.defines[ \"ADAPTED_LUMINANCE\" ] = \"\";\r\n\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\r\n\r\n\t\t}\r\n\t\t//Put something in the adaptive luminance texture so that the scene can render initially\r\n\t\tthis.quad.material = new MeshBasicMaterial( { color: 0x777777 } );\r\n\t\tthis.materialLuminance.needsUpdate = true;\r\n\t\tthis.materialAdaptiveLum.needsUpdate = true;\r\n\t\tthis.materialToneMap.needsUpdate = true;\r\n\t\t// renderer.render( this.scene, this.camera, this.luminanceRT );\r\n\t\t// renderer.render( this.scene, this.camera, this.previousLuminanceRT );\r\n\t\t// renderer.render( this.scene, this.camera, this.currentLuminanceRT );\r\n\r\n\t},\r\n\r\n\tsetAdaptive: function( adaptive ) {\r\n\r\n\t\tif ( adaptive ) {\r\n\r\n\t\t\tthis.adaptive = true;\r\n\t\t\tthis.materialToneMap.defines[ \"ADAPTED_LUMINANCE\" ] = \"\";\r\n\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.adaptive = false;\r\n\t\t\tdelete this.materialToneMap.defines[ \"ADAPTED_LUMINANCE\" ];\r\n\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = null;\r\n\r\n\t\t}\r\n\t\tthis.materialToneMap.needsUpdate = true;\r\n\r\n\t},\r\n\r\n\tsetAdaptionRate: function( rate ) {\r\n\r\n\t\tif ( rate ) {\r\n\r\n\t\t\tthis.materialAdaptiveLum.uniforms.tau.value = Math.abs( rate );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetMinLuminance: function( minLum ) {\r\n\r\n\t\tif ( minLum ) {\r\n\r\n\t\t\tthis.materialToneMap.uniforms.minLuminance.value = minLum;\r\n\t\t\tthis.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetMaxLuminance: function( maxLum ) {\r\n\r\n\t\tif ( maxLum ) {\r\n\r\n\t\t\tthis.materialToneMap.uniforms.maxLuminance.value = maxLum;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetAverageLuminance: function( avgLum ) {\r\n\r\n\t\tif ( avgLum ) {\r\n\r\n\t\t\tthis.materialToneMap.uniforms.averageLuminance.value = avgLum;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetMiddleGrey: function( middleGrey ) {\r\n\r\n\t\tif ( middleGrey ) {\r\n\r\n\t\t\tthis.materialToneMap.uniforms.middleGrey.value = middleGrey;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdispose: function() {\r\n\r\n\t\tif ( this.luminanceRT ) {\r\n\r\n\t\t\tthis.luminanceRT.dispose();\r\n\r\n\t\t}\r\n\t\tif ( this.previousLuminanceRT ) {\r\n\r\n\t\t\tthis.previousLuminanceRT.dispose();\r\n\r\n\t\t}\r\n\t\tif ( this.currentLuminanceRT ) {\r\n\r\n\t\t\tthis.currentLuminanceRT.dispose();\r\n\r\n\t\t}\r\n\t\tif ( this.materialLuminance ) {\r\n\r\n\t\t\tthis.materialLuminance.dispose();\r\n\r\n\t\t}\r\n\t\tif ( this.materialAdaptiveLum ) {\r\n\r\n\t\t\tthis.materialAdaptiveLum.dispose();\r\n\r\n\t\t}\r\n\t\tif ( this.materialCopy ) {\r\n\r\n\t\t\tthis.materialCopy.dispose();\r\n\r\n\t\t}\r\n\t\tif ( this.materialToneMap ) {\r\n\r\n\t\t\tthis.materialToneMap.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar AfterimageShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"damp\": { value: 0.96 },\r\n\t\t\"tOld\": { value: null },\r\n\t\t\"tNew\": { value: null }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float damp;\",\r\n\r\n\t\t\"uniform sampler2D tOld;\",\r\n\t\t\"uniform sampler2D tNew;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\r\n\t\t\"vec4 when_gt( vec4 x, float y ) {\",\r\n\r\n\t\t\t\"return max( sign( x - y ), 0.0 );\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texelOld = texture2D( tOld, vUv );\",\r\n\t\t\t\"vec4 texelNew = texture2D( tNew, vUv );\",\r\n\t\t\t\r\n\t\t\t\"texelOld *= damp * when_gt( texelOld, 0.1 );\",\r\n\r\n\t\t\t\"gl_FragColor = max(texelNew, texelOld);\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar AfterimagePass = function ( damp ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tif ( AfterimageShader === undefined )\r\n\t\t{ console.error( \"AfterimagePass relies on AfterimageShader\" ); }\r\n\r\n\tthis.shader = AfterimageShader;\r\n\r\n\tthis.uniforms = UniformsUtils.clone( this.shader.uniforms );\r\n\r\n\tthis.uniforms[ \"damp\" ].value = damp !== undefined ? damp : 0.96;\r\n\r\n\tthis.textureComp = new WebGLRenderTarget( window.innerWidth, window.innerHeight, {\r\n\r\n\t\tminFilter: LinearFilter,\r\n\t\tmagFilter: NearestFilter,\r\n\t\tformat: RGBAFormat\r\n\r\n\t} );\r\n\r\n\tthis.textureOld = new WebGLRenderTarget( window.innerWidth, window.innerHeight, {\r\n\r\n\t\tminFilter: LinearFilter,\r\n\t\tmagFilter: NearestFilter,\r\n\t\tformat: RGBAFormat\r\n\r\n\t} );\r\n\r\n\tthis.shaderMaterial = new ShaderMaterial( {\r\n\r\n\t\tuniforms: this.uniforms,\r\n\t\tvertexShader: this.shader.vertexShader,\r\n\t\tfragmentShader: this.shader.fragmentShader\r\n\r\n\t} );\r\n\r\n\tthis.sceneComp = new Scene();\r\n\tthis.scene = new Scene();\r\n\r\n\tthis.camera = new OrthographicCamera( -1, 1, 1, -1, 0, 1 );\r\n\tthis.camera.position.z = 1;\r\n\r\n\tvar geometry = new PlaneBufferGeometry( 2, 2 );\r\n\r\n\tthis.quadComp = new Mesh( geometry, this.shaderMaterial );\r\n\tthis.sceneComp.add( this.quadComp );\r\n\r\n\tvar material = new MeshBasicMaterial( { \r\n\t\tmap: this.textureComp.texture\r\n\t} );\r\n\r\n\tvar quadScreen = new Mesh( geometry, material );\r\n\tthis.scene.add( quadScreen );\r\n\r\n};\r\n\r\nAfterimagePass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: AfterimagePass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer ) {\r\n\r\n\t\tthis.uniforms[ \"tOld\" ].value = this.textureOld.texture;\r\n\t\tthis.uniforms[ \"tNew\" ].value = readBuffer.texture;\r\n\r\n\t\tthis.quadComp.material = this.shaderMaterial;\r\n\r\n\t\trenderer.render( this.sceneComp, this.camera, this.textureComp );\r\n\t\trenderer.render( this.scene, this.camera, this.textureOld );\r\n\t\t\r\n\t\tif ( this.renderToScreen ) {\r\n\t\t\t\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\t\t\t\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ConvolutionShader = {\r\n\r\n\tdefines: {\r\n\r\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\r\n\t\t\"KERNEL_SIZE_INT\": \"25\"\r\n\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":        { value: null },\r\n\t\t\"uImageIncrement\": { value: new Vector2( 0.001953125, 0.0 ) },\r\n\t\t\"cKernel\":         { value: [] }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 imageCoord = vUv;\",\r\n\t\t\t\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\r\n\r\n\t\t\t\"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\r\n\r\n\t\t\t\t\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\r\n\t\t\t\t\"imageCoord += uImageIncrement;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tbuildKernel: function ( sigma ) {\r\n\r\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\r\n\r\n\t\tfunction gauss( x, sigma ) {\r\n\r\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\r\n\r\n\t\tif ( kernelSize > kMaxKernelSize ) { kernelSize = kMaxKernelSize; }\r\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\r\n\r\n\t\tvalues = new Array( kernelSize );\r\n\t\tsum = 0.0;\r\n\t\tfor ( i = 0; i < kernelSize; ++ i ) {\r\n\r\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\r\n\t\t\tsum += values[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// normalize the kernel\r\n\r\n\t\tfor ( i = 0; i < kernelSize; ++ i ) { values[ i ] /= sum; }\r\n\r\n\t\treturn values;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BloomPass = function ( strength, kernelSize, sigma, resolution ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tstrength = ( strength !== undefined ) ? strength : 1;\r\n\tkernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;\r\n\tsigma = ( sigma !== undefined ) ? sigma : 4.0;\r\n\tresolution = ( resolution !== undefined ) ? resolution : 256;\r\n\r\n\t// render targets\r\n\r\n\tvar pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\r\n\r\n\tthis.renderTargetX = new WebGLRenderTarget( resolution, resolution, pars );\r\n\tthis.renderTargetX.texture.name = \"BloomPass.x\";\r\n\tthis.renderTargetY = new WebGLRenderTarget( resolution, resolution, pars );\r\n\tthis.renderTargetY.texture.name = \"BloomPass.y\";\r\n\r\n\t// copy material\r\n\r\n\tif ( CopyShader === undefined )\r\n\t\t{ console.error( \"BloomPass relies on CopyShader\" ); }\r\n\r\n\tvar copyShader = CopyShader;\r\n\r\n\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\r\n\r\n\tthis.copyUniforms[ \"opacity\" ].value = strength;\r\n\r\n\tthis.materialCopy = new ShaderMaterial( {\r\n\r\n\t\tuniforms: this.copyUniforms,\r\n\t\tvertexShader: copyShader.vertexShader,\r\n\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\tblending: AdditiveBlending,\r\n\t\ttransparent: true\r\n\r\n\t} );\r\n\r\n\t// convolution material\r\n\r\n\tif ( ConvolutionShader === undefined )\r\n\t\t{ console.error( \"BloomPass relies on ConvolutionShader\" ); }\r\n\r\n\tvar convolutionShader = ConvolutionShader;\r\n\r\n\tthis.convolutionUniforms = UniformsUtils.clone( convolutionShader.uniforms );\r\n\r\n\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = BloomPass.blurX;\r\n\tthis.convolutionUniforms[ \"cKernel\" ].value = ConvolutionShader.buildKernel( sigma );\r\n\r\n\tthis.materialConvolution = new ShaderMaterial( {\r\n\r\n\t\tuniforms: this.convolutionUniforms,\r\n\t\tvertexShader:  convolutionShader.vertexShader,\r\n\t\tfragmentShader: convolutionShader.fragmentShader,\r\n\t\tdefines: {\r\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed( 1 ),\r\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed( 0 )\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nBloomPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: BloomPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( maskActive ) { renderer.context.disable( renderer.context.STENCIL_TEST ); }\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 1)\r\n\r\n\t\tthis.quad.material = this.materialConvolution;\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = BloomPass.blurX;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetX, true );\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 2)\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = this.renderTargetX.texture;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = BloomPass.blurY;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetY, true );\r\n\r\n\t\t// Render original scene with superimposed blur to texture\r\n\r\n\t\tthis.quad.material = this.materialCopy;\r\n\r\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetY.texture;\r\n\r\n\t\tif ( maskActive ) { renderer.context.enable( renderer.context.STENCIL_TEST ); }\r\n\r\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nBloomPass.blurX = new Vector2( 0.001953125, 0.0 );\r\nBloomPass.blurY = new Vector2( 0.0, 0.001953125 );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BokehPass = function ( scene, camera, params ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tvar focus = ( params.focus !== undefined ) ? params.focus : 1.0;\r\n\tvar aspect = ( params.aspect !== undefined ) ? params.aspect : camera.aspect;\r\n\tvar aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;\r\n\tvar maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;\r\n\r\n\t// render targets\r\n\r\n\tvar width = params.width || window.innerWidth || 1;\r\n\tvar height = params.height || window.innerHeight || 1;\r\n\r\n\tthis.renderTargetColor = new WebGLRenderTarget( width, height, {\r\n\t\tminFilter: LinearFilter,\r\n\t\tmagFilter: LinearFilter,\r\n\t\tformat: RGBFormat\r\n\t} );\r\n\tthis.renderTargetColor.texture.name = \"BokehPass.color\";\r\n\r\n\tthis.renderTargetDepth = this.renderTargetColor.clone();\r\n\tthis.renderTargetDepth.texture.name = \"BokehPass.depth\";\r\n\r\n\t// depth material\r\n\r\n\tthis.materialDepth = new MeshDepthMaterial();\r\n\tthis.materialDepth.depthPacking = RGBADepthPacking;\r\n\tthis.materialDepth.blending = NoBlending;\r\n\r\n\t// bokeh material\r\n\r\n\tif ( BokehShader === undefined ) {\r\n\r\n\t\tconsole.error( \"BokehPass relies on BokehShader\" );\r\n\r\n\t}\r\n\r\n\tvar bokehShader = BokehShader;\r\n\tvar bokehUniforms = UniformsUtils.clone( bokehShader.uniforms );\r\n\r\n\tbokehUniforms[ \"tDepth\" ].value = this.renderTargetDepth.texture;\r\n\r\n\tbokehUniforms[ \"focus\" ].value = focus;\r\n\tbokehUniforms[ \"aspect\" ].value = aspect;\r\n\tbokehUniforms[ \"aperture\" ].value = aperture;\r\n\tbokehUniforms[ \"maxblur\" ].value = maxblur;\r\n\tbokehUniforms[ \"nearClip\" ].value = camera.near;\r\n\tbokehUniforms[ \"farClip\" ].value = camera.far;\r\n\r\n\tthis.materialBokeh = new ShaderMaterial( {\r\n\t\tdefines: Object.assign( {}, bokehShader.defines ),\r\n\t\tuniforms: bokehUniforms,\r\n\t\tvertexShader: bokehShader.vertexShader,\r\n\t\tfragmentShader: bokehShader.fragmentShader\r\n\t} );\r\n\r\n\tthis.uniforms = bokehUniforms;\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.camera2 = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene2  = new Scene();\r\n\r\n\tthis.quad2 = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad2.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene2.add( this.quad2 );\r\n\r\n\tthis.oldClearColor = new Color();\r\n\tthis.oldClearAlpha = 1;\r\n\r\n};\r\n\r\nBokehPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: BokehPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.quad2.material = this.materialBokeh;\r\n\r\n\t\t// Render depth into texture\r\n\r\n\t\tthis.scene.overrideMaterial = this.materialDepth;\r\n\r\n\t\tthis.oldClearColor.copy( renderer.getClearColor() );\r\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\r\n\t\tvar oldAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\trenderer.setClearColor( 0xffffff );\r\n\t\trenderer.setClearAlpha( 1.0 );\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetDepth, true );\r\n\r\n\t\t// Render bokeh composite\r\n\r\n\t\tthis.uniforms[ \"tColor\" ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ \"nearClip\" ].value = this.camera.near;\r\n\t\tthis.uniforms[ \"farClip\" ].value = this.camera.far;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene2, this.camera2 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene2, this.camera2, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t\tthis.scene.overrideMaterial = null;\r\n\t\trenderer.setClearColor( this.oldClearColor );\r\n\t\trenderer.setClearAlpha( this.oldClearAlpha );\r\n\t\trenderer.autoClear = this.oldAutoClear;\r\n\t\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ClearPass = function ( clearColor, clearAlpha ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;\r\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\r\n\r\n};\r\n\r\nClearPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: ClearPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tvar oldClearColor, oldClearAlpha;\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\toldClearColor = renderer.getClearColor().getHex();\r\n\t\t\toldClearAlpha = renderer.getClearAlpha();\r\n\r\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\r\n\t\trenderer.clear();\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar CubeTexturePass = function ( camera, envMap, opacity ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.camera = camera;\r\n\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.cubeShader = ShaderLib[ 'cube' ];\r\n\tthis.cubeMesh = new Mesh(\r\n\t\tnew BoxBufferGeometry( 10, 10, 10 ),\r\n\t\tnew ShaderMaterial( {\r\n\t\t\tuniforms: this.cubeShader.uniforms,\r\n\t\t\tvertexShader: this.cubeShader.vertexShader,\r\n\t\t\tfragmentShader: this.cubeShader.fragmentShader,\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\tside: BackSide\r\n\t\t} )\r\n\t);\r\n\r\n\tthis.envMap = envMap;\r\n\tthis.opacity = ( opacity !== undefined ) ? opacity : 1.0;\r\n\r\n\tthis.cubeScene = new Scene();\r\n\tthis.cubeCamera = new PerspectiveCamera();\r\n\tthis.cubeScene.add( this.cubeMesh );\r\n\r\n};\r\n\r\nCubeTexturePass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: CubeTexturePass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tvar oldAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\tthis.cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\t\tthis.cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );\r\n\r\n\t\tthis.cubeMesh.material.uniforms[ \"tCube\" ].value = this.envMap;\r\n\t\tthis.cubeMesh.material.uniforms[ \"opacity\" ].value = this.opacity;\r\n\t\tthis.cubeMesh.material.transparent = ( this.opacity < 1.0 );\r\n\r\n\t\trenderer.render( this.cubeScene, this.cubeCamera, this.renderToScreen ? null : readBuffer, this.clear );\r\n\r\n\t\trenderer.autoClear = oldAutoClear;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar DotScreenShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"tSize\":    { value: new Vector2( 256, 256 ) },\r\n\t\t\"center\":   { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\"angle\":    { value: 1.57 },\r\n\t\t\"scale\":    { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform vec2 center;\",\r\n\t\t\"uniform float angle;\",\r\n\t\t\"uniform float scale;\",\r\n\t\t\"uniform vec2 tSize;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"float pattern() {\",\r\n\r\n\t\t\t\"float s = sin( angle ), c = cos( angle );\",\r\n\r\n\t\t\t\"vec2 tex = vUv * tSize - center;\",\r\n\t\t\t\"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\",\r\n\r\n\t\t\t\"return ( sin( point.x ) * sin( point.y ) ) * 4.0;\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\"float average = ( color.r + color.g + color.b ) / 3.0;\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar DotScreenPass = function ( center, angle, scale ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tif ( DotScreenShader === undefined )\r\n\t\t{ console.error( \"DotScreenPass relies on DotScreenShader\" ); }\r\n\r\n\tvar shader = DotScreenShader;\r\n\r\n\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\r\n\r\n\tif ( center !== undefined ) { this.uniforms[ \"center\" ].value.copy( center ); }\r\n\tif ( angle !== undefined ) { this.uniforms[ \"angle\" ].value = angle; }\r\n\tif ( scale !== undefined ) { this.uniforms[ \"scale\" ].value = scale; }\r\n\r\n\tthis.material = new ShaderMaterial( {\r\n\r\n\t\tuniforms: this.uniforms,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t} );\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nDotScreenPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: DotScreenPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ \"tSize\" ].value.set( readBuffer.width, readBuffer.height );\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MaskPass = function ( scene, camera ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.clear = true;\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.inverse = false;\r\n\r\n};\r\n\r\nMaskPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: MaskPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tvar context = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\r\n\t\t// don't update color or depth\r\n\r\n\t\tstate.buffers.color.setMask( false );\r\n\t\tstate.buffers.depth.setMask( false );\r\n\r\n\t\t// lock buffers\r\n\r\n\t\tstate.buffers.color.setLocked( true );\r\n\t\tstate.buffers.depth.setLocked( true );\r\n\r\n\t\t// set up stencil\r\n\r\n\t\tvar writeValue, clearValue;\r\n\r\n\t\tif ( this.inverse ) {\r\n\r\n\t\t\twriteValue = 0;\r\n\t\t\tclearValue = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\twriteValue = 1;\r\n\t\t\tclearValue = 0;\r\n\r\n\t\t}\r\n\r\n\t\tstate.buffers.stencil.setTest( true );\r\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\r\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\r\n\t\tstate.buffers.stencil.setClear( clearValue );\r\n\r\n\t\t// draw into the stencil buffer\r\n\r\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\r\n\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t// unlock color and depth buffer for subsequent rendering\r\n\r\n\t\tstate.buffers.color.setLocked( false );\r\n\t\tstate.buffers.depth.setLocked( false );\r\n\r\n\t\t// only render where stencil is set to 1\r\n\r\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1\r\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nvar ClearMaskPass = function () {\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n};\r\n\r\nClearMaskPass.prototype = Object.create( Pass.prototype );\r\n\r\nObject.assign( ClearMaskPass.prototype, {\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\trenderer.state.buffers.stencil.setTest( false );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar EffectComposer = function ( renderer, renderTarget ) {\r\n\r\n\tthis.renderer = renderer;\r\n\r\n\tif ( renderTarget === undefined ) {\r\n\r\n\t\tvar parameters = {\r\n\t\t\tminFilter: LinearFilter,\r\n\t\t\tmagFilter: LinearFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\tstencilBuffer: false\r\n\t\t};\r\n\r\n\t\tvar size = renderer.getDrawingBufferSize();\r\n\t\trenderTarget = new WebGLRenderTarget( size.width, size.height, parameters );\r\n\t\trenderTarget.texture.name = 'EffectComposer.rt1';\r\n\r\n\t}\r\n\r\n\tthis.renderTarget1 = renderTarget;\r\n\tthis.renderTarget2 = renderTarget.clone();\r\n\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\r\n\r\n\tthis.writeBuffer = this.renderTarget1;\r\n\tthis.readBuffer = this.renderTarget2;\r\n\r\n\tthis.passes = [];\r\n\r\n\t// dependencies\r\n\r\n\tif ( CopyShader === undefined ) {\r\n\r\n\t\tconsole.error( 'EffectComposer relies on CopyShader' );\r\n\r\n\t}\r\n\r\n\tif ( ShaderPass === undefined ) {\r\n\r\n\t\tconsole.error( 'EffectComposer relies on ShaderPass' );\r\n\r\n\t}\r\n\r\n\tthis.copyPass = new ShaderPass( CopyShader );\r\n\r\n};\r\n\r\nObject.assign( EffectComposer.prototype, {\r\n\r\n\tswapBuffers: function () {\r\n\r\n\t\tvar tmp = this.readBuffer;\r\n\t\tthis.readBuffer = this.writeBuffer;\r\n\t\tthis.writeBuffer = tmp;\r\n\r\n\t},\r\n\r\n\taddPass: function ( pass ) {\r\n\r\n\t\tthis.passes.push( pass );\r\n\r\n\t\tvar size = this.renderer.getDrawingBufferSize();\r\n\t\tpass.setSize( size.width, size.height );\r\n\r\n\t},\r\n\r\n\tinsertPass: function ( pass, index ) {\r\n\r\n\t\tthis.passes.splice( index, 0, pass );\r\n\r\n\t},\r\n\r\n\trender: function ( delta ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar maskActive = false;\r\n\r\n\t\tvar pass, i, il = this.passes.length;\r\n\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tpass = this$1.passes[ i ];\r\n\r\n\t\t\tif ( pass.enabled === false ) { continue; }\r\n\r\n\t\t\tpass.render( this$1.renderer, this$1.writeBuffer, this$1.readBuffer, delta, maskActive );\r\n\r\n\t\t\tif ( pass.needsSwap ) {\r\n\r\n\t\t\t\tif ( maskActive ) {\r\n\r\n\t\t\t\t\tvar context = this$1.renderer.context;\r\n\r\n\t\t\t\t\tcontext.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t\tthis$1.copyPass.render( this$1.renderer, this$1.writeBuffer, this$1.readBuffer, delta );\r\n\r\n\t\t\t\t\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis$1.swapBuffers();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( MaskPass !== undefined ) {\r\n\r\n\t\t\t\tif ( pass instanceof MaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = true;\r\n\r\n\t\t\t\t} else if ( pass instanceof ClearMaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\treset: function ( renderTarget ) {\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\tvar size = this.renderer.getDrawingBufferSize();\r\n\r\n\t\t\trenderTarget = this.renderTarget1.clone();\r\n\t\t\trenderTarget.setSize( size.width, size.height );\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTarget1.dispose();\r\n\t\tthis.renderTarget2.dispose();\r\n\t\tthis.renderTarget1 = renderTarget;\r\n\t\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\t\tthis.writeBuffer = this.renderTarget1;\r\n\t\tthis.readBuffer = this.renderTarget2;\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.renderTarget1.setSize( width, height );\r\n\t\tthis.renderTarget2.setSize( width, height );\r\n\r\n\t\tfor ( var i = 0; i < this.passes.length; i ++ ) {\r\n\r\n\t\t\tthis$1.passes[ i ].setSize( width, height );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar FilmShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":   { value: null },\r\n\t\t\"time\":       { value: 0.0 },\r\n\t\t\"nIntensity\": { value: 0.5 },\r\n\t\t\"sIntensity\": { value: 0.05 },\r\n\t\t\"sCount\":     { value: 4096 },\r\n\t\t\"grayscale\":  { value: 1 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"#include <common>\",\r\n\t\t\r\n\t\t// control parameter\r\n\t\t\"uniform float time;\",\r\n\r\n\t\t\"uniform bool grayscale;\",\r\n\r\n\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\r\n\t\t\"uniform float nIntensity;\",\r\n\r\n\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\r\n\t\t\"uniform float sIntensity;\",\r\n\r\n\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\r\n\t\t\"uniform float sCount;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t// sample the source\r\n\t\t\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t// make some noise\r\n\t\t\t\"float dx = rand( vUv + time );\",\r\n\r\n\t\t\t// add noise\r\n\t\t\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\",\r\n\r\n\t\t\t// get us a sine and cosine\r\n\t\t\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\r\n\r\n\t\t\t// add scanlines\r\n\t\t\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\r\n\r\n\t\t\t// interpolate between source and result by intensity\r\n\t\t\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\r\n\r\n\t\t\t// convert to grayscale if desired\r\n\t\t\t\"if( grayscale ) {\",\r\n\r\n\t\t\t\t\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tif ( FilmShader === undefined )\r\n\t\t{ console.error( \"FilmPass relies on FilmShader\" ); }\r\n\r\n\tvar shader = FilmShader;\r\n\r\n\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\r\n\r\n\tthis.material = new ShaderMaterial( {\r\n\r\n\t\tuniforms: this.uniforms,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t} );\r\n\r\n\tif ( grayscale !== undefined )\t{ this.uniforms.grayscale.value = grayscale; }\r\n\tif ( noiseIntensity !== undefined ) { this.uniforms.nIntensity.value = noiseIntensity; }\r\n\tif ( scanlinesIntensity !== undefined ) { this.uniforms.sIntensity.value = scanlinesIntensity; }\r\n\tif ( scanlinesCount !== undefined ) { this.uniforms.sCount.value = scanlinesCount; }\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nFilmPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: FilmPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ \"time\" ].value += delta;\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar DigitalGlitch = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":\t\t{ value: null },//diffuse texture\r\n\t\t\"tDisp\":\t\t{ value: null },//displacement texture for digital glitch squares\r\n\t\t\"byp\":\t\t\t{ value: 0 },//apply the glitch ?\r\n\t\t\"amount\":\t\t{ value: 0.08 },\r\n\t\t\"angle\":\t\t{ value: 0.02 },\r\n\t\t\"seed\":\t\t\t{ value: 0.02 },\r\n\t\t\"seed_x\":\t\t{ value: 0.02 },//-1,1\r\n\t\t\"seed_y\":\t\t{ value: 0.02 },//-1,1\r\n\t\t\"distortion_x\":\t{ value: 0.5 },\r\n\t\t\"distortion_y\":\t{ value: 0.6 },\r\n\t\t\"col_s\":\t\t{ value: 0.05 }\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\"void main() {\",\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\"}\"\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\t\t\"uniform int byp;\",//should we apply the glitch ?\r\n\t\t\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform sampler2D tDisp;\",\r\n\t\t\r\n\t\t\"uniform float amount;\",\r\n\t\t\"uniform float angle;\",\r\n\t\t\"uniform float seed;\",\r\n\t\t\"uniform float seed_x;\",\r\n\t\t\"uniform float seed_y;\",\r\n\t\t\"uniform float distortion_x;\",\r\n\t\t\"uniform float distortion_y;\",\r\n\t\t\"uniform float col_s;\",\r\n\t\t\t\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\r\n\t\t\"float rand(vec2 co){\",\r\n\t\t\t\"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\",\r\n\t\t\"}\",\r\n\t\t\t\t\r\n\t\t\"void main() {\",\r\n\t\t\t\"if(byp<1) {\",\r\n\t\t\t\t\"vec2 p = vUv;\",\r\n\t\t\t\t\"float xs = floor(gl_FragCoord.x / 0.5);\",\r\n\t\t\t\t\"float ys = floor(gl_FragCoord.y / 0.5);\",\r\n\t\t\t\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\r\n\t\t\t\t\"vec4 normal = texture2D (tDisp, p*seed*seed);\",\r\n\t\t\t\t\"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\",\r\n\t\t\t\t\t\"if(seed_x>0.){\",\r\n\t\t\t\t\t\t\"p.y = 1. - (p.y + distortion_y);\",\r\n\t\t\t\t\t\"}\",\r\n\t\t\t\t\t\"else {\",\r\n\t\t\t\t\t\t\"p.y = distortion_y;\",\r\n\t\t\t\t\t\"}\",\r\n\t\t\t\t\"}\",\r\n\t\t\t\t\"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\",\r\n\t\t\t\t\t\"if(seed_y>0.){\",\r\n\t\t\t\t\t\t\"p.x=distortion_x;\",\r\n\t\t\t\t\t\"}\",\r\n\t\t\t\t\t\"else {\",\r\n\t\t\t\t\t\t\"p.x = 1. - (p.x + distortion_x);\",\r\n\t\t\t\t\t\"}\",\r\n\t\t\t\t\"}\",\r\n\t\t\t\t\"p.x+=normal.x*seed_x*(seed/5.);\",\r\n\t\t\t\t\"p.y+=normal.y*seed_y*(seed/5.);\",\r\n\t\t\t\t//base from RGB shift shader\r\n\t\t\t\t\"vec2 offset = amount * vec2( cos(angle), sin(angle));\",\r\n\t\t\t\t\"vec4 cr = texture2D(tDiffuse, p + offset);\",\r\n\t\t\t\t\"vec4 cga = texture2D(tDiffuse, p);\",\r\n\t\t\t\t\"vec4 cb = texture2D(tDiffuse, p - offset);\",\r\n\t\t\t\t\"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\r\n\t\t\t\t//add noise\r\n\t\t\t\t\"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\",\r\n\t\t\t\t\"gl_FragColor = gl_FragColor+ snow;\",\r\n\t\t\t\"}\",\r\n\t\t\t\"else {\",\r\n\t\t\t\t\"gl_FragColor=texture2D (tDiffuse, vUv);\",\r\n\t\t\t\"}\",\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar GlitchPass = function ( dt_size ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tif ( DigitalGlitch === undefined ) { console.error( \"GlitchPass relies on DigitalGlitch\" ); }\r\n\r\n\tvar shader = DigitalGlitch;\r\n\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\r\n\r\n\tif ( dt_size == undefined ) { dt_size = 64; }\r\n\r\n\tthis.uniforms[ \"tDisp\" ].value = this.generateHeightmap( dt_size );\r\n\r\n\tthis.material = new ShaderMaterial( {\r\n\t\tuniforms: this.uniforms,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader\r\n\t} );\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n\tthis.goWild = false;\r\n\tthis.curF = 0;\r\n\tthis.generateTrigger();\r\n\r\n};\r\n\r\nGlitchPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: GlitchPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ 'seed' ].value = Math.random();//default seeding\r\n\t\tthis.uniforms[ 'byp' ].value = 0;\r\n\r\n\t\tif ( this.curF % this.randX == 0 || this.goWild == true ) {\r\n\r\n\t\t\tthis.uniforms[ 'amount' ].value = Math.random() / 30;\r\n\t\t\tthis.uniforms[ 'angle' ].value = _Math.randFloat( - Math.PI, Math.PI );\r\n\t\t\tthis.uniforms[ 'seed_x' ].value = _Math.randFloat( - 1, 1 );\r\n\t\t\tthis.uniforms[ 'seed_y' ].value = _Math.randFloat( - 1, 1 );\r\n\t\t\tthis.uniforms[ 'distortion_x' ].value = _Math.randFloat( 0, 1 );\r\n\t\t\tthis.uniforms[ 'distortion_y' ].value = _Math.randFloat( 0, 1 );\r\n\t\t\tthis.curF = 0;\r\n\t\t\tthis.generateTrigger();\r\n\r\n\t\t} else if ( this.curF % this.randX < this.randX / 5 ) {\r\n\r\n\t\t\tthis.uniforms[ 'amount' ].value = Math.random() / 90;\r\n\t\t\tthis.uniforms[ 'angle' ].value = _Math.randFloat( - Math.PI, Math.PI );\r\n\t\t\tthis.uniforms[ 'distortion_x' ].value = _Math.randFloat( 0, 1 );\r\n\t\t\tthis.uniforms[ 'distortion_y' ].value = _Math.randFloat( 0, 1 );\r\n\t\t\tthis.uniforms[ 'seed_x' ].value = _Math.randFloat( - 0.3, 0.3 );\r\n\t\t\tthis.uniforms[ 'seed_y' ].value = _Math.randFloat( - 0.3, 0.3 );\r\n\r\n\t\t} else if ( this.goWild == false ) {\r\n\r\n\t\t\tthis.uniforms[ 'byp' ].value = 1;\r\n\r\n\t\t}\r\n\r\n\t\tthis.curF ++;\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgenerateTrigger: function() {\r\n\r\n\t\tthis.randX = _Math.randInt( 120, 240 );\r\n\r\n\t},\r\n\r\n\tgenerateHeightmap: function( dt_size ) {\r\n\r\n\t\tvar data_arr = new Float32Array( dt_size * dt_size * 3 );\r\n\t\tvar length = dt_size * dt_size;\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar val = _Math.randFloat( 0, 1 );\r\n\t\t\tdata_arr[ i * 3 + 0 ] = val;\r\n\t\t\tdata_arr[ i * 3 + 1 ] = val;\r\n\t\t\tdata_arr[ i * 3 + 2 ] = val;\r\n\r\n\t\t}\r\n\r\n\t\tvar texture = new DataTexture( data_arr, dt_size, dt_size, RGBFormat, FloatType );\r\n\t\ttexture.needsUpdate = true;\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar HalftoneShader = {\r\n\r\n\tuniforms: {\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"shape\": { value: 1 },\r\n\t\t\"radius\": { value: 4 },\r\n\t\t\"rotateR\": { value: Math.PI / 12 * 1 },\r\n\t\t\"rotateG\": { value: Math.PI / 12 * 2 },\r\n\t\t\"rotateB\": { value: Math.PI / 12 * 3 },\r\n\t\t\"scatter\": { value: 0 },\r\n\t\t\"width\": { value: 1 },\r\n\t\t\"height\": { value: 1 },\r\n\t\t\"blending\": { value: 1 },\r\n\t\t\"blendingMode\": { value: 1 },\r\n\t\t\"greyscale\": { value: false },\r\n\t\t\"disable\": { value: false }\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n    \"varying vec2 vUV;\",\r\n\r\n    \"void main() {\",\r\n\r\n      \"vUV = uv;\",\r\n      \"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\",\r\n\r\n    \"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"#define SQRT2_MINUS_ONE 0.41421356\",\r\n\t\t\"#define SQRT2_HALF_MINUS_ONE 0.20710678\",\r\n\t\t\"#define PI2 6.28318531\",\r\n\t\t\"#define SHAPE_DOT 1\",\r\n\t\t\"#define SHAPE_ELLIPSE 2\",\r\n\t\t\"#define SHAPE_LINE 3\",\r\n\t\t\"#define SHAPE_SQUARE 4\",\r\n\t\t\"#define BLENDING_LINEAR 1\",\r\n\t\t\"#define BLENDING_MULTIPLY 2\",\r\n\t\t\"#define BLENDING_ADD 3\",\r\n\t\t\"#define BLENDING_LIGHTER 4\",\r\n\t\t\"#define BLENDING_DARKER 5\",\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform float radius;\",\r\n\t\t\"uniform float rotateR;\",\r\n\t\t\"uniform float rotateG;\",\r\n\t\t\"uniform float rotateB;\",\r\n\t\t\"uniform float scatter;\",\r\n\t\t\"uniform float width;\",\r\n\t\t\"uniform float height;\",\r\n\t\t\"uniform int shape;\",\r\n\t\t\"uniform bool disable;\",\r\n\t\t\"uniform float blending;\",\r\n\t\t\"uniform int blendingMode;\",\r\n\t\t\"varying vec2 vUV;\",\r\n\t\t\"uniform bool greyscale;\",\r\n\t\t\"const int samples = 8;\",\r\n\r\n\t\t\"float blend( float a, float b, float t ) {\",\r\n\r\n\t\t\t// linear blend\r\n\t\t\t\"return a * ( 1.0 - t ) + b * t;\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"float hypot( float x, float y ) {\",\r\n\r\n\t\t\t// vector magnitude\r\n\t\t\t\"return sqrt( x * x + y * y );\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"float rand( vec2 seed ){\",\r\n\r\n\t\t\t// get pseudo-random number\r\n\t    \"return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {\",\r\n\r\n\t\t\t// apply shape-specific transforms\r\n\t\t\t\"float dist = hypot( coord.x - p.x, coord.y - p.y );\",\r\n\t\t\t\"float rad = channel;\",\r\n\r\n\t\t\t\"if ( shape == SHAPE_DOT ) {\",\r\n\r\n\t\t\t\t\"rad = pow( abs( rad ), 1.125 ) * rad_max;\",\r\n\r\n\t\t\t\"} else if ( shape == SHAPE_ELLIPSE ) {\",\r\n\r\n\t\t\t\t\"rad = pow( abs( rad ), 1.125 ) * rad_max;\",\r\n\r\n\t\t\t\t\"if ( dist != 0.0 ) {\",\r\n\t\t\t\t\t\"float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );\",\r\n\t\t\t\t\t\"dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;\",\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"} else if ( shape == SHAPE_LINE ) {\",\r\n\r\n\t\t\t\t\"rad = pow( abs( rad ), 1.5) * rad_max;\",\r\n\t\t\t\t\"float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;\",\r\n\t\t\t\t\"dist = hypot( normal.x * dot_p, normal.y * dot_p );\",\r\n\r\n\t\t\t\"} else if ( shape == SHAPE_SQUARE ) {\",\r\n\r\n\t\t\t\t\"float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;\",\r\n\t\t\t\t\"float sin_t = abs( sin( theta ) );\",\r\n\t\t\t\t\"float cos_t = abs( cos( theta ) );\",\r\n\t\t\t\t\"rad = pow( abs( rad ), 1.4 );\",\r\n\t\t\t\t\"rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"return rad - dist;\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"struct Cell {\",\r\n\r\n\t\t\t// grid sample positions\r\n\t\t\t\"vec2 normal;\",\r\n\t\t\t\"vec2 p1;\",\r\n\t\t\t\"vec2 p2;\",\r\n\t\t\t\"vec2 p3;\",\r\n\t\t\t\"vec2 p4;\",\r\n\t\t\t\"float samp2;\",\r\n\t\t\t\"float samp1;\",\r\n\t\t\t\"float samp3;\",\r\n\t\t\t\"float samp4;\",\r\n\r\n\t\t\"};\",\r\n\r\n\t\t\"vec4 getSample( vec2 point ) {\",\r\n\r\n\t\t\t// multi-sampled point\r\n\t\t\t\"vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );\",\r\n\t\t\t\"float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;\",\r\n\t\t\t\"float step = PI2 / float( samples );\",\r\n\t\t\t\"float dist = radius * 0.66;\",\r\n\r\n\t\t\t\"for ( int i = 0; i < samples; ++i ) {\",\r\n\r\n\t\t\t\t\"float r = base + step * float( i );\",\r\n\t\t\t\t\"vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );\",\r\n\t\t\t\t\"tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"tex /= float( samples ) + 1.0;\",\r\n\t\t\t\"return tex;\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {\",\r\n\r\n\t\t\t// get colour for given point\r\n\t\t\t\"float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;\",\r\n\r\n\t\t\t\"if ( channel == 0 ) {\",\r\n\r\n\t\t\t\t\"c.samp1 = getSample( c.p1 ).r;\",\r\n\t\t\t\t\"c.samp2 = getSample( c.p2 ).r;\",\r\n\t\t\t\t\"c.samp3 = getSample( c.p3 ).r;\",\r\n\t\t\t\t\"c.samp4 = getSample( c.p4 ).r;\",\r\n\r\n\t\t\t\"} else if (channel == 1) {\",\r\n\r\n\t\t\t\t\"c.samp1 = getSample( c.p1 ).g;\",\r\n\t\t\t\t\"c.samp2 = getSample( c.p2 ).g;\",\r\n\t\t\t\t\"c.samp3 = getSample( c.p3 ).g;\",\r\n\t\t\t\t\"c.samp4 = getSample( c.p4 ).g;\",\r\n\r\n\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\"c.samp1 = getSample( c.p1 ).b;\",\r\n\t\t\t\t\"c.samp3 = getSample( c.p3 ).b;\",\r\n\t\t\t\t\"c.samp2 = getSample( c.p2 ).b;\",\r\n\t\t\t\t\"c.samp4 = getSample( c.p4 ).b;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );\",\r\n\t\t\t\"dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );\",\r\n\t\t\t\"dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );\",\r\n\t\t\t\"dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );\",\r\n\t\t\t\"res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;\",\r\n\t\t\t\"res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;\",\r\n\t\t\t\"res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;\",\r\n\t\t\t\"res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;\",\r\n\t\t\t\"res = clamp( res, 0.0, 1.0 );\",\r\n\r\n\t\t\t\"return res;\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {\",\r\n\r\n\t\t\t// get containing cell\r\n\t\t\t\"Cell c;\",\r\n\r\n\t\t\t// calc grid\r\n\t\t\t\"vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );\",\r\n\t\t\t\"float threshold = step * 0.5;\",\r\n\t\t\t\"float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );\",\r\n\t\t\t\"float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );\",\r\n\t\t\t\"vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );\",\r\n\t\t\t\"float offset_normal = mod( hypot( offset.x, offset.y ), step );\",\r\n\t\t\t\"float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;\",\r\n\t\t\t\"float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;\",\r\n\t\t\t\"float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );\",\r\n\t\t\t\"float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;\",\r\n\t\t\t\"float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;\",\r\n\r\n\t\t\t// get closest corner\r\n\t\t\t\"c.normal = n;\",\r\n\t\t\t\"c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;\",\r\n\t\t\t\"c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;\",\r\n\r\n\t\t\t// scatter\r\n\t\t\t\"if ( scatter != 0.0 ) {\",\r\n\r\n\t\t\t\t\"float off_mag = scatter * threshold * 0.5;\",\r\n\t\t\t\t\"float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;\",\r\n\t\t\t\t\"c.p1.x += cos( off_angle ) * off_mag;\",\r\n\t\t\t\t\"c.p1.y += sin( off_angle ) * off_mag;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t// find corners\r\n\t\t\t\"float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );\",\r\n\t\t\t\"float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );\",\r\n\t\t\t\"c.p2.x = c.p1.x - n.x * normal_step;\",\r\n\t\t\t\"c.p2.y = c.p1.y - n.y * normal_step;\",\r\n\t\t\t\"c.p3.x = c.p1.x + n.y * line_step;\",\r\n\t\t\t\"c.p3.y = c.p1.y - n.x * line_step;\",\r\n\t\t\t\"c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;\",\r\n\t\t\t\"c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;\",\r\n\r\n\t\t\t\"return c;\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"float blendColour( float a, float b, float t ) {\",\r\n\r\n\t\t\t// blend colours\r\n\t\t\t\"if ( blendingMode == BLENDING_LINEAR ) {\",\r\n\t\t\t\t\"return blend( a, b, 1.0 - t );\",\r\n\t\t\t\"} else if ( blendingMode == BLENDING_ADD ) {\",\r\n\t\t\t\t\"return blend( a, min( 1.0, a + b ), t );\",\r\n\t\t\t\"} else if ( blendingMode == BLENDING_MULTIPLY ) {\",\r\n\t\t\t\t\"return blend( a, max( 0.0, a * b ), t );\",\r\n\t\t\t\"} else if ( blendingMode == BLENDING_LIGHTER ) {\",\r\n\t\t\t\t\"return blend( a, max( a, b ), t );\",\r\n\t\t\t\"} else if ( blendingMode == BLENDING_DARKER ) {\",\r\n\t\t\t\t\"return blend( a, min( a, b ), t );\",\r\n\t\t\t\"} else {\",\r\n\t\t\t\t\"return blend( a, b, 1.0 - t );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"if ( ! disable ) {\",\r\n\r\n\t\t\t\t// setup\r\n\t\t\t\t\"vec2 p = vec2( vUV.x * width, vUV.y * height );\",\r\n\t\t\t\t\"vec2 origin = vec2( 0, 0 );\",\r\n\t\t\t\t\"float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;\",\r\n\r\n\t\t\t\t// get channel samples\r\n\t\t\t\t\"Cell cell_r = getReferenceCell( p, origin, rotateR, radius );\",\r\n\t\t\t\t\"Cell cell_g = getReferenceCell( p, origin, rotateG, radius );\",\r\n\t\t\t\t\"Cell cell_b = getReferenceCell( p, origin, rotateB, radius );\",\r\n\t\t\t\t\"float r = getDotColour( cell_r, p, 0, rotateR, aa );\",\r\n\t\t\t\t\"float g = getDotColour( cell_g, p, 1, rotateG, aa );\",\r\n\t\t\t\t\"float b = getDotColour( cell_b, p, 2, rotateB, aa );\",\r\n\r\n\t\t\t\t// blend with original\r\n\t\t\t\t\"vec4 colour = texture2D( tDiffuse, vUV );\",\r\n\t\t\t\t\"r = blendColour( r, colour.r, blending );\",\r\n\t\t\t\t\"g = blendColour( g, colour.g, blending );\",\r\n\t\t\t\t\"b = blendColour( b, colour.b, blending );\",\r\n\r\n\t\t\t\t\"if ( greyscale ) {\",\r\n\t\t\t\t\t\"r = g = b = (r + b + g) / 3.0;\",\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( r, g, b, 1.0 );\",\r\n\r\n\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUV );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar HalftonePass = function ( width, height, params ) {\n\tvar this$1 = this;\n\r\n\r\n\tPass.call( this );\r\n\r\n \tif ( HalftoneShader === undefined ) {\r\n\r\n \t\tconsole.error( 'HalftonePass requires HalftoneShader' );\r\n\r\n \t}\r\n\r\n \tthis.uniforms = UniformsUtils.clone( HalftoneShader.uniforms );\r\n \tthis.material = new ShaderMaterial( {\r\n \t\tuniforms: this.uniforms,\r\n \t\tfragmentShader: HalftoneShader.fragmentShader,\r\n \t\tvertexShader: HalftoneShader.vertexShader\r\n \t} );\r\n\r\n\t// set params\r\n\tthis.uniforms.width.value = width;\r\n\tthis.uniforms.height.value = height;\r\n\r\n\tfor ( var key in params ) {\r\n\r\n\t\tif ( params.hasOwnProperty( key ) && this$1.uniforms.hasOwnProperty( key ) ) {\r\n\r\n\t\t\tthis$1.uniforms[key].value = params[key];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n \tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n \tthis.scene = new Scene();\r\n \tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n \tthis.quad.frustumCulled = false;\r\n \tthis.scene.add( this.quad );\r\n\r\n };\r\n\r\n HalftonePass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: HalftonePass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n \t\tthis.material.uniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n \t\tthis.quad.material = this.material;\r\n\r\n \t\tif ( this.renderToScreen ) {\r\n\r\n \t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n \t},\r\n\r\n \tsetSize: function ( width, height ) {\r\n\r\n \t\tthis.uniforms.width.value = width;\r\n \t\tthis.uniforms.height.value = height;\r\n\r\n \t}\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar OutlinePass = function ( resolution, scene, camera, selectedObjects ) {\r\n\r\n\tthis.renderScene = scene;\r\n\tthis.renderCamera = camera;\r\n\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\r\n\tthis.visibleEdgeColor = new Color( 1, 1, 1 );\r\n\tthis.hiddenEdgeColor = new Color( 0.1, 0.04, 0.02 );\r\n\tthis.edgeGlow = 0.0;\r\n\tthis.usePatternTexture = false;\r\n\tthis.edgeThickness = 1.0;\r\n\tthis.edgeStrength = 3.0;\r\n\tthis.downSampleRatio = 2;\r\n\tthis.pulsePeriod = 0;\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\r\n\r\n\tvar pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\r\n\r\n\tvar resx = Math.round( this.resolution.x / this.downSampleRatio );\r\n\tvar resy = Math.round( this.resolution.y / this.downSampleRatio );\r\n\r\n\tthis.maskBufferMaterial = new MeshBasicMaterial( { color: 0xffffff } );\r\n\tthis.maskBufferMaterial.side = DoubleSide;\r\n\tthis.renderTargetMaskBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );\r\n\tthis.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\r\n\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\r\n\r\n\tthis.depthMaterial = new MeshDepthMaterial();\r\n\tthis.depthMaterial.side = DoubleSide;\r\n\tthis.depthMaterial.depthPacking = RGBADepthPacking;\r\n\tthis.depthMaterial.blending = NoBlending;\r\n\r\n\tthis.prepareMaskMaterial = this.getPrepareMaskMaterial();\r\n\tthis.prepareMaskMaterial.side = DoubleSide;\r\n\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );\r\n\r\n\tthis.renderTargetDepthBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );\r\n\tthis.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\r\n\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\r\n\r\n\tthis.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget( resx, resy, pars );\r\n\tthis.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\r\n\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\r\n\r\n\tthis.renderTargetBlurBuffer1 = new WebGLRenderTarget( resx, resy, pars );\r\n\tthis.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\r\n\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\r\n\tthis.renderTargetBlurBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );\r\n\tthis.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\r\n\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\r\n\r\n\tthis.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\r\n\tthis.renderTargetEdgeBuffer1 = new WebGLRenderTarget( resx, resy, pars );\r\n\tthis.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\r\n\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\r\n\tthis.renderTargetEdgeBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );\r\n\tthis.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\r\n\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\r\n\r\n\tvar MAX_EDGE_THICKNESS = 4;\r\n\tvar MAX_EDGE_GLOW = 4;\r\n\r\n\tthis.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );\r\n\tthis.separableBlurMaterial1.uniforms[ \"texSize\" ].value = new Vector2( resx, resy );\r\n\tthis.separableBlurMaterial1.uniforms[ \"kernelRadius\" ].value = 1;\r\n\tthis.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );\r\n\tthis.separableBlurMaterial2.uniforms[ \"texSize\" ].value = new Vector2( Math.round( resx / 2 ), Math.round( resy / 2 ) );\r\n\tthis.separableBlurMaterial2.uniforms[ \"kernelRadius\" ].value = MAX_EDGE_GLOW;\r\n\r\n\t// Overlay material\r\n\tthis.overlayMaterial = this.getOverlayMaterial();\r\n\r\n\t// copy material\r\n\tif ( CopyShader === undefined )\r\n\t\t{ console.error( \"OutlinePass relies on CopyShader\" ); }\r\n\r\n\tvar copyShader = CopyShader;\r\n\r\n\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\r\n\tthis.copyUniforms[ \"opacity\" ].value = 1.0;\r\n\r\n\tthis.materialCopy = new ShaderMaterial( {\r\n\t\tuniforms: this.copyUniforms,\r\n\t\tvertexShader: copyShader.vertexShader,\r\n\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\tblending: NoBlending,\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false,\r\n\t\ttransparent: true\r\n\t} );\r\n\r\n\tthis.enabled = true;\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.oldClearColor = new Color();\r\n\tthis.oldClearAlpha = 1;\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n\tthis.tempPulseColor1 = new Color();\r\n\tthis.tempPulseColor2 = new Color();\r\n\tthis.textureMatrix = new Matrix4();\r\n\r\n\tfunction replaceDepthToViewZ( string, camera ) {\r\n\r\n\t\tvar type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\r\n\r\n\t\treturn string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nOutlinePass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: OutlinePass,\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.renderTargetMaskBuffer.dispose();\r\n\t\tthis.renderTargetDepthBuffer.dispose();\r\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\r\n\t\tthis.renderTargetBlurBuffer1.dispose();\r\n\t\tthis.renderTargetBlurBuffer2.dispose();\r\n\t\tthis.renderTargetEdgeBuffer1.dispose();\r\n\t\tthis.renderTargetEdgeBuffer2.dispose();\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tthis.renderTargetMaskBuffer.setSize( width, height );\r\n\r\n\t\tvar resx = Math.round( width / this.downSampleRatio );\r\n\t\tvar resy = Math.round( height / this.downSampleRatio );\r\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize( resx, resy );\r\n\t\tthis.renderTargetBlurBuffer1.setSize( resx, resy );\r\n\t\tthis.renderTargetEdgeBuffer1.setSize( resx, resy );\r\n\t\tthis.separableBlurMaterial1.uniforms[ \"texSize\" ].value = new Vector2( resx, resy );\r\n\r\n\t\tresx = Math.round( resx / 2 );\r\n\t\tresy = Math.round( resy / 2 );\r\n\r\n\t\tthis.renderTargetBlurBuffer2.setSize( resx, resy );\r\n\t\tthis.renderTargetEdgeBuffer2.setSize( resx, resy );\r\n\r\n\t\tthis.separableBlurMaterial2.uniforms[ \"texSize\" ].value = new Vector2( resx, resy );\r\n\r\n\t},\r\n\r\n\tchangeVisibilityOfSelectedObjects: function ( bVisible ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\r\n\r\n\t\t\tif ( object.isMesh ) {\r\n\r\n\t\t\t\tif ( bVisible ) {\r\n\r\n\t\t\t\t\tobject.visible = object.userData.oldVisible;\r\n\t\t\t\t\tdelete object.userData.oldVisible;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tobject.userData.oldVisible = object.visible;\r\n\t\t\t\t\tobject.visible = bVisible;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < this.selectedObjects.length; i ++ ) {\r\n\r\n\t\t\tvar selectedObject = this$1.selectedObjects[ i ];\r\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tchangeVisibilityOfNonSelectedObjects: function ( bVisible ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar selectedMeshes = [];\r\n\r\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\r\n\r\n\t\t\tif ( object.isMesh ) { selectedMeshes.push( object ); }\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < this.selectedObjects.length; i ++ ) {\r\n\r\n\t\t\tvar selectedObject = this$1.selectedObjects[ i ];\r\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\r\n\r\n\t\t}\r\n\r\n\t\tfunction VisibilityChangeCallBack( object ) {\r\n\r\n\t\t\tif ( object.isMesh || object.isLine || object.isSprite ) {\r\n\r\n\t\t\t\tvar bFound = false;\r\n\r\n\t\t\t\tfor ( var i = 0; i < selectedMeshes.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar selectedObjectId = selectedMeshes[ i ].id;\r\n\r\n\t\t\t\t\tif ( selectedObjectId === object.id ) {\r\n\r\n\t\t\t\t\t\tbFound = true;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! bFound ) {\r\n\r\n\t\t\t\t\tvar visibility = object.visible;\r\n\r\n\t\t\t\t\tif ( ! bVisible || object.bVisible ) { object.visible = bVisible; }\r\n\r\n\t\t\t\t\tobject.bVisible = visibility;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderScene.traverse( VisibilityChangeCallBack );\r\n\r\n\t},\r\n\r\n\tupdateTextureMatrix: function () {\r\n\r\n\t\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\r\n\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t0.0, 0.0, 0.0, 1.0 );\r\n\t\tthis.textureMatrix.multiply( this.renderCamera.projectionMatrix );\r\n\t\tthis.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );\r\n\r\n\t},\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( this.selectedObjects.length > 0 ) {\r\n\r\n\t\t\tthis.oldClearColor.copy( renderer.getClearColor() );\r\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\r\n\t\t\tvar oldAutoClear = renderer.autoClear;\r\n\r\n\t\t\trenderer.autoClear = false;\r\n\r\n\t\t\tif ( maskActive ) { renderer.context.disable( renderer.context.STENCIL_TEST ); }\r\n\r\n\t\t\trenderer.setClearColor( 0xffffff, 1 );\r\n\r\n\t\t\t// Make selected objects invisible\r\n\t\t\tthis.changeVisibilityOfSelectedObjects( false );\r\n\r\n\t\t\tvar currentBackground = this.renderScene.background;\r\n\t\t\tthis.renderScene.background = null;\r\n\r\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\r\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\r\n\t\t\trenderer.render( this.renderScene, this.renderCamera, this.renderTargetDepthBuffer, true );\r\n\r\n\t\t\t// Make selected objects visible\r\n\t\t\tthis.changeVisibilityOfSelectedObjects( true );\r\n\r\n\t\t\t// Update Texture Matrix for Depth compare\r\n\t\t\tthis.updateTextureMatrix();\r\n\r\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\r\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( false );\r\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\r\n\t\t\tthis.prepareMaskMaterial.uniforms[ \"cameraNearFar\" ].value = new Vector2( this.renderCamera.near, this.renderCamera.far );\r\n\t\t\tthis.prepareMaskMaterial.uniforms[ \"depthTexture\" ].value = this.renderTargetDepthBuffer.texture;\r\n\t\t\tthis.prepareMaskMaterial.uniforms[ \"textureMatrix\" ].value = this.textureMatrix;\r\n\t\t\trenderer.render( this.renderScene, this.renderCamera, this.renderTargetMaskBuffer, true );\r\n\t\t\tthis.renderScene.overrideMaterial = null;\r\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( true );\r\n\r\n\t\t\tthis.renderScene.background = currentBackground;\r\n\r\n\t\t\t// 2. Downsample to Half resolution\r\n\t\t\tthis.quad.material = this.materialCopy;\r\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetMaskBuffer.texture;\r\n\t\t\trenderer.render( this.scene, this.camera, this.renderTargetMaskDownSampleBuffer, true );\r\n\r\n\t\t\tthis.tempPulseColor1.copy( this.visibleEdgeColor );\r\n\t\t\tthis.tempPulseColor2.copy( this.hiddenEdgeColor );\r\n\r\n\t\t\tif ( this.pulsePeriod > 0 ) {\r\n\r\n\t\t\t\tvar scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;\r\n\t\t\t\tthis.tempPulseColor1.multiplyScalar( scalar );\r\n\t\t\t\tthis.tempPulseColor2.multiplyScalar( scalar );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// 3. Apply Edge Detection Pass\r\n\t\t\tthis.quad.material = this.edgeDetectionMaterial;\r\n\t\t\tthis.edgeDetectionMaterial.uniforms[ \"maskTexture\" ].value = this.renderTargetMaskDownSampleBuffer.texture;\r\n\t\t\tthis.edgeDetectionMaterial.uniforms[ \"texSize\" ].value = new Vector2( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );\r\n\t\t\tthis.edgeDetectionMaterial.uniforms[ \"visibleEdgeColor\" ].value = this.tempPulseColor1;\r\n\t\t\tthis.edgeDetectionMaterial.uniforms[ \"hiddenEdgeColor\" ].value = this.tempPulseColor2;\r\n\t\t\trenderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer1, true );\r\n\r\n\t\t\t// 4. Apply Blur on Half res\r\n\t\t\tthis.quad.material = this.separableBlurMaterial1;\r\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"colorTexture\" ].value = this.renderTargetEdgeBuffer1.texture;\r\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"direction\" ].value = OutlinePass.BlurDirectionX;\r\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"kernelRadius\" ].value = this.edgeThickness;\r\n\t\t\trenderer.render( this.scene, this.camera, this.renderTargetBlurBuffer1, true );\r\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"colorTexture\" ].value = this.renderTargetBlurBuffer1.texture;\r\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"direction\" ].value = OutlinePass.BlurDirectionY;\r\n\t\t\trenderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer1, true );\r\n\r\n\t\t\t// Apply Blur on quarter res\r\n\t\t\tthis.quad.material = this.separableBlurMaterial2;\r\n\t\t\tthis.separableBlurMaterial2.uniforms[ \"colorTexture\" ].value = this.renderTargetEdgeBuffer1.texture;\r\n\t\t\tthis.separableBlurMaterial2.uniforms[ \"direction\" ].value = OutlinePass.BlurDirectionX;\r\n\t\t\trenderer.render( this.scene, this.camera, this.renderTargetBlurBuffer2, true );\r\n\t\t\tthis.separableBlurMaterial2.uniforms[ \"colorTexture\" ].value = this.renderTargetBlurBuffer2.texture;\r\n\t\t\tthis.separableBlurMaterial2.uniforms[ \"direction\" ].value = OutlinePass.BlurDirectionY;\r\n\t\t\trenderer.render( this.scene, this.camera, this.renderTargetEdgeBuffer2, true );\r\n\r\n\t\t\t// Blend it additively over the input texture\r\n\t\t\tthis.quad.material = this.overlayMaterial;\r\n\t\t\tthis.overlayMaterial.uniforms[ \"maskTexture\" ].value = this.renderTargetMaskBuffer.texture;\r\n\t\t\tthis.overlayMaterial.uniforms[ \"edgeTexture1\" ].value = this.renderTargetEdgeBuffer1.texture;\r\n\t\t\tthis.overlayMaterial.uniforms[ \"edgeTexture2\" ].value = this.renderTargetEdgeBuffer2.texture;\r\n\t\t\tthis.overlayMaterial.uniforms[ \"patternTexture\" ].value = this.patternTexture;\r\n\t\t\tthis.overlayMaterial.uniforms[ \"edgeStrength\" ].value = this.edgeStrength;\r\n\t\t\tthis.overlayMaterial.uniforms[ \"edgeGlow\" ].value = this.edgeGlow;\r\n\t\t\tthis.overlayMaterial.uniforms[ \"usePatternTexture\" ].value = this.usePatternTexture;\r\n\r\n\t\t\tif ( maskActive ) { renderer.context.enable( renderer.context.STENCIL_TEST ); }\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, readBuffer, false );\r\n\r\n\t\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\r\n\t\t\trenderer.autoClear = oldAutoClear;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\tthis.quad.material = this.materialCopy;\r\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetPrepareMaskMaterial: function () {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"depthTexture\": { value: null },\r\n\t\t\t\t\"cameraNearFar\": { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t\"textureMatrix\": { value: new Matrix4() }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: [\r\n\t\t\t\t'varying vec4 projTexCoord;',\r\n\t\t\t\t'varying vec4 vPosition;',\r\n\t\t\t\t'uniform mat4 textureMatrix;',\r\n\r\n\t\t\t\t'void main() {',\r\n\r\n\t\t\t\t'\tvPosition = modelViewMatrix * vec4( position, 1.0 );',\r\n\t\t\t\t'\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\r\n\t\t\t\t'\tprojTexCoord = textureMatrix * worldPosition;',\r\n\t\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n\r\n\t\t\t\t'}'\r\n\t\t\t].join( '\\n' ),\r\n\r\n\t\t\tfragmentShader: [\r\n\t\t\t\t'#include <packing>',\r\n\t\t\t\t'varying vec4 vPosition;',\r\n\t\t\t\t'varying vec4 projTexCoord;',\r\n\t\t\t\t'uniform sampler2D depthTexture;',\r\n\t\t\t\t'uniform vec2 cameraNearFar;',\r\n\r\n\t\t\t\t'void main() {',\r\n\r\n\t\t\t\t'\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));',\r\n\t\t\t\t'\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );',\r\n\t\t\t\t'\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;',\r\n\t\t\t\t'\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);',\r\n\r\n\t\t\t\t'}'\r\n\t\t\t].join( '\\n' )\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tgetEdgeDetectionMaterial: function () {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"maskTexture\": { value: null },\r\n\t\t\t\t\"texSize\": { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t\"visibleEdgeColor\": { value: new Vector3( 1.0, 1.0, 1.0 ) },\r\n\t\t\t\t\"hiddenEdgeColor\": { value: new Vector3( 1.0, 1.0, 1.0 ) },\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t\"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t\"varying vec2 vUv;\\\r\n\t\t\t\tuniform sampler2D maskTexture;\\\r\n\t\t\t\tuniform vec2 texSize;\\\r\n\t\t\t\tuniform vec3 visibleEdgeColor;\\\r\n\t\t\t\tuniform vec3 hiddenEdgeColor;\\\r\n\t\t\t\t\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\r\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\r\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\r\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\r\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\r\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\r\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\\\r\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\\\r\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\\\r\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\\\r\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\\\r\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\\\r\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\r\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\r\n\t\t\t\t}\"\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tgetSeperableBlurMaterial: function ( maxRadius ) {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\t\"MAX_RADIUS\": maxRadius,\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"colorTexture\": { value: null },\r\n\t\t\t\t\"texSize\": { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t\"direction\": { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t\"kernelRadius\": { value: 1.0 }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t\"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t\"#include <common>\\\r\n\t\t\t\tvarying vec2 vUv;\\\r\n\t\t\t\tuniform sampler2D colorTexture;\\\r\n\t\t\t\tuniform vec2 texSize;\\\r\n\t\t\t\tuniform vec2 direction;\\\r\n\t\t\t\tuniform float kernelRadius;\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\r\n\t\t\t\t}\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\r\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\r\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\r\n\t\t\t\t\tvec2 uvOffset = delta;\\\r\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\r\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\r\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\r\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\r\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\\\r\n\t\t\t\t\t\tweightSum += (2.0 * w);\\\r\n\t\t\t\t\t\tuvOffset += delta;\\\r\n\t\t\t\t\t}\\\r\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\\r\n\t\t\t\t}\"\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tgetOverlayMaterial: function () {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"maskTexture\": { value: null },\r\n\t\t\t\t\"edgeTexture1\": { value: null },\r\n\t\t\t\t\"edgeTexture2\": { value: null },\r\n\t\t\t\t\"patternTexture\": { value: null },\r\n\t\t\t\t\"edgeStrength\": { value: 1.0 },\r\n\t\t\t\t\"edgeGlow\": { value: 1.0 },\r\n\t\t\t\t\"usePatternTexture\": { value: 0.0 }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t\"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t\"varying vec2 vUv;\\\r\n\t\t\t\tuniform sampler2D maskTexture;\\\r\n\t\t\t\tuniform sampler2D edgeTexture1;\\\r\n\t\t\t\tuniform sampler2D edgeTexture2;\\\r\n\t\t\t\tuniform sampler2D patternTexture;\\\r\n\t\t\t\tuniform float edgeStrength;\\\r\n\t\t\t\tuniform float edgeGlow;\\\r\n\t\t\t\tuniform bool usePatternTexture;\\\r\n\t\t\t\t\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\r\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\r\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\\\r\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\r\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\r\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\r\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\r\n\t\t\t\t\tif(usePatternTexture)\\\r\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\r\n\t\t\t\t\tgl_FragColor = finalColor;\\\r\n\t\t\t\t}\",\r\n\t\t\tblending: AdditiveBlending,\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\ttransparent: true\r\n\t\t} );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nOutlinePass.BlurDirectionX = new Vector2( 1.0, 0.0 );\r\nOutlinePass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.overrideMaterial = overrideMaterial;\r\n\r\n\tthis.clearColor = clearColor;\r\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\r\n\r\n\tthis.clear = true;\r\n\tthis.clearDepth = false;\r\n\tthis.needsSwap = false;\r\n\r\n};\r\n\r\nRenderPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: RenderPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tvar oldAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\tthis.scene.overrideMaterial = this.overrideMaterial;\r\n\r\n\t\tvar oldClearColor, oldClearAlpha;\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\toldClearColor = renderer.getClearColor().getHex();\r\n\t\t\toldClearAlpha = renderer.getClearAlpha();\r\n\r\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.clearDepth ) {\r\n\r\n\t\t\trenderer.clearDepth();\r\n\r\n\t\t}\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );\r\n\r\n\t\tif ( this.clearColor ) {\r\n\r\n\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\r\n\r\n\t\t}\r\n\r\n\t\tthis.scene.overrideMaterial = null;\r\n\t\trenderer.autoClear = oldAutoClear;\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\r\n\r\n\tformat = format !== undefined ? format : DepthFormat;\r\n\r\n\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\r\n\r\n\t\tthrow new Error( 'DepthTexture format must be either DepthFormat or DepthStencilFormat' );\r\n\r\n\t}\r\n\r\n\tif ( type === undefined && format === DepthFormat ) { type = UnsignedShortType; }\r\n\tif ( type === undefined && format === DepthStencilFormat ) { type = UnsignedInt248Type; }\r\n\r\n\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { width: width, height: height };\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\r\n\r\n\tthis.flipY = false;\r\n\tthis.generateMipmaps\t= false;\r\n\r\n}\r\n\r\nDepthTexture.prototype = Object.create( Texture.prototype );\r\nDepthTexture.prototype.constructor = DepthTexture;\r\nDepthTexture.prototype.isDepthTexture = true;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SAOShader = {\r\n\tdefines: {\r\n\t\t'NUM_SAMPLES': 7,\r\n\t\t'NUM_RINGS': 4,\r\n\t\t'NORMAL_TEXTURE': 0,\r\n\t\t'DIFFUSE_TEXTURE': 0,\r\n\t\t'DEPTH_PACKING': 1,\r\n\t\t'PERSPECTIVE_CAMERA': 1\r\n\t},\r\n\tuniforms: {\r\n\r\n\t\t'tDepth': { type: 't', value: null },\r\n\t\t'tDiffuse': { type: 't', value: null },\r\n\t\t'tNormal': { type: 't', value: null },\r\n\t\t'size': { type: 'v2', value: new Vector2( 512, 512 ) },\r\n\r\n\t\t'cameraNear': { type: 'f', value: 1 },\r\n\t\t'cameraFar': { type: 'f', value: 100 },\r\n\t\t'cameraProjectionMatrix': { type: 'm4', value: new Matrix4() },\r\n\t\t'cameraInverseProjectionMatrix': { type: 'm4', value: new Matrix4() },\r\n\r\n\t\t'scale': { type: 'f', value: 1.0 },\r\n\t\t'intensity': { type: 'f', value: 0.1 },\r\n\t\t'bias': { type: 'f', value: 0.5 },\r\n\r\n\t\t'minResolution': { type: 'f', value: 0.0 },\r\n\t\t'kernelRadius': { type: 'f', value: 100.0 },\r\n\t\t'randomSeed': { type: 'f', value: 0.0 }\r\n\t},\r\n\tvertexShader: [\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\t\t\"\tvUv = uv;\",\r\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\tfragmentShader: [\r\n\t\t\"#include <common>\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"#if DIFFUSE_TEXTURE == 1\",\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"#endif\",\r\n\r\n\t\t\"uniform sampler2D tDepth;\",\r\n\r\n\t\t\"#if NORMAL_TEXTURE == 1\",\r\n\t\t\"uniform sampler2D tNormal;\",\r\n\t\t\"#endif\",\r\n\r\n\t\t\"uniform float cameraNear;\",\r\n\t\t\"uniform float cameraFar;\",\r\n\t\t\"uniform mat4 cameraProjectionMatrix;\",\r\n\t\t\"uniform mat4 cameraInverseProjectionMatrix;\",\r\n\r\n\t\t\"uniform float scale;\",\r\n\t\t\"uniform float intensity;\",\r\n\t\t\"uniform float bias;\",\r\n\t\t\"uniform float kernelRadius;\",\r\n\t\t\"uniform float minResolution;\",\r\n\t\t\"uniform vec2 size;\",\r\n\t\t\"uniform float randomSeed;\",\r\n\r\n\t\t\"// RGBA depth\",\r\n\r\n\t\t\"#include <packing>\",\r\n\r\n\t\t\"vec4 getDefaultColor( const in vec2 screenPosition ) {\",\r\n\t\t\"\t#if DIFFUSE_TEXTURE == 1\",\r\n\t\t\"\treturn texture2D( tDiffuse, vUv );\",\r\n\t\t\"\t#else\",\r\n\t\t\"\treturn vec4( 1.0 );\",\r\n\t\t\"\t#endif\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float getDepth( const in vec2 screenPosition ) {\",\r\n\t\t\"\t#if DEPTH_PACKING == 1\",\r\n\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\r\n\t\t\"\t#else\",\r\n\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\r\n\t\t\"\t#endif\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float getViewZ( const in float depth ) {\",\r\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\r\n\t\t\"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\r\n\t\t\"\t#else\",\r\n\t\t\"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\r\n\t\t\"\t#endif\",\r\n\t\t\"}\",\r\n\r\n\t\t\"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\r\n\t\t\"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\r\n\t\t\"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\r\n\t\t\"\tclipPosition *= clipW; // unprojection.\",\r\n\r\n\t\t\"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\",\r\n\t\t\"\t#if NORMAL_TEXTURE == 1\",\r\n\t\t\"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\r\n\t\t\"\t#else\",\r\n\t\t\"\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\",\r\n\t\t\"\t#endif\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float scaleDividedByCameraFar;\",\r\n\t\t\"float minResolutionMultipliedByCameraFar;\",\r\n\r\n\t\t\"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\",\r\n\t\t\"\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\",\r\n\t\t\"\tfloat viewDistance = length( viewDelta );\",\r\n\t\t\"\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\",\r\n\r\n\t\t\"\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\",\r\n\t\t\"}\",\r\n\r\n\t\t\"// moving costly divides into consts\",\r\n\t\t\"const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\",\r\n\t\t\"const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\",\r\n\r\n\t\t\"float getAmbientOcclusion( const in vec3 centerViewPosition ) {\",\r\n\t\t\"\t// precompute some variables require in getOcclusion.\",\r\n\t\t\"\tscaleDividedByCameraFar = scale / cameraFar;\",\r\n\t\t\"\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\",\r\n\t\t\"\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\",\r\n\r\n\t\t\"\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\",\r\n\t\t\"\tfloat angle = rand( vUv + randomSeed ) * PI2;\",\r\n\t\t\"\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\",\r\n\t\t\"\tvec2 radiusStep = radius;\",\r\n\r\n\t\t\"\tfloat occlusionSum = 0.0;\",\r\n\t\t\"\tfloat weightSum = 0.0;\",\r\n\r\n\t\t\"\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\",\r\n\t\t\"\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\",\r\n\t\t\"\t\tradius += radiusStep;\",\r\n\t\t\"\t\tangle += ANGLE_STEP;\",\r\n\r\n\t\t\"\t\tfloat sampleDepth = getDepth( sampleUv );\",\r\n\t\t\"\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\",\r\n\t\t\"\t\t\tcontinue;\",\r\n\t\t\"\t\t}\",\r\n\r\n\t\t\"\t\tfloat sampleViewZ = getViewZ( sampleDepth );\",\r\n\t\t\"\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\",\r\n\t\t\"\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\",\r\n\t\t\"\t\tweightSum += 1.0;\",\r\n\t\t\"\t}\",\r\n\r\n\t\t\"\tif( weightSum == 0.0 ) discard;\",\r\n\r\n\t\t\"\treturn occlusionSum * ( intensity / weightSum );\",\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\t\t\"\tfloat centerDepth = getDepth( vUv );\",\r\n\t\t\"\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\",\r\n\t\t\"\t\tdiscard;\",\r\n\t\t\"\t}\",\r\n\r\n\t\t\"\tfloat centerViewZ = getViewZ( centerDepth );\",\r\n\t\t\"\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\",\r\n\r\n\t\t\"\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\",\r\n\r\n\t\t\"\tgl_FragColor = getDefaultColor( vUv );\",\r\n\t\t\"\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\",\r\n\t\t\"}\"\r\n\t].join( \"\\n\" )\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvar DepthLimitedBlurShader = {\n\tdefines: {\n\t\t'KERNEL_RADIUS': 4,\n\t\t'DEPTH_PACKING': 1,\n\t\t'PERSPECTIVE_CAMERA': 1\n\t},\n\tuniforms: {\n\t\t'tDiffuse': { type: 't', value: null },\n\t\t'size': { type: 'v2', value: new Vector2( 512, 512 ) },\n\t\t'sampleUvOffsets': { type: 'v2v', value: [ new Vector2( 0, 0 ) ] },\n\t\t'sampleWeights': { type: '1fv', value: [ 1.0 ] },\n\t\t'tDepth': { type: 't', value: null },\n\t\t'cameraNear': { type: 'f', value: 10 },\n\t\t'cameraFar': { type: 'f', value: 1000 },\n\t\t'depthCutoff': { type: 'f', value: 10 },\n\t},\n\tvertexShader: [\n\t\t\"#include <common>\",\n\n\t\t\"uniform vec2 size;\",\n\n\t\t\"varying vec2 vUv;\",\n\t\t\"varying vec2 vInvSize;\",\n\n\t\t\"void main() {\",\n\t\t\"\tvUv = uv;\",\n\t\t\"\tvInvSize = 1.0 / size;\",\n\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\tfragmentShader: [\n\t\t\"#include <common>\",\n\t\t\"#include <packing>\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"uniform float cameraNear;\",\n\t\t\"uniform float cameraFar;\",\n\t\t\"uniform float depthCutoff;\",\n\n\t\t\"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\",\n\t\t\"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\",\n\n\t\t\"varying vec2 vUv;\",\n\t\t\"varying vec2 vInvSize;\",\n\n\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\t\t\"\t#if DEPTH_PACKING == 1\",\n\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n\t\t\"\t#else\",\n\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\t\t\"\t#endif\",\n\t\t\"}\",\n\n\t\t\"float getViewZ( const in float depth ) {\",\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\"\t#else\",\n\t\t\"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\"\t#endif\",\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\t\t\"\tfloat depth = getDepth( vUv );\",\n\t\t\"\tif( depth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\"\t\tdiscard;\",\n\t\t\"\t}\",\n\n\t\t\"\tfloat centerViewZ = -getViewZ( depth );\",\n\t\t\"\tbool rBreak = false, lBreak = false;\",\n\n\t\t\"\tfloat weightSum = sampleWeights[0];\",\n\t\t\"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\",\n\n\t\t\"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\",\n\n\t\t\"\t\tfloat sampleWeight = sampleWeights[i];\",\n\t\t\"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\",\n\n\t\t\"\t\tvec2 sampleUv = vUv + sampleUvOffset;\",\n\t\t\"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\",\n\n\t\t\"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\",\n\n\t\t\"\t\tif( ! rBreak ) {\",\n\t\t\"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n\t\t\"\t\t\tweightSum += sampleWeight;\",\n\t\t\"\t\t}\",\n\n\t\t\"\t\tsampleUv = vUv - sampleUvOffset;\",\n\t\t\"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\",\n\n\t\t\"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\",\n\n\t\t\"\t\tif( ! lBreak ) {\",\n\t\t\"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n\t\t\"\t\t\tweightSum += sampleWeight;\",\n\t\t\"\t\t}\",\n\n\t\t\"\t}\",\n\n\t\t\"\tgl_FragColor = diffuseSum / weightSum;\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n};\n\nvar BlurShaderUtils = {\n\n\tcreateSampleWeights: function ( kernelRadius, stdDev ) {\n\n\t\tvar gaussian = function ( x, stdDev ) {\n\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );\n\n\t\t};\n\n\t\tvar weights = [];\n\n\t\tfor ( var i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\tweights.push( gaussian( i, stdDev ) );\n\n\t\t}\n\n\t\treturn weights;\n\n\t},\n\n\tcreateSampleOffsets: function ( kernelRadius, uvIncrement ) {\n\n\t\tvar offsets = [];\n\n\t\tfor ( var i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\toffsets.push( uvIncrement.clone().multiplyScalar( i ) );\n\n\t\t}\n\n\t\treturn offsets;\n\n\t},\n\n\tconfigure: function ( material, kernelRadius, stdDev, uvIncrement ) {\n\n\t\tmaterial.defines[ 'KERNEL_RADIUS' ] = kernelRadius;\n\t\tmaterial.uniforms[ 'sampleUvOffsets' ].value = BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );\n\t\tmaterial.uniforms[ 'sampleWeights' ].value = BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );\n\t\tmaterial.needsUpdate = true;\n\n\t}\n\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar UnpackDepthRGBAShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"opacity\":  { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float opacity;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"#include <packing>\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\",\r\n\t\t\t\"gl_FragColor = vec4( vec3( depth ), opacity );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SAOPass = function ( scene, camera, depthTexture, useNormals, resolution ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.clear = true;\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.supportsDepthTextureExtension = ( depthTexture !== undefined ) ? depthTexture : false;\r\n\tthis.supportsNormalTexture = ( useNormals !== undefined ) ? useNormals : false;\r\n\r\n\tthis.oldClearColor = new Color();\r\n\tthis.oldClearAlpha = 1;\r\n\r\n\tthis.params = {\r\n\t\toutput: 0,\r\n\t\tsaoBias: 0.5,\r\n\t\tsaoIntensity: 0.18,\r\n\t\tsaoScale: 1,\r\n\t\tsaoKernelRadius: 100,\r\n\t\tsaoMinResolution: 0,\r\n\t\tsaoBlur: true,\r\n\t\tsaoBlurRadius: 8,\r\n\t\tsaoBlurStdDev: 4,\r\n\t\tsaoBlurDepthCutoff: 0.01\r\n\t};\r\n\r\n\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\r\n\r\n\tthis.saoRenderTarget = new WebGLRenderTarget( this.resolution.x, this.resolution.y, {\r\n\t\tminFilter: LinearFilter,\r\n\t\tmagFilter: LinearFilter,\r\n\t\tformat: RGBAFormat\r\n\t} );\r\n\tthis.blurIntermediateRenderTarget = this.saoRenderTarget.clone();\r\n\tthis.beautyRenderTarget = this.saoRenderTarget.clone();\r\n\r\n\tthis.normalRenderTarget = new WebGLRenderTarget( this.resolution.x, this.resolution.y, {\r\n\t\tminFilter: NearestFilter,\r\n\t\tmagFilter: NearestFilter,\r\n\t\tformat: RGBAFormat\r\n\t} );\r\n\tthis.depthRenderTarget = this.normalRenderTarget.clone();\r\n\r\n\tif ( this.supportsDepthTextureExtension ) {\r\n\r\n\t\tvar depthTexture = new DepthTexture();\r\n\t\tdepthTexture.type = UnsignedShortType;\r\n\t\tdepthTexture.minFilter = NearestFilter;\r\n\t\tdepthTexture.maxFilter = NearestFilter;\r\n\r\n\t\tthis.beautyRenderTarget.depthTexture = depthTexture;\r\n\t\tthis.beautyRenderTarget.depthBuffer = true;\r\n\r\n\t}\r\n\r\n\tthis.depthMaterial = new MeshDepthMaterial();\r\n\tthis.depthMaterial.depthPacking = RGBADepthPacking;\r\n\tthis.depthMaterial.blending = NoBlending;\r\n\r\n\tthis.normalMaterial = new MeshNormalMaterial();\r\n\tthis.normalMaterial.blending = NoBlending;\r\n\r\n\tif ( SAOShader === undefined ) {\r\n\r\n\t\tconsole.error( 'SAOPass relies on SAOShader' );\r\n\r\n\t}\r\n\r\n\tthis.saoMaterial = new ShaderMaterial( {\r\n\t\tdefines: Object.assign( {}, SAOShader.defines ),\r\n\t\tfragmentShader: SAOShader.fragmentShader,\r\n\t\tvertexShader: SAOShader.vertexShader,\r\n\t\tuniforms: UniformsUtils.clone( SAOShader.uniforms )\r\n\t} );\r\n\tthis.saoMaterial.extensions.derivatives = true;\r\n\tthis.saoMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;\r\n\tthis.saoMaterial.defines[ 'NORMAL_TEXTURE' ] = this.supportsNormalTexture ? 1 : 0;\r\n\tthis.saoMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;\r\n\tthis.saoMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;\r\n\tthis.saoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;\r\n\tthis.saoMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );\r\n\tthis.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse( this.camera.projectionMatrix );\r\n\tthis.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;\r\n\tthis.saoMaterial.blending = NoBlending;\r\n\r\n\tif ( DepthLimitedBlurShader === undefined ) {\r\n\r\n\t\tconsole.error( 'SAOPass relies on DepthLimitedBlurShader' );\r\n\r\n\t}\r\n\r\n\tthis.vBlurMaterial = new ShaderMaterial( {\r\n\t\tuniforms: UniformsUtils.clone( DepthLimitedBlurShader.uniforms ),\r\n\t\tdefines: Object.assign( {}, DepthLimitedBlurShader.defines ),\r\n\t\tvertexShader: DepthLimitedBlurShader.vertexShader,\r\n\t\tfragmentShader: DepthLimitedBlurShader.fragmentShader\r\n\t} );\r\n\tthis.vBlurMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;\r\n\tthis.vBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;\r\n\tthis.vBlurMaterial.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;\r\n\tthis.vBlurMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;\r\n\tthis.vBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );\r\n\tthis.vBlurMaterial.blending = NoBlending;\r\n\r\n\tthis.hBlurMaterial = new ShaderMaterial( {\r\n\t\tuniforms: UniformsUtils.clone( DepthLimitedBlurShader.uniforms ),\r\n\t\tdefines: Object.assign( {}, DepthLimitedBlurShader.defines ),\r\n\t\tvertexShader: DepthLimitedBlurShader.vertexShader,\r\n\t\tfragmentShader: DepthLimitedBlurShader.fragmentShader\r\n\t} );\r\n\tthis.hBlurMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;\r\n\tthis.hBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;\r\n\tthis.hBlurMaterial.uniforms[ 'tDiffuse' ].value = this.blurIntermediateRenderTarget.texture;\r\n\tthis.hBlurMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;\r\n\tthis.hBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );\r\n\tthis.hBlurMaterial.blending = NoBlending;\r\n\r\n\tif ( CopyShader === undefined ) {\r\n\r\n\t\tconsole.error( 'SAOPass relies on CopyShader' );\r\n\r\n\t}\r\n\r\n\tthis.materialCopy = new ShaderMaterial( {\r\n\t\tuniforms: UniformsUtils.clone( CopyShader.uniforms ),\r\n\t\tvertexShader: CopyShader.vertexShader,\r\n\t\tfragmentShader: CopyShader.fragmentShader,\r\n\t\tblending: NoBlending\r\n\t} );\r\n\tthis.materialCopy.transparent = true;\r\n\tthis.materialCopy.depthTest = false;\r\n\tthis.materialCopy.depthWrite = false;\r\n\tthis.materialCopy.blending = CustomBlending;\r\n\tthis.materialCopy.blendSrc = DstColorFactor;\r\n\tthis.materialCopy.blendDst = ZeroFactor;\r\n\tthis.materialCopy.blendEquation = AddEquation;\r\n\tthis.materialCopy.blendSrcAlpha = DstAlphaFactor;\r\n\tthis.materialCopy.blendDstAlpha = ZeroFactor;\r\n\tthis.materialCopy.blendEquationAlpha = AddEquation;\r\n\r\n\tif ( CopyShader === undefined ) {\r\n\r\n\t\tconsole.error( 'SAOPass relies on UnpackDepthRGBAShader' );\r\n\r\n\t}\r\n\r\n\tthis.depthCopy = new ShaderMaterial( {\r\n\t\tuniforms: UniformsUtils.clone( UnpackDepthRGBAShader.uniforms ),\r\n\t\tvertexShader: UnpackDepthRGBAShader.vertexShader,\r\n\t\tfragmentShader: UnpackDepthRGBAShader.fragmentShader,\r\n\t\tblending: NoBlending\r\n\t} );\r\n\r\n\tthis.quadCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.quadScene = new Scene();\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quadScene.add( this.quad );\r\n\r\n};\r\n\r\nSAOPass.OUTPUT = {\r\n\t'Beauty': 1,\r\n\t'Default': 0,\r\n\t'SAO': 2,\r\n\t'Depth': 3,\r\n\t'Normal': 4\r\n};\r\n\r\nSAOPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\tconstructor: SAOPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\t// Rendering readBuffer first when rendering to screen\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\tthis.materialCopy.blending = NoBlending;\r\n\t\t\tthis.materialCopy.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\t\t\tthis.materialCopy.needsUpdate = true;\r\n\t\t\tthis.renderPass( renderer, this.materialCopy, null );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.params.output === 1 ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.oldClearColor.copy( renderer.getClearColor() );\r\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\r\n\t\tvar oldAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\trenderer.clearTarget( this.depthRenderTarget );\r\n\r\n\t\tthis.saoMaterial.uniforms[ 'bias' ].value = this.params.saoBias;\r\n\t\tthis.saoMaterial.uniforms[ 'intensity' ].value = this.params.saoIntensity;\r\n\t\tthis.saoMaterial.uniforms[ 'scale' ].value = this.params.saoScale;\r\n\t\tthis.saoMaterial.uniforms[ 'kernelRadius' ].value = this.params.saoKernelRadius;\r\n\t\tthis.saoMaterial.uniforms[ 'minResolution' ].value = this.params.saoMinResolution;\r\n\t\tthis.saoMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;\r\n\t\tthis.saoMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;\r\n\t\t// this.saoMaterial.uniforms['randomSeed'].value = Math.random();\r\n\r\n\t\tvar depthCutoff = this.params.saoBlurDepthCutoff * ( this.camera.far - this.camera.near );\r\n\t\tthis.vBlurMaterial.uniforms[ 'depthCutoff' ].value = depthCutoff;\r\n\t\tthis.hBlurMaterial.uniforms[ 'depthCutoff' ].value = depthCutoff;\r\n\r\n\t\tthis.vBlurMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;\r\n\t\tthis.vBlurMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;\r\n\t\tthis.hBlurMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;\r\n\t\tthis.hBlurMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;\r\n\r\n\t\tthis.params.saoBlurRadius = Math.floor( this.params.saoBlurRadius );\r\n\t\tif ( ( this.prevStdDev !== this.params.saoBlurStdDev ) || ( this.prevNumSamples !== this.params.saoBlurRadius ) ) {\r\n\r\n\t\t\tBlurShaderUtils.configure( this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2( 0, 1 ) );\r\n\t\t\tBlurShaderUtils.configure( this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2( 1, 0 ) );\r\n\t\t\tthis.prevStdDev = this.params.saoBlurStdDev;\r\n\t\t\tthis.prevNumSamples = this.params.saoBlurRadius;\r\n\r\n\t\t}\r\n\r\n\t\t// Rendering scene to depth texture\r\n\t\trenderer.setClearColor( 0x000000 );\r\n\t\trenderer.render( this.scene, this.camera, this.beautyRenderTarget, true );\r\n\r\n\t\t// Re-render scene if depth texture extension is not supported\r\n\t\tif ( ! this.supportsDepthTextureExtension ) {\r\n\r\n\t\t\t// Clear rule : far clipping plane in both RGBA and Basic encoding\r\n\t\t\tthis.renderOverride( renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.supportsNormalTexture ) {\r\n\r\n\t\t\t// Clear rule : default normal is facing the camera\r\n\t\t\tthis.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\t// Rendering SAO texture\r\n\t\tthis.renderPass( renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0 );\r\n\r\n\t\t// Blurring SAO texture\r\n\t\tif ( this.params.saoBlur ) {\r\n\r\n\t\t\tthis.renderPass( renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0 );\r\n\t\t\tthis.renderPass( renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tvar outputMaterial = this.materialCopy;\r\n\t\t// Setting up SAO rendering\r\n\t\tif ( this.params.output === 3 ) {\r\n\r\n\t\t\tif ( this.supportsDepthTextureExtension ) {\r\n\r\n\t\t\t\tthis.materialCopy.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.depthTexture;\r\n\t\t\t\tthis.materialCopy.needsUpdate = true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.depthCopy.uniforms[ 'tDiffuse' ].value = this.depthRenderTarget.texture;\r\n\t\t\t\tthis.depthCopy.needsUpdate = true;\r\n\t\t\t\toutputMaterial = this.depthCopy;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( this.params.output === 4 ) {\r\n\r\n\t\t\tthis.materialCopy.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;\r\n\t\t\tthis.materialCopy.needsUpdate = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.materialCopy.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;\r\n\t\t\tthis.materialCopy.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\t// Blending depends on output, only want a CustomBlending when showing SAO\r\n\t\tif ( this.params.output === 0 ) {\r\n\r\n\t\t\toutputMaterial.blending = CustomBlending;\r\n\r\n\t\t} else {\r\n\r\n\t\t\toutputMaterial.blending = NoBlending;\r\n\r\n\t\t}\r\n\r\n\t\t// Rendering SAOPass result on top of previous pass\r\n\t\tthis.renderPass( renderer, outputMaterial, this.renderToScreen ? null : readBuffer );\r\n\r\n\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\r\n\t\trenderer.autoClear = oldAutoClear;\r\n\r\n\t},\r\n\r\n\trenderPass: function ( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {\r\n\r\n\t\t// save original state\r\n\t\tvar originalClearColor = renderer.getClearColor();\r\n\t\tvar originalClearAlpha = renderer.getClearAlpha();\r\n\t\tvar originalAutoClear = renderer.autoClear;\r\n\r\n\t\t// setup pass state\r\n\t\trenderer.autoClear = false;\r\n\t\tvar clearNeeded = ( clearColor !== undefined ) && ( clearColor !== null );\r\n\t\tif ( clearNeeded ) {\r\n\r\n\t\t\trenderer.setClearColor( clearColor );\r\n\t\t\trenderer.setClearAlpha( clearAlpha || 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.quad.material = passMaterial;\r\n\t\trenderer.render( this.quadScene, this.quadCamera, renderTarget, clearNeeded );\r\n\r\n\t\t// restore original state\r\n\t\trenderer.autoClear = originalAutoClear;\r\n\t\trenderer.setClearColor( originalClearColor );\r\n\t\trenderer.setClearAlpha( originalClearAlpha );\r\n\r\n\t},\r\n\r\n\trenderOverride: function ( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {\r\n\r\n\t\tvar originalClearColor = renderer.getClearColor();\r\n\t\tvar originalClearAlpha = renderer.getClearAlpha();\r\n\t\tvar originalAutoClear = renderer.autoClear;\r\n\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\tclearColor = overrideMaterial.clearColor || clearColor;\r\n\t\tclearAlpha = overrideMaterial.clearAlpha || clearAlpha;\r\n\t\tvar clearNeeded = ( clearColor !== undefined ) && ( clearColor !== null );\r\n\t\tif ( clearNeeded ) {\r\n\r\n\t\t\trenderer.setClearColor( clearColor );\r\n\t\t\trenderer.setClearAlpha( clearAlpha || 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.scene.overrideMaterial = overrideMaterial;\r\n\t\trenderer.render( this.scene, this.camera, renderTarget, clearNeeded );\r\n\t\tthis.scene.overrideMaterial = null;\r\n\r\n\t\t// restore original state\r\n\t\trenderer.autoClear = originalAutoClear;\r\n\t\trenderer.setClearColor( originalClearColor );\r\n\t\trenderer.setClearAlpha( originalClearAlpha );\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tthis.beautyRenderTarget.setSize( width, height );\r\n\t\tthis.saoRenderTarget.setSize( width, height );\r\n\t\tthis.blurIntermediateRenderTarget.setSize( width, height );\r\n\t\tthis.normalRenderTarget.setSize( width, height );\r\n\t\tthis.depthRenderTarget.setSize( width, height );\r\n\r\n\t\tthis.saoMaterial.uniforms[ 'size' ].value.set( width, height );\r\n\t\tthis.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse( this.camera.projectionMatrix );\r\n\t\tthis.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;\r\n\t\tthis.saoMaterial.needsUpdate = true;\r\n\r\n\t\tthis.vBlurMaterial.uniforms[ 'size' ].value.set( width, height );\r\n\t\tthis.vBlurMaterial.needsUpdate = true;\r\n\r\n\t\tthis.hBlurMaterial.uniforms[ 'size' ].value.set( width, height );\r\n\t\tthis.hBlurMaterial.needsUpdate = true;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SavePass = function ( renderTarget ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tif ( CopyShader === undefined )\r\n\t\t{ console.error( \"SavePass relies on CopyShader\" ); }\r\n\r\n\tvar shader = CopyShader;\r\n\r\n\tthis.textureID = \"tDiffuse\";\r\n\r\n\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\r\n\r\n\tthis.material = new ShaderMaterial( {\r\n\r\n\t\tuniforms: this.uniforms,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t} );\r\n\r\n\tthis.renderTarget = renderTarget;\r\n\r\n\tif ( this.renderTarget === undefined ) {\r\n\r\n\t\tthis.renderTarget = new WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBFormat, stencilBuffer: false } );\r\n\t\tthis.renderTarget.texture.name = \"SavePass.rt\";\r\n\r\n\t}\r\n\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nSavePass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: SavePass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer ) {\r\n\r\n\t\tif ( this.uniforms[ this.textureID ] ) {\r\n\r\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\r\n\r\n\t\t}\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTarget, this.clear );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SMAAShader = [ {\r\n\r\n\tdefines: {\r\n\r\n\t\t\"SMAA_THRESHOLD\": \"0.1\"\r\n\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":\t\t{ value: null },\r\n\t\t\"resolution\":\t{ value: new Vector2( 1 / 1024, 1 / 512 ) }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform vec2 resolution;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\"varying vec4 vOffset[ 3 ];\",\r\n\r\n\t\t\"void SMAAEdgeDetectionVS( vec2 texcoord ) {\",\r\n\t\t\t\"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\", // WebGL port note: Changed sign in W component\r\n\t\t\t\"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\", // WebGL port note: Changed sign in W component\r\n\t\t\t\"vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\", // WebGL port note: Changed sign in W component\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\"SMAAEdgeDetectionVS( vUv );\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\"varying vec4 vOffset[ 3 ];\",\r\n\r\n\t\t\"vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\",\r\n\t\t\t\"vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\",\r\n\r\n\t\t\t// Calculate color deltas:\r\n\t\t\t\"vec4 delta;\",\r\n\t\t\t\"vec3 C = texture2D( colorTex, texcoord ).rgb;\",\r\n\r\n\t\t\t\"vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\",\r\n\t\t\t\"vec3 t = abs( C - Cleft );\",\r\n\t\t\t\"delta.x = max( max( t.r, t.g ), t.b );\",\r\n\r\n\t\t\t\"vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\",\r\n\t\t\t\"t = abs( C - Ctop );\",\r\n\t\t\t\"delta.y = max( max( t.r, t.g ), t.b );\",\r\n\r\n\t\t\t// We do the usual threshold:\r\n\t\t\t\"vec2 edges = step( threshold, delta.xy );\",\r\n\r\n\t\t\t// Then discard if there is no edge:\r\n\t\t\t\"if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\",\r\n\t\t\t\t\"discard;\",\r\n\r\n\t\t\t// Calculate right and bottom deltas:\r\n\t\t\t\"vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\",\r\n\t\t\t\"t = abs( C - Cright );\",\r\n\t\t\t\"delta.z = max( max( t.r, t.g ), t.b );\",\r\n\r\n\t\t\t\"vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\",\r\n\t\t\t\"t = abs( C - Cbottom );\",\r\n\t\t\t\"delta.w = max( max( t.r, t.g ), t.b );\",\r\n\r\n\t\t\t// Calculate the maximum delta in the direct neighborhood:\r\n\t\t\t\"float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\",\r\n\r\n\t\t\t// Calculate left-left and top-top deltas:\r\n\t\t\t\"vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\",\r\n\t\t\t\"t = abs( C - Cleftleft );\",\r\n\t\t\t\"delta.z = max( max( t.r, t.g ), t.b );\",\r\n\r\n\t\t\t\"vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\",\r\n\t\t\t\"t = abs( C - Ctoptop );\",\r\n\t\t\t\"delta.w = max( max( t.r, t.g ), t.b );\",\r\n\r\n\t\t\t// Calculate the final maximum delta:\r\n\t\t\t\"maxDelta = max( max( maxDelta, delta.z ), delta.w );\",\r\n\r\n\t\t\t// Local contrast adaptation in action:\r\n\t\t\t\"edges.xy *= step( 0.5 * maxDelta, delta.xy );\",\r\n\r\n\t\t\t\"return vec4( edges, 0.0, 0.0 );\",\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\")\r\n\r\n}, {\r\n\r\n\tdefines: {\r\n\r\n\t\t\"SMAA_MAX_SEARCH_STEPS\":\t\t\"8\",\r\n\t\t\"SMAA_AREATEX_MAX_DISTANCE\":\t\"16\",\r\n\t\t\"SMAA_AREATEX_PIXEL_SIZE\":\t\t\"( 1.0 / vec2( 160.0, 560.0 ) )\",\r\n\t\t\"SMAA_AREATEX_SUBTEX_SIZE\":\t\t\"( 1.0 / 7.0 )\"\r\n\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":\t\t{ value: null },\r\n\t\t\"tArea\":\t\t{ value: null },\r\n\t\t\"tSearch\":\t\t{ value: null },\r\n\t\t\"resolution\":\t{ value: new Vector2( 1 / 1024, 1 / 512 ) }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform vec2 resolution;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\"varying vec4 vOffset[ 3 ];\",\r\n\t\t\"varying vec2 vPixcoord;\",\r\n\r\n\t\t\"void SMAABlendingWeightCalculationVS( vec2 texcoord ) {\",\r\n\t\t\t\"vPixcoord = texcoord / resolution;\",\r\n\r\n\t\t\t// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\r\n\t\t\t\"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\", // WebGL port note: Changed sign in Y and W components\r\n\t\t\t\"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\", // WebGL port note: Changed sign in Y and W components\r\n\r\n\t\t\t// And these for the searches, they indicate the ends of the loops:\r\n\t\t\t\"vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\"SMAABlendingWeightCalculationVS( vUv );\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform sampler2D tArea;\",\r\n\t\t\"uniform sampler2D tSearch;\",\r\n\t\t\"uniform vec2 resolution;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\"varying vec4 vOffset[3];\",\r\n\t\t\"varying vec2 vPixcoord;\",\r\n\r\n\t\t\"vec2 round( vec2 x ) {\",\r\n\t\t\t\"return sign( x ) * floor( abs( x ) + 0.5 );\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\",\r\n\t\t\t// Not required if searchTex accesses are set to point:\r\n\t\t\t// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\r\n\t\t\t// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\r\n\t\t\t//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\r\n\t\t\t\"e.r = bias + e.r * scale;\",\r\n\t\t\t\"return 255.0 * texture2D( searchTex, e, 0.0 ).r;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\",\r\n\t\t\t\r\n\t\t\t\"vec2 e = vec2( 0.0, 1.0 );\",\r\n\r\n\t\t\t\"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\r\n\t\t\t\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\",\r\n\t\t\t\t\"texcoord -= vec2( 2.0, 0.0 ) * resolution;\",\r\n\t\t\t\t\"if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t// We correct the previous (-0.25, -0.125) offset we applied:\r\n\t\t\t\"texcoord.x += 0.25 * resolution.x;\",\r\n\r\n\t\t\t// The searches are bias by 1, so adjust the coords accordingly:\r\n\t\t\t\"texcoord.x += resolution.x;\",\r\n\r\n\t\t\t// Disambiguate the length added by the last step:\r\n\t\t\t\"texcoord.x += 2.0 * resolution.x;\", // Undo last step\r\n\t\t\t\"texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\",\r\n\r\n\t\t\t\"return texcoord.x;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\",\r\n\t\t\t\"vec2 e = vec2( 0.0, 1.0 );\",\r\n\r\n\t\t\t\"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\r\n\t\t\t\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\",\r\n\t\t\t\t\"texcoord += vec2( 2.0, 0.0 ) * resolution;\",\r\n\t\t\t\t\"if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"texcoord.x -= 0.25 * resolution.x;\",\r\n\t\t\t\"texcoord.x -= resolution.x;\",\r\n\t\t\t\"texcoord.x -= 2.0 * resolution.x;\",\r\n\t\t\t\"texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\",\r\n\r\n\t\t\t\"return texcoord.x;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\",\r\n\t\t\t\"vec2 e = vec2( 1.0, 0.0 );\",\r\n\r\n\t\t\t\"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\r\n\t\t\t\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\",\r\n\t\t\t\t\"texcoord += vec2( 0.0, 2.0 ) * resolution;\", // WebGL port note: Changed sign\r\n\t\t\t\t\"if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"texcoord.y -= 0.25 * resolution.y;\", // WebGL port note: Changed sign\r\n\t\t\t\"texcoord.y -= resolution.y;\", // WebGL port note: Changed sign\r\n\t\t\t\"texcoord.y -= 2.0 * resolution.y;\", // WebGL port note: Changed sign\r\n\t\t\t\"texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );\", // WebGL port note: Changed sign\r\n\r\n\t\t\t\"return texcoord.y;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\",\r\n\t\t\t\"vec2 e = vec2( 1.0, 0.0 );\",\r\n\r\n\t\t\t\"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\r\n\t\t\t\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\",\r\n\t\t\t\t\"texcoord -= vec2( 0.0, 2.0 ) * resolution;\", // WebGL port note: Changed sign\r\n\t\t\t\t\"if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"texcoord.y += 0.25 * resolution.y;\", // WebGL port note: Changed sign\r\n\t\t\t\"texcoord.y += resolution.y;\", // WebGL port note: Changed sign\r\n\t\t\t\"texcoord.y += 2.0 * resolution.y;\", // WebGL port note: Changed sign\r\n\t\t\t\"texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );\", // WebGL port note: Changed sign\r\n\r\n\t\t\t\"return texcoord.y;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\",\r\n\t\t\t// Rounding prevents precision errors of bilinear filtering:\r\n\t\t\t\"vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\",\r\n\r\n\t\t\t// We do a scale and bias for mapping to texel space:\r\n\t\t\t\"texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\",\r\n\r\n\t\t\t// Move to proper place, according to the subpixel offset:\r\n\t\t\t\"texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\",\r\n\r\n\t\t\t\"return texture2D( areaTex, texcoord, 0.0 ).rg;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\",\r\n\t\t\t\"vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\",\r\n\r\n\t\t\t\"vec2 e = texture2D( edgesTex, texcoord ).rg;\",\r\n\r\n\t\t\t\"if ( e.g > 0.0 ) {\", // Edge at north\r\n\t\t\t\t\"vec2 d;\",\r\n\r\n\t\t\t\t// Find the distance to the left:\r\n\t\t\t\t\"vec2 coords;\",\r\n\t\t\t\t\"coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\",\r\n\t\t\t\t\"coords.y = offset[ 1 ].y;\", // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\r\n\t\t\t\t\"d.x = coords.x;\",\r\n\r\n\t\t\t\t// Now fetch the left crossing edges, two at a time using bilinear\r\n\t\t\t\t// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\r\n\t\t\t\t// discern what value each edge has:\r\n\t\t\t\t\"float e1 = texture2D( edgesTex, coords, 0.0 ).r;\",\r\n\r\n\t\t\t\t// Find the distance to the right:\r\n\t\t\t\t\"coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\",\r\n\t\t\t\t\"d.y = coords.x;\",\r\n\r\n\t\t\t\t// We want the distances to be in pixel units (doing this here allow to\r\n\t\t\t\t// better interleave arithmetic and memory accesses):\r\n\t\t\t\t\"d = d / resolution.x - pixcoord.x;\",\r\n\r\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\r\n\t\t\t\t// quadratically:\r\n\t\t\t\t\"vec2 sqrt_d = sqrt( abs( d ) );\",\r\n\r\n\t\t\t\t// Fetch the right crossing edges:\r\n\t\t\t\t\"coords.y -= 1.0 * resolution.y;\", // WebGL port note: Added\r\n\t\t\t\t\"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\",\r\n\r\n\t\t\t\t// Ok, we know how this pattern looks like, now it is time for getting\r\n\t\t\t\t// the actual area:\r\n\t\t\t\t\"weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"if ( e.r > 0.0 ) {\", // Edge at west\r\n\t\t\t\t\"vec2 d;\",\r\n\r\n\t\t\t\t// Find the distance to the top:\r\n\t\t\t\t\"vec2 coords;\",\r\n\r\n\t\t\t\t\"coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\",\r\n\t\t\t\t\"coords.x = offset[ 0 ].x;\", // offset[1].x = texcoord.x - 0.25 * resolution.x;\r\n\t\t\t\t\"d.x = coords.y;\",\r\n\r\n\t\t\t\t// Fetch the top crossing edges:\r\n\t\t\t\t\"float e1 = texture2D( edgesTex, coords, 0.0 ).g;\",\r\n\r\n\t\t\t\t// Find the distance to the bottom:\r\n\t\t\t\t\"coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\",\r\n\t\t\t\t\"d.y = coords.y;\",\r\n\r\n\t\t\t\t// We want the distances to be in pixel units:\r\n\t\t\t\t\"d = d / resolution.y - pixcoord.y;\",\r\n\r\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\r\n\t\t\t\t// quadratically:\r\n\t\t\t\t\"vec2 sqrt_d = sqrt( abs( d ) );\",\r\n\r\n\t\t\t\t// Fetch the bottom crossing edges:\r\n\t\t\t\t\"coords.y -= 1.0 * resolution.y;\", // WebGL port note: Added\r\n\t\t\t\t\"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\",\r\n\r\n\t\t\t\t// Get the area for this direction:\r\n\t\t\t\t\"weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"return weights;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\")\r\n\r\n}, {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":\t\t{ value: null },\r\n\t\t\"tColor\":\t\t{ value: null },\r\n\t\t\"resolution\":\t{ value: new Vector2( 1 / 1024, 1 / 512 ) }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform vec2 resolution;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\"varying vec4 vOffset[ 2 ];\",\r\n\r\n\t\t\"void SMAANeighborhoodBlendingVS( vec2 texcoord ) {\",\r\n\t\t\t\"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );\", // WebGL port note: Changed sign in W component\r\n\t\t\t\"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );\", // WebGL port note: Changed sign in W component\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\"SMAANeighborhoodBlendingVS( vUv );\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform sampler2D tColor;\",\r\n\t\t\"uniform vec2 resolution;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\"varying vec4 vOffset[ 2 ];\",\r\n\r\n\t\t\"vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\",\r\n\t\t\t// Fetch the blending weights for current pixel:\r\n\t\t\t\"vec4 a;\",\r\n\t\t\t\"a.xz = texture2D( blendTex, texcoord ).xz;\",\r\n\t\t\t\"a.y = texture2D( blendTex, offset[ 1 ].zw ).g;\",\r\n\t\t\t\"a.w = texture2D( blendTex, offset[ 1 ].xy ).a;\",\r\n\r\n\t\t\t// Is there any blending weight with a value greater than 0.0?\r\n\t\t\t\"if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\",\r\n\t\t\t\t\"return texture2D( colorTex, texcoord, 0.0 );\",\r\n\t\t\t\"} else {\",\r\n\t\t\t\t// Up to 4 lines can be crossing a pixel (one through each edge). We\r\n\t\t\t\t// favor blending by choosing the line with the maximum weight for each\r\n\t\t\t\t// direction:\r\n\t\t\t\t\"vec2 offset;\",\r\n\t\t\t\t\"offset.x = a.a > a.b ? a.a : -a.b;\", // left vs. right\r\n\t\t\t\t\"offset.y = a.g > a.r ? -a.g : a.r;\", // top vs. bottom // WebGL port note: Changed signs\r\n\r\n\t\t\t\t// Then we go in the direction that has the maximum weight:\r\n\t\t\t\t\"if ( abs( offset.x ) > abs( offset.y )) {\", // horizontal vs. vertical\r\n\t\t\t\t\t\"offset.y = 0.0;\",\r\n\t\t\t\t\"} else {\",\r\n\t\t\t\t\t\"offset.x = 0.0;\",\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t// Fetch the opposite color and lerp by hand:\r\n\t\t\t\t\"vec4 C = texture2D( colorTex, texcoord, 0.0 );\",\r\n\t\t\t\t\"texcoord += sign( offset ) * resolution;\",\r\n\t\t\t\t\"vec4 Cop = texture2D( colorTex, texcoord, 0.0 );\",\r\n\t\t\t\t\"float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\",\r\n\r\n\t\t\t\t// WebGL port note: Added gamma correction\r\n\t\t\t\t\"C.xyz = pow(C.xyz, vec3(2.2));\",\r\n\t\t\t\t\"Cop.xyz = pow(Cop.xyz, vec3(2.2));\",\r\n\t\t\t\t\"vec4 mixed = mix(C, Cop, s);\",\r\n\t\t\t\t\"mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\",\r\n\r\n\t\t\t\t\"return mixed;\",\r\n\t\t\t\"}\",\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\")\r\n\r\n} ];\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SMAAPass = function ( width, height ) {\r\n\r\n\tPass.call( this );\r\n\r\n\t// render targets\r\n\r\n\tthis.edgesRT = new WebGLRenderTarget( width, height, {\r\n\t\tdepthBuffer: false,\r\n\t\tstencilBuffer: false,\r\n\t\tgenerateMipmaps: false,\r\n\t\tminFilter: LinearFilter,\r\n\t\tformat: RGBFormat\r\n\t} );\r\n\tthis.edgesRT.texture.name = \"SMAAPass.edges\";\r\n\r\n\tthis.weightsRT = new WebGLRenderTarget( width, height, {\r\n\t\tdepthBuffer: false,\r\n\t\tstencilBuffer: false,\r\n\t\tgenerateMipmaps: false,\r\n\t\tminFilter: LinearFilter,\r\n\t\tformat: RGBAFormat\r\n\t} );\r\n\tthis.weightsRT.texture.name = \"SMAAPass.weights\";\r\n\r\n\t// textures\r\n\r\n\tvar areaTextureImage = new Image();\r\n\tareaTextureImage.src = this.getAreaTexture();\r\n\r\n\tthis.areaTexture = new Texture();\r\n\tthis.areaTexture.name = \"SMAAPass.area\";\r\n\tthis.areaTexture.image = areaTextureImage;\r\n\tthis.areaTexture.format = RGBFormat;\r\n\tthis.areaTexture.minFilter = LinearFilter;\r\n\tthis.areaTexture.generateMipmaps = false;\r\n\tthis.areaTexture.needsUpdate = true;\r\n\tthis.areaTexture.flipY = false;\r\n\r\n\tvar searchTextureImage = new Image();\r\n\tsearchTextureImage.src = this.getSearchTexture();\r\n\r\n\tthis.searchTexture = new Texture();\r\n\tthis.searchTexture.name = \"SMAAPass.search\";\r\n\tthis.searchTexture.image = searchTextureImage;\r\n\tthis.searchTexture.magFilter = NearestFilter;\r\n\tthis.searchTexture.minFilter = NearestFilter;\r\n\tthis.searchTexture.generateMipmaps = false;\r\n\tthis.searchTexture.needsUpdate = true;\r\n\tthis.searchTexture.flipY = false;\r\n\r\n\t// materials - pass 1\r\n\r\n\tif ( SMAAShader === undefined ) {\r\n\t\tconsole.error( \"SMAAPass relies on SMAAShader\" );\r\n\t}\r\n\r\n\tthis.uniformsEdges = UniformsUtils.clone( SMAAShader[0].uniforms );\r\n\r\n\tthis.uniformsEdges[ \"resolution\" ].value.set( 1 / width, 1 / height );\r\n\r\n\tthis.materialEdges = new ShaderMaterial( {\r\n\t\tdefines: Object.assign( {}, SMAAShader[ 0 ].defines ),\r\n\t\tuniforms: this.uniformsEdges,\r\n\t\tvertexShader: SMAAShader[0].vertexShader,\r\n\t\tfragmentShader: SMAAShader[0].fragmentShader\r\n\t} );\r\n\r\n\t// materials - pass 2\r\n\r\n\tthis.uniformsWeights = UniformsUtils.clone( SMAAShader[1].uniforms );\r\n\r\n\tthis.uniformsWeights[ \"resolution\" ].value.set( 1 / width, 1 / height );\r\n\tthis.uniformsWeights[ \"tDiffuse\" ].value = this.edgesRT.texture;\r\n\tthis.uniformsWeights[ \"tArea\" ].value = this.areaTexture;\r\n\tthis.uniformsWeights[ \"tSearch\" ].value = this.searchTexture;\r\n\r\n\tthis.materialWeights = new ShaderMaterial( {\r\n\t\tdefines: Object.assign( {}, SMAAShader[ 1 ].defines ),\r\n\t\tuniforms: this.uniformsWeights,\r\n\t\tvertexShader: SMAAShader[1].vertexShader,\r\n\t\tfragmentShader: SMAAShader[1].fragmentShader\r\n\t} );\r\n\r\n\t// materials - pass 3\r\n\r\n\tthis.uniformsBlend = UniformsUtils.clone( SMAAShader[2].uniforms );\r\n\r\n\tthis.uniformsBlend[ \"resolution\" ].value.set( 1 / width, 1 / height );\r\n\tthis.uniformsBlend[ \"tDiffuse\" ].value = this.weightsRT.texture;\r\n\r\n\tthis.materialBlend = new ShaderMaterial( {\r\n\t\tuniforms: this.uniformsBlend,\r\n\t\tvertexShader: SMAAShader[2].vertexShader,\r\n\t\tfragmentShader: SMAAShader[2].fragmentShader\r\n\t} );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.camera = new OrthographicCamera( -1, 1, 1, -1, 0, 1 );\r\n\tthis.scene  = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nSMAAPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: SMAAPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\t// pass 1\r\n\r\n\t\tthis.uniformsEdges[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\r\n\t\tthis.quad.material = this.materialEdges;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.edgesRT, this.clear );\r\n\r\n\t\t// pass 2\r\n\r\n\t\tthis.quad.material = this.materialWeights;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.weightsRT, this.clear );\r\n\r\n\t\t// pass 3\r\n\r\n\t\tthis.uniformsBlend[ \"tColor\" ].value = readBuffer.texture;\r\n\r\n\t\tthis.quad.material = this.materialBlend;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tthis.edgesRT.setSize( width, height );\r\n\t\tthis.weightsRT.setSize( width, height );\r\n\r\n\t\tthis.materialEdges.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );\r\n\t\tthis.materialWeights.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );\r\n\t\tthis.materialBlend.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );\r\n\r\n\t},\r\n\r\n\tgetAreaTexture: function () {\r\n\t\treturn 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=';\r\n\t},\r\n\r\n\tgetSearchTexture: function () {\r\n\t\treturn 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=';\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SSAARenderPass = function ( scene, camera, clearColor, clearAlpha ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.scene = scene;\r\n\tthis.camera = camera;\r\n\r\n\tthis.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\r\n\tthis.unbiased = true;\r\n\r\n\t// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\r\n\tthis.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;\r\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\r\n\r\n\tif ( CopyShader === undefined ) { console.error( \"SSAARenderPass relies on CopyShader\" ); }\r\n\r\n\tvar copyShader = CopyShader;\r\n\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\r\n\r\n\tthis.copyMaterial = new ShaderMaterial(\t{\r\n\t\tuniforms: this.copyUniforms,\r\n\t\tvertexShader: copyShader.vertexShader,\r\n\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\tpremultipliedAlpha: true,\r\n\t\ttransparent: true,\r\n\t\tblending: AdditiveBlending,\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false\r\n\t} );\r\n\r\n\tthis.camera2 = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene2\t= new Scene();\r\n\tthis.quad2 = new Mesh( new PlaneBufferGeometry( 2, 2 ), this.copyMaterial );\r\n\tthis.quad2.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene2.add( this.quad2 );\r\n\r\n};\r\n\r\nSSAARenderPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: SSAARenderPass,\r\n\r\n\tdispose: function () {\r\n\r\n\t\tif ( this.sampleRenderTarget ) {\r\n\r\n\t\t\tthis.sampleRenderTarget.dispose();\r\n\t\t\tthis.sampleRenderTarget = null;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tif ( this.sampleRenderTarget )\t{ this.sampleRenderTarget.setSize( width, height ); }\r\n\r\n\t},\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( ! this.sampleRenderTarget ) {\r\n\r\n\t\t\tthis.sampleRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat } );\r\n\t\t\tthis.sampleRenderTarget.texture.name = \"SSAARenderPass.sample\";\r\n\r\n\t\t}\r\n\r\n\t\tvar jitterOffsets = SSAARenderPass.JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];\r\n\r\n\t\tvar autoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\tvar oldClearColor = renderer.getClearColor().getHex();\r\n\t\tvar oldClearAlpha = renderer.getClearAlpha();\r\n\r\n\t\tvar baseSampleWeight = 1.0 / jitterOffsets.length;\r\n\t\tvar roundingRange = 1 / 32;\r\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.sampleRenderTarget.texture;\r\n\r\n\t\tvar width = readBuffer.width, height = readBuffer.height;\r\n\r\n\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\r\n\t\tfor ( var i = 0; i < jitterOffsets.length; i ++ ) {\r\n\r\n\t\t\tvar jitterOffset = jitterOffsets[ i ];\r\n\r\n\t\t\tif ( this$1.camera.setViewOffset ) {\r\n\r\n\t\t\t\tthis$1.camera.setViewOffset( width, height,\r\n\t\t\t\t\tjitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625,   // 0.0625 = 1 / 16\r\n\t\t\t\t\twidth, height );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar sampleWeight = baseSampleWeight;\r\n\r\n\t\t\tif ( this$1.unbiased ) {\r\n\r\n\t\t\t\t// the theory is that equal weights for each sample lead to an accumulation of rounding errors.\r\n\t\t\t\t// The following equation varies the sampleWeight per sample so that it is uniformly distributed\r\n\t\t\t\t// across a range of values whose rounding errors cancel each other out.\r\n\r\n\t\t\t\tvar uniformCenteredDistribution = ( - 0.5 + ( i + 0.5 ) / jitterOffsets.length );\r\n\t\t\t\tsampleWeight += roundingRange * uniformCenteredDistribution;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis$1.copyUniforms[ \"opacity\" ].value = sampleWeight;\r\n\t\t\trenderer.setClearColor( this$1.clearColor, this$1.clearAlpha );\r\n\t\t\trenderer.render( this$1.scene, this$1.camera, this$1.sampleRenderTarget, true );\r\n\r\n\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\trenderer.render( this$1.scene2, this$1.camera2, this$1.renderToScreen ? null : writeBuffer, ( i === 0 ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.camera.clearViewOffset ) { this.camera.clearViewOffset(); }\r\n\r\n\t\trenderer.autoClear = autoClear;\r\n\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// These jitter vectors are specified in integers because it is easier.\r\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\r\n// before being used, thus these integers need to be scaled by 1/16.\r\n//\r\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\r\nSSAARenderPass.JitterVectors = [\r\n\t[\r\n\t\t[ 0, 0 ]\r\n\t],\r\n\t[\r\n\t\t[ 4, 4 ], [ - 4, - 4 ]\r\n\t],\r\n\t[\r\n\t\t[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]\r\n\t],\r\n\t[\r\n\t\t[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],\r\n\t\t[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]\r\n\t],\r\n\t[\r\n\t\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\r\n\t\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\r\n\t\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\r\n\t\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]\r\n\t],\r\n\t[\r\n\t\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\r\n\t\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\r\n\t\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\r\n\t\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\r\n\t\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\r\n\t\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\r\n\t\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\r\n\t\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\r\n\t]\r\n];\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SSAOShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":     { value: null },\r\n\t\t\"tDepth\":       { value: null },\r\n\t\t\"size\":         { value: new Vector2( 512, 512 ) },\r\n\t\t\"cameraNear\":   { value: 1 },\r\n\t\t\"cameraFar\":    { value: 100 },\r\n\t\t\"radius\":       { value: 32 },\r\n\t\t\"onlyAO\":       { value: 0 },\r\n\t\t\"aoClamp\":      { value: 0.25 },\r\n\t\t\"lumInfluence\": { value: 0.7 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float cameraNear;\",\r\n\t\t\"uniform float cameraFar;\",\r\n\t\t\"#ifdef USE_LOGDEPTHBUF\",\r\n\t\t\t\"uniform float logDepthBufFC;\",\r\n\t\t\"#endif\",\r\n\r\n\t\t\"uniform float radius;\",     // ao radius\r\n\t\t\"uniform bool onlyAO;\",      // use only ambient occlusion pass?\r\n\r\n\t\t\"uniform vec2 size;\",        // texture width, height\r\n\t\t\"uniform float aoClamp;\",    // depth clamp - reduces haloing at screen edges\r\n\r\n\t\t\"uniform float lumInfluence;\",  // how much luminance affects occlusion\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform sampler2D tDepth;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t// \"#define PI 3.14159265\",\r\n\t\t\"#define DL 2.399963229728653\",  // PI * ( 3.0 - sqrt( 5.0 ) )\r\n\t\t\"#define EULER 2.718281828459045\",\r\n\r\n\t\t// user variables\r\n\r\n\t\t\"const int samples = 64;\",     // ao sample count\r\n\r\n\t\t\"const bool useNoise = true;\",      // use noise instead of pattern for sample dithering\r\n\t\t\"const float noiseAmount = 0.0004;\", // dithering amount\r\n\r\n\t\t\"const float diffArea = 0.4;\",   // self-shadowing reduction\r\n\t\t\"const float gDisplace = 0.4;\",  // gauss bell center\r\n\r\n\t\t// RGBA depth\r\n\r\n\t\t\"#include <packing>\",\r\n\r\n\t\t// generating noise / pattern texture for dithering\r\n\r\n\t\t\"vec2 rand( const vec2 coord ) {\",\r\n\r\n\t\t\t\"vec2 noise;\",\r\n\r\n\t\t\t\"if ( useNoise ) {\",\r\n\r\n\t\t\t\t\"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\",\r\n\t\t\t\t\"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\",\r\n\r\n\t\t\t\t\"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\",\r\n\r\n\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\"float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );\",\r\n\t\t\t\t\"float gg = fract( coord.t * ( size.y / 2.0 ) );\",\r\n\r\n\t\t\t\t\"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"return ( noise * 2.0  - 1.0 ) * noiseAmount;\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"float readDepth( const in vec2 coord ) {\",\r\n\r\n\t\t\t\"float cameraFarPlusNear = cameraFar + cameraNear;\",\r\n\t\t\t\"float cameraFarMinusNear = cameraFar - cameraNear;\",\r\n\t\t\t\"float cameraCoef = 2.0 * cameraNear;\",\r\n\r\n\t\t\t\"#ifdef USE_LOGDEPTHBUF\",\r\n\r\n\t\t\t\t\"float logz = unpackRGBAToDepth( texture2D( tDepth, coord ) );\",\r\n\t\t\t\t\"float w = pow(2.0, (logz / logDepthBufFC)) - 1.0;\",\r\n\t\t\t\t\"float z = (logz / w) + 1.0;\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"float z = unpackRGBAToDepth( texture2D( tDepth, coord ) );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"return cameraCoef / ( cameraFarPlusNear - z * cameraFarMinusNear );\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"float compareDepths( const in float depth1, const in float depth2, inout int far ) {\",\r\n\r\n\t\t\t\"float garea = 8.0;\",                         // gauss bell width\r\n\t\t\t\"float diff = ( depth1 - depth2 ) * 100.0;\",  // depth difference (0-100)\r\n\r\n\t\t\t// reduce left bell width to avoid self-shadowing\r\n\r\n\t\t\t\"if ( diff < gDisplace ) {\",\r\n\r\n\t\t\t\t\"garea = diffArea;\",\r\n\r\n\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\"far = 1;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"float dd = diff - gDisplace;\",\r\n\t\t\t\"float gauss = pow( EULER, -2.0 * ( dd * dd ) / ( garea * garea ) );\",\r\n\t\t\t\"return gauss;\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"float calcAO( float depth, float dw, float dh ) {\",\r\n\r\n\t\t\t\"vec2 vv = vec2( dw, dh );\",\r\n\r\n\t\t\t\"vec2 coord1 = vUv + radius * vv;\",\r\n\t\t\t\"vec2 coord2 = vUv - radius * vv;\",\r\n\r\n\t\t\t\"float temp1 = 0.0;\",\r\n\t\t\t\"float temp2 = 0.0;\",\r\n\r\n\t\t\t\"int far = 0;\",\r\n\t\t\t\"temp1 = compareDepths( depth, readDepth( coord1 ), far );\",\r\n\r\n\t\t\t// DEPTH EXTRAPOLATION\r\n\r\n\t\t\t\"if ( far > 0 ) {\",\r\n\r\n\t\t\t\t\"temp2 = compareDepths( readDepth( coord2 ), depth, far );\",\r\n\t\t\t\t\"temp1 += ( 1.0 - temp1 ) * temp2;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"return temp1;\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 noise = rand( vUv );\",\r\n\t\t\t\"float depth = readDepth( vUv );\",\r\n\r\n\t\t\t\"float tt = clamp( depth, aoClamp, 1.0 );\",\r\n\r\n\t\t\t\"float w = ( 1.0 / size.x ) / tt + ( noise.x * ( 1.0 - noise.x ) );\",\r\n\t\t\t\"float h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) );\",\r\n\r\n\t\t\t\"float ao = 0.0;\",\r\n\r\n\t\t\t\"float dz = 1.0 / float( samples );\",\r\n\t\t\t\"float l = 0.0;\",\r\n\t\t\t\"float z = 1.0 - dz / 2.0;\",\r\n\r\n\t\t\t\"for ( int i = 0; i <= samples; i ++ ) {\",\r\n\r\n\t\t\t\t\"float r = sqrt( 1.0 - z );\",\r\n\r\n\t\t\t\t\"float pw = cos( l ) * r;\",\r\n\t\t\t\t\"float ph = sin( l ) * r;\",\r\n\t\t\t\t\"ao += calcAO( depth, pw * w, ph * h );\",\r\n\t\t\t\t\"z = z - dz;\",\r\n\t\t\t\t\"l = l + DL;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"ao /= float( samples );\",\r\n\t\t\t\"ao = 1.0 - ao;\",\r\n\r\n\t\t\t\"vec3 color = texture2D( tDiffuse, vUv ).rgb;\",\r\n\r\n\t\t\t\"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\",\r\n\t\t\t\"float lum = dot( color.rgb, lumcoeff );\",\r\n\t\t\t\"vec3 luminance = vec3( lum );\",\r\n\r\n\t\t\t\"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\",  // mix( color * ao, white, luminance )\r\n\r\n\t\t\t\"if ( onlyAO ) {\",\r\n\r\n\t\t\t\t\"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\",  // ambient occlusion only\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( final, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SSAOPass = function ( scene, camera, width, height ) {\r\n\r\n\tif ( SSAOShader === undefined ) {\r\n\r\n\t\tconsole.warn( 'SSAOPass depends on SSAOShader' );\r\n\t\treturn new ShaderPass();\r\n\r\n\t}\r\n\r\n\tShaderPass.call( this, SSAOShader );\r\n\r\n\tthis.width = ( width !== undefined ) ? width : 512;\r\n\tthis.height = ( height !== undefined ) ? height : 256;\r\n\r\n\tthis.renderToScreen = false;\r\n\r\n\tthis.camera2 = camera;\r\n\tthis.scene2 = scene;\r\n\r\n\t//Depth material\r\n\tthis.depthMaterial = new MeshDepthMaterial();\r\n\tthis.depthMaterial.depthPacking = RGBADepthPacking;\r\n\tthis.depthMaterial.blending = NoBlending;\r\n\r\n\t//Depth render target\r\n\tthis.depthRenderTarget = new WebGLRenderTarget( this.width, this.height, { minFilter: LinearFilter, magFilter: LinearFilter } );\r\n\t//this.depthRenderTarget.texture.name = 'SSAOShader.rt';\r\n\r\n\t//Shader uniforms\r\n\tthis.uniforms[ 'tDepth' ].value = this.depthRenderTarget.texture;\r\n\tthis.uniforms[ 'size' ].value.set( this.width, this.height );\r\n\tthis.uniforms[ 'cameraNear' ].value = this.camera2.near;\r\n\tthis.uniforms[ 'cameraFar' ].value = this.camera2.far;\r\n\r\n\tthis.uniforms[ 'radius' ].value = 4;\r\n\tthis.uniforms[ 'onlyAO' ].value = false;\r\n\tthis.uniforms[ 'aoClamp' ].value = 0.25;\r\n\tthis.uniforms[ 'lumInfluence' ].value = 0.7;\r\n\r\n\t//Setters and getters for uniforms\r\n\r\n\tObject.defineProperties( this, {\r\n\r\n\t\tradius: {\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.uniforms[ 'radius' ].value;\r\n\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.uniforms[ 'radius' ].value = value;\r\n\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonlyAO: {\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.uniforms[ 'onlyAO' ].value;\r\n\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.uniforms[ 'onlyAO' ].value = value;\r\n\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\taoClamp: {\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.uniforms[ 'aoClamp' ].value;\r\n\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.uniforms[ 'aoClamp' ].value = value;\r\n\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tlumInfluence: {\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this.uniforms[ 'lumInfluence' ].value;\r\n\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis.uniforms[ 'lumInfluence' ].value = value;\r\n\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t} );\r\n\r\n};\r\n\r\nSSAOPass.prototype = Object.create( ShaderPass.prototype );\r\n\r\nSSAOPass.prototype.render = function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t//Render depth into depthRenderTarget\r\n\tthis.scene2.overrideMaterial = this.depthMaterial;\r\n\r\n\trenderer.render( this.scene2, this.camera2, this.depthRenderTarget, true );\r\n\r\n\tthis.scene2.overrideMaterial = null;\r\n\r\n\t//SSAO shaderPass\r\n\tShaderPass.prototype.render.call( this, renderer, writeBuffer, readBuffer, delta, maskActive );\r\n\r\n};\r\n\r\nSSAOPass.prototype.setScene = function ( scene ) {\r\n\r\n\tthis.scene2 = scene;\r\n\r\n};\r\n\r\nSSAOPass.prototype.setCamera = function ( camera ) {\r\n\r\n\tthis.camera2 = camera;\r\n\r\n\tthis.uniforms[ 'cameraNear' ].value = this.camera2.near;\r\n\tthis.uniforms[ 'cameraFar' ].value = this.camera2.far;\r\n\r\n};\r\n\r\nSSAOPass.prototype.setSize = function ( width, height ) {\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.uniforms[ 'size' ].value.set( this.width, this.height );\r\n\tthis.depthRenderTarget.setSize( this.width, this.height );\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TAARenderPass = function ( scene, camera, params ) {\r\n\r\n\tif ( SSAARenderPass === undefined ) {\r\n\r\n\t\tconsole.error( \"TAARenderPass relies on SSAARenderPass\" );\r\n\r\n\t}\r\n\r\n\tSSAARenderPass.call( this, scene, camera, params );\r\n\r\n\tthis.sampleLevel = 0;\r\n\tthis.accumulate = false;\r\n\r\n};\r\n\r\nTAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\r\n\r\nTAARenderPass.prototype = Object.assign( Object.create( SSAARenderPass.prototype ), {\r\n\r\n\tconstructor: TAARenderPass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( ! this.accumulate ) {\r\n\r\n\t\t\tSSAARenderPass.prototype.render.call( this, renderer, writeBuffer, readBuffer, delta );\r\n\r\n\t\t\tthis.accumulateIndex = - 1;\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar jitterOffsets = TAARenderPass.JitterVectors[ 5 ];\r\n\r\n\t\tif ( ! this.sampleRenderTarget ) {\r\n\r\n\t\t\tthis.sampleRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );\r\n\t\t\tthis.sampleRenderTarget.texture.name = \"TAARenderPass.sample\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! this.holdRenderTarget ) {\r\n\r\n\t\t\tthis.holdRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );\r\n\t\t\tthis.holdRenderTarget.texture.name = \"TAARenderPass.hold\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.accumulate && this.accumulateIndex === - 1 ) {\r\n\r\n\t\t\tSSAARenderPass.prototype.render.call( this, renderer, this.holdRenderTarget, readBuffer, delta );\r\n\r\n\t\t\tthis.accumulateIndex = 0;\r\n\r\n\t\t}\r\n\r\n\t\tvar autoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\tvar sampleWeight = 1.0 / ( jitterOffsets.length );\r\n\r\n\t\tif ( this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length ) {\r\n\r\n\t\t\tthis.copyUniforms[ \"opacity\" ].value = sampleWeight;\r\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = writeBuffer.texture;\r\n\r\n\t\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\r\n\t\t\tvar numSamplesPerFrame = Math.pow( 2, this.sampleLevel );\r\n\t\t\tfor ( var i = 0; i < numSamplesPerFrame; i ++ ) {\r\n\r\n\t\t\t\tvar j = this$1.accumulateIndex;\r\n\t\t\t\tvar jitterOffset = jitterOffsets[ j ];\r\n\r\n\t\t\t\tif ( this$1.camera.setViewOffset ) {\r\n\r\n\t\t\t\t\tthis$1.camera.setViewOffset( readBuffer.width, readBuffer.height,\r\n\t\t\t\t\t\tjitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625,   // 0.0625 = 1 / 16\r\n\t\t\t\t\t\treadBuffer.width, readBuffer.height );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\trenderer.render( this$1.scene, this$1.camera, writeBuffer, true );\r\n\t\t\t\trenderer.render( this$1.scene2, this$1.camera2, this$1.sampleRenderTarget, ( this$1.accumulateIndex === 0 ) );\r\n\r\n\t\t\t\tthis$1.accumulateIndex ++;\r\n\r\n\t\t\t\tif ( this$1.accumulateIndex >= jitterOffsets.length ) { break; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.camera.clearViewOffset ) { this.camera.clearViewOffset(); }\r\n\r\n\t\t}\r\n\r\n\t\tvar accumulationWeight = this.accumulateIndex * sampleWeight;\r\n\r\n\t\tif ( accumulationWeight > 0 ) {\r\n\r\n\t\t\tthis.copyUniforms[ \"opacity\" ].value = 1.0;\r\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.sampleRenderTarget.texture;\r\n\t\t\trenderer.render( this.scene2, this.camera2, writeBuffer, true );\r\n\r\n\t\t}\r\n\r\n\t\tif ( accumulationWeight < 1.0 ) {\r\n\r\n\t\t\tthis.copyUniforms[ \"opacity\" ].value = 1.0 - accumulationWeight;\r\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.holdRenderTarget.texture;\r\n\t\t\trenderer.render( this.scene2, this.camera2, writeBuffer, ( accumulationWeight === 0 ) );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.autoClear = autoClear;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TexturePass = function ( map, opacity ) {\r\n\r\n\tPass.call( this );\r\n\r\n\tif ( CopyShader === undefined )\r\n\t\t{ console.error( \"TexturePass relies on CopyShader\" ); }\r\n\r\n\tvar shader = CopyShader;\r\n\r\n\tthis.map = map;\r\n\tthis.opacity = ( opacity !== undefined ) ? opacity : 1.0;\r\n\r\n\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\r\n\r\n\tthis.material = new ShaderMaterial( {\r\n\r\n\t\tuniforms: this.uniforms,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader,\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false\r\n\r\n\t} );\r\n\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene  = new Scene();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nTexturePass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: TexturePass,\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tvar oldAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\tthis.quad.material = this.material;\r\n\r\n\t\tthis.uniforms[ \"opacity\" ].value = this.opacity;\r\n\t\tthis.uniforms[ \"tDiffuse\" ].value = this.map;\r\n\t\tthis.material.transparent = ( this.opacity < 1.0 );\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear );\r\n\r\n\t\trenderer.autoClear = oldAutoClear;\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar LuminosityHighPassShader = {\r\n\r\n  shaderID: \"luminosityHighPass\",\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { type: \"t\", value: null },\r\n\t\t\"luminosityThreshold\": { type: \"f\", value: 1.0 },\r\n\t\t\"smoothWidth\": { type: \"f\", value: 1.0 },\r\n\t\t\"defaultColor\": { type: \"c\", value: new Color( 0x000000 ) },\r\n\t\t\"defaultOpacity\":  { type: \"f\", value: 0.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform vec3 defaultColor;\",\r\n\t\t\"uniform float defaultOpacity;\",\r\n\t\t\"uniform float luminosityThreshold;\",\r\n\t\t\"uniform float smoothWidth;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\r\n\r\n\t\t\t\"float v = dot( texel.xyz, luma );\",\r\n\r\n\t\t\t\"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\",\r\n\r\n\t\t\t\"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\",\r\n\r\n\t\t\t\"gl_FragColor = mix( outputColor, texel, alpha );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\")\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar UnrealBloomPass = function ( resolution, strength, radius, threshold ) {\n\tvar this$1 = this;\n\r\n\r\n\tPass.call( this );\r\n\r\n\tthis.strength = ( strength !== undefined ) ? strength : 1;\r\n\tthis.radius = radius;\r\n\tthis.threshold = threshold;\r\n\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\r\n\r\n\t// create color only once here, reuse it later inside the render function\r\n\tthis.clearColor = new Color( 0, 0, 0 );\r\n\r\n\t// render targets\r\n\tvar pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\r\n\tthis.renderTargetsHorizontal = [];\r\n\tthis.renderTargetsVertical = [];\r\n\tthis.nMips = 5;\r\n\tvar resx = Math.round( this.resolution.x / 2 );\r\n\tvar resy = Math.round( this.resolution.y / 2 );\r\n\r\n\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, pars );\r\n\tthis.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\r\n\tthis.renderTargetBright.texture.generateMipmaps = false;\r\n\r\n\tfor ( var i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\tvar renderTarget = new WebGLRenderTarget( resx, resy, pars );\r\n\r\n\t\trenderTarget.texture.name = \"UnrealBloomPass.h\" + i;\r\n\t\trenderTarget.texture.generateMipmaps = false;\r\n\r\n\t\tthis$1.renderTargetsHorizontal.push( renderTarget );\r\n\r\n\t\tvar renderTarget = new WebGLRenderTarget( resx, resy, pars );\r\n\r\n\t\trenderTarget.texture.name = \"UnrealBloomPass.v\" + i;\r\n\t\trenderTarget.texture.generateMipmaps = false;\r\n\r\n\t\tthis$1.renderTargetsVertical.push( renderTarget );\r\n\r\n\t\tresx = Math.round( resx / 2 );\r\n\r\n\t\tresy = Math.round( resy / 2 );\r\n\r\n\t}\r\n\r\n\t// luminosity high pass material\r\n\r\n\tif ( LuminosityHighPassShader === undefined )\r\n\t\t{ console.error( \"UnrealBloomPass relies on LuminosityHighPassShader\" ); }\r\n\r\n\tvar highPassShader = LuminosityHighPassShader;\r\n\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\r\n\r\n\tthis.highPassUniforms[ \"luminosityThreshold\" ].value = threshold;\r\n\tthis.highPassUniforms[ \"smoothWidth\" ].value = 0.01;\r\n\r\n\tthis.materialHighPassFilter = new ShaderMaterial( {\r\n\t\tuniforms: this.highPassUniforms,\r\n\t\tvertexShader: highPassShader.vertexShader,\r\n\t\tfragmentShader: highPassShader.fragmentShader,\r\n\t\tdefines: {}\r\n\t} );\r\n\r\n\t// Gaussian Blur Materials\r\n\tthis.separableBlurMaterials = [];\r\n\tvar kernelSizeArray = [ 3, 5, 7, 9, 11 ];\r\n\tvar resx = Math.round( this.resolution.x / 2 );\r\n\tvar resy = Math.round( this.resolution.y / 2 );\r\n\r\n\tfor ( var i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\tthis$1.separableBlurMaterials.push( this$1.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\r\n\r\n\t\tthis$1.separableBlurMaterials[ i ].uniforms[ \"texSize\" ].value = new Vector2( resx, resy );\r\n\r\n\t\tresx = Math.round( resx / 2 );\r\n\r\n\t\tresy = Math.round( resy / 2 );\r\n\r\n\t}\r\n\r\n\t// Composite material\r\n\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\r\n\tthis.compositeMaterial.uniforms[ \"blurTexture1\" ].value = this.renderTargetsVertical[ 0 ].texture;\r\n\tthis.compositeMaterial.uniforms[ \"blurTexture2\" ].value = this.renderTargetsVertical[ 1 ].texture;\r\n\tthis.compositeMaterial.uniforms[ \"blurTexture3\" ].value = this.renderTargetsVertical[ 2 ].texture;\r\n\tthis.compositeMaterial.uniforms[ \"blurTexture4\" ].value = this.renderTargetsVertical[ 3 ].texture;\r\n\tthis.compositeMaterial.uniforms[ \"blurTexture5\" ].value = this.renderTargetsVertical[ 4 ].texture;\r\n\tthis.compositeMaterial.uniforms[ \"bloomStrength\" ].value = strength;\r\n\tthis.compositeMaterial.uniforms[ \"bloomRadius\" ].value = 0.1;\r\n\tthis.compositeMaterial.needsUpdate = true;\r\n\r\n\tvar bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\r\n\tthis.compositeMaterial.uniforms[ \"bloomFactors\" ].value = bloomFactors;\r\n\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ),\r\n\t\t\t\t\t\t\t new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\r\n\tthis.compositeMaterial.uniforms[ \"bloomTintColors\" ].value = this.bloomTintColors;\r\n\r\n\t// copy material\r\n\tif ( CopyShader === undefined ) {\r\n\r\n\t\tconsole.error( \"BloomPass relies on CopyShader\" );\r\n\r\n\t}\r\n\r\n\tvar copyShader = CopyShader;\r\n\r\n\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\r\n\tthis.copyUniforms[ \"opacity\" ].value = 1.0;\r\n\r\n\tthis.materialCopy = new ShaderMaterial( {\r\n\t\tuniforms: this.copyUniforms,\r\n\t\tvertexShader: copyShader.vertexShader,\r\n\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\tblending: AdditiveBlending,\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false,\r\n\t\ttransparent: true\r\n\t} );\r\n\r\n\tthis.enabled = true;\r\n\tthis.needsSwap = false;\r\n\r\n\tthis.oldClearColor = new Color();\r\n\tthis.oldClearAlpha = 1;\r\n\r\n\tthis.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tthis.scene = new Scene();\r\n\r\n\tthis.basic = new MeshBasicMaterial();\r\n\r\n\tthis.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );\r\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\r\n\tthis.scene.add( this.quad );\r\n\r\n};\r\n\r\nUnrealBloomPass.prototype = Object.assign( Object.create( Pass.prototype ), {\r\n\r\n\tconstructor: UnrealBloomPass,\r\n\r\n\tdispose: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tfor ( var i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\r\n\r\n\t\t\tthis$1.renderTargetsHorizontal[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < this.renderTargetsVertical.length; i ++ ) {\r\n\r\n\t\t\tthis$1.renderTargetsVertical[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTargetBright.dispose();\r\n\r\n\t},\r\n\r\n\tsetSize: function ( width, height ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar resx = Math.round( width / 2 );\r\n\t\tvar resy = Math.round( height / 2 );\r\n\r\n\t\tthis.renderTargetBright.setSize( resx, resy );\r\n\r\n\t\tfor ( var i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\t\tthis$1.renderTargetsHorizontal[ i ].setSize( resx, resy );\r\n\t\t\tthis$1.renderTargetsVertical[ i ].setSize( resx, resy );\r\n\r\n\t\t\tthis$1.separableBlurMaterials[ i ].uniforms[ \"texSize\" ].value = new Vector2( resx, resy );\r\n\r\n\t\t\tresx = Math.round( resx / 2 );\r\n\t\t\tresy = Math.round( resy / 2 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.oldClearColor.copy( renderer.getClearColor() );\r\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\r\n\t\tvar oldAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\trenderer.setClearColor( this.clearColor, 0 );\r\n\r\n\t\tif ( maskActive ) { renderer.context.disable( renderer.context.STENCIL_TEST ); }\r\n\r\n\t\t// Render input to screen\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\tthis.quad.material = this.basic;\r\n\t\t\tthis.basic.map = readBuffer.texture;\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, undefined, true );\r\n\r\n\t\t}\r\n\r\n\t\t// 1. Extract Bright Areas\r\n\r\n\t\tthis.highPassUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\r\n\t\tthis.highPassUniforms[ \"luminosityThreshold\" ].value = this.threshold;\r\n\t\tthis.quad.material = this.materialHighPassFilter;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetBright, true );\r\n\r\n\t\t// 2. Blur All the mips progressively\r\n\r\n\t\tvar inputRenderTarget = this.renderTargetBright;\r\n\r\n\t\tfor ( var i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\t\tthis$1.quad.material = this$1.separableBlurMaterials[ i ];\r\n\r\n\t\t\tthis$1.separableBlurMaterials[ i ].uniforms[ \"colorTexture\" ].value = inputRenderTarget.texture;\r\n\t\t\tthis$1.separableBlurMaterials[ i ].uniforms[ \"direction\" ].value = UnrealBloomPass.BlurDirectionX;\r\n\t\t\trenderer.render( this$1.scene, this$1.camera, this$1.renderTargetsHorizontal[ i ], true );\r\n\r\n\t\t\tthis$1.separableBlurMaterials[ i ].uniforms[ \"colorTexture\" ].value = this$1.renderTargetsHorizontal[ i ].texture;\r\n\t\t\tthis$1.separableBlurMaterials[ i ].uniforms[ \"direction\" ].value = UnrealBloomPass.BlurDirectionY;\r\n\t\t\trenderer.render( this$1.scene, this$1.camera, this$1.renderTargetsVertical[ i ], true );\r\n\r\n\t\t\tinputRenderTarget = this$1.renderTargetsVertical[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// Composite All the mips\r\n\r\n\t\tthis.quad.material = this.compositeMaterial;\r\n\t\tthis.compositeMaterial.uniforms[ \"bloomStrength\" ].value = this.strength;\r\n\t\tthis.compositeMaterial.uniforms[ \"bloomRadius\" ].value = this.radius;\r\n\t\tthis.compositeMaterial.uniforms[ \"bloomTintColors\" ].value = this.bloomTintColors;\r\n\r\n\t\trenderer.render( this.scene, this.camera, this.renderTargetsHorizontal[ 0 ], true );\r\n\r\n\t\t// Blend it additively over the input texture\r\n\r\n\t\tthis.quad.material = this.materialCopy;\r\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetsHorizontal[ 0 ].texture;\r\n\r\n\t\tif ( maskActive ) { renderer.context.enable( renderer.context.STENCIL_TEST ); }\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, undefined, false );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( this.scene, this.camera, readBuffer, false );\r\n\r\n\t\t}\r\n\r\n\t\t// Restore renderer settings\r\n\r\n\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\r\n\t\trenderer.autoClear = oldAutoClear;\r\n\r\n\t},\r\n\r\n\tgetSeperableBlurMaterial: function ( kernelRadius ) {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\t\"KERNEL_RADIUS\": kernelRadius,\r\n\t\t\t\t\"SIGMA\": kernelRadius\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"colorTexture\": { value: null },\r\n\t\t\t\t\"texSize\": { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t\"direction\": { value: new Vector2( 0.5, 0.5 ) }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t\"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t\"#include <common>\\\r\n\t\t\t\tvarying vec2 vUv;\\n\\\r\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\r\n\t\t\t\tuniform vec2 texSize;\\\r\n\t\t\t\tuniform vec2 direction;\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\r\n\t\t\t\t}\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\r\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\r\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\r\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\r\n\t\t\t\t\t\tfloat x = float(i);\\\r\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\r\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\r\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\r\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\r\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\r\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\r\n\t\t\t\t\t}\\\r\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\r\n\t\t\t\t}\"\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tgetCompositeMaterial: function ( nMips ) {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\t\"NUM_MIPS\": nMips\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"blurTexture1\": { value: null },\r\n\t\t\t\t\"blurTexture2\": { value: null },\r\n\t\t\t\t\"blurTexture3\": { value: null },\r\n\t\t\t\t\"blurTexture4\": { value: null },\r\n\t\t\t\t\"blurTexture5\": { value: null },\r\n\t\t\t\t\"dirtTexture\": { value: null },\r\n\t\t\t\t\"bloomStrength\": { value: 1.0 },\r\n\t\t\t\t\"bloomFactors\": { value: null },\r\n\t\t\t\t\"bloomTintColors\": { value: null },\r\n\t\t\t\t\"bloomRadius\": { value: 0.0 }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader:\r\n\t\t\t\t\"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\r\n\r\n\t\t\tfragmentShader:\r\n\t\t\t\t\"varying vec2 vUv;\\\r\n\t\t\t\tuniform sampler2D blurTexture1;\\\r\n\t\t\t\tuniform sampler2D blurTexture2;\\\r\n\t\t\t\tuniform sampler2D blurTexture3;\\\r\n\t\t\t\tuniform sampler2D blurTexture4;\\\r\n\t\t\t\tuniform sampler2D blurTexture5;\\\r\n\t\t\t\tuniform sampler2D dirtTexture;\\\r\n\t\t\t\tuniform float bloomStrength;\\\r\n\t\t\t\tuniform float bloomRadius;\\\r\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\r\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\r\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\r\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\r\n\t\t\t\t}\\\r\n\t\t\t\t\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\r\n\t\t\t\t}\"\r\n\t\t} );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\r\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// Park-Miller-Carta Pseudo-Random Number Generator\r\n// https://github.com/pnitsch/BitmapData.js/blob/master/js/BitmapData.js\r\n\r\nvar PRNG = function () {\r\n\r\n\tthis.seed = 1;\r\n\tthis.next = function() {\r\n\r\n\t\treturn ( this.gen() / 2147483647 );\r\n\r\n\t};\r\n\tthis.nextRange = function( min, max )\t{\r\n\r\n\t\treturn min + ( ( max - min ) * this.next() )\r\n\r\n\t};\r\n\tthis.gen = function() {\r\n\r\n\t\treturn this.seed = ( this.seed * 16807 ) % 2147483647;\r\n\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\tthis.planes = [\r\n\r\n\t\t( p0 !== undefined ) ? p0 : new Plane(),\r\n\t\t( p1 !== undefined ) ? p1 : new Plane(),\r\n\t\t( p2 !== undefined ) ? p2 : new Plane(),\r\n\t\t( p3 !== undefined ) ? p3 : new Plane(),\r\n\t\t( p4 !== undefined ) ? p4 : new Plane(),\r\n\t\t( p5 !== undefined ) ? p5 : new Plane()\r\n\r\n\t];\r\n\r\n}\r\n\r\nObject.assign( Frustum.prototype, {\r\n\r\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tplanes[ 0 ].copy( p0 );\r\n\t\tplanes[ 1 ].copy( p1 );\r\n\t\tplanes[ 2 ].copy( p2 );\r\n\t\tplanes[ 3 ].copy( p3 );\r\n\t\tplanes[ 4 ].copy( p4 );\r\n\t\tplanes[ 5 ].copy( p5 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( frustum ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix: function ( m ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar me = m.elements;\r\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\r\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tintersectsObject: function () {\r\n\r\n\t\tvar sphere = new Sphere();\r\n\r\n\t\treturn function intersectsObject( object ) {\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\tif ( geometry.boundingSphere === null )\r\n\t\t\t\t{ geometry.computeBoundingSphere(); }\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere )\r\n\t\t\t\t.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSprite: function () {\r\n\r\n\t\tvar sphere = new Sphere();\r\n\r\n\t\treturn function intersectsSprite( sprite ) {\r\n\r\n\t\t\tsphere.center.set( 0, 0, 0 );\r\n\t\t\tsphere.radius = 0.7071067811865476;\r\n\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\r\n\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar center = sphere.center;\r\n\t\tvar negRadius = - sphere.radius;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tintersectsBox: function () {\r\n\r\n\t\tvar p = new Vector3();\r\n\r\n\t\treturn function intersectsBox( box ) {\r\n\r\n\t\t\tvar planes = this.planes;\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tvar plane = planes[ i ];\r\n\r\n\t\t\t\t// corner at max distance\r\n\r\n\t\t\t\tp.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\tp.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\tp.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\r\n\t\t\t\tif ( plane.distanceToPoint( p ) < 0 ) {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar RenderableObject = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.object = null;\r\n\tthis.z = 0;\r\n\tthis.renderOrder = 0;\r\n\r\n};\r\n\r\n//\r\n\r\nvar RenderableFace = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.v1 = new RenderableVertex();\r\n\tthis.v2 = new RenderableVertex();\r\n\tthis.v3 = new RenderableVertex();\r\n\r\n\tthis.normalModel = new Vector3();\r\n\r\n\tthis.vertexNormalsModel = [ new Vector3(), new Vector3(), new Vector3() ];\r\n\tthis.vertexNormalsLength = 0;\r\n\r\n\tthis.color = new Color();\r\n\tthis.material = null;\r\n\tthis.uvs = [ new Vector2(), new Vector2(), new Vector2() ];\r\n\r\n\tthis.z = 0;\r\n\tthis.renderOrder = 0;\r\n\r\n};\r\n\r\n//\r\n\r\nvar RenderableVertex = function () {\r\n\r\n\tthis.position = new Vector3();\r\n\tthis.positionWorld = new Vector3();\r\n\tthis.positionScreen = new Vector4();\r\n\r\n\tthis.visible = true;\r\n\r\n};\r\n\r\nRenderableVertex.prototype.copy = function ( vertex ) {\r\n\r\n\tthis.positionWorld.copy( vertex.positionWorld );\r\n\tthis.positionScreen.copy( vertex.positionScreen );\r\n\r\n};\r\n\r\n//\r\n\r\nvar RenderableLine = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.v1 = new RenderableVertex();\r\n\tthis.v2 = new RenderableVertex();\r\n\r\n\tthis.vertexColors = [ new Color(), new Color() ];\r\n\tthis.material = null;\r\n\r\n\tthis.z = 0;\r\n\tthis.renderOrder = 0;\r\n\r\n};\r\n\r\n//\r\n\r\nvar RenderableSprite = function () {\r\n\r\n\tthis.id = 0;\r\n\r\n\tthis.object = null;\r\n\r\n\tthis.x = 0;\r\n\tthis.y = 0;\r\n\tthis.z = 0;\r\n\r\n\tthis.rotation = 0;\r\n\tthis.scale = new Vector2();\r\n\r\n\tthis.material = null;\r\n\tthis.renderOrder = 0;\r\n\r\n};\r\n\r\n//\r\n\r\nvar Projector = function () {\r\n\r\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\r\n\t\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\r\n\t\t_face, _faceCount, _facePool = [], _facePoolLength = 0,\r\n\t\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\r\n\t\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\r\n\r\n\t\t_renderData = { objects: [], lights: [], elements: [] },\r\n\r\n\t\t_vector3 = new Vector3(),\r\n\t\t_vector4 = new Vector4(),\r\n\r\n\t\t_clipBox = new Box3( new Vector3( - 1, - 1, - 1 ), new Vector3( 1, 1, 1 ) ),\r\n\t\t_boundingBox = new Box3(),\r\n\t\t_points3 = new Array( 3 ),\r\n\r\n\t\t_viewMatrix = new Matrix4(),\r\n\t\t_viewProjectionMatrix = new Matrix4(),\r\n\r\n\t\t_modelMatrix,\r\n\t\t_modelViewProjectionMatrix = new Matrix4(),\r\n\r\n\t\t_normalMatrix = new Matrix3(),\r\n\r\n\t\t_frustum = new Frustum(),\r\n\r\n\t\t_clippedVertex1PositionScreen = new Vector4(),\r\n\t\t_clippedVertex2PositionScreen = new Vector4();\r\n\r\n\t//\r\n\r\n\tthis.projectVector = function ( vector, camera ) {\r\n\r\n\t\tconsole.warn( 'Projector: .projectVector() is now vector.project().' );\r\n\t\tvector.project( camera );\r\n\r\n\t};\r\n\r\n\tthis.unprojectVector = function ( vector, camera ) {\r\n\r\n\t\tconsole.warn( 'Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\tvector.unproject( camera );\r\n\r\n\t};\r\n\r\n\tthis.pickingRay = function () {\r\n\r\n\t\tconsole.error( 'Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tvar RenderList = function () {\r\n\r\n\t\tvar normals = [];\r\n\t\tvar colors = [];\r\n\t\tvar uvs = [];\r\n\r\n\t\tvar object = null;\r\n\t\tvar material = null;\r\n\r\n\t\tvar normalMatrix = new Matrix3();\r\n\r\n\t\tfunction setObject( value ) {\r\n\r\n\t\t\tobject = value;\r\n\t\t\tmaterial = object.material;\r\n\r\n\t\t\tnormalMatrix.getNormalMatrix( object.matrixWorld );\r\n\r\n\t\t\tnormals.length = 0;\r\n\t\t\tcolors.length = 0;\r\n\t\t\tuvs.length = 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction projectVertex( vertex ) {\r\n\r\n\t\t\tvar position = vertex.position;\r\n\t\t\tvar positionWorld = vertex.positionWorld;\r\n\t\t\tvar positionScreen = vertex.positionScreen;\r\n\r\n\t\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\r\n\t\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\tvar invW = 1 / positionScreen.w;\r\n\r\n\t\t\tpositionScreen.x *= invW;\r\n\t\t\tpositionScreen.y *= invW;\r\n\t\t\tpositionScreen.z *= invW;\r\n\r\n\t\t\tvertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&\r\n\t\t\t\t\t positionScreen.y >= - 1 && positionScreen.y <= 1 &&\r\n\t\t\t\t\t positionScreen.z >= - 1 && positionScreen.z <= 1;\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushVertex( x, y, z ) {\r\n\r\n\t\t\t_vertex = getNextVertexInPool();\r\n\t\t\t_vertex.position.set( x, y, z );\r\n\r\n\t\t\tprojectVertex( _vertex );\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushNormal( x, y, z ) {\r\n\r\n\t\t\tnormals.push( x, y, z );\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushColor( r, g, b ) {\r\n\r\n\t\t\tcolors.push( r, g, b );\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushUv( x, y ) {\r\n\r\n\t\t\tuvs.push( x, y );\r\n\r\n\t\t}\r\n\r\n\t\tfunction checkTriangleVisibility( v1, v2, v3 ) {\r\n\r\n\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ) { return true; }\r\n\r\n\t\t\t_points3[ 0 ] = v1.positionScreen;\r\n\t\t\t_points3[ 1 ] = v2.positionScreen;\r\n\t\t\t_points3[ 2 ] = v3.positionScreen;\r\n\r\n\t\t\treturn _clipBox.intersectsBox( _boundingBox.setFromPoints( _points3 ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction checkBackfaceCulling( v1, v2, v3 ) {\r\n\r\n\t\t\treturn ( ( v3.positionScreen.x - v1.positionScreen.x ) *\r\n\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\r\n\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\r\n\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushLine( a, b ) {\r\n\r\n\t\t\tvar v1 = _vertexPool[ a ];\r\n\t\t\tvar v2 = _vertexPool[ b ];\r\n\r\n\t\t\t// Clip\r\n\r\n\t\t\tv1.positionScreen.copy( v1.position ).applyMatrix4( _modelViewProjectionMatrix );\r\n\t\t\tv2.positionScreen.copy( v2.position ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\tif ( clipLine( v1.positionScreen, v2.positionScreen ) === true ) {\r\n\r\n\t\t\t\t// Perform the perspective divide\r\n\t\t\t\tv1.positionScreen.multiplyScalar( 1 / v1.positionScreen.w );\r\n\t\t\t\tv2.positionScreen.multiplyScalar( 1 / v2.positionScreen.w );\r\n\r\n\t\t\t\t_line = getNextLineInPool();\r\n\t\t\t\t_line.id = object.id;\r\n\t\t\t\t_line.v1.copy( v1 );\r\n\t\t\t\t_line.v2.copy( v2 );\r\n\t\t\t\t_line.z = Math.max( v1.positionScreen.z, v2.positionScreen.z );\r\n\t\t\t\t_line.renderOrder = object.renderOrder;\r\n\r\n\t\t\t\t_line.material = object.material;\r\n\r\n\t\t\t\tif ( object.material.vertexColors === VertexColors ) {\r\n\r\n\t\t\t\t\t_line.vertexColors[ 0 ].fromArray( colors, a * 3 );\r\n\t\t\t\t\t_line.vertexColors[ 1 ].fromArray( colors, b * 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_renderData.elements.push( _line );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushTriangle( a, b, c, material ) {\n\t\t\tvar arguments$1 = arguments;\n\r\n\r\n\t\t\tvar v1 = _vertexPool[ a ];\r\n\t\t\tvar v2 = _vertexPool[ b ];\r\n\t\t\tvar v3 = _vertexPool[ c ];\r\n\r\n\t\t\tif ( checkTriangleVisibility( v1, v2, v3 ) === false ) { return; }\r\n\r\n\t\t\tif ( material.side === DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {\r\n\r\n\t\t\t\t_face = getNextFaceInPool();\r\n\r\n\t\t\t\t_face.id = object.id;\r\n\t\t\t\t_face.v1.copy( v1 );\r\n\t\t\t\t_face.v2.copy( v2 );\r\n\t\t\t\t_face.v3.copy( v3 );\r\n\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\r\n\t\t\t\t_face.renderOrder = object.renderOrder;\r\n\r\n\t\t\t\t// face normal\r\n\t\t\t\t_vector3.subVectors( v3.position, v2.position );\r\n\t\t\t\t_vector4.subVectors( v1.position, v2.position );\r\n\t\t\t\t_vector3.cross( _vector4 );\r\n\t\t\t\t_face.normalModel.copy( _vector3 );\r\n\t\t\t\t_face.normalModel.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\tfor ( var i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tvar normal = _face.vertexNormalsModel[ i ];\r\n\t\t\t\t\tnormal.fromArray( normals, arguments$1[ i ] * 3 );\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t\tvar uv = _face.uvs[ i ];\r\n\t\t\t\t\tuv.fromArray( uvs, arguments$1[ i ] * 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_face.vertexNormalsLength = 3;\r\n\r\n\t\t\t\t_face.material = material;\r\n\r\n\t\t\t\tif ( material.vertexColors === FaceColors ) {\r\n\r\n\t\t\t\t\t_face.color.fromArray( colors, a * 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_renderData.elements.push( _face );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tsetObject: setObject,\r\n\t\t\tprojectVertex: projectVertex,\r\n\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\r\n\t\t\tcheckBackfaceCulling: checkBackfaceCulling,\r\n\t\t\tpushVertex: pushVertex,\r\n\t\t\tpushNormal: pushNormal,\r\n\t\t\tpushColor: pushColor,\r\n\t\t\tpushUv: pushUv,\r\n\t\t\tpushLine: pushLine,\r\n\t\t\tpushTriangle: pushTriangle\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tvar renderList = new RenderList();\r\n\r\n\tfunction projectObject( object ) {\r\n\r\n\t\tif ( object.visible === false ) { return; }\r\n\r\n\t\tif ( object instanceof Light ) {\r\n\r\n\t\t\t_renderData.lights.push( object );\r\n\r\n\t\t} else if ( object instanceof Mesh || object instanceof Line || object instanceof Points ) {\r\n\r\n\t\t\tif ( object.material.visible === false ) { return; }\r\n\t\t\tif ( object.frustumCulled === true && _frustum.intersectsObject( object ) === false ) { return; }\r\n\r\n\t\t\taddObject( object );\r\n\r\n\t\t} else if ( object instanceof Sprite ) {\r\n\r\n\t\t\tif ( object.material.visible === false ) { return; }\r\n\t\t\tif ( object.frustumCulled === true && _frustum.intersectsSprite( object ) === false ) { return; }\r\n\r\n\t\t\taddObject( object );\r\n\r\n\t\t}\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( children[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction addObject( object ) {\r\n\r\n\t\t_object = getNextObjectInPool();\r\n\t\t_object.id = object.id;\r\n\t\t_object.object = object;\r\n\r\n\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t_vector3.applyMatrix4( _viewProjectionMatrix );\r\n\t\t_object.z = _vector3.z;\r\n\t\t_object.renderOrder = object.renderOrder;\r\n\r\n\t\t_renderData.objects.push( _object );\r\n\r\n\t}\r\n\r\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\r\n\r\n\t\t_faceCount = 0;\r\n\t\t_lineCount = 0;\r\n\t\t_spriteCount = 0;\r\n\r\n\t\t_renderData.elements.length = 0;\r\n\r\n\t\tif ( scene.autoUpdate === true ) { scene.updateMatrixWorld(); }\r\n\t\tif ( camera.parent === null ) { camera.updateMatrixWorld(); }\r\n\r\n\t\t_viewMatrix.copy( camera.matrixWorldInverse );\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\r\n\r\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\r\n\r\n\t\t//\r\n\r\n\t\t_objectCount = 0;\r\n\r\n\t\t_renderData.objects.length = 0;\r\n\t\t_renderData.lights.length = 0;\r\n\r\n\t\tprojectObject( scene );\r\n\r\n\t\tif ( sortObjects === true ) {\r\n\r\n\t\t\t_renderData.objects.sort( painterSort );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar objects = _renderData.objects;\r\n\r\n\t\tfor ( var o = 0, ol = objects.length; o < ol; o ++ ) {\r\n\r\n\t\t\tvar object = objects[ o ].object;\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\trenderList.setObject( object );\r\n\r\n\t\t\t_modelMatrix = object.matrixWorld;\r\n\r\n\t\t\t_vertexCount = 0;\r\n\r\n\t\t\tif ( object instanceof Mesh ) {\r\n\r\n\t\t\t\tif ( geometry instanceof BufferGeometry ) {\r\n\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tvar isMultiMaterial = Array.isArray( material );\r\n\r\n\t\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\t\tvar groups = geometry.groups;\r\n\r\n\t\t\t\t\tif ( attributes.position === undefined ) { continue; }\r\n\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\tvar x = positions[ i ];\r\n\t\t\t\t\t\tvar y = positions[ i + 1 ];\r\n\t\t\t\t\t\tvar z = positions[ i + 2 ];\r\n\r\n\t\t\t\t\t\tif ( material.morphTargets === true ) {\r\n\r\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphAttributes.position;\r\n\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\r\n\r\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\t\t\tif ( influence === 0 ) { continue; }\r\n\r\n\t\t\t\t\t\t\t\tvar target = morphTargets[ t ];\r\n\r\n\t\t\t\t\t\t\t\tx += ( target.getX( i / 3 ) - positions[ i ] ) * influence;\r\n\t\t\t\t\t\t\t\ty += ( target.getY( i / 3 ) - positions[ i + 1 ] ) * influence;\r\n\t\t\t\t\t\t\t\tz += ( target.getZ( i / 3 ) - positions[ i + 2 ] ) * influence;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\trenderList.pushVertex( x, y, z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes.normal !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\trenderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes.color !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar colors = attributes.color.array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\trenderList.pushColor( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar uvs = attributes.uv.array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = uvs.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\t\t\t\trenderList.pushUv( uvs[ i ], uvs[ i + 1 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t\t\t\tvar indices = geometry.index.array;\r\n\r\n\t\t\t\t\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var g = 0; g < groups.length; g ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar group = groups[ g ];\r\n\r\n\t\t\t\t\t\t\t\tmaterial = isMultiMaterial === true\r\n\t\t\t\t\t\t\t\t\t ? object.material[ group.materialIndex ]\r\n\t\t\t\t\t\t\t\t\t : object.material;\r\n\r\n\t\t\t\t\t\t\t\tif ( material === undefined ) { continue; }\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i = group.start, l = group.start + group.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ], material );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ], material );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var g = 0; g < groups.length; g ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar group = groups[ g ];\r\n\r\n\t\t\t\t\t\t\t\tmaterial = isMultiMaterial === true\r\n\t\t\t\t\t\t\t\t\t ? object.material[ group.materialIndex ]\r\n\t\t\t\t\t\t\t\t\t : object.material;\r\n\r\n\t\t\t\t\t\t\t\tif ( material === undefined ) { continue; }\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i = group.start, l = group.start + group.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2, material );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushTriangle( i, i + 1, i + 2, material );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry instanceof Geometry ) {\r\n\r\n\t\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\r\n\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tvar isMultiMaterial = Array.isArray( material );\r\n\r\n\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\t\tvar vertex = vertices[ v ];\r\n\r\n\t\t\t\t\t\t_vector3.copy( vertex );\r\n\r\n\t\t\t\t\t\tif ( material.morphTargets === true ) {\r\n\r\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\r\n\r\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\t\t\tif ( influence === 0 ) { continue; }\r\n\r\n\t\t\t\t\t\t\t\tvar target = morphTargets[ t ];\r\n\t\t\t\t\t\t\t\tvar targetVertex = target.vertices[ v ];\r\n\r\n\t\t\t\t\t\t\t\t_vector3.x += ( targetVertex.x - vertex.x ) * influence;\r\n\t\t\t\t\t\t\t\t_vector3.y += ( targetVertex.y - vertex.y ) * influence;\r\n\t\t\t\t\t\t\t\t_vector3.z += ( targetVertex.z - vertex.z ) * influence;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\trenderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\tvar face = faces[ f ];\r\n\r\n\t\t\t\t\t\tmaterial = isMultiMaterial === true\r\n\t\t\t\t\t\t\t ? object.material[ face.materialIndex ]\r\n\t\t\t\t\t\t\t : object.material;\r\n\r\n\t\t\t\t\t\tif ( material === undefined ) { continue; }\r\n\r\n\t\t\t\t\t\tvar side = material.side;\r\n\r\n\t\t\t\t\t\tvar v1 = _vertexPool[ face.a ];\r\n\t\t\t\t\t\tvar v2 = _vertexPool[ face.b ];\r\n\t\t\t\t\t\tvar v3 = _vertexPool[ face.c ];\r\n\r\n\t\t\t\t\t\tif ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) { continue; }\r\n\r\n\t\t\t\t\t\tvar visible = renderList.checkBackfaceCulling( v1, v2, v3 );\r\n\r\n\t\t\t\t\t\tif ( side !== DoubleSide ) {\r\n\r\n\t\t\t\t\t\t\tif ( side === FrontSide && visible === false ) { continue; }\r\n\t\t\t\t\t\t\tif ( side === BackSide && visible === true ) { continue; }\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face = getNextFaceInPool();\r\n\r\n\t\t\t\t\t\t_face.id = object.id;\r\n\t\t\t\t\t\t_face.v1.copy( v1 );\r\n\t\t\t\t\t\t_face.v2.copy( v2 );\r\n\t\t\t\t\t\t_face.v3.copy( v3 );\r\n\r\n\t\t\t\t\t\t_face.normalModel.copy( face.normal );\r\n\r\n\t\t\t\t\t\tif ( visible === false && ( side === BackSide || side === DoubleSide ) ) {\r\n\r\n\t\t\t\t\t\t\t_face.normalModel.negate();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\r\n\r\n\t\t\t\t\t\tvar faceVertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\r\n\t\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\r\n\r\n\t\t\t\t\t\t\tif ( visible === false && ( side === BackSide || side === DoubleSide ) ) {\r\n\r\n\t\t\t\t\t\t\t\tnormalModel.negate();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\r\n\r\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[ f ];\r\n\r\n\t\t\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var u = 0; u < 3; u ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t_face.uvs[ u ].copy( vertexUvs[ u ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_face.color = face.color;\r\n\t\t\t\t\t\t_face.material = material;\r\n\r\n\t\t\t\t\t\t_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;\r\n\t\t\t\t\t\t_face.renderOrder = object.renderOrder;\r\n\r\n\t\t\t\t\t\t_renderData.elements.push( _face );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof Line ) {\r\n\r\n\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\r\n\r\n\t\t\t\tif ( geometry instanceof BufferGeometry ) {\r\n\r\n\t\t\t\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t\t\t\tif ( attributes.position !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\trenderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( attributes.color !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tvar colors = attributes.color.array;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushColor( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t\t\t\t\tvar indices = geometry.index.array;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushLine( indices[ i ], indices[ i + 1 ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar step = object instanceof LineSegments ? 2 : 1;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\t\t\t\trenderList.pushLine( i, i + 1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry instanceof Geometry ) {\r\n\r\n\t\t\t\t\tvar vertices = object.geometry.vertices;\r\n\r\n\t\t\t\t\tif ( vertices.length === 0 ) { continue; }\r\n\r\n\t\t\t\t\tv1 = getNextVertexInPool();\r\n\t\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t\tvar step = object instanceof LineSegments ? 2 : 1;\r\n\r\n\t\t\t\t\tfor ( var v = 1, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\t\tv1 = getNextVertexInPool();\r\n\t\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) { continue; }\r\n\r\n\t\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\r\n\r\n\t\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\r\n\t\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\r\n\r\n\t\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\r\n\r\n\t\t\t\t\t\t\t// Perform the perspective divide\r\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\r\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\r\n\r\n\t\t\t\t\t\t\t_line = getNextLineInPool();\r\n\r\n\t\t\t\t\t\t\t_line.id = object.id;\r\n\t\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\r\n\t\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\r\n\r\n\t\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\r\n\t\t\t\t\t\t\t_line.renderOrder = object.renderOrder;\r\n\r\n\t\t\t\t\t\t\t_line.material = object.material;\r\n\r\n\t\t\t\t\t\t\tif ( object.material.vertexColors === VertexColors ) {\r\n\r\n\t\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\r\n\t\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t_renderData.elements.push( _line );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof Points ) {\r\n\r\n\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\r\n\r\n\t\t\t\tif ( geometry instanceof Geometry ) {\r\n\r\n\t\t\t\t\tvar vertices = object.geometry.vertices;\r\n\r\n\t\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\t\tvar vertex = vertices[ v ];\r\n\r\n\t\t\t\t\t\t_vector4.set( vertex.x, vertex.y, vertex.z, 1 );\r\n\t\t\t\t\t\t_vector4.applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t\t\tpushPoint( _vector4, object, camera );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry instanceof BufferGeometry ) {\r\n\r\n\t\t\t\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t\t\t\tif ( attributes.position !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t_vector4.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ], 1 );\r\n\t\t\t\t\t\t\t_vector4.applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t\t\t\tpushPoint( _vector4, object, camera );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof Sprite ) {\r\n\r\n\t\t\t\t_vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );\r\n\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\t\tpushPoint( _vector4, object, camera );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( sortElements === true ) {\r\n\r\n\t\t\t_renderData.elements.sort( painterSort );\r\n\r\n\t\t}\r\n\r\n\t\treturn _renderData;\r\n\r\n\t};\r\n\r\n\tfunction pushPoint( _vector4, object, camera ) {\r\n\r\n\t\tvar invW = 1 / _vector4.w;\r\n\r\n\t\t_vector4.z *= invW;\r\n\r\n\t\tif ( _vector4.z >= - 1 && _vector4.z <= 1 ) {\r\n\r\n\t\t\t_sprite = getNextSpriteInPool();\r\n\t\t\t_sprite.id = object.id;\r\n\t\t\t_sprite.x = _vector4.x * invW;\r\n\t\t\t_sprite.y = _vector4.y * invW;\r\n\t\t\t_sprite.z = _vector4.z;\r\n\t\t\t_sprite.renderOrder = object.renderOrder;\r\n\t\t\t_sprite.object = object;\r\n\r\n\t\t\t_sprite.rotation = object.rotation;\r\n\r\n\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );\r\n\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );\r\n\r\n\t\t\t_sprite.material = object.material;\r\n\r\n\t\t\t_renderData.elements.push( _sprite );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Pools\r\n\r\n\tfunction getNextObjectInPool() {\r\n\r\n\t\tif ( _objectCount === _objectPoolLength ) {\r\n\r\n\t\t\tvar object = new RenderableObject();\r\n\t\t\t_objectPool.push( object );\r\n\t\t\t_objectPoolLength ++;\r\n\t\t\t_objectCount ++;\r\n\t\t\treturn object;\r\n\r\n\t\t}\r\n\r\n\t\treturn _objectPool[ _objectCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextVertexInPool() {\r\n\r\n\t\tif ( _vertexCount === _vertexPoolLength ) {\r\n\r\n\t\t\tvar vertex = new RenderableVertex();\r\n\t\t\t_vertexPool.push( vertex );\r\n\t\t\t_vertexPoolLength ++;\r\n\t\t\t_vertexCount ++;\r\n\t\t\treturn vertex;\r\n\r\n\t\t}\r\n\r\n\t\treturn _vertexPool[ _vertexCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextFaceInPool() {\r\n\r\n\t\tif ( _faceCount === _facePoolLength ) {\r\n\r\n\t\t\tvar face = new RenderableFace();\r\n\t\t\t_facePool.push( face );\r\n\t\t\t_facePoolLength ++;\r\n\t\t\t_faceCount ++;\r\n\t\t\treturn face;\r\n\r\n\t\t}\r\n\r\n\t\treturn _facePool[ _faceCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextLineInPool() {\r\n\r\n\t\tif ( _lineCount === _linePoolLength ) {\r\n\r\n\t\t\tvar line = new RenderableLine();\r\n\t\t\t_linePool.push( line );\r\n\t\t\t_linePoolLength ++;\r\n\t\t\t_lineCount ++;\r\n\t\t\treturn line;\r\n\r\n\t\t}\r\n\r\n\t\treturn _linePool[ _lineCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextSpriteInPool() {\r\n\r\n\t\tif ( _spriteCount === _spritePoolLength ) {\r\n\r\n\t\t\tvar sprite = new RenderableSprite();\r\n\t\t\t_spritePool.push( sprite );\r\n\t\t\t_spritePoolLength ++;\r\n\t\t\t_spriteCount ++;\r\n\t\t\treturn sprite;\r\n\r\n\t\t}\r\n\r\n\t\treturn _spritePool[ _spriteCount ++ ];\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction painterSort( a, b ) {\r\n\r\n\t\tif ( a.renderOrder !== b.renderOrder ) {\r\n\r\n\t\t\treturn a.renderOrder - b.renderOrder;\r\n\r\n\t\t} else if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else if ( a.id !== b.id ) {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction clipLine( s1, s2 ) {\r\n\r\n\t\tvar alpha1 = 0, alpha2 = 1,\r\n\r\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\r\n\t\t// Z = -1 and Z = +1, respectively.\r\n\r\n\t\t\tbc1near = s1.z + s1.w,\r\n\t\t\tbc2near = s2.z + s2.w,\r\n\t\t\tbc1far = - s1.z + s1.w,\r\n\t\t\tbc2far = - s2.z + s2.w;\r\n\r\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\r\n\r\n\t\t\t// Both vertices lie entirely within all clip planes.\r\n\t\t\treturn true;\r\n\r\n\t\t} else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {\r\n\r\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\r\n\t\t\treturn false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// The line segment spans at least one clip plane.\r\n\r\n\t\t\tif ( bc1near < 0 ) {\r\n\r\n\t\t\t\t// v1 lies outside the near plane, v2 inside\r\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\r\n\r\n\t\t\t} else if ( bc2near < 0 ) {\r\n\r\n\t\t\t\t// v2 lies outside the near plane, v1 inside\r\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( bc1far < 0 ) {\r\n\r\n\t\t\t\t// v1 lies outside the far plane, v2 inside\r\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\r\n\r\n\t\t\t} else if ( bc2far < 0 ) {\r\n\r\n\t\t\t\t// v2 lies outside the far plane, v2 inside\r\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( alpha2 < alpha1 ) {\r\n\r\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\r\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\r\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\r\n\t\t\t\ts1.lerp( s2, alpha1 );\r\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SpriteCanvasMaterial = function ( parameters ) {\r\n\r\n\tMaterial.call( this );\r\n\r\n\tthis.type = 'SpriteCanvasMaterial';\r\n\r\n\tthis.color = new Color( 0xffffff );\r\n\tthis.program = function () {};\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nSpriteCanvasMaterial.prototype = Object.create( Material.prototype );\r\nSpriteCanvasMaterial.prototype.constructor = SpriteCanvasMaterial;\r\nSpriteCanvasMaterial.prototype.isSpriteCanvasMaterial = true;\r\n\r\nSpriteCanvasMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new SpriteCanvasMaterial();\r\n\r\n\tmaterial.copy( this );\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.program = this.program;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n//\r\n\r\nvar CanvasRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'CanvasRenderer', REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _this = this,\r\n\t\t_renderData, _elements, _lights,\r\n\t\t_projector = new Projector(),\r\n\r\n\t\t_canvas = parameters.canvas !== undefined\r\n\t\t\t\t ? parameters.canvas\r\n\t\t\t\t : document.createElement( 'canvas' ),\r\n\r\n\t\t_canvasWidth = _canvas.width,\r\n\t\t_canvasHeight = _canvas.height,\r\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),\r\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),\r\n\r\n\t\t_viewportX = 0,\r\n\t\t_viewportY = 0,\r\n\t\t_viewportWidth = _canvasWidth,\r\n\t\t_viewportHeight = _canvasHeight,\r\n\r\n\t\t_pixelRatio = 1,\r\n\r\n\t\t_context = _canvas.getContext( '2d', {\r\n\t\t\talpha: parameters.alpha === true\r\n\t\t} ),\r\n\r\n\t\t_clearColor = new Color( 0x000000 ),\r\n\t\t_clearAlpha = parameters.alpha === true ? 0 : 1,\r\n\r\n\t\t_contextGlobalAlpha = 1,\r\n\t\t_contextGlobalCompositeOperation = 0,\r\n\t\t_contextStrokeStyle = null,\r\n\t\t_contextFillStyle = null,\r\n\t\t_contextLineWidth = null,\r\n\t\t_contextLineCap = null,\r\n\t\t_contextLineJoin = null,\r\n\t\t_contextLineDash = [],\r\n\r\n\t\t_v1, _v2, _v3,\r\n\r\n\t\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\r\n\r\n\t\t_color = new Color(),\r\n\r\n\t\t_diffuseColor = new Color(),\r\n\t\t_emissiveColor = new Color(),\r\n\r\n\t\t_lightColor = new Color(),\r\n\r\n\t\t_patterns = {},\r\n\r\n\t\t_uvs,\r\n\t\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\r\n\r\n\t\t_clipBox = new Box2(),\r\n\t\t_clearBox = new Box2(),\r\n\t\t_elemBox = new Box2(),\r\n\r\n\t\t_ambientLight = new Color(),\r\n\t\t_directionalLights = new Color(),\r\n\t\t_pointLights = new Color(),\r\n\r\n\t\t_vector3 = new Vector3(), // Needed for PointLight\r\n\t\t_centroid = new Vector3(),\r\n\t\t_normal = new Vector3(),\r\n\t\t_normalViewMatrix = new Matrix3();\r\n\r\n\t// dash+gap fallbacks for Firefox and everything else\r\n\r\n\tif ( _context.setLineDash === undefined ) {\r\n\r\n\t\t_context.setLineDash = function () {};\r\n\r\n\t}\r\n\r\n\tthis.domElement = _canvas;\r\n\r\n\tthis.autoClear = true;\r\n\tthis.sortObjects = true;\r\n\tthis.sortElements = true;\r\n\r\n\tthis.info = {\r\n\r\n\t\trender: {\r\n\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _context;\r\n\r\n\t};\r\n\r\n\tthis.getContextAttributes = function () {\r\n\r\n\t\treturn _context.getContextAttributes();\r\n\r\n\t};\r\n\r\n\tthis.getPixelRatio = function () {\r\n\r\n\t\treturn _pixelRatio;\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function ( value ) {\r\n\r\n\t\tif ( value !== undefined ) { _pixelRatio = value; }\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\t_canvasWidth = width * _pixelRatio;\r\n\t\t_canvasHeight = height * _pixelRatio;\r\n\r\n\t\t_canvas.width = _canvasWidth;\r\n\t\t_canvas.height = _canvasHeight;\r\n\r\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\r\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\r\n\r\n\t\tif ( updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\t_clipBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\r\n\t\t_clipBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\r\n\r\n\t\t_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\r\n\t\t_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\r\n\r\n\t\t_contextGlobalAlpha = 1;\r\n\t\t_contextGlobalCompositeOperation = 0;\r\n\t\t_contextStrokeStyle = null;\r\n\t\t_contextFillStyle = null;\r\n\t\t_contextLineWidth = null;\r\n\t\t_contextLineCap = null;\r\n\t\t_contextLineJoin = null;\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\t_viewportX = x * _pixelRatio;\r\n\t\t_viewportY = y * _pixelRatio;\r\n\r\n\t\t_viewportWidth = width * _pixelRatio;\r\n\t\t_viewportHeight = height * _pixelRatio;\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function () {};\r\n\tthis.setScissorTest = function () {};\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.set( color );\r\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n\t\t_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );\r\n\t\t_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );\r\n\r\n\t};\r\n\r\n\tthis.setClearColorHex = function ( hex, alpha ) {\r\n\r\n\t\tconsole.warn( 'CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\r\n\t\tthis.setClearColor( hex, alpha );\r\n\r\n\t};\r\n\r\n\tthis.getClearColor = function () {\r\n\r\n\t\treturn _clearColor;\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn _clearAlpha;\r\n\r\n\t};\r\n\r\n\tthis.getMaxAnisotropy = function () {\r\n\r\n\t\treturn 0;\r\n\r\n\t};\r\n\r\n\tthis.clear = function () {\r\n\r\n\t\tif ( _clearBox.isEmpty() === false ) {\r\n\r\n\t\t\t_clearBox.intersect( _clipBox );\r\n\t\t\t_clearBox.expandByScalar( 2 );\r\n\r\n\t\t\t_clearBox.min.x =   _clearBox.min.x + _canvasWidthHalf;\r\n\t\t\t_clearBox.min.y = - _clearBox.min.y + _canvasHeightHalf;\t\t// higher y value !\r\n\t\t\t_clearBox.max.x =   _clearBox.max.x + _canvasWidthHalf;\r\n\t\t\t_clearBox.max.y = - _clearBox.max.y + _canvasHeightHalf;\t\t// lower y value !\r\n\r\n\t\t\tif ( _clearAlpha < 1 ) {\r\n\r\n\t\t\t\t_context.clearRect(\r\n\t\t\t\t\t_clearBox.min.x | 0,\r\n\t\t\t\t\t_clearBox.max.y | 0,\r\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\r\n\t\t\t\t\t( _clearBox.min.y - _clearBox.max.y ) | 0\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _clearAlpha > 0 ) {\r\n\r\n\t\t\t\tsetOpacity( 1 );\r\n\t\t\t\tsetBlending( NormalBlending );\r\n\r\n\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );\r\n\r\n\t\t\t\t_context.fillRect(\r\n\t\t\t\t\t_clearBox.min.x | 0,\r\n\t\t\t\t\t_clearBox.max.y | 0,\r\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\r\n\t\t\t\t\t( _clearBox.min.y - _clearBox.max.y ) | 0\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_clearBox.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// compatibility\r\n\r\n\tthis.clearColor = function () {};\r\n\tthis.clearDepth = function () {};\r\n\tthis.clearStencil = function () {};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( camera.isCamera === undefined ) {\r\n\r\n\t\t\tconsole.error( 'CanvasRenderer.render: camera is not an instance of Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar background = scene.background;\r\n\r\n\t\tif ( background && background.isColor ) {\r\n\r\n\t\t\tsetOpacity( 1 );\r\n\t\t\tsetBlending( NormalBlending );\r\n\r\n\t\t\tsetFillStyle( background.getStyle() );\r\n\t\t\t_context.fillRect( 0, 0, _canvasWidth, _canvasHeight );\r\n\r\n\t\t} else if ( this.autoClear === true ) {\r\n\r\n\t\t\tthis.clear();\r\n\r\n\t\t}\r\n\r\n\t\t_this.info.render.vertices = 0;\r\n\t\t_this.info.render.faces = 0;\r\n\r\n\t\t_context.setTransform( _viewportWidth / _canvasWidth, 0, 0, - _viewportHeight / _canvasHeight, _viewportX, _canvasHeight - _viewportY );\r\n\t\t_context.translate( _canvasWidthHalf, _canvasHeightHalf );\r\n\r\n\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\r\n\t\t_elements = _renderData.elements;\r\n\t\t_lights = _renderData.lights;\r\n\r\n\t\t_normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );\r\n\r\n\t\tcalculateLights();\r\n\r\n\t\tfor ( var e = 0, el = _elements.length; e < el; e ++ ) {\r\n\r\n\t\t\tvar element = _elements[ e ];\r\n\r\n\t\t\tvar material = element.material;\r\n\r\n\t\t\tif ( material === undefined || material.opacity === 0 ) { continue; }\r\n\r\n\t\t\t_elemBox.makeEmpty();\r\n\r\n\t\t\tif ( element instanceof RenderableSprite ) {\r\n\r\n\t\t\t\t_v1 = element;\r\n\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\trenderSprite( _v1, element, material );\r\n\r\n\t\t\t} else if ( element instanceof RenderableLine ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2;\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [\r\n\t\t\t\t\t_v1.positionScreen,\r\n\t\t\t\t\t_v2.positionScreen\r\n\t\t\t\t] );\r\n\r\n\t\t\t\tif ( _clipBox.intersectsBox( _elemBox ) === true ) {\r\n\r\n\t\t\t\t\trenderLine( _v1, _v2, element, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( element instanceof RenderableFace ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\r\n\r\n\t\t\t\tif ( _v1.positionScreen.z < - 1 || _v1.positionScreen.z > 1 ) { continue; }\r\n\t\t\t\tif ( _v2.positionScreen.z < - 1 || _v2.positionScreen.z > 1 ) { continue; }\r\n\t\t\t\tif ( _v3.positionScreen.z < - 1 || _v3.positionScreen.z > 1 ) { continue; }\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\tif ( material.overdraw > 0 ) {\r\n\r\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen, material.overdraw );\r\n\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen, material.overdraw );\r\n\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen, material.overdraw );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [\r\n\t\t\t\t\t_v1.positionScreen,\r\n\t\t\t\t\t_v2.positionScreen,\r\n\t\t\t\t\t_v3.positionScreen\r\n\t\t\t\t] );\r\n\r\n\t\t\t\tif ( _clipBox.intersectsBox( _elemBox ) === true ) {\r\n\r\n\t\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_clearBox.union( _elemBox );\r\n\r\n\t\t}\r\n\r\n\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction calculateLights() {\r\n\r\n\t\t_ambientLight.setRGB( 0, 0, 0 );\r\n\t\t_directionalLights.setRGB( 0, 0, 0 );\r\n\t\t_pointLights.setRGB( 0, 0, 0 );\r\n\r\n\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = _lights[ l ];\r\n\t\t\tvar lightColor = light.color;\r\n\r\n\t\t\tif ( light.isAmbientLight ) {\r\n\r\n\t\t\t\t_ambientLight.add( lightColor );\r\n\r\n\t\t\t} else if ( light.isDirectionalLight ) {\r\n\r\n\t\t\t\t// for sprites\r\n\r\n\t\t\t\t_directionalLights.add( lightColor );\r\n\r\n\t\t\t} else if ( light.isPointLight ) {\r\n\r\n\t\t\t\t// for sprites\r\n\r\n\t\t\t\t_pointLights.add( lightColor );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction calculateLight( position, normal, color ) {\r\n\r\n\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = _lights[ l ];\r\n\r\n\t\t\t_lightColor.copy( light.color );\r\n\r\n\t\t\tif ( light.isDirectionalLight ) {\r\n\r\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();\r\n\r\n\t\t\t\tvar amount = normal.dot( lightPosition );\r\n\r\n\t\t\t\tif ( amount <= 0 ) { continue; }\r\n\r\n\t\t\t\tamount *= light.intensity;\r\n\r\n\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\r\n\r\n\t\t\t} else if ( light.isPointLight ) {\r\n\r\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\r\n\r\n\t\t\t\tif ( amount <= 0 ) { continue; }\r\n\r\n\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\r\n\r\n\t\t\t\tif ( amount == 0 ) { continue; }\r\n\r\n\t\t\t\tamount *= light.intensity;\r\n\r\n\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderSprite( v1, element, material ) {\r\n\r\n\t\tsetOpacity( material.opacity );\r\n\t\tsetBlending( material.blending );\r\n\r\n\t\tvar scaleX = element.scale.x * _canvasWidthHalf;\r\n\t\tvar scaleY = element.scale.y * _canvasHeightHalf;\r\n\r\n\t\tvar dist = Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite\r\n\t\t_elemBox.min.set( v1.x - dist, v1.y - dist );\r\n\t\t_elemBox.max.set( v1.x + dist, v1.y + dist );\r\n\r\n\t\tif ( material.isSpriteMaterial ) {\r\n\r\n\t\t\tvar texture = material.map;\r\n\r\n\t\t\tif ( texture !== null ) {\r\n\r\n\t\t\t\tvar pattern = _patterns[ texture.id ];\r\n\r\n\t\t\t\tif ( pattern === undefined || pattern.version !== texture.version ) {\r\n\r\n\t\t\t\t\tpattern = textureToPattern( texture );\r\n\t\t\t\t\t_patterns[ texture.id ] = pattern;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( pattern.canvas !== undefined ) {\r\n\r\n\t\t\t\t\tsetFillStyle( pattern.canvas );\r\n\r\n\t\t\t\t\tvar bitmap = texture.image;\r\n\r\n\t\t\t\t\tvar ox = bitmap.width * texture.offset.x;\r\n\t\t\t\t\tvar oy = bitmap.height * texture.offset.y;\r\n\r\n\t\t\t\t\tvar sx = bitmap.width * texture.repeat.x;\r\n\t\t\t\t\tvar sy = bitmap.height * texture.repeat.y;\r\n\r\n\t\t\t\t\tvar cx = scaleX / sx;\r\n\t\t\t\t\tvar cy = scaleY / sy;\r\n\r\n\t\t\t\t\t_context.save();\r\n\t\t\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\t\t\tif ( material.rotation !== 0 ) { _context.rotate( material.rotation ); }\r\n\t\t\t\t\t_context.translate( - scaleX / 2, - scaleY / 2 );\r\n\t\t\t\t\t_context.scale( cx, cy );\r\n\t\t\t\t\t_context.translate( - ox, - oy );\r\n\t\t\t\t\t_context.fillRect( ox, oy, sx, sy );\r\n\t\t\t\t\t_context.restore();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// no texture\r\n\r\n\t\t\t\tsetFillStyle( material.color.getStyle() );\r\n\r\n\t\t\t\t_context.save();\r\n\t\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\t\tif ( material.rotation !== 0 ) { _context.rotate( material.rotation ); }\r\n\t\t\t\t_context.scale( scaleX, - scaleY );\r\n\t\t\t\t_context.fillRect( - 0.5, - 0.5, 1, 1 );\r\n\t\t\t\t_context.restore();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( material.isSpriteCanvasMaterial ) {\r\n\r\n\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\t\t\tsetFillStyle( material.color.getStyle() );\r\n\r\n\t\t\t_context.save();\r\n\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\tif ( material.rotation !== 0 ) { _context.rotate( material.rotation ); }\r\n\t\t\t_context.scale( scaleX, scaleY );\r\n\r\n\t\t\tmaterial.program( _context );\r\n\r\n\t\t\t_context.restore();\r\n\r\n\t\t} else if ( material.isPointsMaterial ) {\r\n\r\n\t\t\tsetFillStyle( material.color.getStyle() );\r\n\r\n\t\t\t_context.save();\r\n\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\tif ( material.rotation !== 0 ) { _context.rotate( material.rotation ); }\r\n\t\t\t_context.scale( scaleX * material.size, - scaleY * material.size );\r\n\t\t\t_context.fillRect( - 0.5, - 0.5, 1, 1 );\r\n\t\t\t_context.restore();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderLine( v1, v2, element, material ) {\r\n\r\n\t\tsetOpacity( material.opacity );\r\n\t\tsetBlending( material.blending );\r\n\r\n\t\t_context.beginPath();\r\n\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\r\n\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\r\n\r\n\t\tif ( material.isLineBasicMaterial ) {\r\n\r\n\t\t\tsetLineWidth( material.linewidth );\r\n\t\t\tsetLineCap( material.linecap );\r\n\t\t\tsetLineJoin( material.linejoin );\r\n\r\n\t\t\tif ( material.vertexColors !== VertexColors ) {\r\n\r\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar colorStyle1 = element.vertexColors[ 0 ].getStyle();\r\n\t\t\t\tvar colorStyle2 = element.vertexColors[ 1 ].getStyle();\r\n\r\n\t\t\t\tif ( colorStyle1 === colorStyle2 ) {\r\n\r\n\t\t\t\t\tsetStrokeStyle( colorStyle1 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttry {\r\n\r\n\t\t\t\t\t\tvar grad = _context.createLinearGradient(\r\n\t\t\t\t\t\t\tv1.positionScreen.x,\r\n\t\t\t\t\t\t\tv1.positionScreen.y,\r\n\t\t\t\t\t\t\tv2.positionScreen.x,\r\n\t\t\t\t\t\t\tv2.positionScreen.y\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tgrad.addColorStop( 0, colorStyle1 );\r\n\t\t\t\t\t\tgrad.addColorStop( 1, colorStyle2 );\r\n\r\n\t\t\t\t\t} catch ( exception ) {\r\n\r\n\t\t\t\t\t\tgrad = colorStyle1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsetStrokeStyle( grad );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.isLineDashedMaterial ) {\r\n\r\n\t\t\t\tsetLineDash( [ material.dashSize, material.gapSize ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_context.stroke();\r\n\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\r\n\r\n\t\t\tif ( material.isLineDashedMaterial ) {\r\n\r\n\t\t\t\tsetLineDash( [] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {\r\n\r\n\t\t_this.info.render.vertices += 3;\r\n\t\t_this.info.render.faces ++;\r\n\r\n\t\tsetOpacity( material.opacity );\r\n\t\tsetBlending( material.blending );\r\n\r\n\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\r\n\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\r\n\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\r\n\r\n\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\r\n\r\n\t\tif ( ( material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial ) && material.map === null ) {\r\n\r\n\t\t\t_diffuseColor.copy( material.color );\r\n\t\t\t_emissiveColor.copy( material.emissive );\r\n\r\n\t\t\tif ( material.vertexColors === FaceColors ) {\r\n\r\n\t\t\t\t_diffuseColor.multiply( element.color );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_color.copy( _ambientLight );\r\n\r\n\t\t\t_centroid.copy( v1.positionWorld ).add( v2.positionWorld ).add( v3.positionWorld ).divideScalar( 3 );\r\n\r\n\t\t\tcalculateLight( _centroid, element.normalModel, _color );\r\n\r\n\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\r\n\r\n\t\t\tmaterial.wireframe === true\r\n\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t : fillPath( _color );\r\n\r\n\t\t} else if ( material.isMeshBasicMaterial || material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial ) {\r\n\r\n\t\t\tif ( material.map !== null ) {\r\n\r\n\t\t\t\tvar mapping = material.map.mapping;\r\n\r\n\t\t\t\tif ( mapping === UVMapping ) {\r\n\r\n\t\t\t\t\t_uvs = element.uvs;\r\n\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material.envMap !== null ) {\r\n\r\n\t\t\t\tif ( material.envMap.mapping === SphericalReflectionMapping ) {\r\n\r\n\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv1 ] ).applyMatrix3( _normalViewMatrix );\r\n\t\t\t\t\t_uv1x = 0.5 * _normal.x + 0.5;\r\n\t\t\t\t\t_uv1y = 0.5 * _normal.y + 0.5;\r\n\r\n\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv2 ] ).applyMatrix3( _normalViewMatrix );\r\n\t\t\t\t\t_uv2x = 0.5 * _normal.x + 0.5;\r\n\t\t\t\t\t_uv2y = 0.5 * _normal.y + 0.5;\r\n\r\n\t\t\t\t\t_normal.copy( element.vertexNormalsModel[ uv3 ] ).applyMatrix3( _normalViewMatrix );\r\n\t\t\t\t\t_uv3x = 0.5 * _normal.x + 0.5;\r\n\t\t\t\t\t_uv3y = 0.5 * _normal.y + 0.5;\r\n\r\n\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_color.copy( material.color );\r\n\r\n\t\t\t\tif ( material.vertexColors === FaceColors ) {\r\n\r\n\t\t\t\t\t_color.multiply( element.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t : fillPath( _color );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( material.isMeshNormalMaterial ) {\r\n\r\n\t\t\t_normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix );\r\n\r\n\t\t\t_color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\tmaterial.wireframe === true\r\n\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t : fillPath( _color );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_color.setRGB( 1, 1, 1 );\r\n\r\n\t\t\tmaterial.wireframe === true\r\n\t\t\t\t ? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t : fillPath( _color );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\r\n\r\n\t\t_context.beginPath();\r\n\t\t_context.moveTo( x0, y0 );\r\n\t\t_context.lineTo( x1, y1 );\r\n\t\t_context.lineTo( x2, y2 );\r\n\t\t_context.closePath();\r\n\r\n\t}\r\n\r\n\tfunction strokePath( color, linewidth, linecap, linejoin ) {\r\n\r\n\t\tsetLineWidth( linewidth );\r\n\t\tsetLineCap( linecap );\r\n\t\tsetLineJoin( linejoin );\r\n\t\tsetStrokeStyle( color.getStyle() );\r\n\r\n\t\t_context.stroke();\r\n\r\n\t\t_elemBox.expandByScalar( linewidth * 2 );\r\n\r\n\t}\r\n\r\n\tfunction fillPath( color ) {\r\n\r\n\t\tsetFillStyle( color.getStyle() );\r\n\t\t_context.fill();\r\n\r\n\t}\r\n\r\n\tfunction textureToPattern( texture ) {\r\n\r\n\t\tif ( texture.version === 0 ||\r\n\t\t\ttexture instanceof CompressedTexture ||\r\n\t\t\ttexture instanceof DataTexture ) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tcanvas: undefined,\r\n\t\t\t\tversion: texture.version\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar image = texture.image;\r\n\r\n\t\tif ( image.complete === false ) {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tcanvas: undefined,\r\n\t\t\t\tversion: 0\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar repeatX = texture.wrapS === RepeatWrapping || texture.wrapS === MirroredRepeatWrapping;\r\n\t\tvar repeatY = texture.wrapT === RepeatWrapping || texture.wrapT === MirroredRepeatWrapping;\r\n\r\n\t\tvar mirrorX = texture.wrapS === MirroredRepeatWrapping;\r\n\t\tvar mirrorY = texture.wrapT === MirroredRepeatWrapping;\r\n\r\n\t\t//\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = image.width * ( mirrorX ? 2 : 1 );\r\n\t\tcanvas.height = image.height * ( mirrorY ? 2 : 1 );\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.setTransform( 1, 0, 0, - 1, 0, image.height );\r\n\t\tcontext.drawImage( image, 0, 0 );\r\n\r\n\t\tif ( mirrorX === true ) {\r\n\r\n\t\t\tcontext.setTransform( - 1, 0, 0, - 1, image.width, image.height );\r\n\t\t\tcontext.drawImage( image, - image.width, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( mirrorY === true ) {\r\n\r\n\t\t\tcontext.setTransform( 1, 0, 0, 1, 0, 0 );\r\n\t\t\tcontext.drawImage( image, 0, image.height );\r\n\r\n\t\t}\r\n\r\n\t\tif ( mirrorX === true && mirrorY === true ) {\r\n\r\n\t\t\tcontext.setTransform( - 1, 0, 0, 1, image.width, 0 );\r\n\t\t\tcontext.drawImage( image, - image.width, image.height );\r\n\r\n\t\t}\r\n\r\n\t\tvar repeat = 'no-repeat';\r\n\r\n\t\tif ( repeatX === true && repeatY === true ) {\r\n\r\n\t\t\trepeat = 'repeat';\r\n\r\n\t\t} else if ( repeatX === true ) {\r\n\r\n\t\t\trepeat = 'repeat-x';\r\n\r\n\t\t} else if ( repeatY === true ) {\r\n\r\n\t\t\trepeat = 'repeat-y';\r\n\r\n\t\t}\r\n\r\n\t\tvar pattern = _context.createPattern( canvas, repeat );\r\n\r\n\t\tif ( texture.onUpdate ) { texture.onUpdate( texture ); }\r\n\r\n\t\treturn {\r\n\t\t\tcanvas: pattern,\r\n\t\t\tversion: texture.version\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\r\n\r\n\t\tvar pattern = _patterns[ texture.id ];\r\n\r\n\t\tif ( pattern === undefined || pattern.version !== texture.version ) {\r\n\r\n\t\t\tpattern = textureToPattern( texture );\r\n\t\t\t_patterns[ texture.id ] = pattern;\r\n\r\n\t\t}\r\n\r\n\t\tif ( pattern.canvas !== undefined ) {\r\n\r\n\t\t\tsetFillStyle( pattern.canvas );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsetFillStyle( 'rgba( 0, 0, 0, 1)' );\r\n\t\t\t_context.fill();\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\r\n\r\n\t\tvar a, b, c, d, e, f, det, idet,\r\n\t\t\toffsetX = texture.offset.x / texture.repeat.x,\r\n\t\t\toffsetY = texture.offset.y / texture.repeat.y,\r\n\t\t\twidth = texture.image.width * texture.repeat.x,\r\n\t\t\theight = texture.image.height * texture.repeat.y;\r\n\r\n\t\tu0 = ( u0 + offsetX ) * width;\r\n\t\tv0 = ( v0 + offsetY ) * height;\r\n\r\n\t\tu1 = ( u1 + offsetX ) * width;\r\n\t\tv1 = ( v1 + offsetY ) * height;\r\n\r\n\t\tu2 = ( u2 + offsetX ) * width;\r\n\t\tv2 = ( v2 + offsetY ) * height;\r\n\r\n\t\tx1 -= x0; y1 -= y0;\r\n\t\tx2 -= x0; y2 -= y0;\r\n\r\n\t\tu1 -= u0; v1 -= v0;\r\n\t\tu2 -= u0; v2 -= v0;\r\n\r\n\t\tdet = u1 * v2 - u2 * v1;\r\n\r\n\t\tif ( det === 0 ) { return; }\r\n\r\n\t\tidet = 1 / det;\r\n\r\n\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\r\n\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\r\n\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\r\n\t\td = ( u1 * y2 - u2 * y1 ) * idet;\r\n\r\n\t\te = x0 - a * u0 - c * v0;\r\n\t\tf = y0 - b * u0 - d * v0;\r\n\r\n\t\t_context.save();\r\n\t\t_context.transform( a, b, c, d, e, f );\r\n\t\t_context.fill();\r\n\t\t_context.restore();\r\n\r\n\t}\r\n\r\n\t// Hide anti-alias gaps\r\n\r\n\tfunction expand( v1, v2, pixels ) {\r\n\r\n\t\tvar x = v2.x - v1.x, y = v2.y - v1.y,\r\n\t\t\tdet = x * x + y * y, idet;\r\n\r\n\t\tif ( det === 0 ) { return; }\r\n\r\n\t\tidet = pixels / Math.sqrt( det );\r\n\r\n\t\tx *= idet; y *= idet;\r\n\r\n\t\tv2.x += x; v2.y += y;\r\n\t\tv1.x -= x; v1.y -= y;\r\n\r\n\t}\r\n\r\n\t// Context cached methods.\r\n\r\n\tfunction setOpacity( value ) {\r\n\r\n\t\tif ( _contextGlobalAlpha !== value ) {\r\n\r\n\t\t\t_context.globalAlpha = value;\r\n\t\t\t_contextGlobalAlpha = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setBlending( value ) {\r\n\r\n\t\tif ( _contextGlobalCompositeOperation !== value ) {\r\n\r\n\t\t\tif ( value === NormalBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'source-over';\r\n\r\n\t\t\t} else if ( value === AdditiveBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'lighter';\r\n\r\n\t\t\t} else if ( value === SubtractiveBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'darker';\r\n\r\n\t\t\t} else if ( value === MultiplyBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'multiply';\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_contextGlobalCompositeOperation = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineWidth( value ) {\r\n\r\n\t\tif ( _contextLineWidth !== value ) {\r\n\r\n\t\t\t_context.lineWidth = value;\r\n\t\t\t_contextLineWidth = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineCap( value ) {\r\n\r\n\t\t// \"butt\", \"round\", \"square\"\r\n\r\n\t\tif ( _contextLineCap !== value ) {\r\n\r\n\t\t\t_context.lineCap = value;\r\n\t\t\t_contextLineCap = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineJoin( value ) {\r\n\r\n\t\t// \"round\", \"bevel\", \"miter\"\r\n\r\n\t\tif ( _contextLineJoin !== value ) {\r\n\r\n\t\t\t_context.lineJoin = value;\r\n\t\t\t_contextLineJoin = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setStrokeStyle( value ) {\r\n\r\n\t\tif ( _contextStrokeStyle !== value ) {\r\n\r\n\t\t\t_context.strokeStyle = value;\r\n\t\t\t_contextStrokeStyle = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setFillStyle( value ) {\r\n\r\n\t\tif ( _contextFillStyle !== value ) {\r\n\r\n\t\t\t_context.fillStyle = value;\r\n\t\t\t_contextFillStyle = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineDash( value ) {\r\n\r\n\t\tif ( _contextLineDash.length !== value.length ) {\r\n\r\n\t\t\t_context.setLineDash( value );\r\n\t\t\t_contextLineDash = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar CSS2DObject = function ( element ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.element = element;\r\n\tthis.element.style.position = 'absolute';\r\n\r\n\tthis.addEventListener( 'removed', function ( event ) {\r\n\r\n\t\tif ( this.element.parentNode !== null ) {\r\n\r\n\t\t\tthis.element.parentNode.removeChild( this.element );\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n};\r\n\r\nCSS2DObject.prototype = Object.create( Object3D.prototype );\r\nCSS2DObject.prototype.constructor = CSS2DObject;\r\n\r\n//\r\n\r\nvar CSS2DRenderer = function () {\r\n\r\n\tconsole.log( 'CSS2DRenderer', REVISION );\r\n\r\n\tvar _width, _height;\r\n\tvar _widthHalf, _heightHalf;\r\n\r\n\tvar vector = new Vector3();\r\n\tvar viewMatrix = new Matrix4();\r\n\tvar viewProjectionMatrix = new Matrix4();\r\n\r\n\tvar cache = {\r\n\t\tobjects: new WeakMap()\r\n\t};\r\n\r\n\tvar domElement = document.createElement( 'div' );\r\n\tdomElement.style.overflow = 'hidden';\r\n\r\n\tthis.domElement = domElement;\r\n\r\n\tthis.getSize = function () {\r\n\r\n\t\treturn {\r\n\t\t\twidth: _width,\r\n\t\t\theight: _height\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\t_widthHalf = _width / 2;\r\n\t\t_heightHalf = _height / 2;\r\n\r\n\t\tdomElement.style.width = width + 'px';\r\n\t\tdomElement.style.height = height + 'px';\r\n\r\n\t};\r\n\r\n\tvar renderObject = function ( object, camera ) {\r\n\r\n\t\tif ( object instanceof CSS2DObject ) {\r\n\r\n\t\t\tvector.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\tvector.applyMatrix4( viewProjectionMatrix );\r\n\r\n\t\t\tvar element = object.element;\r\n\t\t\tvar style = 'translate(-50%,-50%) translate(' + ( vector.x * _widthHalf + _widthHalf ) + 'px,' + ( - vector.y * _heightHalf + _heightHalf ) + 'px)';\r\n\r\n\t\t\telement.style.WebkitTransform = style;\r\n\t\t\telement.style.MozTransform = style;\r\n\t\t\telement.style.oTransform = style;\r\n\t\t\telement.style.transform = style;\r\n\r\n\t\t\tvar objectData = {\r\n\t\t\t\tdistanceToCameraSquared: getDistanceToSquared( camera, object )\r\n\t\t\t};\r\n\r\n\t\t\tcache.objects.set( object, objectData );\r\n\r\n\t\t\tif ( element.parentNode !== domElement ) {\r\n\r\n\t\t\t\tdomElement.appendChild( element );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n\t\t\trenderObject( object.children[ i ], camera );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar getDistanceToSquared = function () {\r\n\r\n\t\tvar a = new Vector3();\r\n\t\tvar b = new Vector3();\r\n\r\n\t\treturn function ( object1, object2 ) {\r\n\r\n\t\t\ta.setFromMatrixPosition( object1.matrixWorld );\r\n\t\t\tb.setFromMatrixPosition( object2.matrixWorld );\r\n\r\n\t\t\treturn a.distanceToSquared( b );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tvar filterAndFlatten = function ( scene ) {\r\n\r\n\t\tvar result = [];\r\n\r\n\t\tscene.traverse( function ( object ) {\r\n\r\n\t\t\tif ( object instanceof CSS2DObject ) { result.push( object ); }\r\n\r\n\t\t} );\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\tvar zOrder = function ( scene ) {\r\n\r\n\t\tvar sorted = filterAndFlatten( scene ).sort( function ( a, b ) {\r\n\r\n\t\t\tvar distanceA = cache.objects.get( a ).distanceToCameraSquared;\r\n\t\t\tvar distanceB = cache.objects.get( b ).distanceToCameraSquared;\r\n\r\n\t\t\treturn distanceA - distanceB;\r\n\r\n\t\t} );\r\n\r\n\t\tvar zMax = sorted.length;\r\n\r\n\t\tfor ( var i = 0, l = sorted.length; i < l; i ++ ) {\r\n\r\n\t\t\tsorted[ i ].element.style.zIndex = zMax - i;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\tif ( camera.parent === null ) { camera.updateMatrixWorld(); }\r\n\r\n\t\tviewMatrix.copy( camera.matrixWorldInverse );\r\n\t\tviewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, viewMatrix );\r\n\r\n\t\trenderObject( scene, camera );\r\n\t\tzOrder( scene );\r\n\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar CSS3DObject = function ( element ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.element = element;\r\n\tthis.element.style.position = 'absolute';\r\n\r\n\tthis.addEventListener( 'removed', function () {\r\n\r\n\t\tif ( this.element.parentNode !== null ) {\r\n\r\n\t\t\tthis.element.parentNode.removeChild( this.element );\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n};\r\n\r\nCSS3DObject.prototype = Object.create( Object3D.prototype );\r\nCSS3DObject.prototype.constructor = CSS3DObject;\r\n\r\nvar CSS3DSprite = function ( element ) {\r\n\r\n\tCSS3DObject.call( this, element );\r\n\r\n};\r\n\r\nCSS3DSprite.prototype = Object.create( CSS3DObject.prototype );\r\nCSS3DSprite.prototype.constructor = CSS3DSprite;\r\n\r\n//\r\n\r\nvar CSS3DRenderer = function () {\r\n\r\n\tconsole.log( 'CSS3DRenderer', REVISION );\r\n\r\n\tvar _width, _height;\r\n\tvar _widthHalf, _heightHalf;\r\n\r\n\tvar matrix = new Matrix4();\r\n\r\n\tvar cache = {\r\n\t\tcamera: { fov: 0, style: '' },\r\n\t\tobjects: new WeakMap()\r\n\t};\r\n\r\n\tvar domElement = document.createElement( 'div' );\r\n\tdomElement.style.overflow = 'hidden';\r\n\r\n\tthis.domElement = domElement;\r\n\r\n\tvar cameraElement = document.createElement( 'div' );\r\n\r\n\tcameraElement.style.WebkitTransformStyle = 'preserve-3d';\r\n\tcameraElement.style.transformStyle = 'preserve-3d';\r\n\r\n\tdomElement.appendChild( cameraElement );\r\n\r\n\tvar isIE = /Trident/i.test( navigator.userAgent );\r\n\r\n\tthis.getSize = function () {\r\n\r\n\t\treturn {\r\n\t\t\twidth: _width,\r\n\t\t\theight: _height\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\t\t_widthHalf = _width / 2;\r\n\t\t_heightHalf = _height / 2;\r\n\r\n\t\tdomElement.style.width = width + 'px';\r\n\t\tdomElement.style.height = height + 'px';\r\n\r\n\t\tcameraElement.style.width = width + 'px';\r\n\t\tcameraElement.style.height = height + 'px';\r\n\r\n\t};\r\n\r\n\tfunction epsilon( value ) {\r\n\r\n\t\treturn Math.abs( value ) < 1e-10 ? 0 : value;\r\n\r\n\t}\r\n\r\n\tfunction getCameraCSSMatrix( matrix ) {\r\n\r\n\t\tvar elements = matrix.elements;\r\n\r\n\t\treturn 'matrix3d(' +\r\n\t\t\tepsilon( elements[ 0 ] ) + ',' +\r\n\t\t\tepsilon( - elements[ 1 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 2 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 3 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 4 ] ) + ',' +\r\n\t\t\tepsilon( - elements[ 5 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 6 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 7 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 8 ] ) + ',' +\r\n\t\t\tepsilon( - elements[ 9 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 10 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 11 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 12 ] ) + ',' +\r\n\t\t\tepsilon( - elements[ 13 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 14 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 15 ] ) +\r\n\t\t')';\r\n\r\n\t}\r\n\r\n\tfunction getObjectCSSMatrix( matrix, cameraCSSMatrix ) {\r\n\r\n\t\tvar elements = matrix.elements;\r\n\t\tvar matrix3d = 'matrix3d(' +\r\n\t\t\tepsilon( elements[ 0 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 1 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 2 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 3 ] ) + ',' +\r\n\t\t\tepsilon( - elements[ 4 ] ) + ',' +\r\n\t\t\tepsilon( - elements[ 5 ] ) + ',' +\r\n\t\t\tepsilon( - elements[ 6 ] ) + ',' +\r\n\t\t\tepsilon( - elements[ 7 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 8 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 9 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 10 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 11 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 12 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 13 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 14 ] ) + ',' +\r\n\t\t\tepsilon( elements[ 15 ] ) +\r\n\t\t')';\r\n\r\n\t\tif ( isIE ) {\r\n\r\n\t\t\treturn 'translate(-50%,-50%)' +\r\n\t\t\t\t'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)' +\r\n\t\t\t\tcameraCSSMatrix +\r\n\t\t\t\tmatrix3d;\r\n\r\n\t\t}\r\n\r\n\t\treturn 'translate(-50%,-50%)' + matrix3d;\r\n\r\n\t}\r\n\r\n\tfunction renderObject( object, camera, cameraCSSMatrix ) {\r\n\r\n\t\tif ( object instanceof CSS3DObject ) {\r\n\r\n\t\t\tvar style;\r\n\r\n\t\t\tif ( object instanceof CSS3DSprite ) {\r\n\r\n\t\t\t\t// http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/\r\n\r\n\t\t\t\tmatrix.copy( camera.matrixWorldInverse );\r\n\t\t\t\tmatrix.transpose();\r\n\t\t\t\tmatrix.copyPosition( object.matrixWorld );\r\n\t\t\t\tmatrix.scale( object.scale );\r\n\r\n\t\t\t\tmatrix.elements[ 3 ] = 0;\r\n\t\t\t\tmatrix.elements[ 7 ] = 0;\r\n\t\t\t\tmatrix.elements[ 11 ] = 0;\r\n\t\t\t\tmatrix.elements[ 15 ] = 1;\r\n\r\n\t\t\t\tstyle = getObjectCSSMatrix( matrix, cameraCSSMatrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstyle = getObjectCSSMatrix( object.matrixWorld, cameraCSSMatrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar element = object.element;\r\n\t\t\tvar cachedStyle = cache.objects.get( object );\r\n\r\n\t\t\tif ( cachedStyle === undefined || cachedStyle !== style ) {\r\n\r\n\t\t\t\telement.style.WebkitTransform = style;\r\n\t\t\t\telement.style.transform = style;\r\n\r\n\t\t\t\tvar objectData = { style: style };\r\n\r\n\t\t\t\tif ( isIE ) {\r\n\r\n\t\t\t\t\tobjectData.distanceToCameraSquared = getDistanceToSquared( camera, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcache.objects.set( object, objectData );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( element.parentNode !== cameraElement ) {\r\n\r\n\t\t\t\tcameraElement.appendChild( element );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n\t\t\trenderObject( object.children[ i ], camera, cameraCSSMatrix );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar getDistanceToSquared = function () {\r\n\r\n\t\tvar a = new Vector3();\r\n\t\tvar b = new Vector3();\r\n\r\n\t\treturn function ( object1, object2 ) {\r\n\r\n\t\t\ta.setFromMatrixPosition( object1.matrixWorld );\r\n\t\t\tb.setFromMatrixPosition( object2.matrixWorld );\r\n\r\n\t\t\treturn a.distanceToSquared( b );\r\n\r\n\t\t};\r\n\r\n\t}();\r\n\r\n\tfunction filterAndFlatten( scene ) {\r\n\r\n\t\tvar result = [];\r\n\r\n\t\tscene.traverse( function ( object ) {\r\n\r\n\t\t\tif ( object instanceof CSS3DObject ) { result.push( object ); }\r\n\r\n\t\t} );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tfunction zOrder( scene ) {\r\n\r\n\t\tvar sorted = filterAndFlatten( scene ).sort( function ( a, b ) {\r\n\r\n\t\t\tvar distanceA = cache.objects.get( a ).distanceToCameraSquared;\r\n\t\t\tvar distanceB = cache.objects.get( b ).distanceToCameraSquared;\r\n\r\n\t\t\treturn distanceA - distanceB;\r\n\r\n\t\t} );\r\n\r\n\t\tvar zMax = sorted.length;\r\n\r\n\t\tfor ( var i = 0, l = sorted.length; i < l; i ++ ) {\r\n\r\n\t\t\tsorted[ i ].element.style.zIndex = zMax - i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tvar fov = camera.projectionMatrix.elements[ 5 ] * _heightHalf;\r\n\r\n\t\tif ( cache.camera.fov !== fov ) {\r\n\r\n\t\t\tif ( camera.isPerspectiveCamera ) {\r\n\r\n\t\t\t\tdomElement.style.WebkitPerspective = fov + 'px';\r\n\t\t\t\tdomElement.style.perspective = fov + 'px';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcache.camera.fov = fov;\r\n\r\n\t\t}\r\n\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\tif ( camera.parent === null ) { camera.updateMatrixWorld(); }\r\n\r\n\t\tvar cameraCSSMatrix = camera.isOrthographicCamera ?\r\n\t\t\t'scale(' + fov + ')' + getCameraCSSMatrix( camera.matrixWorldInverse ) :\r\n\t\t\t'translateZ(' + fov + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse );\r\n\r\n\t\tvar style = cameraCSSMatrix +\r\n\t\t\t'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';\r\n\r\n\t\tif ( cache.camera.style !== style && ! isIE ) {\r\n\r\n\t\t\tcameraElement.style.WebkitTransform = style;\r\n\t\t\tcameraElement.style.transform = style;\r\n\r\n\t\t\tcache.camera.style = style;\r\n\r\n\t\t}\r\n\r\n\t\trenderObject( scene, camera, cameraCSSMatrix );\r\n\r\n\t\tif ( isIE ) {\r\n\r\n\t\t\t// IE10 and 11 does not support 'preserve-3d'.\r\n\t\t\t// Thus, z-order in 3D will not work.\r\n\t\t\t// We have to calc z-order manually and set CSS z-index for IE.\r\n\t\t\t// FYI: z-index can't handle object intersection\r\n\t\t\tzOrder( scene );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar RaytracingRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'RaytracingRenderer', REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar scope = this;\r\n\tvar pool = [];\r\n\tvar renderering = false;\r\n\r\n\tvar canvas = document.createElement( 'canvas' );\r\n\tvar context = canvas.getContext( '2d', {\r\n\t\talpha: parameters.alpha === true\r\n\t} );\r\n\r\n\tvar canvasWidth, canvasHeight;\r\n\r\n\tvar clearColor = new Color( 0x000000 );\r\n\r\n\tthis.domElement = canvas;\r\n\r\n\tthis.autoClear = true;\r\n\r\n\tvar workers = parameters.workers;\r\n\tvar blockSize = parameters.blockSize || 64;\r\n\tthis.randomize = parameters.randomize;\r\n\r\n\tvar toRender = [], workerId = 0, sceneId = 0;\r\n\r\n\tconsole.log( '%cSpinning off ' + workers + ' Workers ', 'font-size: 20px; background: black; color: white; font-family: monospace;' );\r\n\r\n\tthis.setWorkers = function ( w ) {\r\n\r\n\t\tworkers = w || navigator.hardwareConcurrency || 4;\r\n\r\n\t\twhile ( pool.length < workers ) {\r\n\r\n\t\t\tvar worker = new Worker( parameters.workerPath );\r\n\t\t\tworker.id = workerId ++;\r\n\r\n\t\t\tworker.onmessage = function ( e ) {\r\n\r\n\t\t\t\tvar data = e.data;\r\n\r\n\t\t\t\tif ( ! data ) { return; }\r\n\r\n\t\t\t\tif ( data.blockSize && sceneId == data.sceneId ) { // we match sceneId here to be sure\r\n\r\n\t\t\t\t\tvar imagedata = new ImageData( new Uint8ClampedArray( data.data ), data.blockSize, data.blockSize );\r\n\t\t\t\t\tcontext.putImageData( imagedata, data.blockX, data.blockY );\r\n\r\n\t\t\t\t\t// completed\r\n\r\n\t\t\t\t\tconsole.log( 'Worker ' + this.id, data.time / 1000, ( Date.now() - reallyThen ) / 1000 + ' s' );\r\n\r\n\t\t\t\t\tif ( pool.length > workers ) {\r\n\r\n\t\t\t\t\t\tpool.splice( pool.indexOf( this ), 1 );\r\n\t\t\t\t\t\treturn this.terminate();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\trenderNext( this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t\tworker.color = new Color().setHSL( Math.random(), 0.8, 0.8 ).getHexString();\r\n\t\t\tpool.push( worker );\r\n\r\n\t\t\tupdateSettings( worker );\r\n\r\n\t\t\tif ( renderering ) {\r\n\r\n\t\t\t\tworker.postMessage( {\r\n\t\t\t\t\tscene: sceneJSON,\r\n\t\t\t\t\tcamera: cameraJSON,\r\n\t\t\t\t\tannex: materials,\r\n\t\t\t\t\tsceneId: sceneId\r\n\t\t\t\t} );\r\n\r\n\t\t\t\trenderNext( worker );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! renderering ) {\r\n\r\n\t\t\twhile ( pool.length > workers ) {\r\n\r\n\t\t\t\tpool.pop().terminate();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setWorkers( workers );\r\n\r\n\tthis.setClearColor = function ( color  ) {\r\n\r\n\t\tclearColor.set( color );\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function () {};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\tcanvas.width = width;\r\n\t\tcanvas.height = height;\r\n\r\n\t\tcanvasWidth = canvas.width;\r\n\t\tcanvasHeight = canvas.height;\r\n\r\n\t\tcontext.fillStyle = 'white';\r\n\r\n\t\tpool.forEach( updateSettings );\r\n\r\n\t};\r\n\r\n\tthis.setSize( canvas.width, canvas.height );\r\n\r\n\tthis.clear = function () {\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tvar totalBlocks, xblocks, yblocks;\r\n\r\n\tfunction updateSettings( worker ) {\r\n\r\n\t\tworker.postMessage( {\r\n\r\n\t\t\tinit: [ canvasWidth, canvasHeight ],\r\n\t\t\tworker: worker.id,\r\n\t\t\t// workers: pool.length,\r\n\t\t\tblockSize: blockSize\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tfunction renderNext( worker ) {\r\n\r\n\t\tif ( ! toRender.length ) {\r\n\r\n\t\t\trenderering = false;\r\n\t\t\treturn scope.dispatchEvent( { type: \"complete\" } );\r\n\r\n\t\t}\r\n\r\n\t\tvar current = toRender.pop();\r\n\r\n\t\tvar blockX = ( current % xblocks ) * blockSize;\r\n\t\tvar blockY = ( current / xblocks | 0 ) * blockSize;\r\n\r\n\t\tworker.postMessage( {\r\n\t\t\trender: true,\r\n\t\t\tx: blockX,\r\n\t\t\ty: blockY,\r\n\t\t\tsceneId: sceneId\r\n\t\t} );\r\n\r\n\t\tcontext.fillStyle = '#' + worker.color;\r\n\r\n\t\tcontext.fillRect( blockX, blockY, blockSize, blockSize );\r\n\r\n\t}\r\n\r\n\tvar materials = {};\r\n\r\n\tvar sceneJSON, cameraJSON, reallyThen;\r\n\r\n\t// additional properties that were not serialize automatically\r\n\r\n\tvar _annex = {\r\n\r\n\t\tmirror: 1,\r\n\t\treflectivity: 1,\r\n\t\trefractionRatio: 1,\r\n\t\tglass: 1\r\n\r\n\t};\r\n\r\n\tfunction serializeObject( o ) {\r\n\r\n\t\tvar mat = o.material;\r\n\r\n\t\tif ( ! mat || mat.uuid in materials ) { return; }\r\n\r\n\t\tvar props = {};\r\n\t\tfor ( var m in _annex ) {\r\n\r\n\t\t\tif ( mat[ m ] !== undefined ) {\r\n\r\n\t\t\t\tprops[ m ] = mat[ m ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmaterials[ mat.uuid ] = props;\r\n\r\n\t}\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\trenderering = true;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( scene.autoUpdate === true ) { scene.updateMatrixWorld(); }\r\n\r\n\t\t// update camera matrices\r\n\r\n\t\tif ( camera.parent === null ) { camera.updateMatrixWorld(); }\r\n\r\n\t\tsceneJSON = scene.toJSON();\r\n\t\tcameraJSON = camera.toJSON();\r\n\t\t++ sceneId;\r\n\r\n\t\tscene.traverse( serializeObject );\r\n\r\n\t\tpool.forEach( function ( worker ) {\r\n\r\n\t\t\tworker.postMessage( {\r\n\t\t\t\tscene: sceneJSON,\r\n\t\t\t\tcamera: cameraJSON,\r\n\t\t\t\tannex: materials,\r\n\t\t\t\tsceneId: sceneId\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t\tcontext.clearRect( 0, 0, canvasWidth, canvasHeight );\r\n\t\treallyThen = Date.now();\r\n\r\n\t\txblocks = Math.ceil( canvasWidth / blockSize );\r\n\t\tyblocks = Math.ceil( canvasHeight / blockSize );\r\n\t\ttotalBlocks = xblocks * yblocks;\r\n\r\n\t\ttoRender = [];\r\n\r\n\t\tfor ( var i = 0; i < totalBlocks; i ++ ) {\r\n\r\n\t\t\ttoRender.push( i );\r\n\r\n\t\t}\r\n\r\n\t\t// Randomize painting :)\r\n\r\n\t\tif ( scope.randomize ) {\r\n\r\n\t\t\tfor ( var i = 0; i < totalBlocks; i ++ ) {\r\n\r\n\t\t\t\tvar swap = Math.random() * totalBlocks | 0;\r\n\t\t\t\tvar tmp = toRender[ swap ];\r\n\t\t\t\ttoRender[ swap ] = toRender[ i ];\r\n\t\t\t\ttoRender[ i ] = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tpool.forEach( renderNext );\r\n\r\n\t};\r\n\r\n};\r\n\r\nObject.assign( RaytracingRenderer.prototype, EventDispatcher.prototype );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SoftwareRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'SoftwareRenderer', REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar canvas = parameters.canvas !== undefined\r\n\t\t\t ? parameters.canvas\r\n\t\t\t : document.createElement( 'canvas' );\r\n\r\n\tvar context = canvas.getContext( '2d', {\r\n\t\talpha: parameters.alpha === true\r\n\t} );\r\n\r\n\tvar shaders = {};\r\n\tvar textures = {};\r\n\r\n\tvar canvasWidth, canvasHeight;\r\n\tvar canvasWBlocks, canvasHBlocks;\r\n\tvar viewportXScale, viewportYScale, viewportZScale;\r\n\tvar viewportXOffs, viewportYOffs, viewportZOffs;\r\n\r\n\tvar clearColor = new Color( 0x000000 );\r\n\tvar clearAlpha = parameters.alpha === true ? 0 : 1;\r\n\r\n\tvar imagedata, data, zbuffer;\r\n\tvar numBlocks, blockMaxZ, blockFlags;\r\n\r\n\tvar BLOCK_ISCLEAR = ( 1 << 0 );\r\n\tvar BLOCK_NEEDCLEAR = ( 1 << 1 );\r\n\r\n\tvar subpixelBits = 4;\r\n\tvar subpixelBias = ( 1 << subpixelBits ) - 1;\r\n\tvar blockShift = 3;\r\n\tvar blockSize = 1 << blockShift;\r\n\tvar maxZVal = ( 1 << 24 ); // Note: You want to size this so you don't get overflows.\r\n\tvar lineMode = false;\r\n\tvar lookVector = new Vector3( 0, 0, 1 );\r\n\tvar crossVector = new Vector3();\r\n\r\n\tvar rectx1 = Infinity, recty1 = Infinity;\r\n\tvar rectx2 = 0, recty2 = 0;\r\n\r\n\tvar prevrectx1 = Infinity, prevrecty1 = Infinity;\r\n\tvar prevrectx2 = 0, prevrecty2 = 0;\r\n\r\n\tvar projector = new Projector();\r\n\r\n\tvar spriteV1 = new Vector4();\r\n\tvar spriteV2 = new Vector4();\r\n\tvar spriteV3 = new Vector4();\r\n\r\n\tvar spriteUV1 = new Vector2();\r\n\tvar spriteUV2 = new Vector2();\r\n\tvar spriteUV3 = new Vector2();\r\n\r\n\tvar mpVPool = [];\r\n\tvar mpVPoolCount = 0;\r\n\tvar mpNPool = [];\r\n\tvar mpNPoolCount = 0;\r\n\tvar mpUVPool = [];\r\n\tvar mpUVPoolCount = 0;\r\n\r\n\tvar _this = this;\r\n\r\n\tthis.domElement = canvas;\r\n\r\n\tthis.autoClear = true;\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\tclearColor.set( color );\r\n\t\tclearAlpha = alpha;\r\n\t\tclearColorBuffer( clearColor );\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function () {};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\tcanvasWBlocks = Math.floor( width / blockSize );\r\n\t\tcanvasHBlocks = Math.floor( height / blockSize );\r\n\t\tcanvasWidth = canvasWBlocks * blockSize;\r\n\t\tcanvasHeight = canvasHBlocks * blockSize;\r\n\r\n\t\tvar fixScale = 1 << subpixelBits;\r\n\r\n\t\tviewportXScale = fixScale * canvasWidth / 2;\r\n\t\tviewportYScale = - fixScale * canvasHeight / 2;\r\n\t\tviewportZScale = maxZVal / 2;\r\n\r\n\t\tviewportXOffs = fixScale * canvasWidth / 2 + 0.5;\r\n\t\tviewportYOffs = fixScale * canvasHeight / 2 + 0.5;\r\n\t\tviewportZOffs = maxZVal / 2 + 0.5;\r\n\r\n\t\tcanvas.width = canvasWidth;\r\n\t\tcanvas.height = canvasHeight;\r\n\r\n\t\timagedata = context.getImageData( 0, 0, canvasWidth, canvasHeight );\r\n\t\tdata = imagedata.data;\r\n\r\n\t\tzbuffer = new Int32Array( data.length / 4 );\r\n\r\n\t\tnumBlocks = canvasWBlocks * canvasHBlocks;\r\n\t\tblockMaxZ = new Int32Array( numBlocks );\r\n\t\tblockFlags = new Uint8Array( numBlocks );\r\n\r\n\t\tfor ( var i = 0, l = zbuffer.length; i < l; i ++ ) {\r\n\r\n\t\t\tzbuffer[ i ] = maxZVal;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < numBlocks; i ++ ) {\r\n\r\n\t\t\tblockFlags[ i ] = BLOCK_ISCLEAR;\r\n\r\n\t\t}\r\n\r\n\t\tclearColorBuffer( clearColor );\r\n\r\n\t};\r\n\r\n\tthis.clear = function () {\r\n\r\n\t\trectx1 = Infinity;\r\n\t\trecty1 = Infinity;\r\n\t\trectx2 = 0;\r\n\t\trecty2 = 0;\r\n\t\tmpVPoolCount = 0;\r\n\t\tmpNPoolCount = 0;\r\n\t\tmpUVPoolCount = 0;\r\n\r\n\t\tfor ( var i = 0; i < numBlocks; i ++ ) {\r\n\r\n\t\t\tblockMaxZ[ i ] = maxZVal;\r\n\t\t\tblockFlags[ i ] = ( blockFlags[ i ] & BLOCK_ISCLEAR ) ? BLOCK_ISCLEAR : BLOCK_NEEDCLEAR;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\t// TODO: Check why autoClear can't be false.\r\n\t\tthis.clear();\r\n\r\n\t\tvar background = scene.background;\r\n\r\n\t\tif ( background && background.isColor ) {\r\n\r\n\t\t\tclearColorBuffer( background );\r\n\r\n\t\t}\r\n\r\n\t\tvar renderData = projector.projectScene( scene, camera, false, false );\r\n\t\tvar elements = renderData.elements;\r\n\r\n\t\tfor ( var e = 0, el = elements.length; e < el; e ++ ) {\r\n\r\n\t\t\tvar element = elements[ e ];\r\n\t\t\tvar material = element.material;\r\n\t\t\tvar shader = getMaterialShader( material );\r\n\r\n\t\t\tif ( ! shader ) { continue; }\r\n\r\n\t\t\tif ( element instanceof RenderableFace ) {\r\n\r\n\t\t\t\tif ( ! element.uvs ) {\r\n\r\n\t\t\t\t\tdrawTriangle(\r\n\t\t\t\t\t\telement.v1.positionScreen,\r\n\t\t\t\t\t\telement.v2.positionScreen,\r\n\t\t\t\t\t\telement.v3.positionScreen,\r\n\t\t\t\t\t\tnull, null, null,\r\n\t\t\t\t\t\tshader, element, material\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tdrawTriangle(\r\n\t\t\t\t\t\telement.v1.positionScreen,\r\n\t\t\t\t\t\telement.v2.positionScreen,\r\n\t\t\t\t\t\telement.v3.positionScreen,\r\n\t\t\t\t\t\telement.uvs[ 0 ], element.uvs[ 1 ], element.uvs[ 2 ],\r\n\t\t\t\t\t\tshader, element, material\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( element instanceof RenderableSprite ) {\r\n\r\n\t\t\t\tvar scaleX = element.scale.x * 0.5;\r\n\t\t\t\tvar scaleY = element.scale.y * 0.5;\r\n\r\n\t\t\t\tspriteV1.copy( element );\r\n\t\t\t\tspriteV1.x -= scaleX;\r\n\t\t\t\tspriteV1.y += scaleY;\r\n\r\n\t\t\t\tspriteV2.copy( element );\r\n\t\t\t\tspriteV2.x -= scaleX;\r\n\t\t\t\tspriteV2.y -= scaleY;\r\n\r\n\t\t\t\tspriteV3.copy( element );\r\n\t\t\t\tspriteV3.x += scaleX;\r\n\t\t\t\tspriteV3.y += scaleY;\r\n\r\n\t\t\t\tif ( material.map ) {\r\n\r\n\t\t\t\t\tspriteUV1.set( 0, 1 );\r\n\t\t\t\t\tspriteUV2.set( 0, 0 );\r\n\t\t\t\t\tspriteUV3.set( 1, 1 );\r\n\r\n\t\t\t\t\tdrawTriangle(\r\n\t\t\t\t\t\tspriteV1, spriteV2, spriteV3,\r\n\t\t\t\t\t\tspriteUV1, spriteUV2, spriteUV3,\r\n\t\t\t\t\t\tshader, element, material\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tdrawTriangle(\r\n\t\t\t\t\t\tspriteV1, spriteV2, spriteV3,\r\n\t\t\t\t\t\tnull, null, null,\r\n\t\t\t\t\t\tshader, element, material\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tspriteV1.copy( element );\r\n\t\t\t\tspriteV1.x += scaleX;\r\n\t\t\t\tspriteV1.y += scaleY;\r\n\r\n\t\t\t\tspriteV2.copy( element );\r\n\t\t\t\tspriteV2.x -= scaleX;\r\n\t\t\t\tspriteV2.y -= scaleY;\r\n\r\n\t\t\t\tspriteV3.copy( element );\r\n\t\t\t\tspriteV3.x += scaleX;\r\n\t\t\t\tspriteV3.y -= scaleY;\r\n\r\n\t\t\t\tif ( material.map ) {\r\n\r\n\t\t\t\t\tspriteUV1.set( 1, 1 );\r\n\t\t\t\t\tspriteUV2.set( 0, 0 );\r\n\t\t\t\t\tspriteUV3.set( 1, 0 );\r\n\r\n\t\t\t\t\tdrawTriangle(\r\n\t\t\t\t\t\tspriteV1, spriteV2, spriteV3,\r\n\t\t\t\t\t\tspriteUV1, spriteUV2, spriteUV3,\r\n\t\t\t\t\t\tshader, element, material\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tdrawTriangle(\r\n\t\t\t\t\t\tspriteV1, spriteV2, spriteV3,\r\n\t\t\t\t\t\tnull, null, null,\r\n\t\t\t\t\t\tshader, element, material\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( element instanceof RenderableLine ) {\r\n\r\n\t\t\t\tvar shader = getMaterialShader( material );\r\n\r\n\t\t\t\tdrawLine(\r\n\t\t\t\t\telement.v1.positionScreen,\r\n\t\t\t\t\telement.v2.positionScreen,\r\n\t\t\t\t\telement.vertexColors[ 0 ],\r\n\t\t\t\t\telement.vertexColors[ 1 ],\r\n\t\t\t\t\tshader,\r\n\t\t\t\t\tmaterial\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfinishClear();\r\n\r\n\t\tvar x = Math.min( rectx1, prevrectx1 );\r\n\t\tvar y = Math.min( recty1, prevrecty1 );\r\n\t\tvar width = Math.max( rectx2, prevrectx2 ) - x;\r\n\t\tvar height = Math.max( recty2, prevrecty2 ) - y;\r\n\r\n\t\tif ( x !== Infinity ) {\r\n\r\n\t\t\tcontext.putImageData( imagedata, 0, 0, x, y, width, height );\r\n\r\n\t\t}\r\n\r\n\t\tprevrectx1 = rectx1; prevrecty1 = recty1;\r\n\t\tprevrectx2 = rectx2; prevrecty2 = recty2;\r\n\r\n\t};\r\n\r\n\tfunction getAlpha() {\r\n\r\n\t\treturn parameters.alpha === true ? clearAlpha : 1;\r\n\r\n\t}\r\n\r\n\tfunction clearColorBuffer( color ) {\r\n\r\n\t\tvar size = canvasWidth * canvasHeight * 4;\r\n\r\n\t\tfor ( var i = 0; i < size; i += 4 ) {\r\n\r\n\t\t\tdata[ i ] = color.r * 255 | 0;\r\n\t\t\tdata[ i + 1 ] = color.g * 255 | 0;\r\n\t\t\tdata[ i + 2 ] = color.b * 255 | 0;\r\n\t\t\tdata[ i + 3 ] = getAlpha() * 255 | 0;\r\n\r\n\t\t}\r\n\r\n\t\tcontext.fillStyle = 'rgba(' + ( ( clearColor.r * 255 ) | 0 ) + ',' + ( ( clearColor.g * 255 ) | 0 ) + ',' + ( ( clearColor.b * 255 ) | 0 ) + ',' + getAlpha() + ')';\r\n\t\tcontext.fillRect( 0, 0, canvasWidth, canvasHeight );\r\n\r\n\t}\r\n\r\n\tfunction getPalette( material, bSimulateSpecular ) {\r\n\r\n\t\tvar i = 0, j = 0;\r\n\t\tvar diffuseR = material.color.r * 255;\r\n\t\tvar diffuseG = material.color.g * 255;\r\n\t\tvar diffuseB = material.color.b * 255;\r\n\t\tvar palette = new Uint8Array( 256 * 3 );\r\n\r\n\t\tif ( bSimulateSpecular ) {\r\n\r\n\t\t\twhile ( i < 204 ) {\r\n\r\n\t\t\t\tpalette[ j ++ ] = Math.min( i * diffuseR / 204, 255 );\r\n\t\t\t\tpalette[ j ++ ] = Math.min( i * diffuseG / 204, 255 );\r\n\t\t\t\tpalette[ j ++ ] = Math.min( i * diffuseB / 204, 255 );\r\n\t\t\t\t++ i;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( i < 256 ) {\r\n\r\n\t\t\t\t// plus specular highlight\r\n\t\t\t\tpalette[ j ++ ] = Math.min( diffuseR + ( i - 204 ) * ( 255 - diffuseR ) / 82, 255 );\r\n\t\t\t\tpalette[ j ++ ] = Math.min( diffuseG + ( i - 204 ) * ( 255 - diffuseG ) / 82, 255 );\r\n\t\t\t\tpalette[ j ++ ] = Math.min( diffuseB + ( i - 204 ) * ( 255 - diffuseB ) / 82, 255 );\r\n\t\t\t\t++ i;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\twhile ( i < 256 ) {\r\n\r\n\t\t\t\tpalette[ j ++ ] = Math.min( i * diffuseR / 255, 255 );\r\n\t\t\t\tpalette[ j ++ ] = Math.min( i * diffuseG / 255, 255 );\r\n\t\t\t\tpalette[ j ++ ] = Math.min( i * diffuseB / 255, 255 );\r\n\t\t\t\t++ i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn palette;\r\n\r\n\t}\r\n\r\n\tfunction basicMaterialShader( buffer, depthBuf, offset, depth, u, v, n, face, material ) {\r\n\r\n\t\tvar colorOffset = offset * 4;\r\n\r\n\t\tvar texture = textures[ material.map.id ];\r\n\r\n\t\tif ( ! texture.data ) { return; }\r\n\r\n\t\tvar tdim = texture.width;\r\n\t\tvar isTransparent = material.transparent;\r\n\t\tvar tbound = tdim - 1;\r\n\t\tvar tdata = texture.data;\r\n\t\tvar tIndex = ( ( ( v * tdim ) & tbound ) * tdim + ( ( u * tdim ) & tbound ) ) * 4;\r\n\r\n\t\tif ( ! isTransparent ) {\r\n\r\n\t\t\tbuffer[ colorOffset ] = tdata[ tIndex ];\r\n\t\t\tbuffer[ colorOffset + 1 ] = tdata[ tIndex + 1 ];\r\n\t\t\tbuffer[ colorOffset + 2 ] = tdata[ tIndex + 2 ];\r\n\t\t\tbuffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;\r\n\t\t\tdepthBuf[ offset ] = depth;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar srcR = tdata[ tIndex ];\r\n\t\t\tvar srcG = tdata[ tIndex + 1 ];\r\n\t\t\tvar srcB = tdata[ tIndex + 2 ];\r\n\t\t\tvar opaci = tdata[ tIndex + 3 ] * material.opacity / 255;\r\n\t\t\tvar destR = buffer[ colorOffset ];\r\n\t\t\tvar destG = buffer[ colorOffset + 1 ];\r\n\t\t\tvar destB = buffer[ colorOffset + 2 ];\r\n\r\n\t\t\tbuffer[ colorOffset ] = ( srcR * opaci + destR * ( 1 - opaci ) );\r\n\t\t\tbuffer[ colorOffset + 1 ] = ( srcG * opaci + destG * ( 1 - opaci ) );\r\n\t\t\tbuffer[ colorOffset + 2 ] = ( srcB * opaci + destB * ( 1 - opaci ) );\r\n\t\t\tbuffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;\r\n\r\n\t\t\t// Only opaue pixls write to the depth buffer\r\n\r\n\t\t\tif ( buffer[ colorOffset + 3 ] == 255 )\t{ depthBuf[ offset ] = depth; }\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction lightingMaterialShader( buffer, depthBuf, offset, depth, u, v, n, face, material ) {\r\n\r\n\t\tvar colorOffset = offset * 4;\r\n\r\n\t\tvar texture = textures[ material.map.id ];\r\n\r\n\t\tif ( ! texture.data ) { return; }\r\n\r\n\t\tvar tdim = texture.width;\r\n\t\tvar isTransparent = material.transparent;\r\n\t\tvar cIndex = ( n > 0 ? ( ~ ~ n ) : 0 ) * 3;\r\n\t\tvar tbound = tdim - 1;\r\n\t\tvar tdata = texture.data;\r\n\t\tvar tIndex = ( ( ( v * tdim ) & tbound ) * tdim + ( ( u * tdim ) & tbound ) ) * 4;\r\n\r\n\t\tif ( ! isTransparent ) {\r\n\r\n\t\t\tbuffer[ colorOffset ] = ( material.palette[ cIndex ] * tdata[ tIndex ] ) >> 8;\r\n\t\t\tbuffer[ colorOffset + 1 ] = ( material.palette[ cIndex + 1 ] * tdata[ tIndex + 1 ] ) >> 8;\r\n\t\t\tbuffer[ colorOffset + 2 ] = ( material.palette[ cIndex + 2 ] * tdata[ tIndex + 2 ] ) >> 8;\r\n\t\t\tbuffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;\r\n\t\t\tdepthBuf[ offset ] = depth;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar foreColorR = material.palette[ cIndex ] * tdata[ tIndex ];\r\n\t\t\tvar foreColorG = material.palette[ cIndex + 1 ] * tdata[ tIndex + 1 ];\r\n\t\t\tvar foreColorB = material.palette[ cIndex + 2 ] * tdata[ tIndex + 2 ];\r\n\t\t\tvar opaci = tdata[ tIndex + 3 ] * material.opacity / 256;\r\n\t\t\tvar destR = buffer[ colorOffset ];\r\n\t\t\tvar destG = buffer[ colorOffset + 1 ];\r\n\t\t\tvar destB = buffer[ colorOffset + 2 ];\r\n\r\n\t\t\tbuffer[ colorOffset ] = foreColorR * opaci + destR * ( 1 - opaci );\r\n\t\t\tbuffer[ colorOffset + 1 ] = foreColorG * opaci + destG * ( 1 - opaci );\r\n\t\t\tbuffer[ colorOffset + 2 ] = foreColorB * opaci + destB * ( 1 - opaci );\r\n\t\t\tbuffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;\r\n\r\n\t\t\t// Only opaue pixls write to the depth buffer\r\n\r\n\t\t\tif ( buffer[ colorOffset + 3 ] == 255 ) { depthBuf[ offset ] = depth; }\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getMaterialShader( material ) {\r\n\r\n\t\tvar id = material.id;\r\n\t\tvar shader = shaders[ id ];\r\n\r\n\t\tif ( shader && material.map && ! textures[ material.map.id ] ) { delete shaders[ id ]; }\r\n\r\n\t\tif ( shaders[ id ] === undefined || material.needsUpdate === true ) {\r\n\r\n\t\t\tif ( material instanceof MeshBasicMaterial ||\r\n\t\t\t\tmaterial instanceof MeshLambertMaterial ||\r\n\t\t\t\tmaterial instanceof MeshPhongMaterial ||\r\n\t\t\t\tmaterial instanceof SpriteMaterial ) {\r\n\r\n\t\t\t\tif ( material instanceof MeshLambertMaterial ) {\r\n\r\n\t\t\t\t\t// Generate color palette\r\n\t\t\t\t\tif ( ! material.palette ) {\r\n\r\n\t\t\t\t\t\tmaterial.palette = getPalette( material, false );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( material instanceof MeshPhongMaterial ) {\r\n\r\n\t\t\t\t\t// Generate color palette\r\n\t\t\t\t\tif ( ! material.palette ) {\r\n\r\n\t\t\t\t\t\tmaterial.palette = getPalette( material, true );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar string;\r\n\r\n\t\t\t\tif ( material.map ) {\r\n\r\n\t\t\t\t\tvar texture = new SoftwareRenderer.Texture();\r\n\t\t\t\t\ttexture.fromImage( material.map.image );\r\n\r\n\t\t\t\t\tif ( ! texture.data ) { return; }\r\n\r\n\t\t\t\t\ttextures[ material.map.id ] = texture;\r\n\r\n\t\t\t\t\tif ( material instanceof MeshBasicMaterial\r\n\t\t\t\t\t\t|| material instanceof SpriteMaterial ) {\r\n\r\n\t\t\t\t\t\tshader = basicMaterialShader;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tshader = lightingMaterialShader;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( material.vertexColors === FaceColors ) {\r\n\r\n\t\t\t\t\t\tstring = [\r\n\t\t\t\t\t\t\t'var colorOffset = offset * 4;',\r\n\t\t\t\t\t\t\t'buffer[ colorOffset ] = face.color.r * 255;',\r\n\t\t\t\t\t\t\t'buffer[ colorOffset + 1 ] = face.color.g * 255;',\r\n\t\t\t\t\t\t\t'buffer[ colorOffset + 2 ] = face.color.b * 255;',\r\n\t\t\t\t\t\t\t'buffer[ colorOffset + 3 ] = material.opacity * 255;',\r\n\t\t\t\t\t\t\t'depthBuf[ offset ] = depth;'\r\n\t\t\t\t\t\t].join( '\\n' );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tstring = [\r\n\t\t\t\t\t\t\t'var colorOffset = offset * 4;',\r\n\t\t\t\t\t\t\t'buffer[ colorOffset ] = material.color.r * 255;',\r\n\t\t\t\t\t\t\t'buffer[ colorOffset + 1 ] = material.color.g * 255;',\r\n\t\t\t\t\t\t\t'buffer[ colorOffset + 2 ] = material.color.b * 255;',\r\n\t\t\t\t\t\t\t'buffer[ colorOffset + 3 ] = material.opacity * 255;',\r\n\t\t\t\t\t\t\t'depthBuf[ offset ] = depth;'\r\n\t\t\t\t\t\t].join( '\\n' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tshader = new Function( 'buffer, depthBuf, offset, depth, u, v, n, face, material', string );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material instanceof LineBasicMaterial ) {\r\n\r\n\t\t\t\tvar string = [\r\n\t\t\t\t\t'var colorOffset = offset * 4;',\r\n\t\t\t\t\t'buffer[ colorOffset ] = material.color.r * (color1.r+color2.r) * 0.5 * 255;',\r\n\t\t\t\t\t'buffer[ colorOffset + 1 ] = material.color.g * (color1.g+color2.g) * 0.5 * 255;',\r\n\t\t\t\t\t'buffer[ colorOffset + 2 ] = material.color.b * (color1.b+color2.b) * 0.5 * 255;',\r\n\t\t\t\t\t'buffer[ colorOffset + 3 ] = 255;',\r\n\t\t\t\t\t'depthBuf[ offset ] = depth;'\r\n\t\t\t\t].join( '\\n' );\r\n\r\n\t\t\t\tshader = new Function( 'buffer, depthBuf, offset, depth, color1, color2, material', string );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar string = [\r\n\t\t\t\t\t'var colorOffset = offset * 4;',\r\n\t\t\t\t\t'buffer[ colorOffset ] = u * 255;',\r\n\t\t\t\t\t'buffer[ colorOffset + 1 ] = v * 255;',\r\n\t\t\t\t\t'buffer[ colorOffset + 2 ] = 0;',\r\n\t\t\t\t\t'buffer[ colorOffset + 3 ] = 255;',\r\n\t\t\t\t\t'depthBuf[ offset ] = depth;'\r\n\t\t\t\t].join( '\\n' );\r\n\r\n\t\t\t\tshader = new Function( 'buffer, depthBuf, offset, depth, u, v, n, face, material', string );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshaders[ id ] = shader;\r\n\r\n\t\t\tmaterial.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\treturn shader;\r\n\r\n\t}\r\n\r\n\tfunction drawTriangle( v1, v2, v3, uv1, uv2, uv3, shader, face, material ) {\r\n\r\n\t\t// TODO: Implement per-pixel z-clipping\r\n\r\n\t\tif ( v1.z < - 1 || v1.z > 1 || v2.z < - 1 || v2.z > 1 || v3.z < - 1 || v3.z > 1 ) { return; }\r\n\r\n\t\t// https://gist.github.com/2486101\r\n\t\t// explanation: http://pouet.net/topic.php?which=8760&page=1\r\n\r\n\t\tvar fixscale = ( 1 << subpixelBits );\r\n\r\n\t\t// 28.4 fixed-point coordinates\r\n\r\n\t\tvar x1 = ( v1.x * viewportXScale + viewportXOffs ) | 0;\r\n\t\tvar x2 = ( v2.x * viewportXScale + viewportXOffs ) | 0;\r\n\t\tvar x3 = ( v3.x * viewportXScale + viewportXOffs ) | 0;\r\n\r\n\t\tvar y1 = ( v1.y * viewportYScale + viewportYOffs ) | 0;\r\n\t\tvar y2 = ( v2.y * viewportYScale + viewportYOffs ) | 0;\r\n\t\tvar y3 = ( v3.y * viewportYScale + viewportYOffs ) | 0;\r\n\r\n\t\tvar bHasNormal = face.vertexNormalsModel && face.vertexNormalsModel.length;\r\n\t\tvar bHasUV = uv1 && uv2 && uv3;\r\n\r\n\t\tvar longestSide = Math.max(\r\n\t\t\tMath.sqrt( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ),\r\n\t\t\tMath.sqrt( ( x2 - x3 ) * ( x2 - x3 ) + ( y2 - y3 ) * ( y2 - y3 ) ),\r\n\t\t\tMath.sqrt( ( x3 - x1 ) * ( x3 - x1 ) + ( y3 - y1 ) * ( y3 - y1 ) )\r\n\t\t);\r\n\r\n\t\tif ( ! ( face instanceof RenderableSprite ) && ( longestSide > 100 * fixscale ) ) {\r\n\r\n\t\t\t// 1\r\n\t\t\t// |\\\r\n\t\t\t// |a\\\r\n\t\t\t// |__\\\r\n\t\t\t// |\\c|\\\r\n\t\t\t// |b\\|d\\\r\n\t\t\t// |__\\__\\\r\n\t\t\t// 2      3\r\n\t\t\tvar tempFace = { vertexNormalsModel: [], color: face.color };\r\n\t\t\tvar mpUV12, mpUV23, mpUV31;\r\n\r\n\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\tif ( mpUVPoolCount === mpUVPool.length ) {\r\n\r\n\t\t\t\t\tmpUV12 = new Vector2();\r\n\t\t\t\t\tmpUVPool.push( mpUV12 );\r\n\t\t\t\t\t++ mpUVPoolCount;\r\n\r\n\t\t\t\t\tmpUV23 = new Vector2();\r\n\t\t\t\t\tmpUVPool.push( mpUV23 );\r\n\t\t\t\t\t++ mpUVPoolCount;\r\n\r\n\t\t\t\t\tmpUV31 = new Vector2();\r\n\t\t\t\t\tmpUVPool.push( mpUV31 );\r\n\t\t\t\t\t++ mpUVPoolCount;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmpUV12 = mpUVPool[ mpUVPoolCount ];\r\n\t\t\t\t\t++ mpUVPoolCount;\r\n\r\n\t\t\t\t\tmpUV23 = mpUVPool[ mpUVPoolCount ];\r\n\t\t\t\t\t++ mpUVPoolCount;\r\n\r\n\t\t\t\t\tmpUV31 = mpUVPool[ mpUVPoolCount ];\r\n\t\t\t\t\t++ mpUVPoolCount;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar weight;\r\n\r\n\t\t\t\tweight = ( 1 + v2.z ) * ( v2.w / v1.w ) / ( 1 + v1.z );\r\n\t\t\t\tmpUV12.copy( uv1 ).multiplyScalar( weight ).add( uv2 ).multiplyScalar( 1 / ( weight + 1 ) );\r\n\r\n\t\t\t\tweight = ( 1 + v3.z ) * ( v3.w / v2.w ) / ( 1 + v2.z );\r\n\t\t\t\tmpUV23.copy( uv2 ).multiplyScalar( weight ).add( uv3 ).multiplyScalar( 1 / ( weight + 1 ) );\r\n\r\n\t\t\t\tweight = ( 1 + v1.z ) * ( v1.w / v3.w ) / ( 1 + v3.z );\r\n\t\t\t\tmpUV31.copy( uv3 ).multiplyScalar( weight ).add( uv1 ).multiplyScalar( 1 / ( weight + 1 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar mpV12, mpV23, mpV31;\r\n\r\n\t\t\tif ( mpVPoolCount === mpVPool.length ) {\r\n\r\n\t\t\t\tmpV12 = new Vector4();\r\n\t\t\t\tmpVPool.push( mpV12 );\r\n\t\t\t\t++ mpVPoolCount;\r\n\r\n\t\t\t\tmpV23 = new Vector4();\r\n\t\t\t\tmpVPool.push( mpV23 );\r\n\t\t\t\t++ mpVPoolCount;\r\n\r\n\t\t\t\tmpV31 = new Vector4();\r\n\t\t\t\tmpVPool.push( mpV31 );\r\n\t\t\t\t++ mpVPoolCount;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmpV12 = mpVPool[ mpVPoolCount ];\r\n\t\t\t\t++ mpVPoolCount;\r\n\r\n\t\t\t\tmpV23 = mpVPool[ mpVPoolCount ];\r\n\t\t\t\t++ mpVPoolCount;\r\n\r\n\t\t\t\tmpV31 = mpVPool[ mpVPoolCount ];\r\n\t\t\t\t++ mpVPoolCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmpV12.copy( v1 ).add( v2 ).multiplyScalar( 0.5 );\r\n\t\t\tmpV23.copy( v2 ).add( v3 ).multiplyScalar( 0.5 );\r\n\t\t\tmpV31.copy( v3 ).add( v1 ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tvar mpN12, mpN23, mpN31;\r\n\r\n\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\tif ( mpNPoolCount === mpNPool.length ) {\r\n\r\n\t\t\t\t\tmpN12 = new Vector3();\r\n\t\t\t\t\tmpNPool.push( mpN12 );\r\n\t\t\t\t\t++ mpNPoolCount;\r\n\r\n\t\t\t\t\tmpN23 = new Vector3();\r\n\t\t\t\t\tmpNPool.push( mpN23 );\r\n\t\t\t\t\t++ mpNPoolCount;\r\n\r\n\t\t\t\t\tmpN31 = new Vector3();\r\n\t\t\t\t\tmpNPool.push( mpN31 );\r\n\t\t\t\t\t++ mpNPoolCount;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmpN12 = mpNPool[ mpNPoolCount ];\r\n\t\t\t\t\t++ mpNPoolCount;\r\n\r\n\t\t\t\t\tmpN23 = mpNPool[ mpNPoolCount ];\r\n\t\t\t\t\t++ mpNPoolCount;\r\n\r\n\t\t\t\t\tmpN31 = mpNPool[ mpNPoolCount ];\r\n\t\t\t\t\t++ mpNPoolCount;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmpN12.copy( face.vertexNormalsModel[ 0 ] ).add( face.vertexNormalsModel[ 1 ] ).normalize();\r\n\t\t\t\tmpN23.copy( face.vertexNormalsModel[ 1 ] ).add( face.vertexNormalsModel[ 2 ] ).normalize();\r\n\t\t\t\tmpN31.copy( face.vertexNormalsModel[ 2 ] ).add( face.vertexNormalsModel[ 0 ] ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// a\r\n\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\ttempFace.vertexNormalsModel[ 0 ] = face.vertexNormalsModel[ 0 ];\r\n\t\t\t\ttempFace.vertexNormalsModel[ 1 ] = mpN12;\r\n\t\t\t\ttempFace.vertexNormalsModel[ 2 ] = mpN31;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdrawTriangle( v1, mpV12, mpV31, uv1, mpUV12, mpUV31, shader, tempFace, material );\r\n\r\n\t\t\t// b\r\n\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\ttempFace.vertexNormalsModel[ 0 ] = face.vertexNormalsModel[ 1 ];\r\n\t\t\t\ttempFace.vertexNormalsModel[ 1 ] = mpN23;\r\n\t\t\t\ttempFace.vertexNormalsModel[ 2 ] = mpN12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdrawTriangle( v2, mpV23, mpV12, uv2, mpUV23, mpUV12, shader, tempFace, material );\r\n\r\n\t\t\t// c\r\n\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\ttempFace.vertexNormalsModel[ 0 ] = mpN12;\r\n\t\t\t\ttempFace.vertexNormalsModel[ 1 ] = mpN23;\r\n\t\t\t\ttempFace.vertexNormalsModel[ 2 ] = mpN31;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdrawTriangle( mpV12, mpV23, mpV31, mpUV12, mpUV23, mpUV31, shader, tempFace, material );\r\n\r\n\t\t\t// d\r\n\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\ttempFace.vertexNormalsModel[ 0 ] = face.vertexNormalsModel[ 2 ];\r\n\t\t\t\ttempFace.vertexNormalsModel[ 1 ] = mpN31;\r\n\t\t\t\ttempFace.vertexNormalsModel[ 2 ] = mpN23;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdrawTriangle( v3, mpV31, mpV23, uv3, mpUV31, mpUV23, shader, tempFace, material );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// Z values (.28 fixed-point)\r\n\r\n\t\tvar z1 = ( v1.z * viewportZScale + viewportZOffs ) | 0;\r\n\t\tvar z2 = ( v2.z * viewportZScale + viewportZOffs ) | 0;\r\n\t\tvar z3 = ( v3.z * viewportZScale + viewportZOffs ) | 0;\r\n\r\n\t\t// UV values\r\n\t\tvar bHasUV = false;\r\n\t\tvar tu1, tv1, tu2, tv2, tu3, tv3;\r\n\r\n\t\tif ( uv1 && uv2 && uv3 ) {\r\n\r\n\t\t\tbHasUV = true;\r\n\r\n\t\t\ttu1 = uv1.x;\r\n\t\t\ttv1 = 1 - uv1.y;\r\n\t\t\ttu2 = uv2.x;\r\n\t\t\ttv2 = 1 - uv2.y;\r\n\t\t\ttu3 = uv3.x;\r\n\t\t\ttv3 = 1 - uv3.y;\r\n\r\n\t\t}\r\n\r\n\t\t// Normal values\r\n\t\tvar n1, n2, n3, nz1, nz2, nz3;\r\n\r\n\t\tif ( bHasNormal ) {\r\n\r\n\t\t\tn1 = face.vertexNormalsModel[ 0 ];\r\n\t\t\tn2 = face.vertexNormalsModel[ 1 ];\r\n\t\t\tn3 = face.vertexNormalsModel[ 2 ];\r\n\t\t\tnz1 = n1.z * 255;\r\n\t\t\tnz2 = n2.z * 255;\r\n\t\t\tnz3 = n3.z * 255;\r\n\r\n\t\t}\r\n\r\n\t\t// Deltas\r\n\r\n\t\tvar dx12 = x1 - x2, dy12 = y2 - y1;\r\n\t\tvar dx23 = x2 - x3, dy23 = y3 - y2;\r\n\t\tvar dx31 = x3 - x1, dy31 = y1 - y3;\r\n\r\n\t\t// Bounding rectangle\r\n\r\n\t\tvar minx = Math.max( ( Math.min( x1, x2, x3 ) + subpixelBias ) >> subpixelBits, 0 );\r\n\t\tvar maxx = Math.min( ( Math.max( x1, x2, x3 ) + subpixelBias ) >> subpixelBits, canvasWidth );\r\n\t\tvar miny = Math.max( ( Math.min( y1, y2, y3 ) + subpixelBias ) >> subpixelBits, 0 );\r\n\t\tvar maxy = Math.min( ( Math.max( y1, y2, y3 ) + subpixelBias ) >> subpixelBits, canvasHeight );\r\n\r\n\t\trectx1 = Math.min( minx, rectx1 );\r\n\t\trectx2 = Math.max( maxx, rectx2 );\r\n\t\trecty1 = Math.min( miny, recty1 );\r\n\t\trecty2 = Math.max( maxy, recty2 );\r\n\r\n\t\t// Block size, standard 8x8 (must be power of two)\r\n\r\n\t\tvar q = blockSize;\r\n\r\n\t\t// Start in corner of 8x8 block\r\n\r\n\t\tminx &= ~ ( q - 1 );\r\n\t\tminy &= ~ ( q - 1 );\r\n\r\n\t\t// Constant part of half-edge functions\r\n\r\n\t\tvar minXfixscale = ( minx << subpixelBits );\r\n\t\tvar minYfixscale = ( miny << subpixelBits );\r\n\r\n\t\tvar c1 = dy12 * ( ( minXfixscale ) - x1 ) + dx12 * ( ( minYfixscale ) - y1 );\r\n\t\tvar c2 = dy23 * ( ( minXfixscale ) - x2 ) + dx23 * ( ( minYfixscale ) - y2 );\r\n\t\tvar c3 = dy31 * ( ( minXfixscale ) - x3 ) + dx31 * ( ( minYfixscale ) - y3 );\r\n\r\n\t\t// Correct for fill convention\r\n\r\n\t\tif ( dy12 > 0 || ( dy12 == 0 && dx12 > 0 ) ) { c1 ++; }\r\n\t\tif ( dy23 > 0 || ( dy23 == 0 && dx23 > 0 ) ) { c2 ++; }\r\n\t\tif ( dy31 > 0 || ( dy31 == 0 && dx31 > 0 ) ) { c3 ++; }\r\n\r\n\t\t// Note this doesn't kill subpixel precision, but only because we test for >=0 (not >0).\r\n\t\t// It's a bit subtle. :)\r\n\t\tc1 = ( c1 - 1 ) >> subpixelBits;\r\n\t\tc2 = ( c2 - 1 ) >> subpixelBits;\r\n\t\tc3 = ( c3 - 1 ) >> subpixelBits;\r\n\r\n\t\t// Z interpolation setup\r\n\r\n\t\tvar dz12 = z1 - z2, dz31 = z3 - z1;\r\n\t\tvar invDet = 1.0 / ( dx12 * dy31 - dx31 * dy12 );\r\n\t\tvar dzdx = ( invDet * ( dz12 * dy31 - dz31 * dy12 ) ); // dz per one subpixel step in x\r\n\t\tvar dzdy = ( invDet * ( dz12 * dx31 - dx12 * dz31 ) ); // dz per one subpixel step in y\r\n\r\n\t\t// Z at top/left corner of rast area\r\n\r\n\t\tvar cz = ( z1 + ( ( minXfixscale ) - x1 ) * dzdx + ( ( minYfixscale ) - y1 ) * dzdy ) | 0;\r\n\r\n\t\t// Z pixel steps\r\n\r\n\t\tdzdx = ( dzdx * fixscale ) | 0;\r\n\t\tdzdy = ( dzdy * fixscale ) | 0;\r\n\r\n\t\tvar dtvdx, dtvdy, cbtu, cbtv;\r\n\t\tif ( bHasUV ) {\r\n\r\n\t\t\t// UV interpolation setup\r\n\t\t\tvar dtu12 = tu1 - tu2, dtu31 = tu3 - tu1;\r\n\t\t\tvar dtudx = ( invDet * ( dtu12 * dy31 - dtu31 * dy12 ) ); // dtu per one subpixel step in x\r\n\t\t\tvar dtudy = ( invDet * ( dtu12 * dx31 - dx12 * dtu31 ) ); // dtu per one subpixel step in y\r\n\t\t\tvar dtv12 = tv1 - tv2, dtv31 = tv3 - tv1;\r\n\t\t\tdtvdx = ( invDet * ( dtv12 * dy31 - dtv31 * dy12 ) ); // dtv per one subpixel step in x\r\n\t\t\tdtvdy = ( invDet * ( dtv12 * dx31 - dx12 * dtv31 ) ); // dtv per one subpixel step in y\r\n\r\n\t\t\t// UV at top/left corner of rast area\r\n\t\t\tcbtu = ( tu1 + ( minXfixscale - x1 ) * dtudx + ( minYfixscale - y1 ) * dtudy );\r\n\t\t\tcbtv = ( tv1 + ( minXfixscale - x1 ) * dtvdx + ( minYfixscale - y1 ) * dtvdy );\r\n\r\n\t\t\t// UV pixel steps\r\n\t\t\tdtudx = dtudx * fixscale;\r\n\t\t\tdtudy = dtudy * fixscale;\r\n\t\t\tdtvdx = dtvdx * fixscale;\r\n\t\t\tdtvdy = dtvdy * fixscale;\r\n\r\n\t\t}\r\n\r\n\t\tvar dnzdy, cbnz;\r\n\r\n\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t // Normal interpolation setup\r\n\t\t\tvar dnz12 = nz1 - nz2, dnz31 = nz3 - nz1;\r\n\t\t\tvar dnzdx = ( invDet * ( dnz12 * dy31 - dnz31 * dy12 ) ); // dnz per one subpixel step in x\r\n\t\t\tvar dnzdy = ( invDet * ( dnz12 * dx31 - dx12 * dnz31 ) ); // dnz per one subpixel step in y\r\n\r\n\t\t\t// Normal at top/left corner of rast area\r\n\t\t\tcbnz = ( nz1 + ( minXfixscale - x1 ) * dnzdx + ( minYfixscale - y1 ) * dnzdy );\r\n\r\n\t\t\t// Normal pixel steps\r\n\t\t\tdnzdx = ( dnzdx * fixscale );\r\n\t\t\tdnzdy = ( dnzdy * fixscale );\r\n\r\n\t\t}\r\n\r\n\t\t// Set up min/max corners\r\n\t\tvar qm1 = q - 1; // for convenience\r\n\t\tvar nmin1 = 0, nmax1 = 0;\r\n\t\tvar nmin2 = 0, nmax2 = 0;\r\n\t\tvar nmin3 = 0, nmax3 = 0;\r\n\t\tvar nminz = 0, nmaxz = 0;\r\n\t\tif ( dx12 >= 0 ) { nmax1 -= qm1 * dx12; } else { nmin1 -= qm1 * dx12; }\r\n\t\tif ( dy12 >= 0 ) { nmax1 -= qm1 * dy12; } else { nmin1 -= qm1 * dy12; }\r\n\t\tif ( dx23 >= 0 ) { nmax2 -= qm1 * dx23; } else { nmin2 -= qm1 * dx23; }\r\n\t\tif ( dy23 >= 0 ) { nmax2 -= qm1 * dy23; } else { nmin2 -= qm1 * dy23; }\r\n\t\tif ( dx31 >= 0 ) { nmax3 -= qm1 * dx31; } else { nmin3 -= qm1 * dx31; }\r\n\t\tif ( dy31 >= 0 ) { nmax3 -= qm1 * dy31; } else { nmin3 -= qm1 * dy31; }\r\n\t\tif ( dzdx >= 0 ) { nmaxz += qm1 * dzdx; } else { nminz += qm1 * dzdx; }\r\n\t\tif ( dzdy >= 0 ) { nmaxz += qm1 * dzdy; } else { nminz += qm1 * dzdy; }\r\n\r\n\t\t// Loop through blocks\r\n\t\tvar linestep = canvasWidth - q;\r\n\r\n\t\tvar cb1 = c1;\r\n\t\tvar cb2 = c2;\r\n\t\tvar cb3 = c3;\r\n\t\tvar cbz = cz;\r\n\t\tvar qstep = - q;\r\n\t\tvar e1x = qstep * dy12;\r\n\t\tvar e2x = qstep * dy23;\r\n\t\tvar e3x = qstep * dy31;\r\n\t\tvar ezx = qstep * dzdx;\r\n\r\n\t\tvar etux, etvx;\r\n\t\tif ( bHasUV ) {\r\n\r\n\t\t\tetux = qstep * dtudx;\r\n\t\t\tetvx = qstep * dtvdx;\r\n\r\n\t\t}\r\n\r\n\t\tvar enzx;\r\n\t\tif ( bHasNormal ) {\r\n\r\n\t\t\tenzx = qstep * dnzdx;\r\n\r\n\t\t}\r\n\r\n\t\tvar x0 = minx;\r\n\r\n\t\tfor ( var y0 = miny; y0 < maxy; y0 += q ) {\r\n\r\n\t\t\t// New block line - keep hunting for tri outer edge in old block line dir\r\n\t\t\twhile ( x0 >= minx && x0 < maxx && cb1 >= nmax1 && cb2 >= nmax2 && cb3 >= nmax3 ) {\r\n\r\n\t\t\t\tx0 += qstep;\r\n\t\t\t\tcb1 += e1x;\r\n\t\t\t\tcb2 += e2x;\r\n\t\t\t\tcb3 += e3x;\r\n\t\t\t\tcbz += ezx;\r\n\r\n\t\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\t\tcbtu += etux;\r\n\t\t\t\t\tcbtv += etvx;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\t\tcbnz += enzx;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Okay, we're now in a block we know is outside. Reverse direction and go into main loop.\r\n\t\t\tqstep = - qstep;\r\n\t\t\te1x = - e1x;\r\n\t\t\te2x = - e2x;\r\n\t\t\te3x = - e3x;\r\n\t\t\tezx = - ezx;\r\n\r\n\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\tetux = - etux;\r\n\t\t\t\tetvx = - etvx;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\tenzx = - enzx;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( 1 ) {\r\n\r\n\t\t\t\t// Step everything\r\n\t\t\t\tx0 += qstep;\r\n\t\t\t\tcb1 += e1x;\r\n\t\t\t\tcb2 += e2x;\r\n\t\t\t\tcb3 += e3x;\r\n\t\t\t\tcbz += ezx;\r\n\r\n\t\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\t\tcbtu += etux;\r\n\t\t\t\t\tcbtv += etvx;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\t\tcbnz += enzx;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// We're done with this block line when at least one edge completely out\r\n\t\t\t\t// If an edge function is too small and decreasing in the current traversal\r\n\t\t\t\t// dir, we're done with this line.\r\n\t\t\t\tif ( x0 < minx || x0 >= maxx ) { break; }\r\n\t\t\t\tif ( cb1 < nmax1 ) { if ( e1x < 0 ) { break; } else { continue; } }\r\n\t\t\t\tif ( cb2 < nmax2 ) { if ( e2x < 0 ) { break; } else { continue; } }\r\n\t\t\t\tif ( cb3 < nmax3 ) { if ( e3x < 0 ) { break; } else { continue; } }\r\n\r\n\t\t\t\t// We can skip this block if it's already fully covered\r\n\t\t\t\tvar blockX = x0 >> blockShift;\r\n\t\t\t\tvar blockY = y0 >> blockShift;\r\n\t\t\t\tvar blockId = blockX + blockY * canvasWBlocks;\r\n\t\t\t\tvar minz = cbz + nminz;\r\n\r\n\t\t\t\t// farthest point in block closer than closest point in our tri?\r\n\t\t\t\tif ( blockMaxZ[ blockId ] < minz ) { continue; }\r\n\r\n\t\t\t\t// Need to do a deferred clear?\r\n\t\t\t\tvar bflags = blockFlags[ blockId ];\r\n\t\t\t\tif ( bflags & BLOCK_NEEDCLEAR ) { clearBlock( blockX, blockY ); }\r\n\t\t\t\tblockFlags[ blockId ] = bflags & ~ ( BLOCK_ISCLEAR | BLOCK_NEEDCLEAR );\r\n\r\n\t\t\t\t// Offset at top-left corner\r\n\t\t\t\tvar offset = x0 + y0 * canvasWidth;\r\n\r\n\t\t\t\t// Accept whole block when fully covered\r\n\t\t\t\tif ( cb1 >= nmin1 && cb2 >= nmin2 && cb3 >= nmin3 ) {\r\n\r\n\t\t\t\t\tvar maxz = cbz + nmaxz;\r\n\t\t\t\t\tblockMaxZ[ blockId ] = Math.min( blockMaxZ[ blockId ], maxz );\r\n\r\n\t\t\t\t\tvar cy1 = cb1;\r\n\t\t\t\t\tvar cy2 = cb2;\r\n\t\t\t\t\tvar cyz = cbz;\r\n\r\n\t\t\t\t\tvar cytu, cytv;\r\n\t\t\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\t\t\tcytu = cbtu;\r\n\t\t\t\t\t\tcytv = cbtv;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar cynz;\r\n\t\t\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\t\t\tcynz = cbnz;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var iy = 0; iy < q; iy ++ ) {\r\n\r\n\t\t\t\t\t\tvar cx1 = cy1;\r\n\t\t\t\t\t\tvar cx2 = cy2;\r\n\t\t\t\t\t\tvar cxz = cyz;\r\n\r\n\t\t\t\t\t\tvar cxtu;\r\n\t\t\t\t\t\tvar cxtv;\r\n\t\t\t\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\t\t\t\tcxtu = cytu;\r\n\t\t\t\t\t\t\tcxtv = cytv;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar cxnz;\r\n\t\t\t\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\t\t\t\tcxnz = cynz;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( var ix = 0; ix < q; ix ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar z = cxz;\r\n\r\n\t\t\t\t\t\t\tif ( z < zbuffer[ offset ] ) {\r\n\r\n\t\t\t\t\t\t\t\tshader( data, zbuffer, offset, z, cxtu, cxtv, cxnz, face, material );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tcx1 += dy12;\r\n\t\t\t\t\t\t\tcx2 += dy23;\r\n\t\t\t\t\t\t\tcxz += dzdx;\r\n\r\n\t\t\t\t\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\t\t\t\t\tcxtu += dtudx;\r\n\t\t\t\t\t\t\t\tcxtv += dtvdx;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\t\t\t\t\tcxnz += dnzdx;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\toffset ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcy1 += dx12;\r\n\t\t\t\t\t\tcy2 += dx23;\r\n\t\t\t\t\t\tcyz += dzdy;\r\n\r\n\t\t\t\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\t\t\t\tcytu += dtudy;\r\n\t\t\t\t\t\t\tcytv += dtvdy;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\t\t\t\tcynz += dnzdy;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\toffset += linestep;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Partially covered block\r\n\r\n\t\t\t\t\tvar cy1 = cb1;\r\n\t\t\t\t\tvar cy2 = cb2;\r\n\t\t\t\t\tvar cy3 = cb3;\r\n\t\t\t\t\tvar cyz = cbz;\r\n\r\n\t\t\t\t\tvar cytu, cytv;\r\n\t\t\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\t\t\tcytu = cbtu;\r\n\t\t\t\t\t\tcytv = cbtv;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar cynz;\r\n\t\t\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\t\t\tcynz = cbnz;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var iy = 0; iy < q; iy ++ ) {\r\n\r\n\t\t\t\t\t\tvar cx1 = cy1;\r\n\t\t\t\t\t\tvar cx2 = cy2;\r\n\t\t\t\t\t\tvar cx3 = cy3;\r\n\t\t\t\t\t\tvar cxz = cyz;\r\n\r\n\t\t\t\t\t\tvar cxtu;\r\n\t\t\t\t\t\tvar cxtv;\r\n\t\t\t\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\t\t\t\tcxtu = cytu;\r\n\t\t\t\t\t\t\tcxtv = cytv;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar cxnz;\r\n\t\t\t\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\t\t\t\tcxnz = cynz;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( var ix = 0; ix < q; ix ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( ( cx1 | cx2 | cx3 ) >= 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tvar z = cxz;\r\n\r\n\t\t\t\t\t\t\t\tif ( z < zbuffer[ offset ] ) {\r\n\r\n\t\t\t\t\t\t\t\t\tshader( data, zbuffer, offset, z, cxtu, cxtv, cxnz, face, material );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tcx1 += dy12;\r\n\t\t\t\t\t\t\tcx2 += dy23;\r\n\t\t\t\t\t\t\tcx3 += dy31;\r\n\t\t\t\t\t\t\tcxz += dzdx;\r\n\r\n\t\t\t\t\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\t\t\t\t\tcxtu += dtudx;\r\n\t\t\t\t\t\t\t\tcxtv += dtvdx;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\t\t\t\t\tcxnz += dnzdx;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\toffset ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcy1 += dx12;\r\n\t\t\t\t\t\tcy2 += dx23;\r\n\t\t\t\t\t\tcy3 += dx31;\r\n\t\t\t\t\t\tcyz += dzdy;\r\n\r\n\t\t\t\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\t\t\t\tcytu += dtudy;\r\n\t\t\t\t\t\t\tcytv += dtvdy;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\t\t\t\tcynz += dnzdy;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\toffset += linestep;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Advance to next row of blocks\r\n\t\t\tcb1 += q * dx12;\r\n\t\t\tcb2 += q * dx23;\r\n\t\t\tcb3 += q * dx31;\r\n\t\t\tcbz += q * dzdy;\r\n\r\n\t\t\tif ( bHasUV ) {\r\n\r\n\t\t\t\tcbtu += q * dtudy;\r\n\t\t\t\tcbtv += q * dtvdy;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( bHasNormal ) {\r\n\r\n\t\t\t\tcbnz += q * dnzdy;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// When drawing line, the blockShiftShift has to be zero. In order to clean pixel\r\n\t// Using color1 and color2 to interpolation pixel color\r\n\t// LineWidth is according to material.linewidth\r\n\tfunction drawLine( v1, v2, color1, color2, shader, material ) {\r\n\r\n\t\t// While the line mode is enable, blockSize has to be changed to 0.\r\n\t\tif ( ! lineMode ) {\r\n\r\n\t\t\tlineMode = true;\r\n\t\t\tblockShift = 0;\r\n\t\t\tblockSize = 1 << blockShift;\r\n\r\n\t\t\t_this.setSize( canvas.width, canvas.height );\r\n\r\n\t\t}\r\n\r\n\t\t// TODO: Implement per-pixel z-clipping\r\n\t\tif ( v1.z < - 1 || v1.z > 1 || v2.z < - 1 || v2.z > 1 ) { return; }\r\n\r\n\t\tvar halfLineWidth = Math.floor( ( material.linewidth - 1 ) * 0.5 );\r\n\r\n\t\t// https://gist.github.com/2486101\r\n\t\t// explanation: http://pouet.net/topic.php?which=8760&page=1\r\n\r\n\t\t// 28.4 fixed-point coordinates\r\n\t\tvar x1 = ( v1.x * viewportXScale + viewportXOffs ) | 0;\r\n\t\tvar x2 = ( v2.x * viewportXScale + viewportXOffs ) | 0;\r\n\r\n\t\tvar y1 = ( v1.y * viewportYScale + viewportYOffs ) | 0;\r\n\t\tvar y2 = ( v2.y * viewportYScale + viewportYOffs ) | 0;\r\n\r\n\t\tvar z1 = ( v1.z * viewportZScale + viewportZOffs ) | 0;\r\n\t\tvar z2 = ( v2.z * viewportZScale + viewportZOffs ) | 0;\r\n\r\n\t\t// Deltas\r\n\t\tvar dx12 = x1 - x2, dy12 = y1 - y2, dz12 = z1 - z2;\r\n\r\n\t\t// Bounding rectangle\r\n\t\tvar minx = Math.max( ( Math.min( x1, x2 ) + subpixelBias ) >> subpixelBits, 0 );\r\n\t\tvar maxx = Math.min( ( Math.max( x1, x2 ) + subpixelBias ) >> subpixelBits, canvasWidth );\r\n\t\tvar miny = Math.max( ( Math.min( y1, y2 ) + subpixelBias ) >> subpixelBits, 0 );\r\n\t\tvar maxy = Math.min( ( Math.max( y1, y2 ) + subpixelBias ) >> subpixelBits, canvasHeight );\r\n\t\tvar minz = Math.max( ( Math.min( z1, z2 ) + subpixelBias ) >> subpixelBits, 0 );\r\n\t\tvar maxz = ( Math.max( z1, z2 ) + subpixelBias ) >> subpixelBits;\r\n\r\n\t\trectx1 = Math.min( minx, rectx1 );\r\n\t\trectx2 = Math.max( maxx, rectx2 );\r\n\t\trecty1 = Math.min( miny, recty1 );\r\n\t\trecty2 = Math.max( maxy, recty2 );\r\n\r\n\t\t// Get the line's unit vector and cross vector\r\n\t\tvar length = Math.sqrt( ( dy12 * dy12 ) + ( dx12 * dx12 ) );\r\n\t\tvar unitX = ( dx12 / length );\r\n\t\tvar unitY = ( dy12 / length );\r\n\t\tvar unitZ = ( dz12 / length );\r\n\t\tvar pixelX, pixelY, pixelZ;\r\n\t\tvar pX, pY, pZ;\r\n\t\tcrossVector.set( unitX, unitY, unitZ );\r\n\t\tcrossVector.cross( lookVector );\r\n\t\tcrossVector.normalize();\r\n\r\n\t\twhile ( length > 0 ) {\r\n\r\n\t\t\t// Get this pixel.\r\n\t\t\tpixelX = x2 + length * unitX;\r\n\t\t\tpixelY = y2 + length * unitY;\r\n\t\t\tpixelZ = z2 + length * unitZ;\r\n\r\n\t\t\tpixelX = ( pixelX + subpixelBias ) >> subpixelBits;\r\n\t\t\tpixelY = ( pixelY + subpixelBias ) >> subpixelBits;\r\n\t\t\tpZ = ( pixelZ + subpixelBias ) >> subpixelBits;\r\n\r\n\t\t\t// Draw line with line width\r\n\t\t\tfor ( var i = - halfLineWidth; i <= halfLineWidth; ++ i ) {\r\n\r\n\t\t\t\t// Compute the line pixels.\r\n\t\t\t\t// Get the pixels on the vector that crosses to the line vector\r\n\t\t\t\tpX = Math.floor( ( pixelX + crossVector.x * i ) );\r\n\t\t\t\tpY = Math.floor( ( pixelY + crossVector.y * i ) );\r\n\r\n\t\t\t\t// if pixel is over the rect. Continue\r\n\t\t\t\tif ( rectx1 >= pX || rectx2 <= pX || recty1 >= pY || recty2 <= pY )\r\n\t\t\t\t\t{ continue; }\r\n\r\n\t\t\t\t// Find this pixel at which block\r\n\t\t\t\tvar blockX = pX >> blockShift;\r\n\t\t\t\tvar blockY = pY >> blockShift;\r\n\t\t\t\tvar blockId = blockX + blockY * canvasWBlocks;\r\n\r\n\t\t\t\t// Compare the pixel depth width z block.\r\n\t\t\t\tif ( blockMaxZ[ blockId ] < minz ) { continue; }\r\n\r\n\t\t\t\tblockMaxZ[ blockId ] = Math.min( blockMaxZ[ blockId ], maxz );\r\n\r\n\t\t\t\tvar bflags = blockFlags[ blockId ];\r\n\t\t\t\tif ( bflags & BLOCK_NEEDCLEAR ) { clearBlock( blockX, blockY ); }\r\n\t\t\t\tblockFlags[ blockId ] = bflags & ~ ( BLOCK_ISCLEAR | BLOCK_NEEDCLEAR );\r\n\r\n\t\t\t\t// draw pixel\r\n\t\t\t\tvar offset = pX + pY * canvasWidth;\r\n\r\n\t\t\t\tif ( pZ < zbuffer[ offset ] ) {\r\n\r\n\t\t\t\t\tshader( data, zbuffer, offset, pZ, color1, color2, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t-- length;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction clearBlock( blockX, blockY ) {\r\n\r\n\t\tvar zoffset = blockX * blockSize + blockY * blockSize * canvasWidth;\r\n\t\tvar poffset = zoffset * 4;\r\n\r\n\t\tvar zlinestep = canvasWidth - blockSize;\r\n\t\tvar plinestep = zlinestep * 4;\r\n\r\n\t\tfor ( var y = 0; y < blockSize; y ++ ) {\r\n\r\n\t\t\tfor ( var x = 0; x < blockSize; x ++ ) {\r\n\r\n\t\t\t\tzbuffer[ zoffset ++ ] = maxZVal;\r\n\r\n\t\t\t\tdata[ poffset ++ ] = clearColor.r * 255 | 0;\r\n\t\t\t\tdata[ poffset ++ ] = clearColor.g * 255 | 0;\r\n\t\t\t\tdata[ poffset ++ ] = clearColor.b * 255 | 0;\r\n\t\t\t\tdata[ poffset ++ ] = getAlpha() * 255 | 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tzoffset += zlinestep;\r\n\t\t\tpoffset += plinestep;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction finishClear( ) {\r\n\r\n\t\tvar block = 0;\r\n\r\n\t\tfor ( var y = 0; y < canvasHBlocks; y ++ ) {\r\n\r\n\t\t\tfor ( var x = 0; x < canvasWBlocks; x ++ ) {\r\n\r\n\t\t\t\tif ( blockFlags[ block ] & BLOCK_NEEDCLEAR ) {\r\n\r\n\t\t\t\t\tclearBlock( x, y );\r\n\t\t\t\t\tblockFlags[ block ] = BLOCK_ISCLEAR;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tblock ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nSoftwareRenderer.Texture = function () {\r\n\r\n\tvar canvas;\r\n\r\n\tthis.fromImage = function ( image ) {\r\n\r\n\t\tif ( ! image || image.width <= 0 || image.height <= 0 )\r\n\t\t\t{ return; }\r\n\r\n\t\tif ( canvas === undefined ) {\r\n\r\n\t\t\tcanvas = document.createElement( 'canvas' );\r\n\r\n\t\t}\r\n\r\n\t\tvar size = image.width > image.height ? image.width : image.height;\r\n\t\tsize = _Math.ceilPowerOfTwo( size );\r\n\r\n\t\tif ( canvas.width != size || canvas.height != size ) {\r\n\r\n\t\t\tcanvas.width = size;\r\n\t\t\tcanvas.height = size;\r\n\r\n\t\t}\r\n\r\n\t\tvar ctx = canvas.getContext( '2d' );\r\n\t\tctx.clearRect( 0, 0, size, size );\r\n\t\tctx.drawImage( image, 0, 0, size, size );\r\n\r\n\t\tvar imgData = ctx.getImageData( 0, 0, size, size );\r\n\r\n\t\tthis.data = imgData.data;\r\n\t\tthis.width = size;\r\n\t\tthis.height = size;\r\n\t\tthis.srcUrl = image.src;\r\n\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SVGObject = function ( node ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.node = node;\r\n\r\n};\r\n\r\nSVGObject.prototype = Object.create( Object3D.prototype );\r\nSVGObject.prototype.constructor = SVGObject;\r\n\r\nvar SVGRenderer = function () {\r\n\r\n\tconsole.log( 'SVGRenderer', REVISION );\r\n\r\n\tvar _this = this,\r\n\t\t_renderData, _elements, _lights,\r\n\t\t_projector = new Projector(),\r\n\t\t_svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ),\r\n\t\t_svgWidth, _svgHeight, _svgWidthHalf, _svgHeightHalf,\r\n\r\n\t\t_v1, _v2, _v3,\r\n\r\n\t\t_clipBox = new Box2(),\r\n\t\t_elemBox = new Box2(),\r\n\r\n\t\t_color = new Color(),\r\n\t\t_diffuseColor = new Color(),\r\n\t\t_ambientLight = new Color(),\r\n\t\t_directionalLights = new Color(),\r\n\t\t_pointLights = new Color(),\r\n\t\t_clearColor = new Color(),\r\n\t\t_clearAlpha = 1,\r\n\r\n\t\t_vector3 = new Vector3(), // Needed for PointLight\r\n\t\t_centroid = new Vector3(),\r\n\t\t_normal = new Vector3(),\r\n\t\t_normalViewMatrix = new Matrix3(),\r\n\r\n\t\t_viewMatrix = new Matrix4(),\r\n\t\t_viewProjectionMatrix = new Matrix4(),\r\n\r\n\t\t_svgPathPool = [],\r\n\t\t_svgNode, _pathCount = 0,\r\n\r\n\t\t_currentPath, _currentStyle,\r\n\r\n\t\t_quality = 1, _precision = null;\r\n\r\n\tthis.domElement = _svg;\r\n\r\n\tthis.autoClear = true;\r\n\tthis.sortObjects = true;\r\n\tthis.sortElements = true;\r\n\r\n\tthis.info = {\r\n\r\n\t\trender: {\r\n\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setQuality = function ( quality ) {\r\n\r\n\t\tswitch ( quality ) {\r\n\r\n\t\t\tcase \"high\": _quality = 1; break;\r\n\t\t\tcase \"low\": _quality = 0; break;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.set( color );\r\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function () {};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\t_svgWidth = width; _svgHeight = height;\r\n\t\t_svgWidthHalf = _svgWidth / 2; _svgHeightHalf = _svgHeight / 2;\r\n\r\n\t\t_svg.setAttribute( 'viewBox', ( - _svgWidthHalf ) + ' ' + ( - _svgHeightHalf ) + ' ' + _svgWidth + ' ' + _svgHeight );\r\n\t\t_svg.setAttribute( 'width', _svgWidth );\r\n\t\t_svg.setAttribute( 'height', _svgHeight );\r\n\r\n\t\t_clipBox.min.set( - _svgWidthHalf, - _svgHeightHalf );\r\n\t\t_clipBox.max.set( _svgWidthHalf, _svgHeightHalf );\r\n\r\n\t};\r\n\r\n\tthis.setPrecision = function ( precision ) {\r\n\r\n\t\t_precision = precision;\r\n\r\n\t};\r\n\r\n\tfunction removeChildNodes() {\r\n\r\n\t\t_pathCount = 0;\r\n\r\n\t\twhile ( _svg.childNodes.length > 0 ) {\r\n\r\n\t\t\t_svg.removeChild( _svg.childNodes[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getSvgColor( color, opacity ) {\r\n\r\n\t\tvar arg = Math.floor( color.r * 255 ) + ',' + Math.floor( color.g * 255 ) + ',' + Math.floor( color.b * 255 );\r\n\r\n\t\tif ( opacity === undefined || opacity === 1 ) { return 'rgb(' + arg + ')'; }\r\n\r\n\t\treturn 'rgb(' + arg + '); fill-opacity: ' + opacity;\r\n\r\n\t}\r\n\r\n\tfunction convert( c ) {\r\n\r\n\t\treturn _precision !== null ? c.toFixed( _precision ) : c;\r\n\r\n\t}\r\n\r\n\tthis.clear = function () {\r\n\r\n\t\tremoveChildNodes();\r\n\t\t_svg.style.backgroundColor = getSvgColor( _clearColor, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( camera instanceof Camera === false ) {\r\n\r\n\t\t\tconsole.error( 'SVGRenderer.render: camera is not an instance of Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar background = scene.background;\r\n\r\n\t\tif ( background && background.isColor ) {\r\n\r\n\t\t\tremoveChildNodes();\r\n\t\t\t_svg.style.backgroundColor = getSvgColor( background );\r\n\r\n\t\t} else if ( this.autoClear === true ) {\r\n\r\n\t\t\tthis.clear();\r\n\r\n\t\t}\r\n\r\n\t\t_this.info.render.vertices = 0;\r\n\t\t_this.info.render.faces = 0;\r\n\r\n\t\t_viewMatrix.copy( camera.matrixWorldInverse );\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\r\n\r\n\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\r\n\t\t_elements = _renderData.elements;\r\n\t\t_lights = _renderData.lights;\r\n\r\n\t\t_normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );\r\n\r\n\t\tcalculateLights( _lights );\r\n\r\n\t\t // reset accumulated path\r\n\r\n\t\t_currentPath = '';\r\n\t\t_currentStyle = '';\r\n\r\n\t\tfor ( var e = 0, el = _elements.length; e < el; e ++ ) {\r\n\r\n\t\t\tvar element = _elements[ e ];\r\n\t\t\tvar material = element.material;\r\n\r\n\t\t\tif ( material === undefined || material.opacity === 0 ) { continue; }\r\n\r\n\t\t\t_elemBox.makeEmpty();\r\n\r\n\t\t\tif ( element instanceof RenderableSprite ) {\r\n\r\n\t\t\t\t_v1 = element;\r\n\t\t\t\t_v1.x *= _svgWidthHalf; _v1.y *= - _svgHeightHalf;\r\n\r\n\t\t\t\trenderSprite( _v1, element, material );\r\n\r\n\t\t\t} else if ( element instanceof RenderableLine ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2;\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen ] );\r\n\r\n\t\t\t\tif ( _clipBox.intersectsBox( _elemBox ) === true ) {\r\n\r\n\t\t\t\t\trenderLine( _v1, _v2, element, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( element instanceof RenderableFace ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\r\n\r\n\t\t\t\tif ( _v1.positionScreen.z < - 1 || _v1.positionScreen.z > 1 ) { continue; }\r\n\t\t\t\tif ( _v2.positionScreen.z < - 1 || _v2.positionScreen.z > 1 ) { continue; }\r\n\t\t\t\tif ( _v3.positionScreen.z < - 1 || _v3.positionScreen.z > 1 ) { continue; }\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;\r\n\t\t\t\t_v3.positionScreen.x *= _svgWidthHalf; _v3.positionScreen.y *= - _svgHeightHalf;\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [\r\n\t\t\t\t\t_v1.positionScreen,\r\n\t\t\t\t\t_v2.positionScreen,\r\n\t\t\t\t\t_v3.positionScreen\r\n\t\t\t\t] );\r\n\r\n\t\t\t\tif ( _clipBox.intersectsBox( _elemBox ) === true ) {\r\n\r\n\t\t\t\t\trenderFace3( _v1, _v2, _v3, element, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tflushPath(); // just to flush last svg:path\r\n\r\n\t\tscene.traverseVisible( function ( object ) {\r\n\r\n\t\t\t if ( object instanceof SVGObject ) {\r\n\r\n\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t_vector3.applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\t\tvar x = _vector3.x * _svgWidthHalf;\r\n\t\t\t\tvar y = - _vector3.y * _svgHeightHalf;\r\n\r\n\t\t\t\tvar node = object.node;\r\n\t\t\t\tnode.setAttribute( 'transform', 'translate(' + x + ',' + y + ')' );\r\n\r\n\t\t\t\t_svg.appendChild( node );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tfunction calculateLights( lights ) {\r\n\r\n\t\t_ambientLight.setRGB( 0, 0, 0 );\r\n\t\t_directionalLights.setRGB( 0, 0, 0 );\r\n\t\t_pointLights.setRGB( 0, 0, 0 );\r\n\r\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = lights[ l ];\r\n\t\t\tvar lightColor = light.color;\r\n\r\n\t\t\tif ( light.isAmbientLight ) {\r\n\r\n\t\t\t\t_ambientLight.r += lightColor.r;\r\n\t\t\t\t_ambientLight.g += lightColor.g;\r\n\t\t\t\t_ambientLight.b += lightColor.b;\r\n\r\n\t\t\t} else if ( light.isDirectionalLight ) {\r\n\r\n\t\t\t\t_directionalLights.r += lightColor.r;\r\n\t\t\t\t_directionalLights.g += lightColor.g;\r\n\t\t\t\t_directionalLights.b += lightColor.b;\r\n\r\n\t\t\t} else if ( light.isPointLight ) {\r\n\r\n\t\t\t\t_pointLights.r += lightColor.r;\r\n\t\t\t\t_pointLights.g += lightColor.g;\r\n\t\t\t\t_pointLights.b += lightColor.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction calculateLight( lights, position, normal, color ) {\r\n\r\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = lights[ l ];\r\n\t\t\tvar lightColor = light.color;\r\n\r\n\t\t\tif ( light.isDirectionalLight ) {\r\n\r\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();\r\n\r\n\t\t\t\tvar amount = normal.dot( lightPosition );\r\n\r\n\t\t\t\tif ( amount <= 0 ) { continue; }\r\n\r\n\t\t\t\tamount *= light.intensity;\r\n\r\n\t\t\t\tcolor.r += lightColor.r * amount;\r\n\t\t\t\tcolor.g += lightColor.g * amount;\r\n\t\t\t\tcolor.b += lightColor.b * amount;\r\n\r\n\t\t\t} else if ( light.isPointLight ) {\r\n\r\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\r\n\r\n\t\t\t\tif ( amount <= 0 ) { continue; }\r\n\r\n\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\r\n\r\n\t\t\t\tif ( amount == 0 ) { continue; }\r\n\r\n\t\t\t\tamount *= light.intensity;\r\n\r\n\t\t\t\tcolor.r += lightColor.r * amount;\r\n\t\t\t\tcolor.g += lightColor.g * amount;\r\n\t\t\t\tcolor.b += lightColor.b * amount;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderSprite( v1, element, material ) {\r\n\r\n\t\tvar scaleX = element.scale.x * _svgWidthHalf;\r\n\t\tvar scaleY = element.scale.y * _svgHeightHalf;\r\n\r\n\t\tif ( material.isPointsMaterial ) {\r\n\r\n\t\t\tscaleX *= material.size;\r\n\t\t\tscaleY *= material.size;\r\n\r\n\t\t}\r\n\r\n\t\tvar path = 'M' + convert( v1.x - scaleX * 0.5 ) + ',' + convert( v1.y - scaleY * 0.5 ) + 'h' + convert( scaleX ) + 'v' + convert( scaleY ) + 'h' + convert( - scaleX ) + 'z';\r\n\t\tvar style = \"\";\r\n\r\n\t\tif ( material.isSpriteMaterial || material.isPointsMaterial ) {\r\n\r\n\t\t\tstyle = 'fill:' + getSvgColor( material.color, material.opacity );\r\n\r\n\t\t}\r\n\r\n\t\taddPath( style, path );\r\n\r\n\t}\r\n\r\n\tfunction renderLine( v1, v2, element, material ) {\r\n\r\n\t\tvar path = 'M' + convert( v1.positionScreen.x ) + ',' + convert( v1.positionScreen.y ) + 'L' + convert( v2.positionScreen.x ) + ',' + convert( v2.positionScreen.y );\r\n\r\n\t\tif ( material.isLineBasicMaterial ) {\r\n\r\n\t\t\tvar style = 'fill:none;stroke:' + getSvgColor( material.color, material.opacity ) + ';stroke-width:' + material.linewidth + ';stroke-linecap:' + material.linecap;\r\n\r\n\t\t\tif ( material.isLineDashedMaterial ) {\r\n\r\n\t\t\t\tstyle = style + ';stroke-dasharray:' + material.dashSize + \",\" + material.gapSize;\r\n\r\n\t\t\t}\r\n\r\n\t\t\taddPath( style, path );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderFace3( v1, v2, v3, element, material ) {\r\n\r\n\t\t_this.info.render.vertices += 3;\r\n\t\t_this.info.render.faces ++;\r\n\r\n\t\tvar path = 'M' + convert( v1.positionScreen.x ) + ',' + convert( v1.positionScreen.y ) + 'L' + convert( v2.positionScreen.x ) + ',' + convert( v2.positionScreen.y ) + 'L' + convert( v3.positionScreen.x ) + ',' + convert( v3.positionScreen.y ) + 'z';\r\n\t\tvar style = '';\r\n\r\n\t\tif ( material.isMeshBasicMaterial ) {\r\n\r\n\t\t\t_color.copy( material.color );\r\n\r\n\t\t\tif ( material.vertexColors === FaceColors ) {\r\n\r\n\t\t\t\t_color.multiply( element.color );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial ) {\r\n\r\n\t\t\t_diffuseColor.copy( material.color );\r\n\r\n\t\t\tif ( material.vertexColors === FaceColors ) {\r\n\r\n\t\t\t\t_diffuseColor.multiply( element.color );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_color.copy( _ambientLight );\r\n\r\n\t\t\t_centroid.copy( v1.positionWorld ).add( v2.positionWorld ).add( v3.positionWorld ).divideScalar( 3 );\r\n\r\n\t\t\tcalculateLight( _lights, _centroid, element.normalModel, _color );\r\n\r\n\t\t\t_color.multiply( _diffuseColor ).add( material.emissive );\r\n\r\n\t\t} else if ( material.isMeshNormalMaterial ) {\r\n\r\n\t\t\t_normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix );\r\n\r\n\t\t\t_color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.wireframe ) {\r\n\r\n\t\t\tstyle = 'fill:none;stroke:' + getSvgColor( _color, material.opacity ) + ';stroke-width:' + material.wireframeLinewidth + ';stroke-linecap:' + material.wireframeLinecap + ';stroke-linejoin:' + material.wireframeLinejoin;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstyle = 'fill:' + getSvgColor( _color, material.opacity );\r\n\r\n\t\t}\r\n\r\n\t\taddPath( style, path );\r\n\r\n\t}\r\n\r\n\tfunction addPath( style, path ) {\r\n\r\n\t\tif ( _currentStyle === style ) {\r\n\r\n\t\t\t_currentPath += path;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tflushPath();\r\n\r\n\t\t\t_currentStyle = style;\r\n\t\t\t_currentPath = path;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction flushPath() {\r\n\r\n\t\tif ( _currentPath ) {\r\n\r\n\t\t\t_svgNode = getPathNode( _pathCount ++ );\r\n\t\t\t_svgNode.setAttribute( 'd', _currentPath );\r\n\t\t\t_svgNode.setAttribute( 'style', _currentStyle );\r\n\t\t\t_svg.appendChild( _svgNode );\r\n\r\n\t\t}\r\n\r\n\t\t_currentPath = '';\r\n\t\t_currentStyle = '';\r\n\r\n\t}\r\n\r\n\tfunction getPathNode( id ) {\r\n\r\n\t\tif ( _svgPathPool[ id ] == null ) {\r\n\r\n\t\t\t_svgPathPool[ id ] = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );\r\n\r\n\t\t\tif ( _quality == 0 ) {\r\n\r\n\t\t\t\t_svgPathPool[ id ].setAttribute( 'shape-rendering', 'crispEdges' ); //optimizeSpeed\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn _svgPathPool[ id ];\r\n\r\n\t\t}\r\n\r\n\t\treturn _svgPathPool[ id ];\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLAnimation() {\r\n\r\n\tvar context = null;\r\n\tvar isAnimating = false;\r\n\tvar animationLoop = null;\r\n\r\n\tfunction onAnimationFrame( time, frame ) {\r\n\r\n\t\tif ( isAnimating === false ) { return; }\r\n\r\n\t\tanimationLoop( time, frame );\r\n\r\n\t\tcontext.requestAnimationFrame( onAnimationFrame );\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tstart: function () {\r\n\r\n\t\t\tif ( isAnimating === true ) { return; }\r\n\t\t\tif ( animationLoop === null ) { return; }\r\n\r\n\t\t\tcontext.requestAnimationFrame( onAnimationFrame );\r\n\r\n\t\t\tisAnimating = true;\r\n\r\n\t\t},\r\n\r\n\t\tstop: function () {\r\n\r\n\t\t\tisAnimating = false;\r\n\r\n\t\t},\r\n\r\n\t\tsetAnimationLoop: function ( callback ) {\r\n\r\n\t\t\tanimationLoop = callback;\r\n\r\n\t\t},\r\n\r\n\t\tsetContext: function ( value ) {\r\n\r\n\t\t\tcontext = value;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLAttributes( gl ) {\r\n\r\n\tvar buffers = new WeakMap();\r\n\r\n\tfunction createBuffer( attribute, bufferType ) {\r\n\r\n\t\tvar array = attribute.array;\r\n\t\tvar usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\r\n\r\n\t\tvar buffer = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( bufferType, buffer );\r\n\t\tgl.bufferData( bufferType, array, usage );\r\n\r\n\t\tattribute.onUploadCallback();\r\n\r\n\t\tvar type = gl.FLOAT;\r\n\r\n\t\tif ( array instanceof Float32Array ) {\r\n\r\n\t\t\ttype = gl.FLOAT;\r\n\r\n\t\t} else if ( array instanceof Float64Array ) {\r\n\r\n\t\t\tconsole.warn( 'WebGLAttributes: Unsupported data buffer format: Float64Array.' );\r\n\r\n\t\t} else if ( array instanceof Uint16Array ) {\r\n\r\n\t\t\ttype = gl.UNSIGNED_SHORT;\r\n\r\n\t\t} else if ( array instanceof Int16Array ) {\r\n\r\n\t\t\ttype = gl.SHORT;\r\n\r\n\t\t} else if ( array instanceof Uint32Array ) {\r\n\r\n\t\t\ttype = gl.UNSIGNED_INT;\r\n\r\n\t\t} else if ( array instanceof Int32Array ) {\r\n\r\n\t\t\ttype = gl.INT;\r\n\r\n\t\t} else if ( array instanceof Int8Array ) {\r\n\r\n\t\t\ttype = gl.BYTE;\r\n\r\n\t\t} else if ( array instanceof Uint8Array ) {\r\n\r\n\t\t\ttype = gl.UNSIGNED_BYTE;\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tbuffer: buffer,\r\n\t\t\ttype: type,\r\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\r\n\t\t\tversion: attribute.version\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\r\n\r\n\t\tvar array = attribute.array;\r\n\t\tvar updateRange = attribute.updateRange;\r\n\r\n\t\tgl.bindBuffer( bufferType, buffer );\r\n\r\n\t\tif ( attribute.dynamic === false ) {\r\n\r\n\t\t\tgl.bufferData( bufferType, array, gl.STATIC_DRAW );\r\n\r\n\t\t} else if ( updateRange.count === - 1 ) {\r\n\r\n\t\t\t// Not using update ranges\r\n\r\n\t\t\tgl.bufferSubData( bufferType, 0, array );\r\n\r\n\t\t} else if ( updateRange.count === 0 ) {\r\n\r\n\t\t\tconsole.error( 'WebGLObjects.updateBuffer: dynamic BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\r\n\t\t\t\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\r\n\r\n\t\t\tupdateRange.count = - 1; // reset range\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction get( attribute ) {\r\n\r\n\t\tif ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }\r\n\r\n\t\treturn buffers.get( attribute );\r\n\r\n\t}\r\n\r\n\tfunction remove( attribute ) {\r\n\r\n\t\tif ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }\r\n\r\n\t\tvar data = buffers.get( attribute );\r\n\r\n\t\tif ( data ) {\r\n\r\n\t\t\tgl.deleteBuffer( data.buffer );\r\n\r\n\t\t\tbuffers.delete( attribute );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction update( attribute, bufferType ) {\r\n\r\n\t\tif ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }\r\n\r\n\t\tvar data = buffers.get( attribute );\r\n\r\n\t\tif ( data === undefined ) {\r\n\r\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\r\n\r\n\t\t} else if ( data.version < attribute.version ) {\r\n\r\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\r\n\r\n\t\t\tdata.version = attribute.version;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tget: get,\r\n\t\tremove: remove,\r\n\t\tupdate: update\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {\r\n\r\n\tvar clearColor = new Color( 0x000000 );\r\n\tvar clearAlpha = 0;\r\n\r\n\tvar planeCamera, planeMesh;\r\n\tvar boxMesh;\r\n\r\n\tfunction render( renderList, scene, camera, forceClear ) {\r\n\r\n\t\tvar background = scene.background;\r\n\r\n\t\tif ( background === null ) {\r\n\r\n\t\t\tsetClear( clearColor, clearAlpha );\r\n\r\n\t\t} else if ( background && background.isColor ) {\r\n\r\n\t\t\tsetClear( background, 1 );\r\n\t\t\tforceClear = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderer.autoClear || forceClear ) {\r\n\r\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t\tif ( background && background.isCubeTexture ) {\r\n\r\n\t\t\tif ( boxMesh === undefined ) {\r\n\r\n\t\t\t\tboxMesh = new Mesh(\r\n\t\t\t\t\tnew BoxBufferGeometry( 1, 1, 1 ),\r\n\t\t\t\t\tnew ShaderMaterial( {\r\n\t\t\t\t\t\tuniforms: ShaderLib.cube.uniforms,\r\n\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\r\n\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\r\n\t\t\t\t\t\tside: BackSide,\r\n\t\t\t\t\t\tdepthTest: true,\r\n\t\t\t\t\t\tdepthWrite: false,\r\n\t\t\t\t\t\tfog: false\r\n\t\t\t\t\t} )\r\n\t\t\t\t);\r\n\r\n\t\t\t\tboxMesh.geometry.removeAttribute( 'normal' );\r\n\t\t\t\tboxMesh.geometry.removeAttribute( 'uv' );\r\n\r\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobjects.update( boxMesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tboxMesh.material.uniforms.tCube.value = background;\r\n\r\n\t\t\trenderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );\r\n\r\n\t\t} else if ( background && background.isTexture ) {\r\n\r\n\t\t\tif ( planeCamera === undefined ) {\r\n\r\n\t\t\t\tplaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\r\n\t\t\t\tplaneMesh = new Mesh(\r\n\t\t\t\t\tnew PlaneBufferGeometry( 2, 2 ),\r\n\t\t\t\t\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\r\n\t\t\t\t);\r\n\r\n\t\t\t\tobjects.update( planeMesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tplaneMesh.material.map = background;\r\n\r\n\t\t\t// TODO Push this to renderList\r\n\r\n\t\t\trenderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setClear( color, alpha ) {\r\n\r\n\t\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tgetClearColor: function () {\r\n\r\n\t\t\treturn clearColor;\r\n\r\n\t\t},\r\n\t\tsetClearColor: function ( color, alpha ) {\r\n\r\n\t\t\tclearColor.set( color );\r\n\t\t\tclearAlpha = alpha !== undefined ? alpha : 1;\r\n\t\t\tsetClear( clearColor, clearAlpha );\r\n\r\n\t\t},\r\n\t\tgetClearAlpha: function () {\r\n\r\n\t\t\treturn clearAlpha;\r\n\r\n\t\t},\r\n\t\tsetClearAlpha: function ( alpha ) {\r\n\r\n\t\t\tclearAlpha = alpha;\r\n\t\t\tsetClear( clearColor, clearAlpha );\r\n\r\n\t\t},\r\n\t\trender: render\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLBufferRenderer( gl, extensions, info, capabilities ) {\r\n\r\n\tvar mode;\r\n\r\n\tfunction setMode( value ) {\r\n\r\n\t\tmode = value;\r\n\r\n\t}\r\n\r\n\tfunction render( start, count ) {\r\n\r\n\t\tgl.drawArrays( mode, start, count );\r\n\r\n\t\tinfo.update( count, mode );\r\n\r\n\t}\r\n\r\n\tfunction renderInstances( geometry, start, count ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( capabilities.isWebGL2 ) {\r\n\r\n\t\t\textension = gl;\r\n\r\n\t\t} else {\r\n\r\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t\tif ( extension === null ) {\r\n\r\n\t\t\t\tconsole.error( 'WebGLBufferRenderer: using InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\textension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );\r\n\r\n\t\tinfo.update( count, mode, geometry.maxInstancedCount );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tthis.setMode = setMode;\r\n\tthis.render = render;\r\n\tthis.renderInstances = renderInstances;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLCapabilities( gl, extensions, parameters ) {\r\n\r\n\tvar maxAnisotropy;\r\n\r\n\tfunction getMaxAnisotropy() {\r\n\r\n\t\tif ( maxAnisotropy !== undefined ) { return maxAnisotropy; }\r\n\r\n\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaxAnisotropy = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn maxAnisotropy;\r\n\r\n\t}\r\n\r\n\tfunction getMaxPrecision( precision ) {\r\n\r\n\t\tif ( precision === 'highp' ) {\r\n\r\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\r\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\r\n\r\n\t\t\t\treturn 'highp';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprecision = 'mediump';\r\n\r\n\t\t}\r\n\r\n\t\tif ( precision === 'mediump' ) {\r\n\r\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\r\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\r\n\r\n\t\t\t\treturn 'mediump';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn 'lowp';\r\n\r\n\t}\r\n\r\n\tvar isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\r\n\r\n\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\r\n\tvar maxPrecision = getMaxPrecision( precision );\r\n\r\n\tif ( maxPrecision !== precision ) {\r\n\r\n\t\tconsole.warn( 'WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\r\n\t\tprecision = maxPrecision;\r\n\r\n\t}\r\n\r\n\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\r\n\r\n\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\r\n\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\r\n\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\r\n\r\n\tvar vertexTextures = maxVertexTextures > 0;\r\n\tvar floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );\r\n\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\r\n\r\n\treturn {\r\n\r\n\t\tisWebGL2: isWebGL2,\r\n\r\n\t\tgetMaxAnisotropy: getMaxAnisotropy,\r\n\t\tgetMaxPrecision: getMaxPrecision,\r\n\r\n\t\tprecision: precision,\r\n\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\r\n\r\n\t\tmaxTextures: maxTextures,\r\n\t\tmaxVertexTextures: maxVertexTextures,\r\n\t\tmaxTextureSize: maxTextureSize,\r\n\t\tmaxCubemapSize: maxCubemapSize,\r\n\r\n\t\tmaxAttributes: maxAttributes,\r\n\t\tmaxVertexUniforms: maxVertexUniforms,\r\n\t\tmaxVaryings: maxVaryings,\r\n\t\tmaxFragmentUniforms: maxFragmentUniforms,\r\n\r\n\t\tvertexTextures: vertexTextures,\r\n\t\tfloatFragmentTextures: floatFragmentTextures,\r\n\t\tfloatVertexTextures: floatVertexTextures\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLClipping() {\r\n\r\n\tvar scope = this,\r\n\r\n\t\tglobalState = null,\r\n\t\tnumGlobalPlanes = 0,\r\n\t\tlocalClippingEnabled = false,\r\n\t\trenderingShadows = false,\r\n\r\n\t\tplane = new Plane(),\r\n\t\tviewNormalMatrix = new Matrix3(),\r\n\r\n\t\tuniform = { value: null, needsUpdate: false };\r\n\r\n\tthis.uniform = uniform;\r\n\tthis.numPlanes = 0;\r\n\tthis.numIntersection = 0;\r\n\r\n\tthis.init = function ( planes, enableLocalClipping, camera ) {\r\n\r\n\t\tvar enabled =\r\n\t\t\tplanes.length !== 0 ||\r\n\t\t\tenableLocalClipping ||\r\n\t\t\t// enable state of previous frame - the clipping code has to\r\n\t\t\t// run another frame in order to reset the state:\r\n\t\t\tnumGlobalPlanes !== 0 ||\r\n\t\t\tlocalClippingEnabled;\r\n\r\n\t\tlocalClippingEnabled = enableLocalClipping;\r\n\r\n\t\tglobalState = projectPlanes( planes, camera, 0 );\r\n\t\tnumGlobalPlanes = planes.length;\r\n\r\n\t\treturn enabled;\r\n\r\n\t};\r\n\r\n\tthis.beginShadows = function () {\r\n\r\n\t\trenderingShadows = true;\r\n\t\tprojectPlanes( null );\r\n\r\n\t};\r\n\r\n\tthis.endShadows = function () {\r\n\r\n\t\trenderingShadows = false;\r\n\t\tresetGlobalState();\r\n\r\n\t};\r\n\r\n\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\r\n\r\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\r\n\r\n\t\t\t// there's no local clipping\r\n\r\n\t\t\tif ( renderingShadows ) {\r\n\r\n\t\t\t\t// there's no global clipping\r\n\r\n\t\t\t\tprojectPlanes( null );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresetGlobalState();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\r\n\t\t\t\tlGlobal = nGlobal * 4,\r\n\r\n\t\t\t\tdstArray = cache.clippingState || null;\r\n\r\n\t\t\tuniform.value = dstArray; // ensure unique state\r\n\r\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\r\n\r\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\r\n\r\n\t\t\t\tdstArray[ i ] = globalState[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcache.clippingState = dstArray;\r\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\r\n\t\t\tthis.numPlanes += nGlobal;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction resetGlobalState() {\r\n\r\n\t\tif ( uniform.value !== globalState ) {\r\n\r\n\t\t\tuniform.value = globalState;\r\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\r\n\r\n\t\t}\r\n\r\n\t\tscope.numPlanes = numGlobalPlanes;\r\n\t\tscope.numIntersection = 0;\r\n\r\n\t}\r\n\r\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\r\n\r\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\r\n\t\t\tdstArray = null;\r\n\r\n\t\tif ( nPlanes !== 0 ) {\r\n\r\n\t\t\tdstArray = uniform.value;\r\n\r\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\r\n\r\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\r\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\r\n\r\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\r\n\r\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\r\n\r\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\r\n\r\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\r\n\r\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\r\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuniform.value = dstArray;\r\n\t\t\tuniform.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tscope.numPlanes = nPlanes;\r\n\r\n\t\treturn dstArray;\r\n\r\n\t}\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLExtensions( gl ) {\r\n\r\n\tvar extensions = {};\r\n\r\n\treturn {\r\n\r\n\t\tget: function ( name ) {\r\n\r\n\t\t\tif ( extensions[ name ] !== undefined ) {\r\n\r\n\t\t\t\treturn extensions[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar extension;\r\n\r\n\t\t\tswitch ( name ) {\r\n\r\n\t\t\t\tcase 'WEBGL_depth_texture':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\textension = gl.getExtension( name );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( extension === null ) {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLRenderer: ' + name + ' extension not supported.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\textensions[ name ] = extension;\r\n\r\n\t\t\treturn extension;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLGeometries( gl, attributes, info ) {\r\n\r\n\tvar geometries = {};\r\n\tvar wireframeAttributes = {};\r\n\r\n\tfunction onGeometryDispose( event ) {\r\n\r\n\t\tvar geometry = event.target;\r\n\t\tvar buffergeometry = geometries[ geometry.id ];\r\n\r\n\t\tif ( buffergeometry.index !== null ) {\r\n\r\n\t\t\tattributes.remove( buffergeometry.index );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in buffergeometry.attributes ) {\r\n\r\n\t\t\tattributes.remove( buffergeometry.attributes[ name ] );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tdelete geometries[ geometry.id ];\r\n\r\n\t\tvar attribute = wireframeAttributes[ buffergeometry.id ];\r\n\r\n\t\tif ( attribute ) {\r\n\r\n\t\t\tattributes.remove( attribute );\r\n\t\t\tdelete wireframeAttributes[ buffergeometry.id ];\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tinfo.memory.geometries --;\r\n\r\n\t}\r\n\r\n\tfunction get( object, geometry ) {\r\n\r\n\t\tvar buffergeometry = geometries[ geometry.id ];\r\n\r\n\t\tif ( buffergeometry ) { return buffergeometry; }\r\n\r\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tbuffergeometry = geometry;\r\n\r\n\t\t} else if ( geometry.isGeometry ) {\r\n\r\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\r\n\r\n\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbuffergeometry = geometry._bufferGeometry;\r\n\r\n\t\t}\r\n\r\n\t\tgeometries[ geometry.id ] = buffergeometry;\r\n\r\n\t\tinfo.memory.geometries ++;\r\n\r\n\t\treturn buffergeometry;\r\n\r\n\t}\r\n\r\n\tfunction update( geometry ) {\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar geometryAttributes = geometry.attributes;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in geometryAttributes ) {\r\n\r\n\t\t\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\r\n\r\n\t\t}\r\n\r\n\t\t// morph targets\r\n\r\n\t\tvar morphAttributes = geometry.morphAttributes;\r\n\r\n\t\tfor ( var name in morphAttributes ) {\r\n\r\n\t\t\tvar array = morphAttributes[ name ];\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getWireframeAttribute( geometry ) {\r\n\r\n\t\tvar attribute = wireframeAttributes[ geometry.id ];\r\n\r\n\t\tif ( attribute ) { return attribute; }\r\n\r\n\t\tvar indices = [];\r\n\r\n\t\tvar geometryIndex = geometry.index;\r\n\t\tvar geometryAttributes = geometry.attributes;\r\n\r\n\t\t// console.time( 'wireframe' );\r\n\r\n\t\tif ( geometryIndex !== null ) {\r\n\r\n\t\t\tvar array = geometryIndex.array;\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\tvar a = array[ i + 0 ];\r\n\t\t\t\tvar b = array[ i + 1 ];\r\n\t\t\t\tvar c = array[ i + 2 ];\r\n\r\n\t\t\t\tindices.push( a, b, b, c, c, a );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar array = geometryAttributes.position.array;\r\n\r\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\r\n\r\n\t\t\t\tvar a = i + 0;\r\n\t\t\t\tvar b = i + 1;\r\n\t\t\t\tvar c = i + 2;\r\n\r\n\t\t\t\tindices.push( a, b, b, c, c, a );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// console.timeEnd( 'wireframe' );\r\n\r\n\t\tattribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\r\n\r\n\t\tattributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n\t\twireframeAttributes[ geometry.id ] = attribute;\r\n\r\n\t\treturn attribute;\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tget: get,\r\n\t\tupdate: update,\r\n\r\n\t\tgetWireframeAttribute: getWireframeAttribute\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {\r\n\r\n\tvar mode;\r\n\r\n\tfunction setMode( value ) {\r\n\r\n\t\tmode = value;\r\n\r\n\t}\r\n\r\n\tvar type, bytesPerElement;\r\n\r\n\tfunction setIndex( value ) {\r\n\r\n\t\ttype = value.type;\r\n\t\tbytesPerElement = value.bytesPerElement;\r\n\r\n\t}\r\n\r\n\tfunction render( start, count ) {\r\n\r\n\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\r\n\r\n\t\tinfo.update( count, mode );\r\n\r\n\t}\r\n\r\n\tfunction renderInstances( geometry, start, count ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( capabilities.isWebGL2 ) {\r\n\r\n\t\t\textension = gl;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t\tif ( extension === null ) {\r\n\r\n\t\t\t\tconsole.error( 'WebGLIndexedBufferRenderer: using InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\textension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );\r\n\r\n\t\tinfo.update( count, mode, geometry.maxInstancedCount );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tthis.setMode = setMode;\r\n\tthis.setIndex = setIndex;\r\n\tthis.render = render;\r\n\tthis.renderInstances = renderInstances;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLInfo( gl ) {\r\n\r\n\tvar memory = {\r\n\t\tgeometries: 0,\r\n\t\ttextures: 0\r\n\t};\r\n\r\n\tvar render = {\r\n\t\tframe: 0,\r\n\t\tcalls: 0,\r\n\t\ttriangles: 0,\r\n\t\tpoints: 0,\r\n\t\tlines: 0\r\n\t};\r\n\r\n\tfunction update( count, mode, instanceCount ) {\r\n\r\n\t\tinstanceCount = instanceCount || 1;\r\n\r\n\t\trender.calls ++;\r\n\r\n\t\tswitch ( mode ) {\r\n\r\n\t\t\tcase gl.TRIANGLES:\r\n\t\t\t\trender.triangles += instanceCount * ( count / 3 );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase gl.TRIANGLE_STRIP:\r\n\t\t\tcase gl.TRIANGLE_FAN:\r\n\t\t\t\trender.triangles += instanceCount * ( count - 2 );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase gl.LINES:\r\n\t\t\t\trender.lines += instanceCount * ( count / 2 );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase gl.LINE_STRIP:\r\n\t\t\t\trender.lines += instanceCount * ( count - 1 );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase gl.LINE_LOOP:\r\n\t\t\t\trender.lines += instanceCount * count;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase gl.POINTS:\r\n\t\t\t\trender.points += instanceCount * count;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.error( 'WebGLInfo: Unknown draw mode:', mode );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction reset() {\r\n\r\n\t\trender.frame ++;\r\n\t\trender.calls = 0;\r\n\t\trender.triangles = 0;\r\n\t\trender.points = 0;\r\n\t\trender.lines = 0;\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tmemory: memory,\r\n\t\trender: render,\r\n\t\tprograms: null,\r\n\t\tautoReset: true,\r\n\t\treset: reset,\r\n\t\tupdate: update\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction absNumericalSort( a, b ) {\r\n\r\n\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\r\n\r\n}\r\n\r\nfunction WebGLMorphtargets( gl ) {\r\n\r\n\tvar influencesList = {};\r\n\tvar morphInfluences = new Float32Array( 8 );\r\n\r\n\tfunction update( object, geometry, material, program ) {\r\n\r\n\t\tvar objectInfluences = object.morphTargetInfluences;\r\n\r\n\t\tvar length = objectInfluences.length;\r\n\r\n\t\tvar influences = influencesList[ geometry.id ];\r\n\r\n\t\tif ( influences === undefined ) {\r\n\r\n\t\t\t// initialise list\r\n\r\n\t\t\tinfluences = [];\r\n\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tinfluences[ i ] = [ i, 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tinfluencesList[ geometry.id ] = influences;\r\n\r\n\t\t}\r\n\r\n\t\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\r\n\t\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\r\n\r\n\t\t// Remove current morphAttributes\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar influence = influences[ i ];\r\n\r\n\t\t\tif ( influence[ 1 ] !== 0 ) {\r\n\r\n\t\t\t\tif ( morphTargets ) { geometry.removeAttribute( 'morphTarget' + i ); }\r\n\t\t\t\tif ( morphNormals ) { geometry.removeAttribute( 'morphNormal' + i ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Collect influences\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar influence = influences[ i ];\r\n\r\n\t\t\tinfluence[ 0 ] = i;\r\n\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tinfluences.sort( absNumericalSort );\r\n\r\n\t\t// Add morphAttributes\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tvar influence = influences[ i ];\r\n\r\n\t\t\tif ( influence ) {\r\n\r\n\t\t\t\tvar index = influence[ 0 ];\r\n\t\t\t\tvar value = influence[ 1 ];\r\n\r\n\t\t\t\tif ( value ) {\r\n\r\n\t\t\t\t\tif ( morphTargets ) { geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] ); }\r\n\t\t\t\t\tif ( morphNormals ) { geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] ); }\r\n\r\n\t\t\t\t\tmorphInfluences[ i ] = value;\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmorphInfluences[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tupdate: update\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLObjects( geometries, info ) {\r\n\r\n\tvar updateList = {};\r\n\r\n\tfunction update( object ) {\r\n\r\n\t\tvar frame = info.render.frame;\r\n\r\n\t\tvar geometry = object.geometry;\r\n\t\tvar buffergeometry = geometries.get( object, geometry );\r\n\r\n\t\t// Update once per frame\r\n\r\n\t\tif ( updateList[ buffergeometry.id ] !== frame ) {\r\n\r\n\t\t\tif ( geometry.isGeometry ) {\r\n\r\n\t\t\t\tbuffergeometry.updateFromObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometries.update( buffergeometry );\r\n\r\n\t\t\tupdateList[ buffergeometry.id ] = frame;\r\n\r\n\t\t}\r\n\r\n\t\treturn buffergeometry;\r\n\r\n\t}\r\n\r\n\tfunction dispose() {\r\n\r\n\t\tupdateList = {};\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tupdate: update,\r\n\t\tdispose: dispose\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar emptyTexture = new Texture();\r\nvar emptyCubeTexture = new CubeTexture();\r\n\r\n// --- Base for inner nodes (including the root) ---\r\n\r\nfunction UniformContainer() {\r\n\r\n\tthis.seq = [];\r\n\tthis.map = {};\r\n\r\n}\r\n\r\n// --- Utilities ---\r\n\r\n// Array Caches (provide typed arrays for temporary by size)\r\n\r\nvar arrayCacheF32 = [];\r\nvar arrayCacheI32 = [];\r\n\r\n// Float32Array caches used for uploading Matrix uniforms\r\n\r\nvar mat4array = new Float32Array( 16 );\r\nvar mat3array = new Float32Array( 9 );\r\nvar mat2array = new Float32Array( 4 );\r\n\r\n// Flattening for arrays of vectors and matrices\r\n\r\nfunction flatten( array, nBlocks, blockSize ) {\r\n\r\n\tvar firstElem = array[ 0 ];\r\n\r\n\tif ( firstElem <= 0 || firstElem > 0 ) { return array; }\r\n\t// unoptimized: ! isNaN( firstElem )\r\n\t// see http://jacksondunstan.com/articles/983\r\n\r\n\tvar n = nBlocks * blockSize,\r\n\t\tr = arrayCacheF32[ n ];\r\n\r\n\tif ( r === undefined ) {\r\n\r\n\t\tr = new Float32Array( n );\r\n\t\tarrayCacheF32[ n ] = r;\r\n\r\n\t}\r\n\r\n\tif ( nBlocks !== 0 ) {\r\n\r\n\t\tfirstElem.toArray( r, 0 );\r\n\r\n\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\r\n\r\n\t\t\toffset += blockSize;\r\n\t\t\tarray[ i ].toArray( r, offset );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn r;\r\n\r\n}\r\n\r\nfunction arraysEqual( a, b ) {\r\n\r\n\tif ( a.length !== b.length ) { return false; }\r\n\r\n\tfor ( var i = 0, l = a.length; i < l; i ++ ) {\r\n\r\n\t\tif ( a[ i ] !== b[ i ] ) { return false; }\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction copyArray( a, b ) {\r\n\r\n\tfor ( var i = 0, l = b.length; i < l; i ++ ) {\r\n\r\n\t\ta[ i ] = b[ i ];\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Texture unit allocation\r\n\r\nfunction allocTexUnits( renderer, n ) {\r\n\r\n\tvar r = arrayCacheI32[ n ];\r\n\r\n\tif ( r === undefined ) {\r\n\r\n\t\tr = new Int32Array( n );\r\n\t\tarrayCacheI32[ n ] = r;\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i !== n; ++ i )\r\n\t\t{ r[ i ] = renderer.allocTextureUnit(); }\r\n\r\n\treturn r;\r\n\r\n}\r\n\r\n// --- Setters ---\r\n\r\n// Note: Defining these methods externally, because they come in a bunch\r\n// and this way their names minify.\r\n\r\n// Single scalar\r\n\r\nfunction setValue1f( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( cache[ 0 ] === v ) { return; }\r\n\r\n\tgl.uniform1f( this.addr, v );\r\n\r\n\tcache[ 0 ] = v;\r\n\r\n}\r\n\r\nfunction setValue1i( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( cache[ 0 ] === v ) { return; }\r\n\r\n\tgl.uniform1i( this.addr, v );\r\n\r\n\tcache[ 0 ] = v;\r\n\r\n}\r\n\r\n// Single float vector (from flat array or VectorN)\r\n\r\nfunction setValue2fv( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( v.x !== undefined ) {\r\n\r\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\r\n\r\n\t\t\tgl.uniform2f( this.addr, v.x, v.y );\r\n\r\n\t\t\tcache[ 0 ] = v.x;\r\n\t\t\tcache[ 1 ] = v.y;\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\t\tgl.uniform2fv( this.addr, v );\r\n\r\n\t\tcopyArray( cache, v );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction setValue3fv( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( v.x !== undefined ) {\r\n\r\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\r\n\r\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\r\n\r\n\t\t\tcache[ 0 ] = v.x;\r\n\t\t\tcache[ 1 ] = v.y;\r\n\t\t\tcache[ 2 ] = v.z;\r\n\r\n\t\t}\r\n\r\n\t} else if ( v.r !== undefined ) {\r\n\r\n\t\tif ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {\r\n\r\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\r\n\r\n\t\t\tcache[ 0 ] = v.r;\r\n\t\t\tcache[ 1 ] = v.g;\r\n\t\t\tcache[ 2 ] = v.b;\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\t\tgl.uniform3fv( this.addr, v );\r\n\r\n\t\tcopyArray( cache, v );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction setValue4fv( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( v.x !== undefined ) {\r\n\r\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\r\n\r\n\t\t\tgl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\r\n\r\n\t\t\tcache[ 0 ] = v.x;\r\n\t\t\tcache[ 1 ] = v.y;\r\n\t\t\tcache[ 2 ] = v.z;\r\n\t\t\tcache[ 3 ] = v.w;\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\t\tgl.uniform4fv( this.addr, v );\r\n\r\n\t\tcopyArray( cache, v );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Single matrix (from flat array or MatrixN)\r\n\r\nfunction setValue2fm( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar elements = v.elements;\r\n\r\n\tif ( elements === undefined ) {\r\n\r\n\t\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\t\tgl.uniformMatrix2fv( this.addr, false, v );\r\n\r\n\t\tcopyArray( cache, v );\r\n\r\n\t} else {\r\n\r\n\t\tif ( arraysEqual( cache, elements ) ) { return; }\r\n\r\n\t\tmat2array.set( elements );\r\n\r\n\t\tgl.uniformMatrix2fv( this.addr, false, mat2array );\r\n\r\n\t\tcopyArray( cache, elements );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction setValue3fm( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar elements = v.elements;\r\n\r\n\tif ( elements === undefined ) {\r\n\r\n\t\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\t\tgl.uniformMatrix3fv( this.addr, false, v );\r\n\r\n\t\tcopyArray( cache, v );\r\n\r\n\t} else {\r\n\r\n\t\tif ( arraysEqual( cache, elements ) ) { return; }\r\n\r\n\t\tmat3array.set( elements );\r\n\r\n\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\r\n\r\n\t\tcopyArray( cache, elements );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction setValue4fm( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar elements = v.elements;\r\n\r\n\tif ( elements === undefined ) {\r\n\r\n\t\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\t\tgl.uniformMatrix4fv( this.addr, false, v );\r\n\r\n\t\tcopyArray( cache, v );\r\n\r\n\t} else {\r\n\r\n\t\tif ( arraysEqual( cache, elements ) ) { return; }\r\n\r\n\t\tmat4array.set( elements );\r\n\r\n\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\r\n\r\n\t\tcopyArray( cache, elements );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Single texture (2D / Cube)\r\n\r\nfunction setValueT1( gl, v, renderer ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar unit = renderer.allocTextureUnit();\r\n\r\n\tif ( cache[ 0 ] !== unit ) {\r\n\r\n\t\tgl.uniform1i( this.addr, unit );\r\n\t\tcache[ 0 ] = unit;\r\n\r\n\t}\r\n\r\n\trenderer.setTexture2D( v || emptyTexture, unit );\r\n\r\n}\r\n\r\nfunction setValueT6( gl, v, renderer ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar unit = renderer.allocTextureUnit();\r\n\r\n\tif ( cache[ 0 ] !== unit ) {\r\n\r\n\t\tgl.uniform1i( this.addr, unit );\r\n\t\tcache[ 0 ] = unit;\r\n\r\n\t}\r\n\r\n\trenderer.setTextureCube( v || emptyCubeTexture, unit );\r\n\r\n}\r\n\r\n// Integer / Boolean vectors or arrays thereof (always flat arrays)\r\n\r\nfunction setValue2iv( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\tgl.uniform2iv( this.addr, v );\r\n\r\n\tcopyArray( cache, v );\r\n\r\n}\r\n\r\nfunction setValue3iv( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\tgl.uniform3iv( this.addr, v );\r\n\r\n\tcopyArray( cache, v );\r\n\r\n}\r\n\r\nfunction setValue4iv( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\tgl.uniform4iv( this.addr, v );\r\n\r\n\tcopyArray( cache, v );\r\n\r\n}\r\n\r\n// Helper to pick the right setter for the singular case\r\n\r\nfunction getSingularSetter( type ) {\r\n\r\n\tswitch ( type ) {\r\n\r\n\t\tcase 0x1406: return setValue1f; // FLOAT\r\n\t\tcase 0x8b50: return setValue2fv; // _VEC2\r\n\t\tcase 0x8b51: return setValue3fv; // _VEC3\r\n\t\tcase 0x8b52: return setValue4fv; // _VEC4\r\n\r\n\t\tcase 0x8b5a: return setValue2fm; // _MAT2\r\n\t\tcase 0x8b5b: return setValue3fm; // _MAT3\r\n\t\tcase 0x8b5c: return setValue4fm; // _MAT4\r\n\r\n\t\tcase 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES\r\n\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\r\n\r\n\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\r\n\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\r\n\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\r\n\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Array of scalars\r\n\r\nfunction setValue1fv( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\tgl.uniform1fv( this.addr, v );\r\n\r\n\tcopyArray( cache, v );\r\n\r\n}\r\nfunction setValue1iv( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( arraysEqual( cache, v ) ) { return; }\r\n\r\n\tgl.uniform1iv( this.addr, v );\r\n\r\n\tcopyArray( cache, v );\r\n\r\n}\r\n\r\n// Array of vectors (flat or from THREE classes)\r\n\r\nfunction setValueV2a( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar data = flatten( v, this.size, 2 );\r\n\r\n\tif ( arraysEqual( cache, data ) ) { return; }\r\n\r\n\tgl.uniform2fv( this.addr, data );\r\n\r\n\tthis.updateCache( data );\r\n\r\n}\r\n\r\nfunction setValueV3a( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar data = flatten( v, this.size, 3 );\r\n\r\n\tif ( arraysEqual( cache, data ) ) { return; }\r\n\r\n\tgl.uniform3fv( this.addr, data );\r\n\r\n\tthis.updateCache( data );\r\n\r\n}\r\n\r\nfunction setValueV4a( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar data = flatten( v, this.size, 4 );\r\n\r\n\tif ( arraysEqual( cache, data ) ) { return; }\r\n\r\n\tgl.uniform4fv( this.addr, data );\r\n\r\n\tthis.updateCache( data );\r\n\r\n}\r\n\r\n// Array of matrices (flat or from THREE clases)\r\n\r\nfunction setValueM2a( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar data = flatten( v, this.size, 4 );\r\n\r\n\tif ( arraysEqual( cache, data ) ) { return; }\r\n\r\n\tgl.uniformMatrix2fv( this.addr, false, data );\r\n\r\n\tthis.updateCache( data );\r\n\r\n}\r\n\r\nfunction setValueM3a( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar data = flatten( v, this.size, 9 );\r\n\r\n\tif ( arraysEqual( cache, data ) ) { return; }\r\n\r\n\tgl.uniformMatrix3fv( this.addr, false, data );\r\n\r\n\tthis.updateCache( data );\r\n\r\n}\r\n\r\nfunction setValueM4a( gl, v ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar data = flatten( v, this.size, 16 );\r\n\r\n\tif ( arraysEqual( cache, data ) ) { return; }\r\n\r\n\tgl.uniformMatrix4fv( this.addr, false, data );\r\n\r\n\tthis.updateCache( data );\r\n\r\n}\r\n\r\n// Array of textures (2D / Cube)\r\n\r\nfunction setValueT1a( gl, v, renderer ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar n = v.length;\r\n\r\n\tvar units = allocTexUnits( renderer, n );\r\n\r\n\tif ( arraysEqual( cache, units ) === false ) {\r\n\r\n\t\tgl.uniform1iv( this.addr, units );\r\n\t\tcopyArray( cache, units );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i !== n; ++ i ) {\r\n\r\n\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction setValueT6a( gl, v, renderer ) {\r\n\r\n\tvar cache = this.cache;\r\n\tvar n = v.length;\r\n\r\n\tvar units = allocTexUnits( renderer, n );\r\n\r\n\tif ( arraysEqual( cache, units ) === false ) {\r\n\r\n\t\tgl.uniform1iv( this.addr, units );\r\n\t\tcopyArray( cache, units );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i !== n; ++ i ) {\r\n\r\n\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Helper to pick the right setter for a pure (bottom-level) array\r\n\r\nfunction getPureArraySetter( type ) {\r\n\r\n\tswitch ( type ) {\r\n\r\n\t\tcase 0x1406: return setValue1fv; // FLOAT\r\n\t\tcase 0x8b50: return setValueV2a; // _VEC2\r\n\t\tcase 0x8b51: return setValueV3a; // _VEC3\r\n\t\tcase 0x8b52: return setValueV4a; // _VEC4\r\n\r\n\t\tcase 0x8b5a: return setValueM2a; // _MAT2\r\n\t\tcase 0x8b5b: return setValueM3a; // _MAT3\r\n\t\tcase 0x8b5c: return setValueM4a; // _MAT4\r\n\r\n\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\r\n\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\r\n\r\n\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\r\n\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\r\n\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\r\n\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\r\n\r\n\t}\r\n\r\n}\r\n\r\n// --- Uniform Classes ---\r\n\r\nfunction SingleUniform( id, activeInfo, addr ) {\r\n\r\n\tthis.id = id;\r\n\tthis.addr = addr;\r\n\tthis.cache = [];\r\n\tthis.setValue = getSingularSetter( activeInfo.type );\r\n\r\n\t// this.path = activeInfo.name; // DEBUG\r\n\r\n}\r\n\r\nfunction PureArrayUniform( id, activeInfo, addr ) {\r\n\r\n\tthis.id = id;\r\n\tthis.addr = addr;\r\n\tthis.cache = [];\r\n\tthis.size = activeInfo.size;\r\n\tthis.setValue = getPureArraySetter( activeInfo.type );\r\n\r\n\t// this.path = activeInfo.name; // DEBUG\r\n\r\n}\r\n\r\nPureArrayUniform.prototype.updateCache = function ( data ) {\r\n\r\n\tvar cache = this.cache;\r\n\r\n\tif ( data instanceof Float32Array && cache.length !== data.length ) {\r\n\r\n\t\tthis.cache = new Float32Array( data.length );\r\n\r\n\t}\r\n\r\n\tcopyArray( cache, data );\r\n\r\n};\r\n\r\nfunction StructuredUniform( id ) {\r\n\r\n\tthis.id = id;\r\n\r\n\tUniformContainer.call( this ); // mix-in\r\n\r\n}\r\n\r\nStructuredUniform.prototype.setValue = function ( gl, value, renderer ) {\r\n\r\n\tvar seq = this.seq;\r\n\r\n\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\tvar u = seq[ i ];\r\n\t\tu.setValue( gl, value[ u.id ], renderer );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// --- Top-level ---\r\n\r\n// Parser - builds up the property tree from the path strings\r\n\r\nvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\r\n\r\n// extracts\r\n// \t- the identifier (member name or array index)\r\n//  - followed by an optional right bracket (found when array index)\r\n//  - followed by an optional left bracket or dot (type of subscript)\r\n//\r\n// Note: These portions can be read in a non-overlapping fashion and\r\n// allow straightforward parsing of the hierarchy that WebGL encodes\r\n// in the uniform names.\r\n\r\nfunction addUniform( container, uniformObject ) {\r\n\r\n\tcontainer.seq.push( uniformObject );\r\n\tcontainer.map[ uniformObject.id ] = uniformObject;\r\n\r\n}\r\n\r\nfunction parseUniform( activeInfo, addr, container ) {\r\n\r\n\tvar path = activeInfo.name,\r\n\t\tpathLength = path.length;\r\n\r\n\t// reset RegExp object, because of the early exit of a previous run\r\n\tRePathPart.lastIndex = 0;\r\n\r\n\twhile ( true ) {\r\n\r\n\t\tvar match = RePathPart.exec( path ),\r\n\t\t\tmatchEnd = RePathPart.lastIndex,\r\n\r\n\t\t\tid = match[ 1 ],\r\n\t\t\tidIsIndex = match[ 2 ] === ']',\r\n\t\t\tsubscript = match[ 3 ];\r\n\r\n\t\tif ( idIsIndex ) { id = id | 0; } // convert to integer\r\n\r\n\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\r\n\r\n\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\r\n\r\n\t\t\taddUniform( container, subscript === undefined ?\r\n\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\r\n\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// step into inner node / create it in case it doesn't exist\r\n\r\n\t\t\tvar map = container.map, next = map[ id ];\r\n\r\n\t\t\tif ( next === undefined ) {\r\n\r\n\t\t\t\tnext = new StructuredUniform( id );\r\n\t\t\t\taddUniform( container, next );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcontainer = next;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Root Container\r\n\r\nfunction WebGLUniforms( gl, program, renderer ) {\n\tvar this$1 = this;\n\r\n\r\n\tUniformContainer.call( this );\r\n\r\n\tthis.renderer = renderer;\r\n\r\n\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\r\n\r\n\tfor ( var i = 0; i < n; ++ i ) {\r\n\r\n\t\tvar info = gl.getActiveUniform( program, i ),\r\n\t\t\taddr = gl.getUniformLocation( program, info.name );\r\n\r\n\t\tparseUniform( info, addr, this$1 );\r\n\r\n\t}\r\n\r\n}\r\n\r\nWebGLUniforms.prototype.setValue = function ( gl, name, value ) {\r\n\r\n\tvar u = this.map[ name ];\r\n\r\n\tif ( u !== undefined ) { u.setValue( gl, value, this.renderer ); }\r\n\r\n};\r\n\r\nWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\r\n\r\n\tvar v = object[ name ];\r\n\r\n\tif ( v !== undefined ) { this.setValue( gl, name, v ); }\r\n\r\n};\r\n\r\n// Static interface\r\n\r\nWebGLUniforms.upload = function ( gl, seq, values, renderer ) {\r\n\r\n\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\tvar u = seq[ i ],\r\n\t\t\tv = values[ u.id ];\r\n\r\n\t\tif ( v.needsUpdate !== false ) {\r\n\r\n\t\t\t// note: always updating when .needsUpdate is undefined\r\n\t\t\tu.setValue( gl, v.value, renderer );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nWebGLUniforms.seqWithValue = function ( seq, values ) {\r\n\r\n\tvar r = [];\r\n\r\n\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\tvar u = seq[ i ];\r\n\t\tif ( u.id in values ) { r.push( u ); }\r\n\r\n\t}\r\n\r\n\treturn r;\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction addLineNumbers( string ) {\r\n\r\n\tvar lines = string.split( '\\n' );\r\n\r\n\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\r\n\t}\r\n\r\n\treturn lines.join( '\\n' );\r\n\r\n}\r\n\r\nfunction WebGLShader( gl, type, string ) {\r\n\r\n\tvar shader = gl.createShader( type );\r\n\r\n\tgl.shaderSource( shader, string );\r\n\tgl.compileShader( shader );\r\n\r\n\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\r\n\t\tconsole.error( 'WebGLShader: Shader couldn\\'t compile.' );\r\n\r\n\t}\r\n\r\n\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\r\n\t\tconsole.warn( 'WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\r\n\t}\r\n\r\n\t// --enable-privileged-webgl-extension\r\n\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\r\n\treturn shader;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar programIdCount = 0;\r\n\r\nfunction getEncodingComponents( encoding ) {\r\n\r\n\tswitch ( encoding ) {\r\n\r\n\t\tcase LinearEncoding:\r\n\t\t\treturn [ 'Linear', '( value )' ];\r\n\t\tcase sRGBEncoding:\r\n\t\t\treturn [ 'sRGB', '( value )' ];\r\n\t\tcase RGBEEncoding:\r\n\t\t\treturn [ 'RGBE', '( value )' ];\r\n\t\tcase RGBM7Encoding:\r\n\t\t\treturn [ 'RGBM', '( value, 7.0 )' ];\r\n\t\tcase RGBM16Encoding:\r\n\t\t\treturn [ 'RGBM', '( value, 16.0 )' ];\r\n\t\tcase RGBDEncoding:\r\n\t\t\treturn [ 'RGBD', '( value, 256.0 )' ];\r\n\t\tcase GammaEncoding:\r\n\t\t\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\r\n\t\tdefault:\r\n\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getTexelDecodingFunction( functionName, encoding ) {\r\n\r\n\tvar components = getEncodingComponents( encoding );\r\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\r\n\r\n}\r\n\r\nfunction getTexelEncodingFunction( functionName, encoding ) {\r\n\r\n\tvar components = getEncodingComponents( encoding );\r\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\r\n\r\n}\r\n\r\nfunction getToneMappingFunction( functionName, toneMapping ) {\r\n\r\n\tvar toneMappingName;\r\n\r\n\tswitch ( toneMapping ) {\r\n\r\n\t\tcase LinearToneMapping:\r\n\t\t\ttoneMappingName = 'Linear';\r\n\t\t\tbreak;\r\n\r\n\t\tcase ReinhardToneMapping:\r\n\t\t\ttoneMappingName = 'Reinhard';\r\n\t\t\tbreak;\r\n\r\n\t\tcase Uncharted2ToneMapping:\r\n\t\t\ttoneMappingName = 'Uncharted2';\r\n\t\t\tbreak;\r\n\r\n\t\tcase CineonToneMapping:\r\n\t\t\ttoneMappingName = 'OptimizedCineon';\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\r\n\r\n\t}\r\n\r\n\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\r\n\r\n}\r\n\r\nfunction generateExtensions( extensions, parameters, rendererExtensions ) {\r\n\r\n\textensions = extensions || {};\r\n\r\n\tvar chunks = [\r\n\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\r\n\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\r\n\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''\r\n\t];\r\n\r\n\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\r\n\r\n}\r\n\r\nfunction generateDefines( defines ) {\r\n\r\n\tvar chunks = [];\r\n\r\n\tfor ( var name in defines ) {\r\n\r\n\t\tvar value = defines[ name ];\r\n\r\n\t\tif ( value === false ) { continue; }\r\n\r\n\t\tchunks.push( '#define ' + name + ' ' + value );\r\n\r\n\t}\r\n\r\n\treturn chunks.join( '\\n' );\r\n\r\n}\r\n\r\nfunction fetchAttributeLocations( gl, program ) {\r\n\r\n\tvar attributes = {};\r\n\r\n\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\r\n\r\n\tfor ( var i = 0; i < n; i ++ ) {\r\n\r\n\t\tvar info = gl.getActiveAttrib( program, i );\r\n\t\tvar name = info.name;\r\n\r\n\t\t// console.log( 'WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\r\n\r\n\t\tattributes[ name ] = gl.getAttribLocation( program, name );\r\n\r\n\t}\r\n\r\n\treturn attributes;\r\n\r\n}\r\n\r\nfunction filterEmptyLine( string ) {\r\n\r\n\treturn string !== '';\r\n\r\n}\r\n\r\nfunction replaceLightNums( string, parameters ) {\r\n\r\n\treturn string\r\n\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\r\n\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\r\n\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\r\n\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\r\n\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\r\n\r\n}\r\n\r\nfunction replaceClippingPlaneNums( string, parameters ) {\r\n\r\n\treturn string\r\n\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\r\n\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\r\n\r\n}\r\n\r\nfunction parseIncludes( string ) {\r\n\r\n\tvar pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\r\n\r\n\tfunction replace( match, include ) {\r\n\r\n\t\tvar replace = ShaderChunk[ include ];\r\n\r\n\t\tif ( replace === undefined ) {\r\n\r\n\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\r\n\r\n\t\t}\r\n\r\n\t\treturn parseIncludes( replace );\r\n\r\n\t}\r\n\r\n\treturn string.replace( pattern, replace );\r\n\r\n}\r\n\r\nfunction unrollLoops( string ) {\r\n\r\n\tvar pattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\r\n\r\n\tfunction replace( match, start, end, snippet ) {\r\n\r\n\t\tvar unroll = '';\r\n\r\n\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\r\n\r\n\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\r\n\r\n\t\t}\r\n\r\n\t\treturn unroll;\r\n\r\n\t}\r\n\r\n\treturn string.replace( pattern, replace );\r\n\r\n}\r\n\r\nfunction WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities ) {\r\n\r\n\tvar gl = renderer.context;\r\n\r\n\tvar defines = material.defines;\r\n\r\n\tvar vertexShader = shader.vertexShader;\r\n\tvar fragmentShader = shader.fragmentShader;\r\n\r\n\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\r\n\tif ( parameters.shadowMapType === PCFShadowMap ) {\r\n\r\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\r\n\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\r\n\r\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\r\n\t}\r\n\r\n\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\r\n\tif ( parameters.envMap ) {\r\n\r\n\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\tcase CubeReflectionMapping:\r\n\t\t\tcase CubeRefractionMapping:\r\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase CubeUVReflectionMapping:\r\n\t\t\tcase CubeUVRefractionMapping:\r\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase EquirectangularReflectionMapping:\r\n\t\t\tcase EquirectangularRefractionMapping:\r\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase SphericalReflectionMapping:\r\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\tcase CubeRefractionMapping:\r\n\t\t\tcase EquirectangularRefractionMapping:\r\n\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tswitch ( material.combine ) {\r\n\r\n\t\t\tcase MultiplyOperation:\r\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MixOperation:\r\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase AddOperation:\r\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\r\n\t// console.log( 'building new program ' );\r\n\r\n\t//\r\n\r\n\tvar customExtensions = capabilities.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );\r\n\r\n\tvar customDefines = generateDefines( defines );\r\n\r\n\t//\r\n\r\n\tvar program = gl.createProgram();\r\n\r\n\tvar prefixVertex, prefixFragment;\r\n\r\n\tif ( material.isRawShaderMaterial ) {\r\n\r\n\t\tprefixVertex = [\r\n\r\n\t\t\tcustomDefines\r\n\r\n\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t\tif ( prefixVertex.length > 0 ) {\r\n\r\n\t\t\tprefixVertex += '\\n';\r\n\r\n\t\t}\r\n\r\n\t\tprefixFragment = [\r\n\r\n\t\t\tcustomExtensions,\r\n\t\t\tcustomDefines\r\n\r\n\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t\tif ( prefixFragment.length > 0 ) {\r\n\r\n\t\t\tprefixFragment += '\\n';\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tprefixVertex = [\r\n\r\n\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t'#define SHADER_NAME ' + shader.name,\r\n\r\n\t\t\tcustomDefines,\r\n\r\n\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\r\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\r\n\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\r\n\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\r\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\r\n\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\r\n\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\r\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\tparameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t'uniform vec3 cameraPosition;',\r\n\r\n\t\t\t'attribute vec3 position;',\r\n\t\t\t'attribute vec3 normal;',\r\n\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t'#ifdef USE_COLOR',\r\n\r\n\t\t\t'\tattribute vec3 color;',\r\n\r\n\t\t\t'#endif',\r\n\r\n\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\r\n\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t'\tattribute vec3 morphTarget3;',\r\n\r\n\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\r\n\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\r\n\t\t\t'\t#else',\r\n\r\n\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\r\n\t\t\t'\t#endif',\r\n\r\n\t\t\t'#endif',\r\n\r\n\t\t\t'#ifdef USE_SKINNING',\r\n\r\n\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t'\tattribute vec4 skinWeight;',\r\n\r\n\t\t\t'#endif',\r\n\r\n\t\t\t'\\n'\r\n\r\n\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t\tprefixFragment = [\r\n\r\n\t\t\tcustomExtensions,\r\n\r\n\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t'#define SHADER_NAME ' + shader.name,\r\n\r\n\t\t\tcustomDefines,\r\n\r\n\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer\r\n\r\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\r\n\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\r\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\r\n\r\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\r\n\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\r\n\r\n\t\t\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\r\n\r\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\tparameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\t\t\tparameters.envMap && ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',\r\n\r\n\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t'uniform vec3 cameraPosition;',\r\n\r\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\r\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\r\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\r\n\r\n\t\t\tparameters.dithering ? '#define DITHERING' : '',\r\n\r\n\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\r\n\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\r\n\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\r\n\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\r\n\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',\r\n\r\n\t\t\tparameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',\r\n\r\n\t\t\t'\\n'\r\n\r\n\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t}\r\n\r\n\tvertexShader = parseIncludes( vertexShader );\r\n\tvertexShader = replaceLightNums( vertexShader, parameters );\r\n\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\r\n\r\n\tfragmentShader = parseIncludes( fragmentShader );\r\n\tfragmentShader = replaceLightNums( fragmentShader, parameters );\r\n\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\r\n\r\n\tvertexShader = unrollLoops( vertexShader );\r\n\tfragmentShader = unrollLoops( fragmentShader );\r\n\r\n\tif ( capabilities.isWebGL2 && ! material.isRawShaderMaterial ) {\r\n\r\n\t\tvar isGLSL3ShaderMaterial = false;\r\n\r\n\t\tvar versionRegex = /^\\s*#version\\s+300\\s+es\\s*\\n/;\r\n\r\n\t\tif ( material.isShaderMaterial &&\r\n\t\t\tvertexShader.match( versionRegex ) !== null &&\r\n\t\t\tfragmentShader.match( versionRegex ) !== null ) {\r\n\r\n\t\t\tisGLSL3ShaderMaterial = true;\r\n\r\n\t\t\tvertexShader = vertexShader.replace( versionRegex, '' );\r\n\t\t\tfragmentShader = fragmentShader.replace( versionRegex, '' );\r\n\r\n\t\t}\r\n\r\n\t\t// GLSL 3.0 conversion\r\n\t\tprefixVertex = [\r\n\t\t\t'#version 300 es\\n',\r\n\t\t\t'#define attribute in',\r\n\t\t\t'#define varying out',\r\n\t\t\t'#define texture2D texture'\r\n\t\t].join( '\\n' ) + '\\n' + prefixVertex;\r\n\r\n\t\tprefixFragment = [\r\n\t\t\t'#version 300 es\\n',\r\n\t\t\t'#define varying in',\r\n\t\t\tisGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',\r\n\t\t\tisGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',\r\n\t\t\t'#define gl_FragDepthEXT gl_FragDepth',\r\n\t\t\t'#define texture2D texture',\r\n\t\t\t'#define textureCube texture',\r\n\t\t\t'#define texture2DProj textureProj',\r\n\t\t\t'#define texture2DLodEXT textureLod',\r\n\t\t\t'#define texture2DProjLodEXT textureProjLod',\r\n\t\t\t'#define textureCubeLodEXT textureLod',\r\n\t\t\t'#define texture2DGradEXT textureGrad',\r\n\t\t\t'#define texture2DProjGradEXT textureProjGrad',\r\n\t\t\t'#define textureCubeGradEXT textureGrad'\r\n\t\t].join( '\\n' ) + '\\n' + prefixFragment;\r\n\r\n\t}\r\n\r\n\tvar vertexGlsl = prefixVertex + vertexShader;\r\n\tvar fragmentGlsl = prefixFragment + fragmentShader;\r\n\r\n\t// console.log( '*VERTEX*', vertexGlsl );\r\n\t// console.log( '*FRAGMENT*', fragmentGlsl );\r\n\r\n\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\r\n\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\r\n\r\n\tgl.attachShader( program, glVertexShader );\r\n\tgl.attachShader( program, glFragmentShader );\r\n\r\n\t// Force a particular attribute to index 0.\r\n\r\n\tif ( material.index0AttributeName !== undefined ) {\r\n\r\n\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\r\n\r\n\t} else if ( parameters.morphTargets === true ) {\r\n\r\n\t\t// programs with morphTargets displace position out of attribute 0\r\n\t\tgl.bindAttribLocation( program, 0, 'position' );\r\n\r\n\t}\r\n\r\n\tgl.linkProgram( program );\r\n\r\n\tvar programLog = gl.getProgramInfoLog( program ).trim();\r\n\tvar vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\r\n\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\r\n\r\n\tvar runnable = true;\r\n\tvar haveDiagnostics = true;\r\n\r\n\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\r\n\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\r\n\r\n\t\trunnable = false;\r\n\r\n\t\tconsole.error( 'WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\r\n\r\n\t} else if ( programLog !== '' ) {\r\n\r\n\t\tconsole.warn( 'WebGLProgram: gl.getProgramInfoLog()', programLog );\r\n\r\n\t} else if ( vertexLog === '' || fragmentLog === '' ) {\r\n\r\n\t\thaveDiagnostics = false;\r\n\r\n\t}\r\n\r\n\tif ( haveDiagnostics ) {\r\n\r\n\t\tthis.diagnostics = {\r\n\r\n\t\t\trunnable: runnable,\r\n\t\t\tmaterial: material,\r\n\r\n\t\t\tprogramLog: programLog,\r\n\r\n\t\t\tvertexShader: {\r\n\r\n\t\t\t\tlog: vertexLog,\r\n\t\t\t\tprefix: prefixVertex\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfragmentShader: {\r\n\r\n\t\t\t\tlog: fragmentLog,\r\n\t\t\t\tprefix: prefixFragment\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t// clean up\r\n\r\n\tgl.deleteShader( glVertexShader );\r\n\tgl.deleteShader( glFragmentShader );\r\n\r\n\t// set up caching for uniform locations\r\n\r\n\tvar cachedUniforms;\r\n\r\n\tthis.getUniforms = function () {\r\n\r\n\t\tif ( cachedUniforms === undefined ) {\r\n\r\n\t\t\tcachedUniforms = new WebGLUniforms( gl, program, renderer );\r\n\r\n\t\t}\r\n\r\n\t\treturn cachedUniforms;\r\n\r\n\t};\r\n\r\n\t// set up caching for attribute locations\r\n\r\n\tvar cachedAttributes;\r\n\r\n\tthis.getAttributes = function () {\r\n\r\n\t\tif ( cachedAttributes === undefined ) {\r\n\r\n\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\r\n\r\n\t\t}\r\n\r\n\t\treturn cachedAttributes;\r\n\r\n\t};\r\n\r\n\t// free resource\r\n\r\n\tthis.destroy = function () {\r\n\r\n\t\tgl.deleteProgram( program );\r\n\t\tthis.program = undefined;\r\n\r\n\t};\r\n\r\n\t// DEPRECATED\r\n\r\n\tObject.defineProperties( this, {\r\n\r\n\t\tuniforms: {\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLProgram: .uniforms is now .getUniforms().' );\r\n\t\t\t\treturn this.getUniforms();\r\n\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tattributes: {\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLProgram: .attributes is now .getAttributes().' );\r\n\t\t\t\treturn this.getAttributes();\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t//\r\n\r\n\tthis.name = shader.name;\r\n\tthis.id = programIdCount ++;\r\n\tthis.code = code;\r\n\tthis.usedTimes = 1;\r\n\tthis.program = program;\r\n\tthis.vertexShader = glVertexShader;\r\n\tthis.fragmentShader = glFragmentShader;\r\n\r\n\treturn this;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLPrograms( renderer, extensions, capabilities ) {\r\n\r\n\tvar programs = [];\r\n\r\n\tvar shaderIDs = {\r\n\t\tMeshDepthMaterial: 'depth',\r\n\t\tMeshDistanceMaterial: 'distanceRGBA',\r\n\t\tMeshNormalMaterial: 'normal',\r\n\t\tMeshBasicMaterial: 'basic',\r\n\t\tMeshLambertMaterial: 'lambert',\r\n\t\tMeshPhongMaterial: 'phong',\r\n\t\tMeshToonMaterial: 'phong',\r\n\t\tMeshStandardMaterial: 'physical',\r\n\t\tMeshPhysicalMaterial: 'physical',\r\n\t\tLineBasicMaterial: 'basic',\r\n\t\tLineDashedMaterial: 'dashed',\r\n\t\tPointsMaterial: 'points',\r\n\t\tShadowMaterial: 'shadow',\r\n\t\tSpriteMaterial: 'sprite'\r\n\t};\r\n\r\n\tvar parameterNames = [\r\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\r\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"objectSpaceNormalMap\", \"displacementMap\", \"specularMap\",\r\n\t\t\"roughnessMap\", \"metalnessMap\", \"gradientMap\",\r\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\r\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\r\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\r\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\r\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\", \"numRectAreaLights\",\r\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\r\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\", \"dithering\"\r\n\t];\r\n\r\n\tfunction allocateBones( object ) {\r\n\r\n\t\tvar skeleton = object.skeleton;\r\n\t\tvar bones = skeleton.bones;\r\n\r\n\t\tif ( capabilities.floatVertexTextures ) {\r\n\r\n\t\t\treturn 1024;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// default for when object is not specified\r\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\r\n\t\t\t//\r\n\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t//    (up to 54 should be safe)\r\n\r\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\r\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n\t\t\tvar maxBones = Math.min( nVertexMatrices, bones.length );\r\n\r\n\t\t\tif ( maxBones < bones.length ) {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn maxBones;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\r\n\r\n\t\tvar encoding;\r\n\r\n\t\tif ( ! map ) {\r\n\r\n\t\t\tencoding = LinearEncoding;\r\n\r\n\t\t} else if ( map.isTexture ) {\r\n\r\n\t\t\tencoding = map.encoding;\r\n\r\n\t\t} else if ( map.isWebGLRenderTarget ) {\r\n\r\n\t\t\tconsole.warn( \"WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\r\n\t\t\tencoding = map.texture.encoding;\r\n\r\n\t\t}\r\n\r\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\r\n\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\r\n\r\n\t\t\tencoding = GammaEncoding;\r\n\r\n\t\t}\r\n\r\n\t\treturn encoding;\r\n\r\n\t}\r\n\r\n\tthis.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {\r\n\r\n\t\tvar shaderID = shaderIDs[ material.type ];\r\n\r\n\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t// (not to blow over maxLights budget)\r\n\r\n\t\tvar maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;\r\n\t\tvar precision = capabilities.precision;\r\n\r\n\t\tif ( material.precision !== null ) {\r\n\r\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\r\n\r\n\t\t\tif ( precision !== material.precision ) {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\tvar parameters = {\r\n\r\n\t\t\tshaderID: shaderID,\r\n\r\n\t\t\tprecision: precision,\r\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\r\n\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\r\n\t\t\tmap: !! material.map,\r\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\r\n\t\t\tenvMap: !! material.envMap,\r\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\r\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\r\n\t\t\tlightMap: !! material.lightMap,\r\n\t\t\taoMap: !! material.aoMap,\r\n\t\t\temissiveMap: !! material.emissiveMap,\r\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\r\n\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\tobjectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\r\n\t\t\tdisplacementMap: !! material.displacementMap,\r\n\t\t\troughnessMap: !! material.roughnessMap,\r\n\t\t\tmetalnessMap: !! material.metalnessMap,\r\n\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\talphaMap: !! material.alphaMap,\r\n\r\n\t\t\tgradientMap: !! material.gradientMap,\r\n\r\n\t\t\tcombine: material.combine,\r\n\r\n\t\t\tvertexColors: material.vertexColors,\r\n\r\n\t\t\tfog: !! fog,\r\n\t\t\tuseFog: material.fog,\r\n\t\t\tfogExp: ( fog && fog.isFogExp2 ),\r\n\r\n\t\t\tflatShading: material.flatShading,\r\n\r\n\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\r\n\r\n\t\t\tskinning: material.skinning && maxBones > 0,\r\n\t\t\tmaxBones: maxBones,\r\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures,\r\n\r\n\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\r\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\r\n\r\n\t\t\tnumDirLights: lights.directional.length,\r\n\t\t\tnumPointLights: lights.point.length,\r\n\t\t\tnumSpotLights: lights.spot.length,\r\n\t\t\tnumRectAreaLights: lights.rectArea.length,\r\n\t\t\tnumHemiLights: lights.hemi.length,\r\n\r\n\t\t\tnumClippingPlanes: nClipPlanes,\r\n\t\t\tnumClipIntersection: nClipIntersection,\r\n\r\n\t\t\tdithering: material.dithering,\r\n\r\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,\r\n\t\t\tshadowMapType: renderer.shadowMap.type,\r\n\r\n\t\t\ttoneMapping: renderer.toneMapping,\r\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\r\n\r\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\r\n\r\n\t\t\talphaTest: material.alphaTest,\r\n\t\t\tdoubleSided: material.side === DoubleSide,\r\n\t\t\tflipSided: material.side === BackSide,\r\n\r\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\r\n\r\n\t\t};\r\n\r\n\t\treturn parameters;\r\n\r\n\t};\r\n\r\n\tthis.getProgramCode = function ( material, parameters ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tif ( parameters.shaderID ) {\r\n\r\n\t\t\tarray.push( parameters.shaderID );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarray.push( material.fragmentShader );\r\n\t\t\tarray.push( material.vertexShader );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.defines !== undefined ) {\r\n\r\n\t\t\tfor ( var name in material.defines ) {\r\n\r\n\t\t\t\tarray.push( name );\r\n\t\t\t\tarray.push( material.defines[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\r\n\r\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\r\n\r\n\t\t}\r\n\r\n\t\tarray.push( material.onBeforeCompile.toString() );\r\n\r\n\t\tarray.push( renderer.gammaOutput );\r\n\r\n\t\treturn array.join();\r\n\r\n\t};\r\n\r\n\tthis.acquireProgram = function ( material, shader, parameters, code ) {\r\n\r\n\t\tvar program;\r\n\r\n\t\t// Check if code has been already compiled\r\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\r\n\r\n\t\t\tvar programInfo = programs[ p ];\r\n\r\n\t\t\tif ( programInfo.code === code ) {\r\n\r\n\t\t\t\tprogram = programInfo;\r\n\t\t\t\t++ program.usedTimes;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tprogram = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities );\r\n\t\t\tprograms.push( program );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\tthis.releaseProgram = function ( program ) {\r\n\r\n\t\tif ( -- program.usedTimes === 0 ) {\r\n\r\n\t\t\t// Remove from unordered set\r\n\t\t\tvar i = programs.indexOf( program );\r\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\r\n\t\t\tprograms.pop();\r\n\r\n\t\t\t// Free WebGL resources\r\n\t\t\tprogram.destroy();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Exposed for resource monitoring & error feedback via renderer.info:\r\n\tthis.programs = programs;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLProperties() {\r\n\r\n\tvar properties = new WeakMap();\r\n\r\n\tfunction get( object ) {\r\n\r\n\t\tvar map = properties.get( object );\r\n\r\n\t\tif ( map === undefined ) {\r\n\r\n\t\t\tmap = {};\r\n\t\t\tproperties.set( object, map );\r\n\r\n\t\t}\r\n\r\n\t\treturn map;\r\n\r\n\t}\r\n\r\n\tfunction remove( object ) {\r\n\r\n\t\tproperties.delete( object );\r\n\r\n\t}\r\n\r\n\tfunction update( object, key, value ) {\r\n\r\n\t\tproperties.get( object )[ key ] = value;\r\n\r\n\t}\r\n\r\n\tfunction dispose() {\r\n\r\n\t\tproperties = new WeakMap();\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tget: get,\r\n\t\tremove: remove,\r\n\t\tupdate: update,\r\n\t\tdispose: dispose\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction painterSortStable( a, b ) {\r\n\r\n\tif ( a.renderOrder !== b.renderOrder ) {\r\n\r\n\t\treturn a.renderOrder - b.renderOrder;\r\n\r\n\t} else if ( a.program && b.program && a.program !== b.program ) {\r\n\r\n\t\treturn a.program.id - b.program.id;\r\n\r\n\t} else if ( a.material.id !== b.material.id ) {\r\n\r\n\t\treturn a.material.id - b.material.id;\r\n\r\n\t} else if ( a.z !== b.z ) {\r\n\r\n\t\treturn a.z - b.z;\r\n\r\n\t} else {\r\n\r\n\t\treturn a.id - b.id;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction reversePainterSortStable( a, b ) {\r\n\r\n\tif ( a.renderOrder !== b.renderOrder ) {\r\n\r\n\t\treturn a.renderOrder - b.renderOrder;\r\n\r\n\t} if ( a.z !== b.z ) {\r\n\r\n\t\treturn b.z - a.z;\r\n\r\n\t} else {\r\n\r\n\t\treturn a.id - b.id;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction WebGLRenderList() {\r\n\r\n\tvar renderItems = [];\r\n\tvar renderItemsIndex = 0;\r\n\r\n\tvar opaque = [];\r\n\tvar transparent = [];\r\n\r\n\tfunction init() {\r\n\r\n\t\trenderItemsIndex = 0;\r\n\r\n\t\topaque.length = 0;\r\n\t\ttransparent.length = 0;\r\n\r\n\t}\r\n\r\n\tfunction push( object, geometry, material, z, group ) {\r\n\r\n\t\tvar renderItem = renderItems[ renderItemsIndex ];\r\n\r\n\t\tif ( renderItem === undefined ) {\r\n\r\n\t\t\trenderItem = {\r\n\t\t\t\tid: object.id,\r\n\t\t\t\tobject: object,\r\n\t\t\t\tgeometry: geometry,\r\n\t\t\t\tmaterial: material,\r\n\t\t\t\tprogram: material.program,\r\n\t\t\t\trenderOrder: object.renderOrder,\r\n\t\t\t\tz: z,\r\n\t\t\t\tgroup: group\r\n\t\t\t};\r\n\r\n\t\t\trenderItems[ renderItemsIndex ] = renderItem;\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderItem.id = object.id;\r\n\t\t\trenderItem.object = object;\r\n\t\t\trenderItem.geometry = geometry;\r\n\t\t\trenderItem.material = material;\r\n\t\t\trenderItem.program = material.program;\r\n\t\t\trenderItem.renderOrder = object.renderOrder;\r\n\t\t\trenderItem.z = z;\r\n\t\t\trenderItem.group = group;\r\n\r\n\t\t}\r\n\r\n\t\t( material.transparent === true ? transparent : opaque ).push( renderItem );\r\n\r\n\t\trenderItemsIndex ++;\r\n\r\n\t}\r\n\r\n\tfunction sort() {\r\n\r\n\t\tif ( opaque.length > 1 ) { opaque.sort( painterSortStable ); }\r\n\t\tif ( transparent.length > 1 ) { transparent.sort( reversePainterSortStable ); }\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\topaque: opaque,\r\n\t\ttransparent: transparent,\r\n\r\n\t\tinit: init,\r\n\t\tpush: push,\r\n\r\n\t\tsort: sort\r\n\t};\r\n\r\n}\r\n\r\nfunction WebGLRenderLists() {\r\n\r\n\tvar lists = {};\r\n\r\n\tfunction get( scene, camera ) {\r\n\r\n\t\tvar hash = scene.id + ',' + camera.id;\r\n\t\tvar list = lists[ hash ];\r\n\r\n\t\tif ( list === undefined ) {\r\n\r\n\t\t\t// console.log( 'WebGLRenderLists:', hash );\r\n\r\n\t\t\tlist = new WebGLRenderList();\r\n\t\t\tlists[ hash ] = list;\r\n\r\n\t\t}\r\n\r\n\t\treturn list;\r\n\r\n\t}\r\n\r\n\tfunction dispose() {\r\n\r\n\t\tlists = {};\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tget: get,\r\n\t\tdispose: dispose\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction UniformsCache() {\r\n\r\n\tvar lights = {};\r\n\r\n\treturn {\r\n\r\n\t\tget: function ( light ) {\r\n\r\n\t\t\tif ( lights[ light.id ] !== undefined ) {\r\n\r\n\t\t\t\treturn lights[ light.id ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar uniforms;\r\n\r\n\t\t\tswitch ( light.type ) {\r\n\r\n\t\t\t\tcase 'DirectionalLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tdirection: new Vector3(),\r\n\t\t\t\t\t\tcolor: new Color(),\r\n\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'SpotLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tposition: new Vector3(),\r\n\t\t\t\t\t\tdirection: new Vector3(),\r\n\t\t\t\t\t\tcolor: new Color(),\r\n\t\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\t\tconeCos: 0,\r\n\t\t\t\t\t\tpenumbraCos: 0,\r\n\t\t\t\t\t\tdecay: 0,\r\n\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tposition: new Vector3(),\r\n\t\t\t\t\t\tcolor: new Color(),\r\n\t\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\t\tdecay: 0,\r\n\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new Vector2(),\r\n\t\t\t\t\t\tshadowCameraNear: 1,\r\n\t\t\t\t\t\tshadowCameraFar: 1000\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'HemisphereLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tdirection: new Vector3(),\r\n\t\t\t\t\t\tskyColor: new Color(),\r\n\t\t\t\t\t\tgroundColor: new Color()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'RectAreaLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tcolor: new Color(),\r\n\t\t\t\t\t\tposition: new Vector3(),\r\n\t\t\t\t\t\thalfWidth: new Vector3(),\r\n\t\t\t\t\t\thalfHeight: new Vector3()\r\n\t\t\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlights[ light.id ] = uniforms;\r\n\r\n\t\t\treturn uniforms;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\r\n\r\nvar count = 0;\r\n\r\nfunction WebGLLights() {\r\n\r\n\tvar cache = new UniformsCache();\r\n\r\n\tvar state = {\r\n\r\n\t\tid: count ++,\r\n\r\n\t\thash: {\r\n\t\t\tstateID: - 1,\r\n\t\t\tdirectionalLength: - 1,\r\n\t\t\tpointLength: - 1,\r\n\t\t\tspotLength: - 1,\r\n\t\t\trectAreaLength: - 1,\r\n\t\t\themiLength: - 1,\r\n\t\t\tshadowsLength: - 1\r\n\t\t},\r\n\r\n\t\tambient: [ 0, 0, 0 ],\r\n\t\tdirectional: [],\r\n\t\tdirectionalShadowMap: [],\r\n\t\tdirectionalShadowMatrix: [],\r\n\t\tspot: [],\r\n\t\tspotShadowMap: [],\r\n\t\tspotShadowMatrix: [],\r\n\t\trectArea: [],\r\n\t\tpoint: [],\r\n\t\tpointShadowMap: [],\r\n\t\tpointShadowMatrix: [],\r\n\t\themi: []\r\n\r\n\t};\r\n\r\n\tvar vector3 = new Vector3();\r\n\tvar matrix4 = new Matrix4();\r\n\tvar matrix42 = new Matrix4();\r\n\r\n\tfunction setup( lights, shadows, camera ) {\r\n\r\n\t\tvar r = 0, g = 0, b = 0;\r\n\r\n\t\tvar directionalLength = 0;\r\n\t\tvar pointLength = 0;\r\n\t\tvar spotLength = 0;\r\n\t\tvar rectAreaLength = 0;\r\n\t\tvar hemiLength = 0;\r\n\r\n\t\tvar viewMatrix = camera.matrixWorldInverse;\r\n\r\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar light = lights[ i ];\r\n\r\n\t\t\tvar color = light.color;\r\n\t\t\tvar intensity = light.intensity;\r\n\t\t\tvar distance = light.distance;\r\n\r\n\t\t\tvar shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\r\n\r\n\t\t\tif ( light.isAmbientLight ) {\r\n\r\n\t\t\t\tr += color.r * intensity;\r\n\t\t\t\tg += color.g * intensity;\r\n\t\t\t\tb += color.b * intensity;\r\n\r\n\t\t\t} else if ( light.isDirectionalLight ) {\r\n\r\n\t\t\t\tvar uniforms = cache.get( light );\r\n\r\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tuniforms.direction.sub( vector3 );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tvar shadow = light.shadow;\r\n\r\n\t\t\t\t\tuniforms.shadowBias = shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\r\n\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\r\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\r\n\r\n\t\t\t\tdirectionalLength ++;\r\n\r\n\t\t\t} else if ( light.isSpotLight ) {\r\n\r\n\t\t\t\tvar uniforms = cache.get( light );\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\r\n\t\t\t\tuniforms.distance = distance;\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tuniforms.direction.sub( vector3 );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\r\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\r\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\r\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tvar shadow = light.shadow;\r\n\r\n\t\t\t\t\tuniforms.shadowBias = shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\r\n\t\t\t\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\r\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\r\n\r\n\t\t\t\tspotLength ++;\r\n\r\n\t\t\t} else if ( light.isRectAreaLight ) {\r\n\r\n\t\t\t\tvar uniforms = cache.get( light );\r\n\r\n\t\t\t\t// (a) intensity is the total visible light emitted\r\n\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\r\n\r\n\t\t\t\t// (b) intensity is the brightness of the light\r\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\r\n\t\t\t\tmatrix42.identity();\r\n\t\t\t\tmatrix4.copy( light.matrixWorld );\r\n\t\t\t\tmatrix4.premultiply( viewMatrix );\r\n\t\t\t\tmatrix42.extractRotation( matrix4 );\r\n\r\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\r\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\r\n\r\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\r\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\r\n\r\n\t\t\t\t// TODO (abelnation): RectAreaLight distance?\r\n\t\t\t\t// uniforms.distance = distance;\r\n\r\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\r\n\r\n\t\t\t\trectAreaLength ++;\r\n\r\n\t\t\t} else if ( light.isPointLight ) {\r\n\r\n\t\t\t\tvar uniforms = cache.get( light );\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\tuniforms.distance = light.distance;\r\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tvar shadow = light.shadow;\r\n\r\n\t\t\t\t\tuniforms.shadowBias = shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\r\n\t\t\t\t\tuniforms.shadowCameraNear = shadow.camera.near;\r\n\t\t\t\t\tuniforms.shadowCameraFar = shadow.camera.far;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\r\n\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\r\n\t\t\t\tstate.point[ pointLength ] = uniforms;\r\n\r\n\t\t\t\tpointLength ++;\r\n\r\n\t\t\t} else if ( light.isHemisphereLight ) {\r\n\r\n\t\t\t\tvar uniforms = cache.get( light );\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\t\t\tuniforms.direction.normalize();\r\n\r\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\r\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\r\n\r\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\r\n\r\n\t\t\t\themiLength ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.ambient[ 0 ] = r;\r\n\t\tstate.ambient[ 1 ] = g;\r\n\t\tstate.ambient[ 2 ] = b;\r\n\r\n\t\tstate.directional.length = directionalLength;\r\n\t\tstate.spot.length = spotLength;\r\n\t\tstate.rectArea.length = rectAreaLength;\r\n\t\tstate.point.length = pointLength;\r\n\t\tstate.hemi.length = hemiLength;\r\n\r\n\t\tstate.hash.stateID = state.id;\r\n\t\tstate.hash.directionalLength = directionalLength;\r\n\t\tstate.hash.pointLength = pointLength;\r\n\t\tstate.hash.spotLength = spotLength;\r\n\t\tstate.hash.rectAreaLength = rectAreaLength;\r\n\t\tstate.hash.hemiLength = hemiLength;\r\n\t\tstate.hash.shadowsLength = shadows.length;\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tsetup: setup,\r\n\t\tstate: state\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLRenderState() {\r\n\r\n\tvar lights = new WebGLLights();\r\n\r\n\tvar lightsArray = [];\r\n\tvar shadowsArray = [];\r\n\r\n\tfunction init() {\r\n\r\n\t\tlightsArray.length = 0;\r\n\t\tshadowsArray.length = 0;\r\n\r\n\t}\r\n\r\n\tfunction pushLight( light ) {\r\n\r\n\t\tlightsArray.push( light );\r\n\r\n\t}\r\n\r\n\tfunction pushShadow( shadowLight ) {\r\n\r\n\t\tshadowsArray.push( shadowLight );\r\n\r\n\t}\r\n\r\n\tfunction setupLights( camera ) {\r\n\r\n\t\tlights.setup( lightsArray, shadowsArray, camera );\r\n\r\n\t}\r\n\r\n\tvar state = {\r\n\t\tlightsArray: lightsArray,\r\n\t\tshadowsArray: shadowsArray,\r\n\r\n\t\tlights: lights\r\n\t};\r\n\r\n\treturn {\r\n\t\tinit: init,\r\n\t\tstate: state,\r\n\t\tsetupLights: setupLights,\r\n\r\n\t\tpushLight: pushLight,\r\n\t\tpushShadow: pushShadow\r\n\t};\r\n\r\n}\r\n\r\nfunction WebGLRenderStates() {\r\n\r\n\tvar renderStates = {};\r\n\r\n\tfunction get( scene, camera ) {\r\n\r\n\t\tvar renderState;\r\n\r\n\t\tif ( renderStates[ scene.id ] === undefined ) {\r\n\r\n\t\t\trenderState = new WebGLRenderState();\r\n\t\t\trenderStates[ scene.id ] = {};\r\n\t\t\trenderStates[ scene.id ][ camera.id ] = renderState;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( renderStates[ scene.id ][ camera.id ] === undefined ) {\r\n\r\n\t\t\t\trenderState = new WebGLRenderState();\r\n\t\t\t\trenderStates[ scene.id ][ camera.id ] = renderState;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderState = renderStates[ scene.id ][ camera.id ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn renderState;\r\n\r\n\t}\r\n\r\n\tfunction dispose() {\r\n\r\n\t\trenderStates = {};\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tget: get,\r\n\t\tdispose: dispose\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\r\n\r\n\tvar _frustum = new Frustum(),\r\n\t\t_projScreenMatrix = new Matrix4(),\r\n\r\n\t\t_shadowMapSize = new Vector2(),\r\n\t\t_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),\r\n\r\n\t\t_lookTarget = new Vector3(),\r\n\t\t_lightPositionWorld = new Vector3(),\r\n\r\n\t\t_MorphingFlag = 1,\r\n\t\t_SkinningFlag = 2,\r\n\r\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\r\n\r\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\r\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\r\n\r\n\t\t_materialCache = {};\r\n\r\n\tvar shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\r\n\r\n\tvar cubeDirections = [\r\n\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\r\n\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\r\n\t];\r\n\r\n\tvar cubeUps = [\r\n\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\r\n\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\r\n\t];\r\n\r\n\tvar cube2DViewPorts = [\r\n\t\tnew Vector4(), new Vector4(), new Vector4(),\r\n\t\tnew Vector4(), new Vector4(), new Vector4()\r\n\t];\r\n\r\n\t// init\r\n\r\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\r\n\r\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\r\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\r\n\r\n\t\tvar depthMaterial = new MeshDepthMaterial( {\r\n\r\n\t\t\tdepthPacking: RGBADepthPacking,\r\n\r\n\t\t\tmorphTargets: useMorphing,\r\n\t\t\tskinning: useSkinning\r\n\r\n\t\t} );\r\n\r\n\t\t_depthMaterials[ i ] = depthMaterial;\r\n\r\n\t\t//\r\n\r\n\t\tvar distanceMaterial = new MeshDistanceMaterial( {\r\n\r\n\t\t\tmorphTargets: useMorphing,\r\n\t\t\tskinning: useSkinning\r\n\r\n\t\t} );\r\n\r\n\t\t_distanceMaterials[ i ] = distanceMaterial;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.enabled = false;\r\n\r\n\tthis.autoUpdate = true;\r\n\tthis.needsUpdate = false;\r\n\r\n\tthis.type = PCFShadowMap;\r\n\r\n\tthis.render = function ( lights, scene, camera ) {\r\n\r\n\t\tif ( scope.enabled === false ) { return; }\r\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) { return; }\r\n\r\n\t\tif ( lights.length === 0 ) { return; }\r\n\r\n\t\t// TODO Clean up (needed in case of contextlost)\r\n\t\tvar _gl = _renderer.context;\r\n\t\tvar _state = _renderer.state;\r\n\r\n\t\t// Set GL state for depth map.\r\n\t\t_state.disable( _gl.BLEND );\r\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\r\n\t\t_state.buffers.depth.setTest( true );\r\n\t\t_state.setScissorTest( false );\r\n\r\n\t\t// render depth map\r\n\r\n\t\tvar faceCount;\r\n\r\n\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar light = lights[ i ];\r\n\t\t\tvar shadow = light.shadow;\r\n\t\t\tvar isPointLight = light && light.isPointLight;\r\n\r\n\t\t\tif ( shadow === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLShadowMap:', light, 'has no shadow.' );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar shadowCamera = shadow.camera;\r\n\r\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\r\n\t\t\t_shadowMapSize.min( _maxShadowMapSize );\r\n\r\n\t\t\tif ( isPointLight ) {\r\n\r\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\r\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\r\n\r\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\r\n\t\t\t\t// following orientation:\r\n\t\t\t\t//\r\n\t\t\t\t//  xzXZ\r\n\t\t\t\t//   y Y\r\n\t\t\t\t//\r\n\t\t\t\t// X - Positive x direction\r\n\t\t\t\t// x - Negative x direction\r\n\t\t\t\t// Y - Positive y direction\r\n\t\t\t\t// y - Negative y direction\r\n\t\t\t\t// Z - Positive z direction\r\n\t\t\t\t// z - Negative z direction\r\n\r\n\t\t\t\t// positive X\r\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// negative X\r\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// positive Z\r\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// negative Z\r\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// positive Y\r\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\r\n\t\t\t\t// negative Y\r\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\r\n\r\n\t\t\t\t_shadowMapSize.x *= 4.0;\r\n\t\t\t\t_shadowMapSize.y *= 2.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( shadow.map === null ) {\r\n\r\n\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\r\n\r\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\r\n\t\t\t\tshadow.map.texture.name = light.name + \".shadowMap\";\r\n\r\n\t\t\t\tshadowCamera.updateProjectionMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( shadow.isSpotLightShadow ) {\r\n\r\n\t\t\t\tshadow.update( light );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar shadowMap = shadow.map;\r\n\t\t\tvar shadowMatrix = shadow.matrix;\r\n\r\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\r\n\r\n\t\t\tif ( isPointLight ) {\r\n\r\n\t\t\t\tfaceCount = 6;\r\n\r\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\r\n\t\t\t\t// equal to inverse of the light's position\r\n\r\n\t\t\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfaceCount = 1;\r\n\r\n\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\t\t\t\tshadowCamera.updateMatrixWorld();\r\n\r\n\t\t\t\t// compute shadow matrix\r\n\r\n\t\t\t\tshadowMatrix.set(\r\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t\t);\r\n\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t_renderer.clear();\r\n\r\n\t\t\t// render shadow map for each cube face (if omni-directional) or\r\n\t\t\t// run a single pass if not\r\n\r\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\r\n\r\n\t\t\t\tif ( isPointLight ) {\r\n\r\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\r\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\r\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\r\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\r\n\r\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\r\n\t\t\t\t\t_state.viewport( vpDimensions );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// update camera matrices and frustum\r\n\r\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t\t\t// set object matrices & frustum culling\r\n\r\n\t\t\t\trenderObject( scene, camera, shadowCamera, isPointLight );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tscope.needsUpdate = false;\r\n\r\n\t};\r\n\r\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tvar result = null;\r\n\r\n\t\tvar materialVariants = _depthMaterials;\r\n\t\tvar customMaterial = object.customDepthMaterial;\r\n\r\n\t\tif ( isPointLight ) {\r\n\r\n\t\t\tmaterialVariants = _distanceMaterials;\r\n\t\t\tcustomMaterial = object.customDistanceMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! customMaterial ) {\r\n\r\n\t\t\tvar useMorphing = false;\r\n\r\n\t\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\t\tif ( geometry && geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\r\n\r\n\t\t\t\t} else if ( geometry && geometry.isGeometry ) {\r\n\r\n\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.isSkinnedMesh && material.skinning === false ) {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLShadowMap: SkinnedMesh with material.skinning set to false:', object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\r\n\r\n\t\t\tvar variantIndex = 0;\r\n\r\n\t\t\tif ( useMorphing ) { variantIndex |= _MorphingFlag; }\r\n\t\t\tif ( useSkinning ) { variantIndex |= _SkinningFlag; }\r\n\r\n\t\t\tresult = materialVariants[ variantIndex ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = customMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _renderer.localClippingEnabled &&\r\n\t\t\t\tmaterial.clipShadows === true &&\r\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\r\n\r\n\t\t\t// in this case we need a unique material instance reflecting the\r\n\t\t\t// appropriate state\r\n\r\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\r\n\r\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\r\n\r\n\t\t\tif ( materialsForVariant === undefined ) {\r\n\r\n\t\t\t\tmaterialsForVariant = {};\r\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\r\n\r\n\t\t\tif ( cachedMaterial === undefined ) {\r\n\r\n\t\t\t\tcachedMaterial = result.clone();\r\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult = cachedMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tresult.visible = material.visible;\r\n\t\tresult.wireframe = material.wireframe;\r\n\r\n\t\tresult.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];\r\n\r\n\t\tresult.clipShadows = material.clipShadows;\r\n\t\tresult.clippingPlanes = material.clippingPlanes;\r\n\t\tresult.clipIntersection = material.clipIntersection;\r\n\r\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\r\n\t\tresult.linewidth = material.linewidth;\r\n\r\n\t\tif ( isPointLight && result.isMeshDistanceMaterial ) {\r\n\r\n\t\t\tresult.referencePosition.copy( lightPositionWorld );\r\n\t\t\tresult.nearDistance = shadowCameraNear;\r\n\t\t\tresult.farDistance = shadowCameraFar;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tfunction renderObject( object, camera, shadowCamera, isPointLight ) {\r\n\r\n\t\tif ( object.visible === false ) { return; }\r\n\r\n\t\tvar visible = object.layers.test( camera.layers );\r\n\r\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\r\n\r\n\t\t\tif ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\r\n\r\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\tvar geometry = _objects.update( object );\r\n\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\t\t\tvar groups = geometry.groups;\r\n\r\n\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\t\tvar group = groups[ k ];\r\n\t\t\t\t\t\tvar groupMaterial = material[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\r\n\r\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\r\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( material.visible ) {\r\n\r\n\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\r\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\trenderObject( children[ i ], camera, shadowCamera, isPointLight );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLState( gl, extensions, utils, capabilities ) {\r\n\r\n\tfunction ColorBuffer() {\r\n\r\n\t\tvar locked = false;\r\n\r\n\t\tvar color = new Vector4();\r\n\t\tvar currentColorMask = null;\r\n\t\tvar currentColorClear = new Vector4( 0, 0, 0, 0 );\r\n\r\n\t\treturn {\r\n\r\n\t\t\tsetMask: function ( colorMask ) {\r\n\r\n\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\r\n\r\n\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\r\n\t\t\t\t\tcurrentColorMask = colorMask;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetLocked: function ( lock ) {\r\n\r\n\t\t\t\tlocked = lock;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\r\n\r\n\t\t\t\tif ( premultipliedAlpha === true ) {\r\n\r\n\t\t\t\t\tr *= a; g *= a; b *= a;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolor.set( r, g, b, a );\r\n\r\n\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\r\n\r\n\t\t\t\t\tgl.clearColor( r, g, b, a );\r\n\t\t\t\t\tcurrentColorClear.copy( color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\treset: function () {\r\n\r\n\t\t\t\tlocked = false;\r\n\r\n\t\t\t\tcurrentColorMask = null;\r\n\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction DepthBuffer() {\r\n\r\n\t\tvar locked = false;\r\n\r\n\t\tvar currentDepthMask = null;\r\n\t\tvar currentDepthFunc = null;\r\n\t\tvar currentDepthClear = null;\r\n\r\n\t\treturn {\r\n\r\n\t\t\tsetTest: function ( depthTest ) {\r\n\r\n\t\t\t\tif ( depthTest ) {\r\n\r\n\t\t\t\t\tenable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tdisable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetMask: function ( depthMask ) {\r\n\r\n\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\r\n\r\n\t\t\t\t\tgl.depthMask( depthMask );\r\n\t\t\t\t\tcurrentDepthMask = depthMask;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetFunc: function ( depthFunc ) {\r\n\r\n\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\r\n\r\n\t\t\t\t\tif ( depthFunc ) {\r\n\r\n\t\t\t\t\t\tswitch ( depthFunc ) {\r\n\r\n\t\t\t\t\t\t\tcase NeverDepth:\r\n\r\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase AlwaysDepth:\r\n\r\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase LessDepth:\r\n\r\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase LessEqualDepth:\r\n\r\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase EqualDepth:\r\n\r\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase GreaterEqualDepth:\r\n\r\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase GreaterDepth:\r\n\r\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase NotEqualDepth:\r\n\r\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrentDepthFunc = depthFunc;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetLocked: function ( lock ) {\r\n\r\n\t\t\t\tlocked = lock;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetClear: function ( depth ) {\r\n\r\n\t\t\t\tif ( currentDepthClear !== depth ) {\r\n\r\n\t\t\t\t\tgl.clearDepth( depth );\r\n\t\t\t\t\tcurrentDepthClear = depth;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\treset: function () {\r\n\r\n\t\t\t\tlocked = false;\r\n\r\n\t\t\t\tcurrentDepthMask = null;\r\n\t\t\t\tcurrentDepthFunc = null;\r\n\t\t\t\tcurrentDepthClear = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction StencilBuffer() {\r\n\r\n\t\tvar locked = false;\r\n\r\n\t\tvar currentStencilMask = null;\r\n\t\tvar currentStencilFunc = null;\r\n\t\tvar currentStencilRef = null;\r\n\t\tvar currentStencilFuncMask = null;\r\n\t\tvar currentStencilFail = null;\r\n\t\tvar currentStencilZFail = null;\r\n\t\tvar currentStencilZPass = null;\r\n\t\tvar currentStencilClear = null;\r\n\r\n\t\treturn {\r\n\r\n\t\t\tsetTest: function ( stencilTest ) {\r\n\r\n\t\t\t\tif ( stencilTest ) {\r\n\r\n\t\t\t\t\tenable( gl.STENCIL_TEST );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tdisable( gl.STENCIL_TEST );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetMask: function ( stencilMask ) {\r\n\r\n\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\r\n\r\n\t\t\t\t\tgl.stencilMask( stencilMask );\r\n\t\t\t\t\tcurrentStencilMask = stencilMask;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\r\n\r\n\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\r\n\t\t\t\t     currentStencilRef \t!== stencilRef \t||\r\n\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\r\n\r\n\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\r\n\r\n\t\t\t\t\tcurrentStencilFunc = stencilFunc;\r\n\t\t\t\t\tcurrentStencilRef = stencilRef;\r\n\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\r\n\r\n\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\r\n\t\t\t\t     currentStencilZFail !== stencilZFail ||\r\n\t\t\t\t     currentStencilZPass !== stencilZPass ) {\r\n\r\n\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\r\n\r\n\t\t\t\t\tcurrentStencilFail = stencilFail;\r\n\t\t\t\t\tcurrentStencilZFail = stencilZFail;\r\n\t\t\t\t\tcurrentStencilZPass = stencilZPass;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetLocked: function ( lock ) {\r\n\r\n\t\t\t\tlocked = lock;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetClear: function ( stencil ) {\r\n\r\n\t\t\t\tif ( currentStencilClear !== stencil ) {\r\n\r\n\t\t\t\t\tgl.clearStencil( stencil );\r\n\t\t\t\t\tcurrentStencilClear = stencil;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\treset: function () {\r\n\r\n\t\t\t\tlocked = false;\r\n\r\n\t\t\t\tcurrentStencilMask = null;\r\n\t\t\t\tcurrentStencilFunc = null;\r\n\t\t\t\tcurrentStencilRef = null;\r\n\t\t\t\tcurrentStencilFuncMask = null;\r\n\t\t\t\tcurrentStencilFail = null;\r\n\t\t\t\tcurrentStencilZFail = null;\r\n\t\t\t\tcurrentStencilZPass = null;\r\n\t\t\t\tcurrentStencilClear = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar colorBuffer = new ColorBuffer();\r\n\tvar depthBuffer = new DepthBuffer();\r\n\tvar stencilBuffer = new StencilBuffer();\r\n\r\n\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\r\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\r\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\r\n\r\n\tvar enabledCapabilities = {};\r\n\r\n\tvar compressedTextureFormats = null;\r\n\r\n\tvar currentProgram = null;\r\n\r\n\tvar currentBlendingEnabled = null;\r\n\tvar currentBlending = null;\r\n\tvar currentBlendEquation = null;\r\n\tvar currentBlendSrc = null;\r\n\tvar currentBlendDst = null;\r\n\tvar currentBlendEquationAlpha = null;\r\n\tvar currentBlendSrcAlpha = null;\r\n\tvar currentBlendDstAlpha = null;\r\n\tvar currentPremultipledAlpha = false;\r\n\r\n\tvar currentFlipSided = null;\r\n\tvar currentCullFace = null;\r\n\r\n\tvar currentLineWidth = null;\r\n\r\n\tvar currentPolygonOffsetFactor = null;\r\n\tvar currentPolygonOffsetUnits = null;\r\n\r\n\tvar maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\r\n\r\n\tvar lineWidthAvailable = false;\r\n\tvar version = 0;\r\n\tvar glVersion = gl.getParameter( gl.VERSION );\r\n\r\n\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\r\n\r\n\t\tversion = parseFloat( /^WebGL\\ ([0-9])/.exec( glVersion )[ 1 ] );\r\n\t\tlineWidthAvailable = ( version >= 1.0 );\r\n\r\n\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\r\n\r\n\t\tversion = parseFloat( /^OpenGL\\ ES\\ ([0-9])/.exec( glVersion )[ 1 ] );\r\n\t\tlineWidthAvailable = ( version >= 2.0 );\r\n\r\n\t}\r\n\r\n\tvar currentTextureSlot = null;\r\n\tvar currentBoundTextures = {};\r\n\r\n\tvar currentScissor = new Vector4();\r\n\tvar currentViewport = new Vector4();\r\n\r\n\tfunction createTexture( type, target, count ) {\r\n\r\n\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\r\n\t\tvar texture = gl.createTexture();\r\n\r\n\t\tgl.bindTexture( type, texture );\r\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\r\n\t\tfor ( var i = 0; i < count; i ++ ) {\r\n\r\n\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n\tvar emptyTextures = {};\r\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\r\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\r\n\r\n\t// init\r\n\r\n\tcolorBuffer.setClear( 0, 0, 0, 1 );\r\n\tdepthBuffer.setClear( 1 );\r\n\tstencilBuffer.setClear( 0 );\r\n\r\n\tenable( gl.DEPTH_TEST );\r\n\tdepthBuffer.setFunc( LessEqualDepth );\r\n\r\n\tsetFlipSided( false );\r\n\tsetCullFace( CullFaceBack );\r\n\tenable( gl.CULL_FACE );\r\n\r\n\tsetBlending( NoBlending );\r\n\r\n\t//\r\n\r\n\tfunction initAttributes() {\r\n\r\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tnewAttributes[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction enableAttribute( attribute ) {\r\n\r\n\t\tenableAttributeAndDivisor( attribute, 0 );\r\n\r\n\t}\r\n\r\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\r\n\r\n\t\tnewAttributes[ attribute ] = 1;\r\n\r\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\tenabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\r\n\r\n\t\t\tvar extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t\textension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );\r\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction disableUnusedAttributes() {\r\n\r\n\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction enable( id ) {\r\n\r\n\t\tif ( enabledCapabilities[ id ] !== true ) {\r\n\r\n\t\t\tgl.enable( id );\r\n\t\t\tenabledCapabilities[ id ] = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction disable( id ) {\r\n\r\n\t\tif ( enabledCapabilities[ id ] !== false ) {\r\n\r\n\t\t\tgl.disable( id );\r\n\t\t\tenabledCapabilities[ id ] = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getCompressedTextureFormats() {\r\n\r\n\t\tif ( compressedTextureFormats === null ) {\r\n\r\n\t\t\tcompressedTextureFormats = [];\r\n\r\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\r\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||\r\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {\r\n\r\n\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\r\n\r\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\r\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn compressedTextureFormats;\r\n\r\n\t}\r\n\r\n\tfunction useProgram( program ) {\r\n\r\n\t\tif ( currentProgram !== program ) {\r\n\r\n\t\t\tgl.useProgram( program );\r\n\r\n\t\t\tcurrentProgram = program;\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\r\n\r\n\t\tif ( blending === NoBlending ) {\r\n\r\n\t\t\tif ( currentBlendingEnabled ) {\r\n\r\n\t\t\t\tdisable( gl.BLEND );\r\n\t\t\t\tcurrentBlendingEnabled = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! currentBlendingEnabled ) {\r\n\r\n\t\t\tenable( gl.BLEND );\r\n\t\t\tcurrentBlendingEnabled = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending !== CustomBlending ) {\r\n\r\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\r\n\r\n\t\t\t\tif ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {\r\n\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\r\n\t\t\t\t\tcurrentBlendEquation = AddEquation;\r\n\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tswitch ( blending ) {\r\n\r\n\t\t\t\t\t\tcase NormalBlending:\r\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase AdditiveBlending:\r\n\t\t\t\t\t\t\tgl.blendFunc( gl.ONE, gl.ONE );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase SubtractiveBlending:\r\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase MultiplyBlending:\r\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.error( 'WebGLState: Invalid blending: ', blending );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tswitch ( blending ) {\r\n\r\n\t\t\t\t\t\tcase NormalBlending:\r\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase AdditiveBlending:\r\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase SubtractiveBlending:\r\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase MultiplyBlending:\r\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.error( 'WebGLState: Invalid blending: ', blending );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrentBlendSrc = null;\r\n\t\t\t\tcurrentBlendDst = null;\r\n\t\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\t\tcurrentBlendDstAlpha = null;\r\n\r\n\t\t\t\tcurrentBlending = blending;\r\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// custom blending\r\n\r\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\r\n\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\r\n\t\t\tgl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );\r\n\r\n\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\r\n\t\t\tgl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );\r\n\r\n\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\r\n\t\t}\r\n\r\n\t\tcurrentBlending = blending;\r\n\t\tcurrentPremultipledAlpha = null;\r\n\r\n\t}\r\n\r\n\tfunction setMaterial( material, frontFaceCW ) {\r\n\r\n\t\tmaterial.side === DoubleSide\r\n\t\t\t? disable( gl.CULL_FACE )\r\n\t\t\t: enable( gl.CULL_FACE );\r\n\r\n\t\tvar flipSided = ( material.side === BackSide );\r\n\t\tif ( frontFaceCW ) { flipSided = ! flipSided; }\r\n\r\n\t\tsetFlipSided( flipSided );\r\n\r\n\t\t( material.blending === NormalBlending && material.transparent === false )\r\n\t\t\t? setBlending( NoBlending )\r\n\t\t\t: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\r\n\r\n\t\tdepthBuffer.setFunc( material.depthFunc );\r\n\t\tdepthBuffer.setTest( material.depthTest );\r\n\t\tdepthBuffer.setMask( material.depthWrite );\r\n\t\tcolorBuffer.setMask( material.colorWrite );\r\n\r\n\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction setFlipSided( flipSided ) {\r\n\r\n\t\tif ( currentFlipSided !== flipSided ) {\r\n\r\n\t\t\tif ( flipSided ) {\r\n\r\n\t\t\t\tgl.frontFace( gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.frontFace( gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentFlipSided = flipSided;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setCullFace( cullFace ) {\r\n\r\n\t\tif ( cullFace !== CullFaceNone ) {\r\n\r\n\t\t\tenable( gl.CULL_FACE );\r\n\r\n\t\t\tif ( cullFace !== currentCullFace ) {\r\n\r\n\t\t\t\tif ( cullFace === CullFaceBack ) {\r\n\r\n\t\t\t\t\tgl.cullFace( gl.BACK );\r\n\r\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\r\n\r\n\t\t\t\t\tgl.cullFace( gl.FRONT );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdisable( gl.CULL_FACE );\r\n\r\n\t\t}\r\n\r\n\t\tcurrentCullFace = cullFace;\r\n\r\n\t}\r\n\r\n\tfunction setLineWidth( width ) {\r\n\r\n\t\tif ( width !== currentLineWidth ) {\r\n\r\n\t\t\tif ( lineWidthAvailable ) { gl.lineWidth( width ); }\r\n\r\n\t\t\tcurrentLineWidth = width;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setPolygonOffset( polygonOffset, factor, units ) {\r\n\r\n\t\tif ( polygonOffset ) {\r\n\r\n\t\t\tenable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\r\n\r\n\t\t\t\tgl.polygonOffset( factor, units );\r\n\r\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\t\tcurrentPolygonOffsetUnits = units;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setScissorTest( scissorTest ) {\r\n\r\n\t\tif ( scissorTest ) {\r\n\r\n\t\t\tenable( gl.SCISSOR_TEST );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdisable( gl.SCISSOR_TEST );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// texture\r\n\r\n\tfunction activeTexture( webglSlot ) {\r\n\r\n\t\tif ( webglSlot === undefined ) { webglSlot = gl.TEXTURE0 + maxTextures - 1; }\r\n\r\n\t\tif ( currentTextureSlot !== webglSlot ) {\r\n\r\n\t\t\tgl.activeTexture( webglSlot );\r\n\t\t\tcurrentTextureSlot = webglSlot;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction bindTexture( webglType, webglTexture ) {\r\n\r\n\t\tif ( currentTextureSlot === null ) {\r\n\r\n\t\t\tactiveTexture();\r\n\r\n\t\t}\r\n\r\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\r\n\r\n\t\tif ( boundTexture === undefined ) {\r\n\r\n\t\t\tboundTexture = { type: undefined, texture: undefined };\r\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\r\n\r\n\t\t}\r\n\r\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\r\n\r\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\r\n\r\n\t\t\tboundTexture.type = webglType;\r\n\t\t\tboundTexture.texture = webglTexture;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction compressedTexImage2D() {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.error( 'WebGLState:', error );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction texImage2D() {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tgl.texImage2D.apply( gl, arguments );\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.error( 'WebGLState:', error );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction scissor( scissor ) {\r\n\r\n\t\tif ( currentScissor.equals( scissor ) === false ) {\r\n\r\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\r\n\t\t\tcurrentScissor.copy( scissor );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction viewport( viewport ) {\r\n\r\n\t\tif ( currentViewport.equals( viewport ) === false ) {\r\n\r\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\r\n\t\t\tcurrentViewport.copy( viewport );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction reset() {\r\n\r\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tenabledCapabilities = {};\r\n\r\n\t\tcompressedTextureFormats = null;\r\n\r\n\t\tcurrentTextureSlot = null;\r\n\t\tcurrentBoundTextures = {};\r\n\r\n\t\tcurrentProgram = null;\r\n\r\n\t\tcurrentBlending = null;\r\n\r\n\t\tcurrentFlipSided = null;\r\n\t\tcurrentCullFace = null;\r\n\r\n\t\tcolorBuffer.reset();\r\n\t\tdepthBuffer.reset();\r\n\t\tstencilBuffer.reset();\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tbuffers: {\r\n\t\t\tcolor: colorBuffer,\r\n\t\t\tdepth: depthBuffer,\r\n\t\t\tstencil: stencilBuffer\r\n\t\t},\r\n\r\n\t\tinitAttributes: initAttributes,\r\n\t\tenableAttribute: enableAttribute,\r\n\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\r\n\t\tdisableUnusedAttributes: disableUnusedAttributes,\r\n\t\tenable: enable,\r\n\t\tdisable: disable,\r\n\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\r\n\r\n\t\tuseProgram: useProgram,\r\n\r\n\t\tsetBlending: setBlending,\r\n\t\tsetMaterial: setMaterial,\r\n\r\n\t\tsetFlipSided: setFlipSided,\r\n\t\tsetCullFace: setCullFace,\r\n\r\n\t\tsetLineWidth: setLineWidth,\r\n\t\tsetPolygonOffset: setPolygonOffset,\r\n\r\n\t\tsetScissorTest: setScissorTest,\r\n\r\n\t\tactiveTexture: activeTexture,\r\n\t\tbindTexture: bindTexture,\r\n\t\tcompressedTexImage2D: compressedTexImage2D,\r\n\t\ttexImage2D: texImage2D,\r\n\r\n\t\tscissor: scissor,\r\n\t\tviewport: viewport,\r\n\r\n\t\treset: reset\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {\r\n\r\n\tvar _videoTextures = {};\r\n\tvar _canvas;\r\n\r\n\t//\r\n\r\n\tfunction clampToMaxSize( image, maxSize ) {\r\n\r\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\r\n\t\t\tif ( 'data' in image ) {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLRenderer: image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t// premultiplied alpha.\r\n\r\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\r\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\r\n\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\tconsole.warn( 'WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height );\r\n\r\n\t\t\treturn canvas;\r\n\r\n\t\t}\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n\tfunction isPowerOfTwo( image ) {\r\n\r\n\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\r\n\r\n\t}\r\n\r\n\tfunction makePowerOfTwo( image ) {\r\n\r\n\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {\r\n\r\n\t\t\tif ( _canvas === undefined ) { _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); }\r\n\r\n\t\t\t_canvas.width = _Math.floorPowerOfTwo( image.width );\r\n\t\t\t_canvas.height = _Math.floorPowerOfTwo( image.height );\r\n\r\n\t\t\tvar context = _canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0, _canvas.width, _canvas.height );\r\n\r\n\t\t\tconsole.warn( 'WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + _canvas.width + 'x' + _canvas.height );\r\n\r\n\t\t\treturn _canvas;\r\n\r\n\t\t}\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n\tfunction textureNeedsPowerOfTwo( texture ) {\r\n\r\n\t\tif ( capabilities.isWebGL2 ) { return false; }\r\n\r\n\t\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\r\n\t\t\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\r\n\r\n\t}\r\n\r\n\tfunction textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {\r\n\r\n\t\treturn texture.generateMipmaps && isPowerOfTwo &&\r\n\t\t\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\r\n\r\n\t}\r\n\r\n\tfunction generateMipmap( target, texture, width, height ) {\r\n\r\n\t\t_gl.generateMipmap( target );\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\t// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11\r\n\t\ttextureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;\r\n\r\n\t}\r\n\r\n\tfunction getInternalFormat( glFormat, glType ) {\r\n\r\n\t\tif ( ! capabilities.isWebGL2 ) { return glFormat; }\r\n\r\n\t\tif ( glFormat === _gl.RGB ) {\r\n\r\n\t\t\tif ( glType === _gl.FLOAT ) { return _gl.RGB32F; }\r\n\t\t\tif ( glType === _gl.HALF_FLOAT ) { return _gl.RGB16F; }\r\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) { return _gl.RGB8; }\r\n\r\n\t\t}\r\n\r\n\t\tif ( glFormat === _gl.RGBA ) {\r\n\r\n\t\t\tif ( glType === _gl.FLOAT ) { return _gl.RGBA32F; }\r\n\t\t\tif ( glType === _gl.HALF_FLOAT ) { return _gl.RGBA16F; }\r\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) { return _gl.RGBA8; }\r\n\r\n\t\t}\r\n\r\n\t\treturn glFormat;\r\n\r\n\t}\r\n\r\n\t// Fallback filters for non-power-of-2 textures\r\n\r\n\tfunction filterFallback( f ) {\r\n\r\n\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\r\n\r\n\t\t\treturn _gl.NEAREST;\r\n\r\n\t\t}\r\n\r\n\t\treturn _gl.LINEAR;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction onTextureDispose( event ) {\r\n\r\n\t\tvar texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tdeallocateTexture( texture );\r\n\r\n\t\tif ( texture.isVideoTexture ) {\r\n\r\n\t\t\tdelete _videoTextures[ texture.id ];\r\n\r\n\t\t}\r\n\r\n\t\tinfo.memory.textures --;\r\n\r\n\t}\r\n\r\n\tfunction onRenderTargetDispose( event ) {\r\n\r\n\t\tvar renderTarget = event.target;\r\n\r\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\tdeallocateRenderTarget( renderTarget );\r\n\r\n\t\tinfo.memory.textures --;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction deallocateTexture( texture ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\r\n\r\n\t\t\t// cube texture\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// 2D texture\r\n\r\n\t\t\tif ( textureProperties.__webglInit === undefined ) { return; }\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t\t// remove all webgl properties\r\n\t\tproperties.remove( texture );\r\n\r\n\t}\r\n\r\n\tfunction deallocateRenderTarget( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\r\n\t\tif ( ! renderTarget ) { return; }\r\n\r\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderTarget.depthTexture ) {\r\n\r\n\t\t\trenderTarget.depthTexture.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderTarget.isWebGLRenderTargetCube ) {\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] ); }\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\r\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer ); }\r\n\r\n\t\t}\r\n\r\n\t\tproperties.remove( renderTarget.texture );\r\n\t\tproperties.remove( renderTarget );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction setTexture2D( texture, slot ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.isVideoTexture ) { updateVideoTexture( texture ); }\r\n\r\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n\t\t\tvar image = texture.image;\r\n\r\n\t\t\tif ( image === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLRenderer: Texture marked for update but image is undefined' );\r\n\r\n\t\t\t} else if ( image.complete === false ) {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLRenderer: Texture marked for update but image is incomplete' );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n\t}\r\n\r\n\tfunction setTextureCube( texture, slot ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.image.length === 6 ) {\r\n\r\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\r\n\r\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\r\n\r\n\t\t\t\t\tinfo.memory.textures ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n\t\t\t\tvar isCompressed = ( texture && texture.isCompressedTexture );\r\n\t\t\t\tvar isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\r\n\r\n\t\t\t\tvar cubeImage = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\t\t\tglFormat = utils.convert( texture.format ),\r\n\t\t\t\t\tglType = utils.convert( texture.type ),\r\n\t\t\t\t\tglInternalFormat = getInternalFormat( glFormat, glType );\r\n\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\t\t\tif ( isDataTexture ) {\r\n\r\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\r\n\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\t\ttextureProperties.__maxMipLevel = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {\r\n\r\n\t\t\t\t\t// We assume images for cube map have the same size.\r\n\t\t\t\t\tgenerateMipmap( _gl.TEXTURE_CUBE_MAP, texture, image.width, image.height );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttextureProperties.__version = texture.version;\r\n\r\n\t\t\t\tif ( texture.onUpdate ) { texture.onUpdate( texture ); }\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setTextureCubeDynamic( texture, slot ) {\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\r\n\r\n\t}\r\n\r\n\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( isPowerOfTwoImage ) {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to ClampToEdgeWrapping.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\r\n\r\n\t\t\t\tconsole.warn( 'WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to NearestFilter or LinearFilter.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\tif ( extension ) {\r\n\r\n\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) { return; }\r\n\t\t\tif ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) { return; }\r\n\r\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\r\n\r\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\r\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction uploadTexture( textureProperties, texture, slot ) {\r\n\r\n\t\tif ( textureProperties.__webglInit === undefined ) {\r\n\r\n\t\t\ttextureProperties.__webglInit = true;\r\n\r\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\tinfo.memory.textures ++;\r\n\r\n\t\t}\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\r\n\r\n\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\r\n\r\n\t\t\timage = makePowerOfTwo( image );\r\n\r\n\t\t}\r\n\r\n\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\tglFormat = utils.convert( texture.format ),\r\n\t\t\tglType = utils.convert( texture.type ),\r\n\t\t\tglInternalFormat = getInternalFormat( glFormat, glType );\r\n\r\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\r\n\r\n\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\r\n\t\tif ( texture.isDepthTexture ) {\r\n\r\n\t\t\t// populate depth texture with dummy data\r\n\r\n\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT;\r\n\r\n\t\t\tif ( texture.type === FloatType ) {\r\n\r\n\t\t\t\tif ( ! capabilities.isWebGL2 ) { throw new Error( 'Float Depth Texture only supported in WebGL2.0' ); }\r\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\r\n\r\n\t\t\t} else if ( capabilities.isWebGL2 ) {\r\n\r\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\r\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT16;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {\r\n\r\n\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\r\n\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\r\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\r\n\t\t\t\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\r\n\r\n\t\t\t\t\ttexture.type = UnsignedShortType;\r\n\t\t\t\t\tglType = utils.convert( texture.type );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\r\n\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\r\n\t\t\tif ( texture.format === DepthStencilFormat ) {\r\n\r\n\t\t\t\tglInternalFormat = _gl.DEPTH_STENCIL;\r\n\r\n\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\r\n\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\r\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\r\n\t\t\t\tif ( texture.type !== UnsignedInt248Type ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\r\n\r\n\t\t\t\t\ttexture.type = UnsignedInt248Type;\r\n\t\t\t\t\tglType = utils.convert( texture.type );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );\r\n\r\n\t\t} else if ( texture.isDataTexture ) {\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( texture.isCompressedTexture ) {\r\n\r\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmipmap = mipmaps[ i ];\r\n\r\n\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\r\n\r\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// regular Texture (image, video, canvas)\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );\r\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {\r\n\r\n\t\t\tgenerateMipmap( _gl.TEXTURE_2D, texture, image.width, image.height );\r\n\r\n\t\t}\r\n\r\n\t\ttextureProperties.__version = texture.version;\r\n\r\n\t\tif ( texture.onUpdate ) { texture.onUpdate( texture ); }\r\n\r\n\t}\r\n\r\n\t// Render targets\r\n\r\n\t// Setup storage for target texture and bind it to correct framebuffer\r\n\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\r\n\r\n\t\tvar glFormat = utils.convert( renderTarget.texture.format );\r\n\t\tvar glType = utils.convert( renderTarget.texture.type );\r\n\t\tvar glInternalFormat = getInternalFormat( glFormat, glType );\r\n\t\tstate.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\r\n\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// FIXME: We don't support !depth !stencil\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\r\n\tfunction setupDepthTexture( framebuffer, renderTarget ) {\r\n\r\n\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\r\n\t\tif ( isCube ) { throw new Error( 'Depth Texture with cube render targets is not supported' ); }\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\r\n\r\n\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of DepthTexture' );\r\n\r\n\t\t}\r\n\r\n\t\t// upload an empty depth texture with framebuffer size\r\n\t\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\r\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\r\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\r\n\r\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\r\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\r\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\r\n\r\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\r\n\r\n\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\r\n\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\r\n\r\n\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\r\n\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthrow new Error( 'Unknown depthTexture format' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Setup GL resources for a non-texture depth buffer\r\n\tfunction setupDepthRenderbuffer( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\r\n\t\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\r\n\r\n\t\tif ( renderTarget.depthTexture ) {\r\n\r\n\t\t\tif ( isCube ) { throw new Error( 'target.depthTexture not supported in Cube render targets' ); }\r\n\r\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\r\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\r\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\r\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Set up GL resources for the render target\r\n\tfunction setupRenderTarget( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\r\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\r\n\t\tinfo.memory.textures ++;\r\n\r\n\t\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\r\n\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\r\n\r\n\t\t// Setup framebuffer\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n\t\t}\r\n\r\n\t\t// Setup color buffer\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) {\r\n\r\n\t\t\t\tgenerateMipmap( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\r\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\r\n\r\n\t\t\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) {\r\n\r\n\t\t\t\tgenerateMipmap( _gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t}\r\n\r\n\t\t// Setup depth and stencil buffers\r\n\r\n\t\tif ( renderTarget.depthBuffer ) {\r\n\r\n\t\t\tsetupDepthRenderbuffer( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction updateRenderTargetMipmap( renderTarget ) {\r\n\r\n\t\tvar texture = renderTarget.texture;\r\n\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\r\n\r\n\t\tif ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {\r\n\r\n\t\t\tvar target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\r\n\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\r\n\r\n\t\t\tstate.bindTexture( target, webglTexture );\r\n\t\t\tgenerateMipmap( target, texture, renderTarget.width, renderTarget.height );\r\n\t\t\tstate.bindTexture( target, null );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction updateVideoTexture( texture ) {\r\n\r\n\t\tvar id = texture.id;\r\n\t\tvar frame = info.render.frame;\r\n\r\n\t\t// Check the last frame we updated the VideoTexture\r\n\r\n\t\tif ( _videoTextures[ id ] !== frame ) {\r\n\r\n\t\t\t_videoTextures[ id ] = frame;\r\n\t\t\ttexture.update();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.setTexture2D = setTexture2D;\r\n\tthis.setTextureCube = setTextureCube;\r\n\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\r\n\tthis.setupRenderTarget = setupRenderTarget;\r\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLUtils( gl, extensions, capabilities ) {\r\n\r\n\tfunction convert( p ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( p === RepeatWrapping ) { return gl.REPEAT; }\r\n\t\tif ( p === ClampToEdgeWrapping ) { return gl.CLAMP_TO_EDGE; }\r\n\t\tif ( p === MirroredRepeatWrapping ) { return gl.MIRRORED_REPEAT; }\r\n\r\n\t\tif ( p === NearestFilter ) { return gl.NEAREST; }\r\n\t\tif ( p === NearestMipMapNearestFilter ) { return gl.NEAREST_MIPMAP_NEAREST; }\r\n\t\tif ( p === NearestMipMapLinearFilter ) { return gl.NEAREST_MIPMAP_LINEAR; }\r\n\r\n\t\tif ( p === LinearFilter ) { return gl.LINEAR; }\r\n\t\tif ( p === LinearMipMapNearestFilter ) { return gl.LINEAR_MIPMAP_NEAREST; }\r\n\t\tif ( p === LinearMipMapLinearFilter ) { return gl.LINEAR_MIPMAP_LINEAR; }\r\n\r\n\t\tif ( p === UnsignedByteType ) { return gl.UNSIGNED_BYTE; }\r\n\t\tif ( p === UnsignedShort4444Type ) { return gl.UNSIGNED_SHORT_4_4_4_4; }\r\n\t\tif ( p === UnsignedShort5551Type ) { return gl.UNSIGNED_SHORT_5_5_5_1; }\r\n\t\tif ( p === UnsignedShort565Type ) { return gl.UNSIGNED_SHORT_5_6_5; }\r\n\r\n\t\tif ( p === ByteType ) { return gl.BYTE; }\r\n\t\tif ( p === ShortType ) { return gl.SHORT; }\r\n\t\tif ( p === UnsignedShortType ) { return gl.UNSIGNED_SHORT; }\r\n\t\tif ( p === IntType ) { return gl.INT; }\r\n\t\tif ( p === UnsignedIntType ) { return gl.UNSIGNED_INT; }\r\n\t\tif ( p === FloatType ) { return gl.FLOAT; }\r\n\r\n\t\tif ( p === HalfFloatType ) {\r\n\r\n\t\t\tif ( capabilities.isWebGL2 ) { return gl.HALF_FLOAT; }\r\n\r\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\r\n\t\t\tif ( extension !== null ) { return extension.HALF_FLOAT_OES; }\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === AlphaFormat ) { return gl.ALPHA; }\r\n\t\tif ( p === RGBFormat ) { return gl.RGB; }\r\n\t\tif ( p === RGBAFormat ) { return gl.RGBA; }\r\n\t\tif ( p === LuminanceFormat ) { return gl.LUMINANCE; }\r\n\t\tif ( p === LuminanceAlphaFormat ) { return gl.LUMINANCE_ALPHA; }\r\n\t\tif ( p === DepthFormat ) { return gl.DEPTH_COMPONENT; }\r\n\t\tif ( p === DepthStencilFormat ) { return gl.DEPTH_STENCIL; }\r\n\r\n\t\tif ( p === AddEquation ) { return gl.FUNC_ADD; }\r\n\t\tif ( p === SubtractEquation ) { return gl.FUNC_SUBTRACT; }\r\n\t\tif ( p === ReverseSubtractEquation ) { return gl.FUNC_REVERSE_SUBTRACT; }\r\n\r\n\t\tif ( p === ZeroFactor ) { return gl.ZERO; }\r\n\t\tif ( p === OneFactor ) { return gl.ONE; }\r\n\t\tif ( p === SrcColorFactor ) { return gl.SRC_COLOR; }\r\n\t\tif ( p === OneMinusSrcColorFactor ) { return gl.ONE_MINUS_SRC_COLOR; }\r\n\t\tif ( p === SrcAlphaFactor ) { return gl.SRC_ALPHA; }\r\n\t\tif ( p === OneMinusSrcAlphaFactor ) { return gl.ONE_MINUS_SRC_ALPHA; }\r\n\t\tif ( p === DstAlphaFactor ) { return gl.DST_ALPHA; }\r\n\t\tif ( p === OneMinusDstAlphaFactor ) { return gl.ONE_MINUS_DST_ALPHA; }\r\n\r\n\t\tif ( p === DstColorFactor ) { return gl.DST_COLOR; }\r\n\t\tif ( p === OneMinusDstColorFactor ) { return gl.ONE_MINUS_DST_COLOR; }\r\n\t\tif ( p === SrcAlphaSaturateFactor ) { return gl.SRC_ALPHA_SATURATE; }\r\n\r\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\r\n\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\r\n\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n\t\t\tif ( extension !== null ) {\r\n\r\n\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) { return extension.COMPRESSED_RGB_S3TC_DXT1_EXT; }\r\n\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT; }\r\n\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT; }\r\n\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT; }\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\r\n\t\t\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\r\n\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n\t\t\tif ( extension !== null ) {\r\n\r\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) { return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; }\r\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) { return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; }\r\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) { return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; }\r\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) { return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG; }\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === RGB_ETC1_Format ) {\r\n\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\r\n\r\n\t\t\tif ( extension !== null ) { return extension.COMPRESSED_RGB_ETC1_WEBGL; }\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\r\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\r\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\r\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\r\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\r\n\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\r\n\r\n\t\t\tif ( extension !== null ) {\r\n\r\n\t\t\t\treturn p;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === MinEquation || p === MaxEquation ) {\r\n\r\n\t\t\tif ( capabilities.isWebGL2 ) {\r\n\r\n\t\t\t\tif ( p === MinEquation ) { return gl.MIN; }\r\n\t\t\t\tif ( p === MaxEquation ) { return gl.MAX; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\r\n\t\t\tif ( extension !== null ) {\r\n\r\n\t\t\t\tif ( p === MinEquation ) { return extension.MIN_EXT; }\r\n\t\t\t\tif ( p === MaxEquation ) { return extension.MAX_EXT; }\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === UnsignedInt248Type ) {\r\n\r\n\t\t\tif ( capabilities.isWebGL2 ) { return gl.UNSIGNED_INT_24_8; }\r\n\r\n\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\r\n\r\n\t\t\tif ( extension !== null ) { return extension.UNSIGNED_INT_24_8_WEBGL; }\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\treturn { convert: convert };\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ArrayCamera( array ) {\r\n\r\n\tPerspectiveCamera.call( this );\r\n\r\n\tthis.cameras = array || [];\r\n\r\n}\r\n\r\nArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {\r\n\r\n\tconstructor: ArrayCamera,\r\n\r\n\tisArrayCamera: true\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebVRManager( renderer ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar device = null;\r\n\tvar frameData = null;\r\n\r\n\tvar poseTarget = null;\r\n\r\n\tvar controllers = [];\r\n\tvar standingMatrix = new Matrix4();\r\n\tvar standingMatrixInverse = new Matrix4();\r\n\r\n\tvar frameOfReferenceType = 'stage';\r\n\r\n\tif ( typeof window !== 'undefined' && 'VRFrameData' in window ) {\r\n\r\n\t\tframeData = new window.VRFrameData();\r\n\t\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\r\n\r\n\t}\r\n\r\n\tvar matrixWorldInverse = new Matrix4();\r\n\tvar tempQuaternion = new Quaternion();\r\n\tvar tempPosition = new Vector3();\r\n\r\n\tvar cameraL = new PerspectiveCamera();\r\n\tcameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );\r\n\tcameraL.layers.enable( 1 );\r\n\r\n\tvar cameraR = new PerspectiveCamera();\r\n\tcameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );\r\n\tcameraR.layers.enable( 2 );\r\n\r\n\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\r\n\tcameraVR.layers.enable( 1 );\r\n\tcameraVR.layers.enable( 2 );\r\n\r\n\t//\r\n\r\n\tfunction isPresenting() {\r\n\r\n\t\treturn device !== null && device.isPresenting === true;\r\n\r\n\t}\r\n\r\n\tvar currentSize, currentPixelRatio;\r\n\r\n\tfunction onVRDisplayPresentChange() {\r\n\r\n\t\tif ( isPresenting() ) {\r\n\r\n\t\t\tvar eyeParameters = device.getEyeParameters( 'left' );\r\n\t\t\tvar renderWidth = eyeParameters.renderWidth;\r\n\t\t\tvar renderHeight = eyeParameters.renderHeight;\r\n\r\n\t\t\tcurrentPixelRatio = renderer.getPixelRatio();\r\n\t\t\tcurrentSize = renderer.getSize();\r\n\r\n\t\t\trenderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );\r\n\r\n\t\t\tanimation.start();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( scope.enabled ) {\r\n\r\n\t\t\t\trenderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tanimation.stop();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar triggers = [];\r\n\r\n\tfunction findGamepad( id ) {\r\n\r\n\t\tvar gamepads = navigator.getGamepads && navigator.getGamepads();\r\n\r\n\t\tfor ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar gamepad = gamepads[ i ];\r\n\r\n\t\t\tif ( gamepad && ( gamepad.id === 'Daydream Controller' ||\r\n\t\t\t\tgamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||\r\n\t\t\t\tgamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||\r\n\t\t\t\tgamepad.id.startsWith( 'Spatial Controller' ) ) ) {\r\n\r\n\t\t\t\tif ( j === id ) { return gamepad; }\r\n\r\n\t\t\t\tj ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction updateControllers() {\r\n\r\n\t\tfor ( var i = 0; i < controllers.length; i ++ ) {\r\n\r\n\t\t\tvar controller = controllers[ i ];\r\n\r\n\t\t\tvar gamepad = findGamepad( i );\r\n\r\n\t\t\tif ( gamepad !== undefined && gamepad.pose !== undefined ) {\r\n\r\n\t\t\t\tif ( gamepad.pose === null ) { return; }\r\n\r\n\t\t\t\t//  Pose\r\n\r\n\t\t\t\tvar pose = gamepad.pose;\r\n\r\n\t\t\t\tif ( pose.hasPosition === false ) { controller.position.set( 0.2, - 0.6, - 0.05 ); }\r\n\r\n\t\t\t\tif ( pose.position !== null ) { controller.position.fromArray( pose.position ); }\r\n\t\t\t\tif ( pose.orientation !== null ) { controller.quaternion.fromArray( pose.orientation ); }\r\n\t\t\t\tcontroller.matrix.compose( controller.position, controller.quaternion, controller.scale );\r\n\t\t\t\tcontroller.matrix.premultiply( standingMatrix );\r\n\t\t\t\tcontroller.matrix.decompose( controller.position, controller.quaternion, controller.scale );\r\n\t\t\t\tcontroller.matrixWorldNeedsUpdate = true;\r\n\t\t\t\tcontroller.visible = true;\r\n\r\n\t\t\t\t//  Trigger\r\n\r\n\t\t\t\tvar buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;\r\n\r\n\t\t\t\tif ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {\r\n\r\n\t\t\t\t\ttriggers[ i ] = gamepad.buttons[ buttonId ].pressed;\r\n\r\n\t\t\t\t\tif ( triggers[ i ] === true ) {\r\n\r\n\t\t\t\t\t\tcontroller.dispatchEvent( { type: 'selectstart' } );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcontroller.dispatchEvent( { type: 'selectend' } );\r\n\t\t\t\t\t\tcontroller.dispatchEvent( { type: 'select' } );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcontroller.visible = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tthis.enabled = false;\r\n\r\n\tthis.getController = function ( id ) {\r\n\r\n\t\tvar controller = controllers[ id ];\r\n\r\n\t\tif ( controller === undefined ) {\r\n\r\n\t\t\tcontroller = new Group();\r\n\t\t\tcontroller.matrixAutoUpdate = false;\r\n\t\t\tcontroller.visible = false;\r\n\r\n\t\t\tcontrollers[ id ] = controller;\r\n\r\n\t\t}\r\n\r\n\t\treturn controller;\r\n\r\n\t};\r\n\r\n\tthis.getDevice = function () {\r\n\r\n\t\treturn device;\r\n\r\n\t};\r\n\r\n\tthis.setDevice = function ( value ) {\r\n\r\n\t\tif ( value !== undefined ) { device = value; }\r\n\r\n\t\tanimation.setContext( value );\r\n\r\n\t};\r\n\r\n\tthis.setFrameOfReferenceType = function ( value ) {\r\n\r\n\t\tframeOfReferenceType = value;\r\n\r\n\t};\r\n\r\n\tthis.setPoseTarget = function ( object ) {\r\n\r\n\t\tif ( object !== undefined ) { poseTarget = object; }\r\n\r\n\t};\r\n\r\n\tthis.getCamera = function ( camera ) {\r\n\r\n\t\tvar userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;\r\n\r\n\t\tif ( device === null ) {\r\n\r\n\t\t\tcamera.position.set( 0, userHeight, 0 );\r\n\t\t\treturn camera;\r\n\r\n\t\t}\r\n\r\n\t\tdevice.depthNear = camera.near;\r\n\t\tdevice.depthFar = camera.far;\r\n\r\n\t\tdevice.getFrameData( frameData );\r\n\r\n\t\t//\r\n\r\n\t\tif ( frameOfReferenceType === 'stage' ) {\r\n\r\n\t\t\tvar stageParameters = device.stageParameters;\r\n\r\n\t\t\tif ( stageParameters ) {\r\n\r\n\t\t\t\tstandingMatrix.fromArray( stageParameters.sittingToStandingTransform );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstandingMatrix.makeTranslation( 0, userHeight, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar pose = frameData.pose;\r\n\t\tvar poseObject = poseTarget !== null ? poseTarget : camera;\r\n\r\n\t\t// We want to manipulate poseObject by its position and quaternion components since users may rely on them.\r\n\t\tposeObject.matrix.copy( standingMatrix );\r\n\t\tposeObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );\r\n\r\n\t\tif ( pose.orientation !== null ) {\r\n\r\n\t\t\ttempQuaternion.fromArray( pose.orientation );\r\n\t\t\tposeObject.quaternion.multiply( tempQuaternion );\r\n\r\n\t\t}\r\n\r\n\t\tif ( pose.position !== null ) {\r\n\r\n\t\t\ttempQuaternion.setFromRotationMatrix( standingMatrix );\r\n\t\t\ttempPosition.fromArray( pose.position );\r\n\t\t\ttempPosition.applyQuaternion( tempQuaternion );\r\n\t\t\tposeObject.position.add( tempPosition );\r\n\r\n\t\t}\r\n\r\n\t\tposeObject.updateMatrixWorld();\r\n\r\n\t\tif ( device.isPresenting === false ) { return camera; }\r\n\r\n\t\t//\r\n\r\n\t\tcameraL.near = camera.near;\r\n\t\tcameraR.near = camera.near;\r\n\r\n\t\tcameraL.far = camera.far;\r\n\t\tcameraR.far = camera.far;\r\n\r\n\t\tcameraVR.matrixWorld.copy( camera.matrixWorld );\r\n\t\tcameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );\r\n\r\n\t\tcameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );\r\n\t\tcameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );\r\n\r\n\t\t// TODO (mrdoob) Double check this code\r\n\r\n\t\tstandingMatrixInverse.getInverse( standingMatrix );\r\n\r\n\t\tif ( frameOfReferenceType === 'stage' ) {\r\n\r\n\t\t\tcameraL.matrixWorldInverse.multiply( standingMatrixInverse );\r\n\t\t\tcameraR.matrixWorldInverse.multiply( standingMatrixInverse );\r\n\r\n\t\t}\r\n\r\n\t\tvar parent = poseObject.parent;\r\n\r\n\t\tif ( parent !== null ) {\r\n\r\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\r\n\t\t\tcameraL.matrixWorldInverse.multiply( matrixWorldInverse );\r\n\t\t\tcameraR.matrixWorldInverse.multiply( matrixWorldInverse );\r\n\r\n\t\t}\r\n\r\n\t\t// envMap and Mirror needs camera.matrixWorld\r\n\r\n\t\tcameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );\r\n\t\tcameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );\r\n\r\n\t\tcameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );\r\n\t\tcameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );\r\n\r\n\t\t// HACK (mrdoob)\r\n\t\t// https://github.com/w3c/webvr/issues/203\r\n\r\n\t\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\r\n\r\n\t\t//\r\n\r\n\t\tvar layers = device.getLayers();\r\n\r\n\t\tif ( layers.length ) {\r\n\r\n\t\t\tvar layer = layers[ 0 ];\r\n\r\n\t\t\tif ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {\r\n\r\n\t\t\t\tcameraL.bounds.fromArray( layer.leftBounds );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {\r\n\r\n\t\t\t\tcameraR.bounds.fromArray( layer.rightBounds );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tupdateControllers();\r\n\r\n\t\treturn cameraVR;\r\n\r\n\t};\r\n\r\n\tthis.getStandingMatrix = function () {\r\n\r\n\t\treturn standingMatrix;\r\n\r\n\t};\r\n\r\n\tthis.isPresenting = isPresenting;\r\n\r\n\t// Animation Loop\r\n\r\n\tvar animation = new WebGLAnimation();\r\n\r\n\tthis.setAnimationLoop = function ( callback ) {\r\n\r\n\t\tanimation.setAnimationLoop( callback );\r\n\r\n\t};\r\n\r\n\tthis.submitFrame = function () {\r\n\r\n\t\tif ( isPresenting() ) { device.submitFrame(); }\r\n\r\n\t};\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tif ( typeof window !== 'undefined' ) {\r\n\r\n\t\t\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebXRManager( renderer ) {\r\n\r\n\tvar gl = renderer.context;\r\n\r\n\tvar device = null;\r\n\tvar session = null;\r\n\r\n\tvar frameOfReference = null;\r\n\tvar frameOfReferenceType = 'stage';\r\n\r\n\tvar pose = null;\r\n\r\n\tvar controllers = [];\r\n\tvar inputSources = [];\r\n\r\n\tfunction isPresenting() {\r\n\r\n\t\treturn session !== null && frameOfReference !== null;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar cameraL = new PerspectiveCamera();\r\n\tcameraL.layers.enable( 1 );\r\n\tcameraL.viewport = new Vector4();\r\n\r\n\tvar cameraR = new PerspectiveCamera();\r\n\tcameraR.layers.enable( 2 );\r\n\tcameraR.viewport = new Vector4();\r\n\r\n\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\r\n\tcameraVR.layers.enable( 1 );\r\n\tcameraVR.layers.enable( 2 );\r\n\r\n\t//\r\n\r\n\tthis.enabled = false;\r\n\r\n\tthis.getController = function ( id ) {\r\n\r\n\t\tvar controller = controllers[ id ];\r\n\r\n\t\tif ( controller === undefined ) {\r\n\r\n\t\t\tcontroller = new Group();\r\n\t\t\tcontroller.matrixAutoUpdate = false;\r\n\t\t\tcontroller.visible = false;\r\n\r\n\t\t\tcontrollers[ id ] = controller;\r\n\r\n\t\t}\r\n\r\n\t\treturn controller;\r\n\r\n\t};\r\n\r\n\tthis.getDevice = function () {\r\n\r\n\t\treturn device;\r\n\r\n\t};\r\n\r\n\tthis.setDevice = function ( value ) {\r\n\r\n\t\tif ( value !== undefined ) { device = value; }\r\n\t\tif ( value instanceof XRDevice ) { gl.setCompatibleXRDevice( value ); }\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction onSessionEvent( event ) {\r\n\r\n\t\tvar controller = controllers[ inputSources.indexOf( event.inputSource ) ];\r\n\t\tif ( controller ) { controller.dispatchEvent( { type: event.type } ); }\r\n\r\n\t}\r\n\r\n\tfunction onSessionEnd() {\r\n\r\n\t\trenderer.setFramebuffer( null );\r\n\t\tanimation.stop();\r\n\r\n\t}\r\n\r\n\tthis.setFrameOfReferenceType = function ( value ) {\r\n\r\n\t\tframeOfReferenceType = value;\r\n\r\n\t};\r\n\r\n\tthis.setSession = function ( value ) {\r\n\r\n\t\tsession = value;\r\n\r\n\t\tif ( session !== null ) {\r\n\r\n\t\t\tsession.addEventListener( 'select', onSessionEvent );\r\n\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\r\n\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\r\n\t\t\tsession.addEventListener( 'end', onSessionEnd );\r\n\r\n\t\t\tsession.baseLayer = new XRWebGLLayer( session, gl );\r\n\t\t\tsession.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) {\r\n\r\n\t\t\t\tframeOfReference = value;\r\n\r\n\t\t\t\trenderer.setFramebuffer( session.baseLayer.framebuffer );\r\n\r\n\t\t\t\tanimation.setContext( session );\r\n\t\t\t\tanimation.start();\r\n\r\n\t\t\t} );\r\n\r\n\t\t\t//\r\n\r\n\t\t\tinputSources = session.getInputSources();\r\n\r\n\t\t\tsession.addEventListener( 'inputsourceschange', function () {\r\n\r\n\t\t\t\tinputSources = session.getInputSources();\r\n\t\t\t\tconsole.log( inputSources );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction updateCamera( camera, parent ) {\r\n\r\n\t\tif ( parent === null ) {\r\n\r\n\t\t\tcamera.matrixWorld.copy( camera.matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\r\n\r\n\t\t}\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t}\r\n\r\n\tthis.getCamera = function ( camera ) {\r\n\r\n\t\tif ( isPresenting() ) {\r\n\r\n\t\t\tvar parent = camera.parent;\r\n\t\t\tvar cameras = cameraVR.cameras;\r\n\r\n\t\t\t// apply camera.parent to cameraVR\r\n\r\n\t\t\tupdateCamera( cameraVR, parent );\r\n\r\n\t\t\tfor ( var i = 0; i < cameras.length; i ++ ) {\r\n\r\n\t\t\t\tupdateCamera( cameras[ i ], parent );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update camera and its children\r\n\r\n\t\t\tcamera.matrixWorld.copy( cameraVR.matrixWorld );\r\n\r\n\t\t\tvar children = camera.children;\r\n\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tchildren[ i ].updateMatrixWorld( true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cameraVR;\r\n\r\n\t\t}\r\n\r\n\t\treturn camera;\r\n\r\n\t};\r\n\r\n\tthis.isPresenting = isPresenting;\r\n\r\n\t// Animation Loop\r\n\r\n\tvar onAnimationFrameCallback = null;\r\n\r\n\tfunction onAnimationFrame( time, frame ) {\r\n\r\n\t\tpose = frame.getDevicePose( frameOfReference );\r\n\r\n\t\tif ( pose !== null ) {\r\n\r\n\t\t\tvar layer = session.baseLayer;\r\n\t\t\tvar views = frame.views;\r\n\r\n\t\t\tfor ( var i = 0; i < views.length; i ++ ) {\r\n\r\n\t\t\t\tvar view = views[ i ];\r\n\t\t\t\tvar viewport = layer.getViewport( view );\r\n\t\t\t\tvar viewMatrix = pose.getViewMatrix( view );\r\n\r\n\t\t\t\tvar camera = cameraVR.cameras[ i ];\r\n\t\t\t\tcamera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );\r\n\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\r\n\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\r\n\r\n\t\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\t\tcameraVR.matrix.copy( camera.matrix );\r\n\r\n\t\t\t\t\t// HACK (mrdoob)\r\n\t\t\t\t\t// https://github.com/w3c/webvr/issues/203\r\n\r\n\t\t\t\t\tcameraVR.projectionMatrix.copy( camera.projectionMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfor ( var i = 0; i < controllers.length; i ++ ) {\r\n\r\n\t\t\tvar controller = controllers[ i ];\r\n\r\n\t\t\tvar inputSource = inputSources[ i ];\r\n\r\n\t\t\tif ( inputSource ) {\r\n\r\n\t\t\t\tvar inputPose = frame.getInputPose( inputSource, frameOfReference );\r\n\r\n\t\t\t\tif ( inputPose !== null ) {\r\n\r\n\t\t\t\t\tif ( 'targetRay' in inputPose ) {\r\n\r\n\t\t\t\t\t\tcontroller.matrix.elements = inputPose.targetRay.transformMatrix;\r\n\r\n\t\t\t\t\t} else if ( 'pointerMatrix' in inputPose ) {\r\n\r\n\t\t\t\t\t\t// DEPRECATED\r\n\r\n\t\t\t\t\t\tcontroller.matrix.elements = inputPose.pointerMatrix;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontroller.matrix.decompose( controller.position, controller.rotation, controller.scale );\r\n\t\t\t\t\tcontroller.visible = true;\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcontroller.visible = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( onAnimationFrameCallback ) { onAnimationFrameCallback( time ); }\r\n\r\n\t}\r\n\r\n\tvar animation = new WebGLAnimation();\r\n\tanimation.setAnimationLoop( onAnimationFrame );\r\n\r\n\tthis.setAnimationLoop = function ( callback ) {\r\n\r\n\t\tonAnimationFrameCallback = callback;\r\n\r\n\t};\r\n\r\n\tthis.dispose = function () {};\r\n\r\n\t// DEPRECATED\r\n\r\n\tthis.getStandingMatrix = function () {\r\n\r\n\t\tconsole.warn( 'WebXRManager: getStandingMatrix() is no longer needed.' );\r\n\t\treturn new Matrix4();\r\n\r\n\t};\r\n\r\n\tthis.submitFrame = function () {};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGLRenderer( parameters ) {\r\n\r\n\tconsole.log( 'WebGLRenderer', REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\r\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';\r\n\r\n\tvar currentRenderList = null;\r\n\tvar currentRenderState = null;\r\n\r\n\t// public properties\r\n\r\n\tthis.domElement = _canvas;\r\n\tthis.context = null;\r\n\r\n\t// clearing\r\n\r\n\tthis.autoClear = true;\r\n\tthis.autoClearColor = true;\r\n\tthis.autoClearDepth = true;\r\n\tthis.autoClearStencil = true;\r\n\r\n\t// scene graph\r\n\r\n\tthis.sortObjects = true;\r\n\r\n\t// user-defined clipping\r\n\r\n\tthis.clippingPlanes = [];\r\n\tthis.localClippingEnabled = false;\r\n\r\n\t// physically based shading\r\n\r\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\tthis.gammaInput = false;\r\n\tthis.gammaOutput = false;\r\n\r\n\t// physical lights\r\n\r\n\tthis.physicallyCorrectLights = false;\r\n\r\n\t// tone mapping\r\n\r\n\tthis.toneMapping = LinearToneMapping;\r\n\tthis.toneMappingExposure = 1.0;\r\n\tthis.toneMappingWhitePoint = 1.0;\r\n\r\n\t// morphs\r\n\r\n\tthis.maxMorphTargets = 8;\r\n\tthis.maxMorphNormals = 4;\r\n\r\n\t// internal properties\r\n\r\n\tvar _this = this,\r\n\r\n\t\t_isContextLost = false,\r\n\r\n\t\t// internal state cache\r\n\r\n\t\t_framebuffer = null,\r\n\r\n\t\t_currentRenderTarget = null,\r\n\t\t_currentFramebuffer = null,\r\n\t\t_currentMaterialId = - 1,\r\n\r\n\t\t// geometry and program caching\r\n\r\n\t\t_currentGeometryProgram = {\r\n\t\t\tgeometry: null,\r\n\t\t\tprogram: null,\r\n\t\t\twireframe: false\r\n\t\t},\r\n\r\n\t\t_currentCamera = null,\r\n\t\t_currentArrayCamera = null,\r\n\r\n\t\t_currentViewport = new Vector4(),\r\n\t\t_currentScissor = new Vector4(),\r\n\t\t_currentScissorTest = null,\r\n\r\n\t\t//\r\n\r\n\t\t_usedTextureUnits = 0,\r\n\r\n\t\t//\r\n\r\n\t\t_width = _canvas.width,\r\n\t\t_height = _canvas.height,\r\n\r\n\t\t_pixelRatio = 1,\r\n\r\n\t\t_viewport = new Vector4( 0, 0, _width, _height ),\r\n\t\t_scissor = new Vector4( 0, 0, _width, _height ),\r\n\t\t_scissorTest = false,\r\n\r\n\t\t// frustum\r\n\r\n\t\t_frustum = new Frustum(),\r\n\r\n\t\t// clipping\r\n\r\n\t\t_clipping = new WebGLClipping(),\r\n\t\t_clippingEnabled = false,\r\n\t\t_localClippingEnabled = false,\r\n\r\n\t\t// camera matrices cache\r\n\r\n\t\t_projScreenMatrix = new Matrix4(),\r\n\r\n\t\t_vector3 = new Vector3();\r\n\r\n\tfunction getTargetPixelRatio() {\r\n\r\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\r\n\r\n\t}\r\n\r\n\t// initialize\r\n\r\n\tvar _gl;\r\n\r\n\ttry {\r\n\r\n\t\tvar contextAttributes = {\r\n\t\t\talpha: _alpha,\r\n\t\t\tdepth: _depth,\r\n\t\t\tstencil: _stencil,\r\n\t\t\tantialias: _antialias,\r\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\r\n\t\t\tpowerPreference: _powerPreference\r\n\t\t};\r\n\r\n\t\t// event listeners must be registered before WebGL context is created, see #12753\r\n\r\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\r\n\r\n\t\t_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );\r\n\r\n\t\tif ( _gl === null ) {\r\n\r\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\r\n\r\n\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\r\n\r\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\r\n\t\t\t_gl.getShaderPrecisionFormat = function () {\r\n\r\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t} catch ( error ) {\r\n\r\n\t\tconsole.error( 'WebGLRenderer: ' + error.message );\r\n\r\n\t}\r\n\r\n\tvar extensions, capabilities, state, info;\r\n\tvar properties, textures, attributes, geometries, objects;\r\n\tvar programCache, renderLists, renderStates;\r\n\r\n\tvar background, morphtargets, bufferRenderer, indexedBufferRenderer;\r\n\r\n\tvar utils;\r\n\r\n\tfunction initGLContext() {\r\n\r\n\t\textensions = new WebGLExtensions( _gl );\r\n\r\n\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\r\n\r\n\t\tif ( ! capabilities.isWebGL2 ) {\r\n\r\n\t\t\textensions.get( 'WEBGL_depth_texture' );\r\n\t\t\textensions.get( 'OES_texture_float' );\r\n\t\t\textensions.get( 'OES_texture_half_float' );\r\n\t\t\textensions.get( 'OES_texture_half_float_linear' );\r\n\t\t\textensions.get( 'OES_standard_derivatives' );\r\n\t\t\textensions.get( 'OES_element_index_uint' );\r\n\t\t\textensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t}\r\n\r\n\t\textensions.get( 'OES_texture_float_linear' );\r\n\r\n\t\tutils = new WebGLUtils( _gl, extensions, capabilities );\r\n\r\n\t\tstate = new WebGLState( _gl, extensions, utils, capabilities );\r\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\r\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\r\n\r\n\t\tinfo = new WebGLInfo( _gl );\r\n\t\tproperties = new WebGLProperties();\r\n\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\r\n\t\tattributes = new WebGLAttributes( _gl );\r\n\t\tgeometries = new WebGLGeometries( _gl, attributes, info );\r\n\t\tobjects = new WebGLObjects( geometries, info );\r\n\t\tmorphtargets = new WebGLMorphtargets( _gl );\r\n\t\tprogramCache = new WebGLPrograms( _this, extensions, capabilities );\r\n\t\trenderLists = new WebGLRenderLists();\r\n\t\trenderStates = new WebGLRenderStates();\r\n\r\n\t\tbackground = new WebGLBackground( _this, state, objects, _premultipliedAlpha );\r\n\r\n\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );\r\n\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );\r\n\r\n\t\tinfo.programs = programCache.programs;\r\n\r\n\t\t_this.context = _gl;\r\n\t\t_this.capabilities = capabilities;\r\n\t\t_this.extensions = extensions;\r\n\t\t_this.properties = properties;\r\n\t\t_this.renderLists = renderLists;\r\n\t\t_this.state = state;\r\n\t\t_this.info = info;\r\n\r\n\t}\r\n\r\n\tinitGLContext();\r\n\r\n\t// vr\r\n\r\n\tvar vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );\r\n\r\n\tthis.vr = vr;\r\n\r\n\t// shadow map\r\n\r\n\tvar shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );\r\n\r\n\tthis.shadowMap = shadowMap;\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _gl;\r\n\r\n\t};\r\n\r\n\tthis.getContextAttributes = function () {\r\n\r\n\t\treturn _gl.getContextAttributes();\r\n\r\n\t};\r\n\r\n\tthis.forceContextLoss = function () {\r\n\r\n\t\tvar extension = extensions.get( 'WEBGL_lose_context' );\r\n\t\tif ( extension ) { extension.loseContext(); }\r\n\r\n\t};\r\n\r\n\tthis.forceContextRestore = function () {\r\n\r\n\t\tvar extension = extensions.get( 'WEBGL_lose_context' );\r\n\t\tif ( extension ) { extension.restoreContext(); }\r\n\r\n\t};\r\n\r\n\tthis.getPixelRatio = function () {\r\n\r\n\t\treturn _pixelRatio;\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function ( value ) {\r\n\r\n\t\tif ( value === undefined ) { return; }\r\n\r\n\t\t_pixelRatio = value;\r\n\r\n\t\tthis.setSize( _width, _height, false );\r\n\r\n\t};\r\n\r\n\tthis.getSize = function () {\r\n\r\n\t\treturn {\r\n\t\t\twidth: _width,\r\n\t\t\theight: _height\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\tif ( vr.isPresenting() ) {\r\n\r\n\t\t\tconsole.warn( 'WebGLRenderer: Can\\'t change size while VR device is presenting.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\t_canvas.width = width * _pixelRatio;\r\n\t\t_canvas.height = height * _pixelRatio;\r\n\r\n\t\tif ( updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.getDrawingBufferSize = function () {\r\n\r\n\t\treturn {\r\n\t\t\twidth: _width * _pixelRatio,\r\n\t\t\theight: _height * _pixelRatio\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\t_pixelRatio = pixelRatio;\r\n\r\n\t\t_canvas.width = width * pixelRatio;\r\n\t\t_canvas.height = height * pixelRatio;\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.getCurrentViewport = function () {\r\n\r\n\t\treturn _currentViewport;\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\t_viewport.set( x, _height - y - height, width, height );\r\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\t_scissor.set( x, _height - y - height, width, height );\r\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\r\n\r\n\t};\r\n\r\n\tthis.setScissorTest = function ( boolean ) {\r\n\r\n\t\tstate.setScissorTest( _scissorTest = boolean );\r\n\r\n\t};\r\n\r\n\t// Clearing\r\n\r\n\tthis.getClearColor = function () {\r\n\r\n\t\treturn background.getClearColor();\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function () {\r\n\r\n\t\tbackground.setClearColor.apply( background, arguments );\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn background.getClearAlpha();\r\n\r\n\t};\r\n\r\n\tthis.setClearAlpha = function () {\r\n\r\n\t\tbackground.setClearAlpha.apply( background, arguments );\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\tvar bits = 0;\r\n\r\n\t\tif ( color === undefined || color ) { bits |= _gl.COLOR_BUFFER_BIT; }\r\n\t\tif ( depth === undefined || depth ) { bits |= _gl.DEPTH_BUFFER_BIT; }\r\n\t\tif ( stencil === undefined || stencil ) { bits |= _gl.STENCIL_BUFFER_BIT; }\r\n\r\n\t\t_gl.clear( bits );\r\n\r\n\t};\r\n\r\n\tthis.clearColor = function () {\r\n\r\n\t\tthis.clear( true, false, false );\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function () {\r\n\r\n\t\tthis.clear( false, true, false );\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function () {\r\n\r\n\t\tthis.clear( false, false, true );\r\n\r\n\t};\r\n\r\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\t\tthis.clear( color, depth, stencil );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\r\n\r\n\t\trenderLists.dispose();\r\n\t\trenderStates.dispose();\r\n\t\tproperties.dispose();\r\n\t\tobjects.dispose();\r\n\r\n\t\tvr.dispose();\r\n\r\n\t\tanimation.stop();\r\n\r\n\t};\r\n\r\n\t// Events\r\n\r\n\tfunction onContextLost( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tconsole.log( 'WebGLRenderer: Context Lost.' );\r\n\r\n\t\t_isContextLost = true;\r\n\r\n\t}\r\n\r\n\tfunction onContextRestore(  ) {\r\n\r\n\t\tconsole.log( 'WebGLRenderer: Context Restored.' );\r\n\r\n\t\t_isContextLost = false;\r\n\r\n\t\tinitGLContext();\r\n\r\n\t}\r\n\r\n\tfunction onMaterialDispose( event ) {\r\n\r\n\t\tvar material = event.target;\r\n\r\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tdeallocateMaterial( material );\r\n\r\n\t}\r\n\r\n\t// Buffer deallocation\r\n\r\n\tfunction deallocateMaterial( material ) {\r\n\r\n\t\treleaseMaterialProgramReference( material );\r\n\r\n\t\tproperties.remove( material );\r\n\r\n\t}\r\n\r\n\tfunction releaseMaterialProgramReference( material ) {\r\n\r\n\t\tvar programInfo = properties.get( material ).program;\r\n\r\n\t\tmaterial.program = undefined;\r\n\r\n\t\tif ( programInfo !== undefined ) {\r\n\r\n\t\t\tprogramCache.releaseProgram( programInfo );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Buffer rendering\r\n\r\n\tfunction renderObjectImmediate( object, program ) {\r\n\r\n\t\tobject.render( function ( object ) {\r\n\r\n\t\t\t_this.renderBufferImmediate( object, program );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tthis.renderBufferImmediate = function ( object, program ) {\r\n\r\n\t\tstate.initAttributes();\r\n\r\n\t\tvar buffers = properties.get( object );\r\n\r\n\t\tif ( object.hasPositions && ! buffers.position ) { buffers.position = _gl.createBuffer(); }\r\n\t\tif ( object.hasNormals && ! buffers.normal ) { buffers.normal = _gl.createBuffer(); }\r\n\t\tif ( object.hasUvs && ! buffers.uv ) { buffers.uv = _gl.createBuffer(); }\r\n\t\tif ( object.hasColors && ! buffers.color ) { buffers.color = _gl.createBuffer(); }\r\n\r\n\t\tvar programAttributes = program.getAttributes();\r\n\r\n\t\tif ( object.hasPositions ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( programAttributes.position );\r\n\t\t\t_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasNormals ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( programAttributes.normal );\r\n\t\t\t_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasUvs ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( programAttributes.uv );\r\n\t\t\t_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasColors ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( programAttributes.color );\r\n\t\t\t_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n\t\tobject.count = 0;\r\n\r\n\t};\r\n\r\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\r\n\r\n\t\tvar frontFaceCW = ( object.isMesh && object.normalMatrix.determinant() < 0 );\r\n\r\n\t\tstate.setMaterial( material, frontFaceCW );\r\n\r\n\t\tvar program = setProgram( camera, fog, material, object );\r\n\r\n\t\tvar updateBuffers = false;\r\n\r\n\t\tif ( _currentGeometryProgram.geometry !== geometry.id ||\r\n\t\t\t_currentGeometryProgram.program !== program.id ||\r\n\t\t\t_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {\r\n\r\n\t\t\t_currentGeometryProgram.geometry = geometry.id;\r\n\t\t\t_currentGeometryProgram.program = program.id;\r\n\t\t\t_currentGeometryProgram.wireframe = material.wireframe === true;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.morphTargetInfluences ) {\r\n\r\n\t\t\tmorphtargets.update( object, geometry, material, program );\r\n\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar position = geometry.attributes.position;\r\n\t\tvar rangeFactor = 1;\r\n\r\n\t\tif ( material.wireframe === true ) {\r\n\r\n\t\t\tindex = geometries.getWireframeAttribute( geometry );\r\n\t\t\trangeFactor = 2;\r\n\r\n\t\t}\r\n\r\n\t\tvar attribute;\r\n\t\tvar renderer = bufferRenderer;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tattribute = attributes.get( index );\r\n\r\n\t\t\trenderer = indexedBufferRenderer;\r\n\t\t\trenderer.setIndex( attribute );\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tsetupVertexAttributes( material, program, geometry );\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar dataCount = Infinity;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tdataCount = index.count;\r\n\r\n\t\t} else if ( position !== undefined ) {\r\n\r\n\t\t\tdataCount = position.count;\r\n\r\n\t\t}\r\n\r\n\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\r\n\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\r\n\r\n\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\r\n\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\r\n\r\n\t\tvar drawStart = Math.max( rangeStart, groupStart );\r\n\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\r\n\r\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\r\n\r\n\t\tif ( drawCount === 0 ) { return; }\r\n\r\n\t\t//\r\n\r\n\t\tif ( object.isMesh ) {\r\n\r\n\t\t\tif ( material.wireframe === true ) {\r\n\r\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\r\n\t\t\t\trenderer.setMode( _gl.LINES );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tswitch ( object.drawMode ) {\r\n\r\n\t\t\t\t\tcase TrianglesDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase TriangleStripDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase TriangleFanDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object.isLine ) {\r\n\r\n\t\t\tvar lineWidth = material.linewidth;\r\n\r\n\t\t\tif ( lineWidth === undefined ) { lineWidth = 1; } // Not using Line*Material\r\n\r\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\r\n\r\n\t\t\tif ( object.isLineSegments ) {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINES );\r\n\r\n\t\t\t} else if ( object.isLineLoop ) {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINE_LOOP );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object.isPoints ) {\r\n\r\n\t\t\trenderer.setMode( _gl.POINTS );\r\n\r\n\t\t} else if ( object.isSprite ) {\r\n\r\n\t\t\trenderer.setMode( _gl.TRIANGLES );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\r\n\r\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\r\n\r\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( drawStart, drawCount );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupVertexAttributes( material, program, geometry ) {\r\n\r\n\t\tif ( geometry && geometry.isInstancedBufferGeometry & ! capabilities.isWebGL2 ) {\r\n\r\n\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {\r\n\r\n\t\t\t\tconsole.error( 'WebGLRenderer.setupVertexAttributes: using InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.initAttributes();\r\n\r\n\t\tvar geometryAttributes = geometry.attributes;\r\n\r\n\t\tvar programAttributes = program.getAttributes();\r\n\r\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\r\n\r\n\t\tfor ( var name in programAttributes ) {\r\n\r\n\t\t\tvar programAttribute = programAttributes[ name ];\r\n\r\n\t\t\tif ( programAttribute >= 0 ) {\r\n\r\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\r\n\r\n\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\r\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\r\n\t\t\t\t\tvar attribute = attributes.get( geometryAttribute );\r\n\r\n\t\t\t\t\t// TODO Attribute may not be available on context restore\r\n\r\n\t\t\t\t\tif ( attribute === undefined ) { continue; }\r\n\r\n\t\t\t\t\tvar buffer = attribute.buffer;\r\n\t\t\t\t\tvar type = attribute.type;\r\n\t\t\t\t\tvar bytesPerElement = attribute.bytesPerElement;\r\n\r\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\tvar data = geometryAttribute.data;\r\n\t\t\t\t\t\tvar stride = data.stride;\r\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\r\n\r\n\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\r\n\r\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\r\n\r\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\r\n\r\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\r\n\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\t\tswitch ( value.length ) {\r\n\r\n\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t}\r\n\r\n\t// Compile\r\n\r\n\tthis.compile = function ( scene, camera ) {\r\n\r\n\t\tcurrentRenderState = renderStates.get( scene, camera );\r\n\t\tcurrentRenderState.init();\r\n\r\n\t\tscene.traverse( function ( object ) {\r\n\r\n\t\t\tif ( object.isLight ) {\r\n\r\n\t\t\t\tcurrentRenderState.pushLight( object );\r\n\r\n\t\t\t\tif ( object.castShadow ) {\r\n\r\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tcurrentRenderState.setupLights( camera );\r\n\r\n\t\tscene.traverse( function ( object ) {\r\n\r\n\t\t\tif ( object.material ) {\r\n\r\n\t\t\t\tif ( Array.isArray( object.material ) ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0; i < object.material.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tinitMaterial( object.material[ i ], scene.fog, object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tinitMaterial( object.material, scene.fog, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\t// Animation Loop\r\n\r\n\tvar onAnimationFrameCallback = null;\r\n\r\n\tfunction onAnimationFrame( time ) {\r\n\r\n\t\tif ( vr.isPresenting() ) { return; }\r\n\t\tif ( onAnimationFrameCallback ) { onAnimationFrameCallback( time ); }\r\n\r\n\t}\r\n\r\n\tvar animation = new WebGLAnimation();\r\n\tanimation.setAnimationLoop( onAnimationFrame );\r\n\r\n\tif ( typeof window !== 'undefined' ) { animation.setContext( window ); }\r\n\r\n\tthis.setAnimationLoop = function ( callback ) {\r\n\r\n\t\tonAnimationFrameCallback = callback;\r\n\t\tvr.setAnimationLoop( callback );\r\n\r\n\t\tanimation.start();\r\n\r\n\t};\r\n\r\n\t// Rendering\r\n\r\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( ! ( camera && camera.isCamera ) ) {\r\n\r\n\t\t\tconsole.error( 'WebGLRenderer.render: camera is not an instance of Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _isContextLost ) { return; }\r\n\r\n\t\t// reset caching for this frame\r\n\r\n\t\t_currentGeometryProgram.geometry = null;\r\n\t\t_currentGeometryProgram.program = null;\r\n\t\t_currentGeometryProgram.wireframe = false;\r\n\t\t_currentMaterialId = - 1;\r\n\t\t_currentCamera = null;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( scene.autoUpdate === true ) { scene.updateMatrixWorld(); }\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tif ( camera.parent === null ) { camera.updateMatrixWorld(); }\r\n\r\n\t\tif ( vr.enabled ) {\r\n\r\n\t\t\tcamera = vr.getCamera( camera );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tcurrentRenderState = renderStates.get( scene, camera );\r\n\t\tcurrentRenderState.init();\r\n\r\n\t\tscene.onBeforeRender( _this, scene, camera, renderTarget );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t_localClippingEnabled = this.localClippingEnabled;\r\n\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\r\n\r\n\t\tcurrentRenderList = renderLists.get( scene, camera );\r\n\t\tcurrentRenderList.init();\r\n\r\n\t\tprojectObject( scene, camera, _this.sortObjects );\r\n\r\n\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\tcurrentRenderList.sort();\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( _clippingEnabled ) { _clipping.beginShadows(); }\r\n\r\n\t\tvar shadowsArray = currentRenderState.state.shadowsArray;\r\n\r\n\t\tshadowMap.render( shadowsArray, scene, camera );\r\n\r\n\t\tcurrentRenderState.setupLights( camera );\r\n\r\n\t\tif ( _clippingEnabled ) { _clipping.endShadows(); }\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.info.autoReset ) { this.info.reset(); }\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\trenderTarget = null;\r\n\r\n\t\t}\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\r\n\t\t//\r\n\r\n\t\tbackground.render( currentRenderList, scene, camera, forceClear );\r\n\r\n\t\t// render scene\r\n\r\n\t\tvar opaqueObjects = currentRenderList.opaque;\r\n\t\tvar transparentObjects = currentRenderList.transparent;\r\n\r\n\t\tif ( scene.overrideMaterial ) {\r\n\r\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\r\n\t\t\tif ( opaqueObjects.length ) { renderObjects( opaqueObjects, scene, camera, overrideMaterial ); }\r\n\t\t\tif ( transparentObjects.length ) { renderObjects( transparentObjects, scene, camera, overrideMaterial ); }\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// opaque pass (front-to-back order)\r\n\r\n\t\t\tif ( opaqueObjects.length ) { renderObjects( opaqueObjects, scene, camera ); }\r\n\r\n\t\t\t// transparent pass (back-to-front order)\r\n\r\n\t\t\tif ( transparentObjects.length ) { renderObjects( transparentObjects, scene, camera ); }\r\n\r\n\t\t}\r\n\r\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n\t\tstate.buffers.depth.setTest( true );\r\n\t\tstate.buffers.depth.setMask( true );\r\n\t\tstate.buffers.color.setMask( true );\r\n\r\n\t\tstate.setPolygonOffset( false );\r\n\r\n\t\tscene.onAfterRender( _this, scene, camera );\r\n\r\n\t\tif ( vr.enabled ) {\r\n\r\n\t\t\tvr.submitFrame();\r\n\r\n\t\t}\r\n\r\n\t\t// _gl.finish();\r\n\r\n\t\tcurrentRenderList = null;\r\n\t\tcurrentRenderState = null;\r\n\r\n\t};\r\n\r\n\tfunction projectObject( object, camera, sortObjects ) {\r\n\r\n\t\tif ( object.visible === false ) { return; }\r\n\r\n\t\tvar visible = object.layers.test( camera.layers );\r\n\r\n\t\tif ( visible ) {\r\n\r\n\t\t\tif ( object.isLight ) {\r\n\r\n\t\t\t\tcurrentRenderState.pushLight( object );\r\n\r\n\t\t\t\tif ( object.castShadow ) {\r\n\r\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object.isSprite ) {\r\n\r\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\r\n\r\n\t\t\t\t\tif ( sortObjects ) {\r\n\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\r\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar geometry = objects.update( object );\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tcurrentRenderList.push( object, geometry, material, _vector3.z, null );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object.isImmediateRenderObject ) {\r\n\r\n\t\t\t\tif ( sortObjects ) {\r\n\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\r\n\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrentRenderList.push( object, null, object.material, _vector3.z, null );\r\n\r\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\r\n\r\n\t\t\t\tif ( object.isSkinnedMesh ) {\r\n\r\n\t\t\t\t\tobject.skeleton.update();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\tif ( sortObjects ) {\r\n\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\r\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar geometry = objects.update( object );\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\t\t\t\tvar groups = geometry.groups;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\t\t\t\tvar groupMaterial = material[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\r\n\r\n\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( material.visible ) {\r\n\r\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, _vector3.z, null );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( children[ i ], camera, sortObjects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\r\n\r\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar renderItem = renderList[ i ];\r\n\r\n\t\t\tvar object = renderItem.object;\r\n\t\t\tvar geometry = renderItem.geometry;\r\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\r\n\t\t\tvar group = renderItem.group;\r\n\r\n\t\t\tif ( camera.isArrayCamera ) {\r\n\r\n\t\t\t\t_currentArrayCamera = camera;\r\n\r\n\t\t\t\tvar cameras = camera.cameras;\r\n\r\n\t\t\t\tfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar camera2 = cameras[ j ];\r\n\r\n\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\r\n\r\n\t\t\t\t\t\tif ( 'viewport' in camera2 ) { // XR\r\n\r\n\t\t\t\t\t\t\tstate.viewport( _currentViewport.copy( camera2.viewport ) );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar bounds = camera2.bounds;\r\n\r\n\t\t\t\t\t\t\tvar x = bounds.x * _width;\r\n\t\t\t\t\t\t\tvar y = bounds.y * _height;\r\n\t\t\t\t\t\t\tvar width = bounds.z * _width;\r\n\t\t\t\t\t\t\tvar height = bounds.w * _height;\r\n\r\n\t\t\t\t\t\t\tstate.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcurrentRenderState.setupLights( camera2 );\r\n\r\n\t\t\t\t\t\trenderObject( object, scene, camera2, geometry, material, group );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_currentArrayCamera = null;\r\n\r\n\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderObject( object, scene, camera, geometry, material, group ) {\r\n\r\n\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\r\n\t\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\r\n\r\n\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\r\n\t\tif ( object.isImmediateRenderObject ) {\r\n\r\n\t\t\tstate.setMaterial( material );\r\n\r\n\t\t\tvar program = setProgram( camera, scene.fog, material, object );\r\n\r\n\t\t\t_currentGeometryProgram.geometry = null;\r\n\t\t\t_currentGeometryProgram.program = null;\r\n\t\t\t_currentGeometryProgram.wireframe = false;\r\n\r\n\t\t\trenderObjectImmediate( object, program );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\r\n\r\n\t\t}\r\n\r\n\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\r\n\t\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\r\n\r\n\t}\r\n\r\n\tfunction initMaterial( material, fog, object ) {\r\n\r\n\t\tvar materialProperties = properties.get( material );\r\n\r\n\t\tvar lights = currentRenderState.state.lights;\r\n\t\tvar shadowsArray = currentRenderState.state.shadowsArray;\r\n\r\n\t\tvar lightsHash = materialProperties.lightsHash;\r\n\t\tvar lightsStateHash = lights.state.hash;\r\n\r\n\t\tvar parameters = programCache.getParameters(\r\n\t\t\tmaterial, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );\r\n\r\n\t\tvar code = programCache.getProgramCode( material, parameters );\r\n\r\n\t\tvar program = materialProperties.program;\r\n\t\tvar programChange = true;\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\t// new material\r\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\t} else if ( program.code !== code ) {\r\n\r\n\t\t\t// changed glsl or parameters\r\n\t\t\treleaseMaterialProgramReference( material );\r\n\r\n\t\t} else if ( lightsHash.stateID !== lightsStateHash.stateID ||\r\n\t\t\tlightsHash.directionalLength !== lightsStateHash.directionalLength ||\r\n\t\t\tlightsHash.pointLength !== lightsStateHash.pointLength ||\r\n\t\t\tlightsHash.spotLength !== lightsStateHash.spotLength ||\r\n\t\t\tlightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||\r\n\t\t\tlightsHash.hemiLength !== lightsStateHash.hemiLength ||\r\n\t\t\tlightsHash.shadowsLength !== lightsStateHash.shadowsLength ) {\r\n\r\n\t\t\tlightsHash.stateID = lightsStateHash.stateID;\r\n\t\t\tlightsHash.directionalLength = lightsStateHash.directionalLength;\r\n\t\t\tlightsHash.pointLength = lightsStateHash.pointLength;\r\n\t\t\tlightsHash.spotLength = lightsStateHash.spotLength;\r\n\t\t\tlightsHash.rectAreaLength = lightsStateHash.rectAreaLength;\r\n\t\t\tlightsHash.hemiLength = lightsStateHash.hemiLength;\r\n\t\t\tlightsHash.shadowsLength = lightsStateHash.shadowsLength;\r\n\r\n\t\t\tprogramChange = false;\r\n\r\n\t\t} else if ( parameters.shaderID !== undefined ) {\r\n\r\n\t\t\t// same glsl and uniform list\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// only rebuild uniform list\r\n\t\t\tprogramChange = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( programChange ) {\r\n\r\n\t\t\tif ( parameters.shaderID ) {\r\n\r\n\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\r\n\r\n\t\t\t\tmaterialProperties.shader = {\r\n\t\t\t\t\tname: material.type,\r\n\t\t\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterialProperties.shader = {\r\n\t\t\t\t\tname: material.type,\r\n\t\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.onBeforeCompile( materialProperties.shader, _this );\r\n\r\n\t\t\t// Computing code again as onBeforeCompile may have changed the shaders\r\n\t\t\tcode = programCache.getProgramCode( material, parameters );\r\n\r\n\t\t\tprogram = programCache.acquireProgram( material, materialProperties.shader, parameters, code );\r\n\r\n\t\t\tmaterialProperties.program = program;\r\n\t\t\tmaterial.program = program;\r\n\r\n\t\t}\r\n\r\n\t\tvar programAttributes = program.getAttributes();\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\t\tif ( programAttributes[ 'morphTarget' + i ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\t\tif ( programAttributes[ 'morphNormal' + i ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar uniforms = materialProperties.shader.uniforms;\r\n\r\n\t\tif ( ! material.isShaderMaterial &&\r\n\t\t\t! material.isRawShaderMaterial ||\r\n\t\t\tmaterial.clipping === true ) {\r\n\r\n\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\r\n\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\r\n\t\t\tuniforms.clippingPlanes = _clipping.uniform;\r\n\r\n\t\t}\r\n\r\n\t\tmaterialProperties.fog = fog;\r\n\r\n\t\t// store the light setup it was created for\r\n\t\tif ( lightsHash === undefined ) {\r\n\r\n\t\t\tmaterialProperties.lightsHash = lightsHash = {};\r\n\r\n\t\t}\r\n\r\n\t\tlightsHash.stateID = lightsStateHash.stateID;\r\n\t\tlightsHash.directionalLength = lightsStateHash.directionalLength;\r\n\t\tlightsHash.pointLength = lightsStateHash.pointLength;\r\n\t\tlightsHash.spotLength = lightsStateHash.spotLength;\r\n\t\tlightsHash.rectAreaLength = lightsStateHash.rectAreaLength;\r\n\t\tlightsHash.hemiLength = lightsStateHash.hemiLength;\r\n\t\tlightsHash.shadowsLength = lightsStateHash.shadowsLength;\r\n\r\n\t\tif ( material.lights ) {\r\n\r\n\t\t\t// wire up the material to this renderer's lighting state\r\n\r\n\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\r\n\t\t\tuniforms.directionalLights.value = lights.state.directional;\r\n\t\t\tuniforms.spotLights.value = lights.state.spot;\r\n\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\r\n\t\t\tuniforms.pointLights.value = lights.state.point;\r\n\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\r\n\r\n\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\r\n\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\r\n\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\r\n\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\r\n\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\r\n\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\r\n\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\r\n\r\n\t\t}\r\n\r\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\r\n\t\t\tuniformsList =\r\n\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\r\n\r\n\t\tmaterialProperties.uniformsList = uniformsList;\r\n\r\n\t}\r\n\r\n\tfunction setProgram( camera, fog, material, object ) {\r\n\r\n\t\t_usedTextureUnits = 0;\r\n\r\n\t\tvar materialProperties = properties.get( material );\r\n\t\tvar lights = currentRenderState.state.lights;\r\n\r\n\t\tvar lightsHash = materialProperties.lightsHash;\r\n\t\tvar lightsStateHash = lights.state.hash;\r\n\r\n\t\tif ( _clippingEnabled ) {\r\n\r\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\r\n\r\n\t\t\t\tvar useCache =\r\n\t\t\t\t\tcamera === _currentCamera &&\r\n\t\t\t\t\tmaterial.id === _currentMaterialId;\r\n\r\n\t\t\t\t// we might want to call this function with some ClippingGroup\r\n\t\t\t\t// object instead of the material, once it becomes feasible\r\n\t\t\t\t// (#8465, #8379)\r\n\t\t\t\t_clipping.setState(\r\n\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\r\n\t\t\t\t\tcamera, materialProperties, useCache );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.needsUpdate === false ) {\r\n\r\n\t\t\tif ( materialProperties.program === undefined ) {\r\n\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\r\n\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t\t} else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID ||\r\n\t\t\t\tlightsHash.directionalLength !== lightsStateHash.directionalLength ||\r\n\t\t\t\tlightsHash.pointLength !== lightsStateHash.pointLength ||\r\n\t\t\t\tlightsHash.spotLength !== lightsStateHash.spotLength ||\r\n\t\t\t\tlightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||\r\n\t\t\t\tlightsHash.hemiLength !== lightsStateHash.hemiLength ||\r\n\t\t\t\tlightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) {\r\n\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\r\n\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\r\n\t\t\t\tmaterialProperties.numIntersection !== _clipping.numIntersection ) ) {\r\n\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.needsUpdate ) {\r\n\r\n\t\t\tinitMaterial( material, fog, object );\r\n\t\t\tmaterial.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar refreshProgram = false;\r\n\t\tvar refreshMaterial = false;\r\n\t\tvar refreshLights = false;\r\n\r\n\t\tvar program = materialProperties.program,\r\n\t\t\tp_uniforms = program.getUniforms(),\r\n\t\t\tm_uniforms = materialProperties.shader.uniforms;\r\n\r\n\t\tif ( state.useProgram( program.program ) ) {\r\n\r\n\t\t\trefreshProgram = true;\r\n\t\t\trefreshMaterial = true;\r\n\t\t\trefreshLights = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.id !== _currentMaterialId ) {\r\n\r\n\t\t\t_currentMaterialId = material.id;\r\n\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshProgram || _currentCamera !== camera ) {\r\n\r\n\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\r\n\r\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\r\n\r\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\r\n\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _currentCamera !== camera ) {\r\n\r\n\t\t\t\t_currentCamera = camera;\r\n\r\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\r\n\t\t\t\t// now, in case this material supports lights - or later, when\r\n\t\t\t\t// the next material that does gets activated:\r\n\r\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\r\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load material specific uniforms\r\n\t\t\t// (shader material also gets them for the sake of genericity)\r\n\r\n\t\t\tif ( material.isShaderMaterial ||\r\n\t\t\t\tmaterial.isMeshPhongMaterial ||\r\n\t\t\t\tmaterial.isMeshStandardMaterial ||\r\n\t\t\t\tmaterial.envMap ) {\r\n\r\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\r\n\r\n\t\t\t\tif ( uCamPos !== undefined ) {\r\n\r\n\t\t\t\t\tuCamPos.setValue( _gl,\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.isMeshPhongMaterial ||\r\n\t\t\t\tmaterial.isMeshLambertMaterial ||\r\n\t\t\t\tmaterial.isMeshBasicMaterial ||\r\n\t\t\t\tmaterial.isMeshStandardMaterial ||\r\n\t\t\t\tmaterial.isShaderMaterial ||\r\n\t\t\t\tmaterial.skinning ) {\r\n\r\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t// not sure why, but otherwise weird things happen\r\n\r\n\t\tif ( material.skinning ) {\r\n\r\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\r\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\r\n\r\n\t\t\tvar skeleton = object.skeleton;\r\n\r\n\t\t\tif ( skeleton ) {\r\n\r\n\t\t\t\tvar bones = skeleton.bones;\r\n\r\n\t\t\t\tif ( capabilities.floatVertexTextures ) {\r\n\r\n\t\t\t\t\tif ( skeleton.boneTexture === undefined ) {\r\n\r\n\t\t\t\t\t\t// layout (1 matrix = 4 pixels)\r\n\t\t\t\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t\t\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n\t\t\t\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n\t\t\t\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n\t\t\t\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n\r\n\t\t\t\t\t\tvar size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\r\n\t\t\t\t\t\tsize = _Math.ceilPowerOfTwo( size );\r\n\t\t\t\t\t\tsize = Math.max( size, 4 );\r\n\r\n\t\t\t\t\t\tvar boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\r\n\t\t\t\t\t\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\r\n\r\n\t\t\t\t\t\tvar boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\r\n\t\t\t\t\t\tboneTexture.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tskeleton.boneMatrices = boneMatrices;\r\n\t\t\t\t\t\tskeleton.boneTexture = boneTexture;\r\n\t\t\t\t\t\tskeleton.boneTextureSize = size;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );\r\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial ) {\r\n\r\n\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\r\n\t\t\tp_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );\r\n\r\n\t\t\tif ( material.lights ) {\r\n\r\n\t\t\t\t// the current material requires lighting info\r\n\r\n\t\t\t\t// note: all lighting uniforms are always set correctly\r\n\t\t\t\t// they simply reference the renderer's state for their\r\n\t\t\t\t// values\r\n\t\t\t\t//\r\n\t\t\t\t// use the current material's .needsUpdate flags to set\r\n\t\t\t\t// the GL state when required\r\n\r\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh uniforms common to several materials\r\n\r\n\t\t\tif ( fog && material.fog ) {\r\n\r\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.isMeshBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material.isMeshLambertMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material.isMeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t\tif ( material.isMeshToonMaterial ) {\r\n\r\n\t\t\t\t\trefreshUniformsToon( m_uniforms, material );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material.isMeshStandardMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t\tif ( material.isMeshPhysicalMaterial ) {\r\n\r\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material.isMeshDepthMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\t\t\t\trefreshUniformsDepth( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material.isMeshDistanceMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\t\t\t\trefreshUniformsDistance( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material.isMeshNormalMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\t\t\t\trefreshUniformsNormal( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material.isLineBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\r\n\t\t\t\tif ( material.isLineDashedMaterial ) {\r\n\r\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material.isPointsMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material.isSpriteMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsSprites( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material.isShadowMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.color.value = material.color;\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// RectAreaLight Texture\r\n\t\t\t// TODO (mrdoob): Find a nicer implementation\r\n\r\n\t\t\tif ( m_uniforms.ltc_1 !== undefined ) { m_uniforms.ltc_1.value = UniformsLib.LTC_1; }\r\n\t\t\tif ( m_uniforms.ltc_2 !== undefined ) { m_uniforms.ltc_2.value = UniformsLib.LTC_2; }\r\n\r\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\r\n\r\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );\r\n\t\t\tmaterial.uniformsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.isSpriteMaterial ) {\r\n\r\n\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\r\n\r\n\t\t}\r\n\r\n\t\t// common matrices\r\n\r\n\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\r\n\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\r\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\t// Uniforms (refresh uniforms objects)\r\n\r\n\tfunction refreshUniformsCommon( uniforms, material ) {\r\n\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t\tif ( material.color ) {\r\n\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissive ) {\r\n\r\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tuniforms.map.value = material.map;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.alphaMap ) {\r\n\r\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.specularMap ) {\r\n\r\n\t\t\tuniforms.specularMap.value = material.specularMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.envMap ) {\r\n\r\n\t\t\tuniforms.envMap.value = material.envMap;\r\n\r\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\r\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\r\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\r\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\r\n\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\r\n\r\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\r\n\t\t\tuniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.lightMap ) {\r\n\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.aoMap ) {\r\n\r\n\t\t\tuniforms.aoMap.value = material.aoMap;\r\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\t// uv repeat and offset setting priorities\r\n\t\t// 1. color map\r\n\t\t// 2. specular map\r\n\t\t// 3. normal map\r\n\t\t// 4. bump map\r\n\t\t// 5. alpha map\r\n\t\t// 6. emissive map\r\n\r\n\t\tvar uvScaleMap;\r\n\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tuvScaleMap = material.map;\r\n\r\n\t\t} else if ( material.specularMap ) {\r\n\r\n\t\t\tuvScaleMap = material.specularMap;\r\n\r\n\t\t} else if ( material.displacementMap ) {\r\n\r\n\t\t\tuvScaleMap = material.displacementMap;\r\n\r\n\t\t} else if ( material.normalMap ) {\r\n\r\n\t\t\tuvScaleMap = material.normalMap;\r\n\r\n\t\t} else if ( material.bumpMap ) {\r\n\r\n\t\t\tuvScaleMap = material.bumpMap;\r\n\r\n\t\t} else if ( material.roughnessMap ) {\r\n\r\n\t\t\tuvScaleMap = material.roughnessMap;\r\n\r\n\t\t} else if ( material.metalnessMap ) {\r\n\r\n\t\t\tuvScaleMap = material.metalnessMap;\r\n\r\n\t\t} else if ( material.alphaMap ) {\r\n\r\n\t\t\tuvScaleMap = material.alphaMap;\r\n\r\n\t\t} else if ( material.emissiveMap ) {\r\n\r\n\t\t\tuvScaleMap = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvScaleMap !== undefined ) {\r\n\r\n\t\t\t// backwards compatibility\r\n\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\r\n\r\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\r\n\r\n\t\t\t\tuvScaleMap.updateMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLine( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsDash( uniforms, material ) {\r\n\r\n\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\tuniforms.scale.value = material.scale;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPoints( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\t\tuniforms.size.value = material.size * _pixelRatio;\r\n\t\tuniforms.scale.value = _height * 0.5;\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\r\n\t\tif ( material.map !== null ) {\r\n\r\n\t\t\tif ( material.map.matrixAutoUpdate === true ) {\r\n\r\n\t\t\t\tmaterial.map.updateMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuniforms.uvTransform.value.copy( material.map.matrix );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsSprites( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\t\tuniforms.rotation.value = material.rotation;\r\n\t\tuniforms.map.value = material.map;\r\n\r\n\t\tif ( material.map !== null ) {\r\n\r\n\t\t\tif ( material.map.matrixAutoUpdate === true ) {\r\n\r\n\t\t\t\tmaterial.map.updateMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuniforms.uvTransform.value.copy( material.map.matrix );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsFog( uniforms, fog ) {\r\n\r\n\t\tuniforms.fogColor.value = fog.color;\r\n\r\n\t\tif ( fog.isFog ) {\r\n\r\n\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\tuniforms.fogFar.value = fog.far;\r\n\r\n\t\t} else if ( fog.isFogExp2 ) {\r\n\r\n\t\t\tuniforms.fogDensity.value = fog.density;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLambert( uniforms, material ) {\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPhong( uniforms, material ) {\r\n\r\n\t\tuniforms.specular.value = material.specular;\r\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\t\tif ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\t\tif ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsToon( uniforms, material ) {\r\n\r\n\t\trefreshUniformsPhong( uniforms, material );\r\n\r\n\t\tif ( material.gradientMap ) {\r\n\r\n\t\t\tuniforms.gradientMap.value = material.gradientMap;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsStandard( uniforms, material ) {\r\n\r\n\t\tuniforms.roughness.value = material.roughness;\r\n\t\tuniforms.metalness.value = material.metalness;\r\n\r\n\t\tif ( material.roughnessMap ) {\r\n\r\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.metalnessMap ) {\r\n\r\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\t\tif ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\t\tif ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.envMap ) {\r\n\r\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\r\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPhysical( uniforms, material ) {\r\n\r\n\t\trefreshUniformsStandard( uniforms, material );\r\n\r\n\t\tuniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\r\n\r\n\t\tuniforms.clearCoat.value = material.clearCoat;\r\n\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsDepth( uniforms, material ) {\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsDistance( uniforms, material ) {\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.referencePosition.value.copy( material.referencePosition );\r\n\t\tuniforms.nearDistance.value = material.nearDistance;\r\n\t\tuniforms.farDistance.value = material.farDistance;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsNormal( uniforms, material ) {\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\t\tif ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\t\tif ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\r\n\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\r\n\r\n\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\r\n\t\tuniforms.directionalLights.needsUpdate = value;\r\n\t\tuniforms.pointLights.needsUpdate = value;\r\n\t\tuniforms.spotLights.needsUpdate = value;\r\n\t\tuniforms.rectAreaLights.needsUpdate = value;\r\n\t\tuniforms.hemisphereLights.needsUpdate = value;\r\n\r\n\t}\r\n\r\n\t// Textures\r\n\r\n\tfunction allocTextureUnit() {\r\n\r\n\t\tvar textureUnit = _usedTextureUnits;\r\n\r\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\r\n\r\n\t\t\tconsole.warn( 'WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\r\n\r\n\t\t}\r\n\r\n\t\t_usedTextureUnits += 1;\r\n\r\n\t\treturn textureUnit;\r\n\r\n\t}\r\n\r\n\tthis.allocTextureUnit = allocTextureUnit;\r\n\r\n\t// this.setTexture2D = setTexture2D;\r\n\tthis.setTexture2D = ( function () {\r\n\r\n\t\tvar warned = false;\r\n\r\n\t\t// backwards compatibility: peel texture.texture\r\n\t\treturn function setTexture2D( texture, slot ) {\r\n\r\n\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\r\n\r\n\t\t\t\tif ( ! warned ) {\r\n\r\n\t\t\t\t\tconsole.warn( \"WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\r\n\t\t\t\t\twarned = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture = texture.texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttextures.setTexture2D( texture, slot );\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tthis.setTexture = ( function () {\r\n\r\n\t\tvar warned = false;\r\n\r\n\t\treturn function setTexture( texture, slot ) {\r\n\r\n\t\t\tif ( ! warned ) {\r\n\r\n\t\t\t\tconsole.warn( \"WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\r\n\t\t\t\twarned = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttextures.setTexture2D( texture, slot );\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tthis.setTextureCube = ( function () {\r\n\r\n\t\tvar warned = false;\r\n\r\n\t\treturn function setTextureCube( texture, slot ) {\r\n\r\n\t\t\t// backwards compatibility: peel texture.texture\r\n\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\r\n\r\n\t\t\t\tif ( ! warned ) {\r\n\r\n\t\t\t\t\tconsole.warn( \"WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\r\n\t\t\t\t\twarned = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture = texture.texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\r\n\t\t\t// TODO: unify these code paths\r\n\t\t\tif ( ( texture && texture.isCubeTexture ) ||\r\n\t\t\t\t( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\r\n\r\n\t\t\t\t// CompressedTexture can have Array in image :/\r\n\r\n\t\t\t\t// this function alone should take care of cube textures\r\n\t\t\t\ttextures.setTextureCube( texture, slot );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// assumed: texture property of WebGLRenderTargetCube\r\n\r\n\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\t//\r\n\r\n\tthis.setFramebuffer = function ( value ) {\r\n\r\n\t\t_framebuffer = value;\r\n\r\n\t};\r\n\r\n\tthis.getRenderTarget = function () {\r\n\r\n\t\treturn _currentRenderTarget;\r\n\r\n\t};\r\n\r\n\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\t_currentRenderTarget = renderTarget;\r\n\r\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\r\n\r\n\t\t\ttextures.setupRenderTarget( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\tvar framebuffer = _framebuffer;\r\n\t\tvar isCube = false;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tvar __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\r\n\t\t\tif ( renderTarget.isWebGLRenderTargetCube ) {\r\n\r\n\t\t\t\tframebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\t\t\t\tisCube = true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tframebuffer = __webglFramebuffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_currentViewport.copy( renderTarget.viewport );\r\n\t\t\t_currentScissor.copy( renderTarget.scissor );\r\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\r\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\r\n\t\t\t_currentScissorTest = _scissorTest;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _currentFramebuffer !== framebuffer ) {\r\n\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_currentFramebuffer = framebuffer;\r\n\r\n\t\t}\r\n\r\n\t\tstate.viewport( _currentViewport );\r\n\t\tstate.scissor( _currentScissor );\r\n\t\tstate.setScissorTest( _currentScissorTest );\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\r\n\r\n\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\r\n\r\n\t\t\tconsole.error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not WebGLRenderTarget.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\r\n\t\tif ( framebuffer ) {\r\n\r\n\t\t\tvar restore = false;\r\n\r\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n\t\t\t\trestore = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tvar texture = renderTarget.texture;\r\n\t\t\t\tvar textureFormat = texture.format;\r\n\t\t\t\tvar textureType = texture.type;\r\n\r\n\t\t\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\r\n\t\t\t\t\t! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\r\n\t\t\t\t\t! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\r\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\r\n\r\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\r\n\r\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( 'WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} finally {\r\n\r\n\t\t\t\tif ( restore ) {\r\n\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.copyFramebufferToTexture = function ( position, texture, level ) {\r\n\r\n\t\tvar width = texture.image.width;\r\n\t\tvar height = texture.image.height;\r\n\t\tvar glFormat = utils.convert( texture.format );\r\n\r\n\t\tthis.setTexture2D( texture, 0 );\r\n\r\n\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0 );\r\n\r\n\t};\r\n\r\n\tthis.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {\r\n\r\n\t\tvar width = srcTexture.image.width;\r\n\t\tvar height = srcTexture.image.height;\r\n\t\tvar glFormat = utils.convert( dstTexture.format );\r\n\t\tvar glType = utils.convert( dstTexture.type );\r\n\r\n\t\tthis.setTexture2D( dstTexture, 0 );\r\n\r\n\t\tif ( srcTexture.isDataTexture ) {\r\n\r\n\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Uniform( value ) {\r\n\r\n\tif ( typeof value === 'string' ) {\r\n\r\n\t\tconsole.warn( 'Uniform: Type parameter is no longer needed.' );\r\n\t\tvalue = arguments[ 1 ];\r\n\r\n\t}\r\n\r\n\tthis.value = value;\r\n\r\n}\r\n\r\nUniform.prototype.clone = function () {\r\n\r\n\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar FXAAShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":   { value: null },\r\n\t\t\"resolution\": { value: new Vector2( 1 / 1024, 1 / 512 ) }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n        \"precision highp float;\",\r\n        \"\",\r\n        \"uniform sampler2D tDiffuse;\",\r\n        \"\",\r\n        \"uniform vec2 resolution;\",\r\n        \"\",\r\n        \"varying vec2 vUv;\",\r\n        \"\",\r\n        \"// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\",\r\n        \"\",\r\n        \"//----------------------------------------------------------------------------------\",\r\n        \"// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag\",\r\n        \"// SDK Version: v3.00\",\r\n        \"// Email:       gameworks@nvidia.com\",\r\n        \"// Site:        http://developer.nvidia.com/\",\r\n        \"//\",\r\n        \"// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\",\r\n        \"//\",\r\n        \"// Redistribution and use in source and binary forms, with or without\",\r\n        \"// modification, are permitted provided that the following conditions\",\r\n        \"// are met:\",\r\n        \"//  * Redistributions of source code must retain the above copyright\",\r\n        \"//    notice, this list of conditions and the following disclaimer.\",\r\n        \"//  * Redistributions in binary form must reproduce the above copyright\",\r\n        \"//    notice, this list of conditions and the following disclaimer in the\",\r\n        \"//    documentation and/or other materials provided with the distribution.\",\r\n        \"//  * Neither the name of NVIDIA CORPORATION nor the names of its\",\r\n        \"//    contributors may be used to endorse or promote products derived\",\r\n        \"//    from this software without specific prior written permission.\",\r\n        \"//\",\r\n        \"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\",\r\n        \"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\",\r\n        \"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\",\r\n        \"// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\",\r\n        \"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\",\r\n        \"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\",\r\n        \"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\",\r\n        \"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\",\r\n        \"// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\",\r\n        \"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\",\r\n        \"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\",\r\n        \"//\",\r\n        \"//----------------------------------------------------------------------------------\",\r\n        \"\",\r\n        \"#define FXAA_PC 1\",\r\n        \"#define FXAA_GLSL_100 1\",\r\n        \"#define FXAA_QUALITY_PRESET 12\",\r\n        \"\",\r\n        \"#define FXAA_GREEN_AS_LUMA 1\",\r\n        \"\",\r\n        \"\",\r\n        \"#ifndef FXAA_PC_CONSOLE\",\r\n        \"    //\",\r\n        \"    // The console algorithm for PC is included\",\r\n        \"    // for developers targeting really low spec machines.\",\r\n        \"    // Likely better to just run FXAA_PC, and use a really low preset.\",\r\n        \"    //\",\r\n        \"    #define FXAA_PC_CONSOLE 0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#ifndef FXAA_GLSL_120\",\r\n        \"    #define FXAA_GLSL_120 0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#ifndef FXAA_GLSL_130\",\r\n        \"    #define FXAA_GLSL_130 0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#ifndef FXAA_HLSL_3\",\r\n        \"    #define FXAA_HLSL_3 0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#ifndef FXAA_HLSL_4\",\r\n        \"    #define FXAA_HLSL_4 0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#ifndef FXAA_HLSL_5\",\r\n        \"    #define FXAA_HLSL_5 0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#ifndef FXAA_GREEN_AS_LUMA\",\r\n        \"    //\",\r\n        \"    // For those using non-linear color,\",\r\n        \"    // and either not able to get luma in alpha, or not wanting to,\",\r\n        \"    // this enables FXAA to run using green as a proxy for luma.\",\r\n        \"    // So with this enabled, no need to pack luma in alpha.\",\r\n        \"    //\",\r\n        \"    // This will turn off AA on anything which lacks some amount of green.\",\r\n        \"    // Pure red and blue or combination of only R and B, will get no AA.\",\r\n        \"    //\",\r\n        \"    // Might want to lower the settings for both,\",\r\n        \"    //    fxaaConsoleEdgeThresholdMin\",\r\n        \"    //    fxaaQualityEdgeThresholdMin\",\r\n        \"    // In order to insure AA does not get turned off on colors\",\r\n        \"    // which contain a minor amount of green.\",\r\n        \"    //\",\r\n        \"    // 1 = On.\",\r\n        \"    // 0 = Off.\",\r\n        \"    //\",\r\n        \"    #define FXAA_GREEN_AS_LUMA 0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#ifndef FXAA_EARLY_EXIT\",\r\n        \"    //\",\r\n        \"    // Controls algorithm's early exit path.\",\r\n        \"    // On PS3 turning this ON adds 2 cycles to the shader.\",\r\n        \"    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\",\r\n        \"    // Turning this off on console will result in a more blurry image.\",\r\n        \"    // So this defaults to on.\",\r\n        \"    //\",\r\n        \"    // 1 = On.\",\r\n        \"    // 0 = Off.\",\r\n        \"    //\",\r\n        \"    #define FXAA_EARLY_EXIT 1\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#ifndef FXAA_DISCARD\",\r\n        \"    //\",\r\n        \"    // Only valid for PC OpenGL currently.\",\r\n        \"    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\",\r\n        \"    //\",\r\n        \"    // 1 = Use discard on pixels which don't need AA.\",\r\n        \"    //     For APIs which enable concurrent TEX+ROP from same surface.\",\r\n        \"    // 0 = Return unchanged color on pixels which don't need AA.\",\r\n        \"    //\",\r\n        \"    #define FXAA_DISCARD 0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#ifndef FXAA_FAST_PIXEL_OFFSET\",\r\n        \"    //\",\r\n        \"    // Used for GLSL 120 only.\",\r\n        \"    //\",\r\n        \"    // 1 = GL API supports fast pixel offsets\",\r\n        \"    // 0 = do not use fast pixel offsets\",\r\n        \"    //\",\r\n        \"    #ifdef GL_EXT_gpu_shader4\",\r\n        \"        #define FXAA_FAST_PIXEL_OFFSET 1\",\r\n        \"    #endif\",\r\n        \"    #ifdef GL_NV_gpu_shader5\",\r\n        \"        #define FXAA_FAST_PIXEL_OFFSET 1\",\r\n        \"    #endif\",\r\n        \"    #ifdef GL_ARB_gpu_shader5\",\r\n        \"        #define FXAA_FAST_PIXEL_OFFSET 1\",\r\n        \"    #endif\",\r\n        \"    #ifndef FXAA_FAST_PIXEL_OFFSET\",\r\n        \"        #define FXAA_FAST_PIXEL_OFFSET 0\",\r\n        \"    #endif\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#ifndef FXAA_GATHER4_ALPHA\",\r\n        \"    //\",\r\n        \"    // 1 = API supports gather4 on alpha channel.\",\r\n        \"    // 0 = API does not support gather4 on alpha channel.\",\r\n        \"    //\",\r\n        \"    #if (FXAA_HLSL_5 == 1)\",\r\n        \"        #define FXAA_GATHER4_ALPHA 1\",\r\n        \"    #endif\",\r\n        \"    #ifdef GL_ARB_gpu_shader5\",\r\n        \"        #define FXAA_GATHER4_ALPHA 1\",\r\n        \"    #endif\",\r\n        \"    #ifdef GL_NV_gpu_shader5\",\r\n        \"        #define FXAA_GATHER4_ALPHA 1\",\r\n        \"    #endif\",\r\n        \"    #ifndef FXAA_GATHER4_ALPHA\",\r\n        \"        #define FXAA_GATHER4_ALPHA 0\",\r\n        \"    #endif\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"\",\r\n        \"\",\r\n        \"#ifndef FXAA_QUALITY_PRESET\",\r\n        \"    //\",\r\n        \"    // Choose the quality preset.\",\r\n        \"    // This needs to be compiled into the shader as it effects code.\",\r\n        \"    // Best option to include multiple presets is to\",\r\n        \"    // in each shader define the preset, then include this file.\",\r\n        \"    //\",\r\n        \"    // OPTIONS\",\r\n        \"    // -----------------------------------------------------------------------\",\r\n        \"    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\",\r\n        \"    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\",\r\n        \"    // 39       - no dither, very expensive\",\r\n        \"    //\",\r\n        \"    // NOTES\",\r\n        \"    // -----------------------------------------------------------------------\",\r\n        \"    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\",\r\n        \"    // 13 = about same speed as FXAA 3.9 and better than 12\",\r\n        \"    // 23 = closest to FXAA 3.9 visually and performance wise\",\r\n        \"    //  _ = the lowest digit is directly related to performance\",\r\n        \"    // _  = the highest digit is directly related to style\",\r\n        \"    //\",\r\n        \"    #define FXAA_QUALITY_PRESET 12\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"\",\r\n        \"\",\r\n        \"\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 10)\",\r\n        \"    #define FXAA_QUALITY_PS 3\",\r\n        \"    #define FXAA_QUALITY_P0 1.5\",\r\n        \"    #define FXAA_QUALITY_P1 3.0\",\r\n        \"    #define FXAA_QUALITY_P2 12.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 11)\",\r\n        \"    #define FXAA_QUALITY_PS 4\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 3.0\",\r\n        \"    #define FXAA_QUALITY_P3 12.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 12)\",\r\n        \"    #define FXAA_QUALITY_PS 5\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 4.0\",\r\n        \"    #define FXAA_QUALITY_P4 12.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 13)\",\r\n        \"    #define FXAA_QUALITY_PS 6\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 4.0\",\r\n        \"    #define FXAA_QUALITY_P5 12.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 14)\",\r\n        \"    #define FXAA_QUALITY_PS 7\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 2.0\",\r\n        \"    #define FXAA_QUALITY_P5 4.0\",\r\n        \"    #define FXAA_QUALITY_P6 12.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 15)\",\r\n        \"    #define FXAA_QUALITY_PS 8\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 2.0\",\r\n        \"    #define FXAA_QUALITY_P5 2.0\",\r\n        \"    #define FXAA_QUALITY_P6 4.0\",\r\n        \"    #define FXAA_QUALITY_P7 12.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 20)\",\r\n        \"    #define FXAA_QUALITY_PS 3\",\r\n        \"    #define FXAA_QUALITY_P0 1.5\",\r\n        \"    #define FXAA_QUALITY_P1 2.0\",\r\n        \"    #define FXAA_QUALITY_P2 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 21)\",\r\n        \"    #define FXAA_QUALITY_PS 4\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 22)\",\r\n        \"    #define FXAA_QUALITY_PS 5\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 23)\",\r\n        \"    #define FXAA_QUALITY_PS 6\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 2.0\",\r\n        \"    #define FXAA_QUALITY_P5 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 24)\",\r\n        \"    #define FXAA_QUALITY_PS 7\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 2.0\",\r\n        \"    #define FXAA_QUALITY_P5 3.0\",\r\n        \"    #define FXAA_QUALITY_P6 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 25)\",\r\n        \"    #define FXAA_QUALITY_PS 8\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 2.0\",\r\n        \"    #define FXAA_QUALITY_P5 2.0\",\r\n        \"    #define FXAA_QUALITY_P6 4.0\",\r\n        \"    #define FXAA_QUALITY_P7 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 26)\",\r\n        \"    #define FXAA_QUALITY_PS 9\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 2.0\",\r\n        \"    #define FXAA_QUALITY_P5 2.0\",\r\n        \"    #define FXAA_QUALITY_P6 2.0\",\r\n        \"    #define FXAA_QUALITY_P7 4.0\",\r\n        \"    #define FXAA_QUALITY_P8 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 27)\",\r\n        \"    #define FXAA_QUALITY_PS 10\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 2.0\",\r\n        \"    #define FXAA_QUALITY_P5 2.0\",\r\n        \"    #define FXAA_QUALITY_P6 2.0\",\r\n        \"    #define FXAA_QUALITY_P7 2.0\",\r\n        \"    #define FXAA_QUALITY_P8 4.0\",\r\n        \"    #define FXAA_QUALITY_P9 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 28)\",\r\n        \"    #define FXAA_QUALITY_PS 11\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 2.0\",\r\n        \"    #define FXAA_QUALITY_P5 2.0\",\r\n        \"    #define FXAA_QUALITY_P6 2.0\",\r\n        \"    #define FXAA_QUALITY_P7 2.0\",\r\n        \"    #define FXAA_QUALITY_P8 2.0\",\r\n        \"    #define FXAA_QUALITY_P9 4.0\",\r\n        \"    #define FXAA_QUALITY_P10 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 29)\",\r\n        \"    #define FXAA_QUALITY_PS 12\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.5\",\r\n        \"    #define FXAA_QUALITY_P2 2.0\",\r\n        \"    #define FXAA_QUALITY_P3 2.0\",\r\n        \"    #define FXAA_QUALITY_P4 2.0\",\r\n        \"    #define FXAA_QUALITY_P5 2.0\",\r\n        \"    #define FXAA_QUALITY_P6 2.0\",\r\n        \"    #define FXAA_QUALITY_P7 2.0\",\r\n        \"    #define FXAA_QUALITY_P8 2.0\",\r\n        \"    #define FXAA_QUALITY_P9 2.0\",\r\n        \"    #define FXAA_QUALITY_P10 4.0\",\r\n        \"    #define FXAA_QUALITY_P11 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"\",\r\n        \"#if (FXAA_QUALITY_PRESET == 39)\",\r\n        \"    #define FXAA_QUALITY_PS 12\",\r\n        \"    #define FXAA_QUALITY_P0 1.0\",\r\n        \"    #define FXAA_QUALITY_P1 1.0\",\r\n        \"    #define FXAA_QUALITY_P2 1.0\",\r\n        \"    #define FXAA_QUALITY_P3 1.0\",\r\n        \"    #define FXAA_QUALITY_P4 1.0\",\r\n        \"    #define FXAA_QUALITY_P5 1.5\",\r\n        \"    #define FXAA_QUALITY_P6 2.0\",\r\n        \"    #define FXAA_QUALITY_P7 2.0\",\r\n        \"    #define FXAA_QUALITY_P8 2.0\",\r\n        \"    #define FXAA_QUALITY_P9 2.0\",\r\n        \"    #define FXAA_QUALITY_P10 4.0\",\r\n        \"    #define FXAA_QUALITY_P11 8.0\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"\",\r\n        \"\",\r\n        \"\",\r\n        \"#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\",\r\n        \"    #define FxaaBool bool\",\r\n        \"    #define FxaaDiscard discard\",\r\n        \"    #define FxaaFloat float\",\r\n        \"    #define FxaaFloat2 vec2\",\r\n        \"    #define FxaaFloat3 vec3\",\r\n        \"    #define FxaaFloat4 vec4\",\r\n        \"    #define FxaaHalf float\",\r\n        \"    #define FxaaHalf2 vec2\",\r\n        \"    #define FxaaHalf3 vec3\",\r\n        \"    #define FxaaHalf4 vec4\",\r\n        \"    #define FxaaInt2 ivec2\",\r\n        \"    #define FxaaSat(x) clamp(x, 0.0, 1.0)\",\r\n        \"    #define FxaaTex sampler2D\",\r\n        \"#else\",\r\n        \"    #define FxaaBool bool\",\r\n        \"    #define FxaaDiscard clip(-1)\",\r\n        \"    #define FxaaFloat float\",\r\n        \"    #define FxaaFloat2 float2\",\r\n        \"    #define FxaaFloat3 float3\",\r\n        \"    #define FxaaFloat4 float4\",\r\n        \"    #define FxaaHalf half\",\r\n        \"    #define FxaaHalf2 half2\",\r\n        \"    #define FxaaHalf3 half3\",\r\n        \"    #define FxaaHalf4 half4\",\r\n        \"    #define FxaaSat(x) saturate(x)\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_GLSL_100 == 1)\",\r\n        \"  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\",\r\n        \"  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_GLSL_120 == 1)\",\r\n        \"    // Requires,\",\r\n        \"    //  #version 120\",\r\n        \"    // And at least,\",\r\n        \"    //  #extension GL_EXT_gpu_shader4 : enable\",\r\n        \"    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\",\r\n        \"    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\",\r\n        \"    #if (FXAA_FAST_PIXEL_OFFSET == 1)\",\r\n        \"        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\",\r\n        \"    #else\",\r\n        \"        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\",\r\n        \"    #endif\",\r\n        \"    #if (FXAA_GATHER4_ALPHA == 1)\",\r\n        \"        // use #extension GL_ARB_gpu_shader5 : enable\",\r\n        \"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\",\r\n        \"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\",\r\n        \"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\",\r\n        \"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\",\r\n        \"    #endif\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_GLSL_130 == 1)\",\r\n        \"    // Requires \\\"#version 130\\\" or better\",\r\n        \"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\",\r\n        \"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\",\r\n        \"    #if (FXAA_GATHER4_ALPHA == 1)\",\r\n        \"        // use #extension GL_ARB_gpu_shader5 : enable\",\r\n        \"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\",\r\n        \"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\",\r\n        \"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\",\r\n        \"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\",\r\n        \"    #endif\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_HLSL_3 == 1)\",\r\n        \"    #define FxaaInt2 float2\",\r\n        \"    #define FxaaTex sampler2D\",\r\n        \"    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\",\r\n        \"    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_HLSL_4 == 1)\",\r\n        \"    #define FxaaInt2 int2\",\r\n        \"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\",\r\n        \"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\",\r\n        \"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"#if (FXAA_HLSL_5 == 1)\",\r\n        \"    #define FxaaInt2 int2\",\r\n        \"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\",\r\n        \"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\",\r\n        \"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\",\r\n        \"    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\",\r\n        \"    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\",\r\n        \"    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\",\r\n        \"    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"\",\r\n        \"\",\r\n        \"#if (FXAA_GREEN_AS_LUMA == 0)\",\r\n        \"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\",\r\n        \"#else\",\r\n        \"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"\",\r\n        \"\",\r\n        \"\",\r\n        \"\",\r\n        \"#if (FXAA_PC == 1)\",\r\n        \"\",\r\n        \"FxaaFloat4 FxaaPixelShader(\",\r\n        \"    //\",\r\n        \"    // Use noperspective interpolation here (turn off perspective interpolation).\",\r\n        \"    // {xy} = center of pixel\",\r\n        \"    FxaaFloat2 pos,\",\r\n        \"    //\",\r\n        \"    // Used only for FXAA Console, and not used on the 360 version.\",\r\n        \"    // Use noperspective interpolation here (turn off perspective interpolation).\",\r\n        \"    // {xy_} = upper left of pixel\",\r\n        \"    // {_zw} = lower right of pixel\",\r\n        \"    FxaaFloat4 fxaaConsolePosPos,\",\r\n        \"    //\",\r\n        \"    // Input color texture.\",\r\n        \"    // {rgb_} = color in linear or perceptual color space\",\r\n        \"    // if (FXAA_GREEN_AS_LUMA == 0)\",\r\n        \"    //     {__a} = luma in perceptual color space (not linear)\",\r\n        \"    FxaaTex tex,\",\r\n        \"    //\",\r\n        \"    // Only used on the optimized 360 version of FXAA Console.\",\r\n        \"    // For everything but 360, just use the same input here as for \\\"tex\\\".\",\r\n        \"    // For 360, same texture, just alias with a 2nd sampler.\",\r\n        \"    // This sampler needs to have an exponent bias of -1.\",\r\n        \"    FxaaTex fxaaConsole360TexExpBiasNegOne,\",\r\n        \"    //\",\r\n        \"    // Only used on the optimized 360 version of FXAA Console.\",\r\n        \"    // For everything but 360, just use the same input here as for \\\"tex\\\".\",\r\n        \"    // For 360, same texture, just alias with a 3nd sampler.\",\r\n        \"    // This sampler needs to have an exponent bias of -2.\",\r\n        \"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\",\r\n        \"    //\",\r\n        \"    // Only used on FXAA Quality.\",\r\n        \"    // This must be from a constant/uniform.\",\r\n        \"    // {x_} = 1.0/screenWidthInPixels\",\r\n        \"    // {_y} = 1.0/screenHeightInPixels\",\r\n        \"    FxaaFloat2 fxaaQualityRcpFrame,\",\r\n        \"    //\",\r\n        \"    // Only used on FXAA Console.\",\r\n        \"    // This must be from a constant/uniform.\",\r\n        \"    // This effects sub-pixel AA quality and inversely sharpness.\",\r\n        \"    //   Where N ranges between,\",\r\n        \"    //     N = 0.50 (default)\",\r\n        \"    //     N = 0.33 (sharper)\",\r\n        \"    // {x__} = -N/screenWidthInPixels\",\r\n        \"    // {_y_} = -N/screenHeightInPixels\",\r\n        \"    // {_z_} =  N/screenWidthInPixels\",\r\n        \"    // {__w} =  N/screenHeightInPixels\",\r\n        \"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\",\r\n        \"    //\",\r\n        \"    // Only used on FXAA Console.\",\r\n        \"    // Not used on 360, but used on PS3 and PC.\",\r\n        \"    // This must be from a constant/uniform.\",\r\n        \"    // {x__} = -2.0/screenWidthInPixels\",\r\n        \"    // {_y_} = -2.0/screenHeightInPixels\",\r\n        \"    // {_z_} =  2.0/screenWidthInPixels\",\r\n        \"    // {__w} =  2.0/screenHeightInPixels\",\r\n        \"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\",\r\n        \"    //\",\r\n        \"    // Only used on FXAA Console.\",\r\n        \"    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\",\r\n        \"    // This must be from a constant/uniform.\",\r\n        \"    // {x__} =  8.0/screenWidthInPixels\",\r\n        \"    // {_y_} =  8.0/screenHeightInPixels\",\r\n        \"    // {_z_} = -4.0/screenWidthInPixels\",\r\n        \"    // {__w} = -4.0/screenHeightInPixels\",\r\n        \"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\",\r\n        \"    //\",\r\n        \"    // Only used on FXAA Quality.\",\r\n        \"    // This used to be the FXAA_QUALITY_SUBPIX define.\",\r\n        \"    // It is here now to allow easier tuning.\",\r\n        \"    // Choose the amount of sub-pixel aliasing removal.\",\r\n        \"    // This can effect sharpness.\",\r\n        \"    //   1.00 - upper limit (softer)\",\r\n        \"    //   0.75 - default amount of filtering\",\r\n        \"    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\",\r\n        \"    //   0.25 - almost off\",\r\n        \"    //   0.00 - completely off\",\r\n        \"    FxaaFloat fxaaQualitySubpix,\",\r\n        \"    //\",\r\n        \"    // Only used on FXAA Quality.\",\r\n        \"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\",\r\n        \"    // It is here now to allow easier tuning.\",\r\n        \"    // The minimum amount of local contrast required to apply algorithm.\",\r\n        \"    //   0.333 - too little (faster)\",\r\n        \"    //   0.250 - low quality\",\r\n        \"    //   0.166 - default\",\r\n        \"    //   0.125 - high quality\",\r\n        \"    //   0.063 - overkill (slower)\",\r\n        \"    FxaaFloat fxaaQualityEdgeThreshold,\",\r\n        \"    //\",\r\n        \"    // Only used on FXAA Quality.\",\r\n        \"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\",\r\n        \"    // It is here now to allow easier tuning.\",\r\n        \"    // Trims the algorithm from processing darks.\",\r\n        \"    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\",\r\n        \"    //   0.0625 - high quality (faster)\",\r\n        \"    //   0.0312 - visible limit (slower)\",\r\n        \"    // Special notes when using FXAA_GREEN_AS_LUMA,\",\r\n        \"    //   Likely want to set this to zero.\",\r\n        \"    //   As colors that are mostly not-green\",\r\n        \"    //   will appear very dark in the green channel!\",\r\n        \"    //   Tune by looking at mostly non-green content,\",\r\n        \"    //   then start at zero and increase until aliasing is a problem.\",\r\n        \"    FxaaFloat fxaaQualityEdgeThresholdMin,\",\r\n        \"    //\",\r\n        \"    // Only used on FXAA Console.\",\r\n        \"    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\",\r\n        \"    // It is here now to allow easier tuning.\",\r\n        \"    // This does not effect PS3, as this needs to be compiled in.\",\r\n        \"    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\",\r\n        \"    //   Due to the PS3 being ALU bound,\",\r\n        \"    //   there are only three safe values here: 2 and 4 and 8.\",\r\n        \"    //   These options use the shaders ability to a free *|/ by 2|4|8.\",\r\n        \"    // For all other platforms can be a non-power of two.\",\r\n        \"    //   8.0 is sharper (default!!!)\",\r\n        \"    //   4.0 is softer\",\r\n        \"    //   2.0 is really soft (good only for vector graphics inputs)\",\r\n        \"    FxaaFloat fxaaConsoleEdgeSharpness,\",\r\n        \"    //\",\r\n        \"    // Only used on FXAA Console.\",\r\n        \"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\",\r\n        \"    // It is here now to allow easier tuning.\",\r\n        \"    // This does not effect PS3, as this needs to be compiled in.\",\r\n        \"    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\",\r\n        \"    //   Due to the PS3 being ALU bound,\",\r\n        \"    //   there are only two safe values here: 1/4 and 1/8.\",\r\n        \"    //   These options use the shaders ability to a free *|/ by 2|4|8.\",\r\n        \"    // The console setting has a different mapping than the quality setting.\",\r\n        \"    // Other platforms can use other values.\",\r\n        \"    //   0.125 leaves less aliasing, but is softer (default!!!)\",\r\n        \"    //   0.25 leaves more aliasing, and is sharper\",\r\n        \"    FxaaFloat fxaaConsoleEdgeThreshold,\",\r\n        \"    //\",\r\n        \"    // Only used on FXAA Console.\",\r\n        \"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\",\r\n        \"    // It is here now to allow easier tuning.\",\r\n        \"    // Trims the algorithm from processing darks.\",\r\n        \"    // The console setting has a different mapping than the quality setting.\",\r\n        \"    // This only applies when FXAA_EARLY_EXIT is 1.\",\r\n        \"    // This does not apply to PS3,\",\r\n        \"    // PS3 was simplified to avoid more shader instructions.\",\r\n        \"    //   0.06 - faster but more aliasing in darks\",\r\n        \"    //   0.05 - default\",\r\n        \"    //   0.04 - slower and less aliasing in darks\",\r\n        \"    // Special notes when using FXAA_GREEN_AS_LUMA,\",\r\n        \"    //   Likely want to set this to zero.\",\r\n        \"    //   As colors that are mostly not-green\",\r\n        \"    //   will appear very dark in the green channel!\",\r\n        \"    //   Tune by looking at mostly non-green content,\",\r\n        \"    //   then start at zero and increase until aliasing is a problem.\",\r\n        \"    FxaaFloat fxaaConsoleEdgeThresholdMin,\",\r\n        \"    //\",\r\n        \"    // Extra constants for 360 FXAA Console only.\",\r\n        \"    // Use zeros or anything else for other platforms.\",\r\n        \"    // These must be in physical constant registers and NOT immediates.\",\r\n        \"    // Immediates will result in compiler un-optimizing.\",\r\n        \"    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\",\r\n        \"    FxaaFloat4 fxaaConsole360ConstDir\",\r\n        \") {\",\r\n        \"\",\r\n        \"    FxaaFloat2 posM;\",\r\n        \"    posM.x = pos.x;\",\r\n        \"    posM.y = pos.y;\",\r\n        \"    #if (FXAA_GATHER4_ALPHA == 1)\",\r\n        \"        #if (FXAA_DISCARD == 0)\",\r\n        \"            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\",\r\n        \"            #if (FXAA_GREEN_AS_LUMA == 0)\",\r\n        \"                #define lumaM rgbyM.w\",\r\n        \"            #else\",\r\n        \"                #define lumaM rgbyM.y\",\r\n        \"            #endif\",\r\n        \"        #endif\",\r\n        \"        #if (FXAA_GREEN_AS_LUMA == 0)\",\r\n        \"            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\",\r\n        \"            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\",\r\n        \"        #else\",\r\n        \"            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\",\r\n        \"            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\",\r\n        \"        #endif\",\r\n        \"        #if (FXAA_DISCARD == 1)\",\r\n        \"            #define lumaM luma4A.w\",\r\n        \"        #endif\",\r\n        \"        #define lumaE luma4A.z\",\r\n        \"        #define lumaS luma4A.x\",\r\n        \"        #define lumaSE luma4A.y\",\r\n        \"        #define lumaNW luma4B.w\",\r\n        \"        #define lumaN luma4B.z\",\r\n        \"        #define lumaW luma4B.x\",\r\n        \"    #else\",\r\n        \"        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\",\r\n        \"        #if (FXAA_GREEN_AS_LUMA == 0)\",\r\n        \"            #define lumaM rgbyM.w\",\r\n        \"        #else\",\r\n        \"            #define lumaM rgbyM.y\",\r\n        \"        #endif\",\r\n        \"        #if (FXAA_GLSL_100 == 1)\",\r\n        \"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\",\r\n        \"        #else\",\r\n        \"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\",\r\n        \"        #endif\",\r\n        \"    #endif\",\r\n        \"\",\r\n        \"    FxaaFloat maxSM = max(lumaS, lumaM);\",\r\n        \"    FxaaFloat minSM = min(lumaS, lumaM);\",\r\n        \"    FxaaFloat maxESM = max(lumaE, maxSM);\",\r\n        \"    FxaaFloat minESM = min(lumaE, minSM);\",\r\n        \"    FxaaFloat maxWN = max(lumaN, lumaW);\",\r\n        \"    FxaaFloat minWN = min(lumaN, lumaW);\",\r\n        \"    FxaaFloat rangeMax = max(maxWN, maxESM);\",\r\n        \"    FxaaFloat rangeMin = min(minWN, minESM);\",\r\n        \"    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\",\r\n        \"    FxaaFloat range = rangeMax - rangeMin;\",\r\n        \"    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\",\r\n        \"    FxaaBool earlyExit = range < rangeMaxClamped;\",\r\n        \"\",\r\n        \"    if(earlyExit)\",\r\n        \"        #if (FXAA_DISCARD == 1)\",\r\n        \"            FxaaDiscard;\",\r\n        \"        #else\",\r\n        \"            return rgbyM;\",\r\n        \"        #endif\",\r\n        \"\",\r\n        \"    #if (FXAA_GATHER4_ALPHA == 0)\",\r\n        \"        #if (FXAA_GLSL_100 == 1)\",\r\n        \"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\",\r\n        \"        #else\",\r\n        \"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\",\r\n        \"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\",\r\n        \"        #endif\",\r\n        \"    #else\",\r\n        \"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\",\r\n        \"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\",\r\n        \"    #endif\",\r\n        \"\",\r\n        \"    FxaaFloat lumaNS = lumaN + lumaS;\",\r\n        \"    FxaaFloat lumaWE = lumaW + lumaE;\",\r\n        \"    FxaaFloat subpixRcpRange = 1.0/range;\",\r\n        \"    FxaaFloat subpixNSWE = lumaNS + lumaWE;\",\r\n        \"    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\",\r\n        \"    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\",\r\n        \"\",\r\n        \"    FxaaFloat lumaNESE = lumaNE + lumaSE;\",\r\n        \"    FxaaFloat lumaNWNE = lumaNW + lumaNE;\",\r\n        \"    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\",\r\n        \"    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\",\r\n        \"\",\r\n        \"    FxaaFloat lumaNWSW = lumaNW + lumaSW;\",\r\n        \"    FxaaFloat lumaSWSE = lumaSW + lumaSE;\",\r\n        \"    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\",\r\n        \"    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\",\r\n        \"    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\",\r\n        \"    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\",\r\n        \"    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\",\r\n        \"    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\",\r\n        \"\",\r\n        \"    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\",\r\n        \"    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\",\r\n        \"    FxaaBool horzSpan = edgeHorz >= edgeVert;\",\r\n        \"    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\",\r\n        \"\",\r\n        \"    if(!horzSpan) lumaN = lumaW;\",\r\n        \"    if(!horzSpan) lumaS = lumaE;\",\r\n        \"    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\",\r\n        \"    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\",\r\n        \"\",\r\n        \"    FxaaFloat gradientN = lumaN - lumaM;\",\r\n        \"    FxaaFloat gradientS = lumaS - lumaM;\",\r\n        \"    FxaaFloat lumaNN = lumaN + lumaM;\",\r\n        \"    FxaaFloat lumaSS = lumaS + lumaM;\",\r\n        \"    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\",\r\n        \"    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\",\r\n        \"    if(pairN) lengthSign = -lengthSign;\",\r\n        \"    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\",\r\n        \"\",\r\n        \"    FxaaFloat2 posB;\",\r\n        \"    posB.x = posM.x;\",\r\n        \"    posB.y = posM.y;\",\r\n        \"    FxaaFloat2 offNP;\",\r\n        \"    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\",\r\n        \"    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\",\r\n        \"    if(!horzSpan) posB.x += lengthSign * 0.5;\",\r\n        \"    if( horzSpan) posB.y += lengthSign * 0.5;\",\r\n        \"\",\r\n        \"    FxaaFloat2 posN;\",\r\n        \"    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\",\r\n        \"    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\",\r\n        \"    FxaaFloat2 posP;\",\r\n        \"    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\",\r\n        \"    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\",\r\n        \"    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\",\r\n        \"    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\",\r\n        \"    FxaaFloat subpixE = subpixC * subpixC;\",\r\n        \"    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\",\r\n        \"\",\r\n        \"    if(!pairN) lumaNN = lumaSS;\",\r\n        \"    FxaaFloat gradientScaled = gradient * 1.0/4.0;\",\r\n        \"    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\",\r\n        \"    FxaaFloat subpixF = subpixD * subpixE;\",\r\n        \"    FxaaBool lumaMLTZero = lumaMM < 0.0;\",\r\n        \"\",\r\n        \"    lumaEndN -= lumaNN * 0.5;\",\r\n        \"    lumaEndP -= lumaNN * 0.5;\",\r\n        \"    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\",\r\n        \"    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\",\r\n        \"    FxaaBool doneNP = (!doneN) || (!doneP);\",\r\n        \"    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\",\r\n        \"    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\",\r\n        \"\",\r\n        \"    if(doneNP) {\",\r\n        \"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"        doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"        doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\",\r\n        \"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\",\r\n        \"        doneNP = (!doneN) || (!doneP);\",\r\n        \"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\",\r\n        \"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\",\r\n        \"\",\r\n        \"        #if (FXAA_QUALITY_PS > 3)\",\r\n        \"        if(doneNP) {\",\r\n        \"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"            doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"            doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\",\r\n        \"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\",\r\n        \"            doneNP = (!doneN) || (!doneP);\",\r\n        \"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\",\r\n        \"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\",\r\n        \"\",\r\n        \"            #if (FXAA_QUALITY_PS > 4)\",\r\n        \"            if(doneNP) {\",\r\n        \"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"                doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"                doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\",\r\n        \"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\",\r\n        \"                doneNP = (!doneN) || (!doneP);\",\r\n        \"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\",\r\n        \"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\",\r\n        \"\",\r\n        \"                #if (FXAA_QUALITY_PS > 5)\",\r\n        \"                if(doneNP) {\",\r\n        \"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"                    doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"                    doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\",\r\n        \"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\",\r\n        \"                    doneNP = (!doneN) || (!doneP);\",\r\n        \"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\",\r\n        \"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\",\r\n        \"\",\r\n        \"                    #if (FXAA_QUALITY_PS > 6)\",\r\n        \"                    if(doneNP) {\",\r\n        \"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"                        doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"                        doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\",\r\n        \"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\",\r\n        \"                        doneNP = (!doneN) || (!doneP);\",\r\n        \"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\",\r\n        \"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\",\r\n        \"\",\r\n        \"                        #if (FXAA_QUALITY_PS > 7)\",\r\n        \"                        if(doneNP) {\",\r\n        \"                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"                            doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"                            doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\",\r\n        \"                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\",\r\n        \"                            doneNP = (!doneN) || (!doneP);\",\r\n        \"                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\",\r\n        \"                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\",\r\n        \"\",\r\n        \"    #if (FXAA_QUALITY_PS > 8)\",\r\n        \"    if(doneNP) {\",\r\n        \"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"        doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"        doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\",\r\n        \"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\",\r\n        \"        doneNP = (!doneN) || (!doneP);\",\r\n        \"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\",\r\n        \"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\",\r\n        \"\",\r\n        \"        #if (FXAA_QUALITY_PS > 9)\",\r\n        \"        if(doneNP) {\",\r\n        \"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"            doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"            doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\",\r\n        \"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\",\r\n        \"            doneNP = (!doneN) || (!doneP);\",\r\n        \"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\",\r\n        \"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\",\r\n        \"\",\r\n        \"            #if (FXAA_QUALITY_PS > 10)\",\r\n        \"            if(doneNP) {\",\r\n        \"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"                doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"                doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\",\r\n        \"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\",\r\n        \"                doneNP = (!doneN) || (!doneP);\",\r\n        \"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\",\r\n        \"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\",\r\n        \"\",\r\n        \"                #if (FXAA_QUALITY_PS > 11)\",\r\n        \"                if(doneNP) {\",\r\n        \"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"                    doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"                    doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\",\r\n        \"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\",\r\n        \"                    doneNP = (!doneN) || (!doneP);\",\r\n        \"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\",\r\n        \"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\",\r\n        \"\",\r\n        \"                    #if (FXAA_QUALITY_PS > 12)\",\r\n        \"                    if(doneNP) {\",\r\n        \"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\r\n        \"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\r\n        \"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\r\n        \"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\r\n        \"                        doneN = abs(lumaEndN) >= gradientScaled;\",\r\n        \"                        doneP = abs(lumaEndP) >= gradientScaled;\",\r\n        \"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\",\r\n        \"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\",\r\n        \"                        doneNP = (!doneN) || (!doneP);\",\r\n        \"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\",\r\n        \"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\",\r\n        \"\",\r\n        \"                    }\",\r\n        \"                    #endif\",\r\n        \"\",\r\n        \"                }\",\r\n        \"                #endif\",\r\n        \"\",\r\n        \"            }\",\r\n        \"            #endif\",\r\n        \"\",\r\n        \"        }\",\r\n        \"        #endif\",\r\n        \"\",\r\n        \"    }\",\r\n        \"    #endif\",\r\n        \"\",\r\n        \"                        }\",\r\n        \"                        #endif\",\r\n        \"\",\r\n        \"                    }\",\r\n        \"                    #endif\",\r\n        \"\",\r\n        \"                }\",\r\n        \"                #endif\",\r\n        \"\",\r\n        \"            }\",\r\n        \"            #endif\",\r\n        \"\",\r\n        \"        }\",\r\n        \"        #endif\",\r\n        \"\",\r\n        \"    }\",\r\n        \"\",\r\n        \"    FxaaFloat dstN = posM.x - posN.x;\",\r\n        \"    FxaaFloat dstP = posP.x - posM.x;\",\r\n        \"    if(!horzSpan) dstN = posM.y - posN.y;\",\r\n        \"    if(!horzSpan) dstP = posP.y - posM.y;\",\r\n        \"\",\r\n        \"    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\",\r\n        \"    FxaaFloat spanLength = (dstP + dstN);\",\r\n        \"    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\",\r\n        \"    FxaaFloat spanLengthRcp = 1.0/spanLength;\",\r\n        \"\",\r\n        \"    FxaaBool directionN = dstN < dstP;\",\r\n        \"    FxaaFloat dst = min(dstN, dstP);\",\r\n        \"    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\",\r\n        \"    FxaaFloat subpixG = subpixF * subpixF;\",\r\n        \"    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\",\r\n        \"    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\",\r\n        \"\",\r\n        \"    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\",\r\n        \"    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\",\r\n        \"    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\",\r\n        \"    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\",\r\n        \"    #if (FXAA_DISCARD == 1)\",\r\n        \"        return FxaaTexTop(tex, posM);\",\r\n        \"    #else\",\r\n        \"        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\",\r\n        \"    #endif\",\r\n        \"}\",\r\n        \"\",\r\n        \"#endif\",\r\n        \"\",\r\n        \"void main() {\",\r\n        \"  gl_FragColor = FxaaPixelShader(\",\r\n        \"    vUv,\",\r\n        \"    vec4(0.0),\",\r\n        \"    tDiffuse,\",\r\n        \"    tDiffuse,\",\r\n        \"    tDiffuse,\",\r\n        \"    resolution,\",\r\n        \"    vec4(0.0),\",\r\n        \"    vec4(0.0),\",\r\n        \"    vec4(0.0),\",\r\n        \"    0.75,\",\r\n        \"    0.166,\",\r\n        \"    0.0833,\",\r\n        \"    0.0,\",\r\n        \"    0.0,\",\r\n        \"    0.0,\",\r\n        \"    vec4(0.0)\",\r\n        \"  );\",\r\n        \"\",\r\n        \"  // TODO avoid querying texture twice for same texel\",\r\n        \"  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\",\r\n        \"}\"\r\n\t].join(\"\\n\")\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar WebGLDeferredRenderer = function ( parameters ) {\r\n\r\n\tparameters = parameters || {};\r\n\r\n\t// private properties\r\n\r\n\tvar _this = this;\r\n\r\n\tvar _gl;\r\n\r\n\tvar _width, _height;\r\n\r\n\t// for Classic Deferred Rendering\r\n\tvar _compColor;\r\n\tvar _passColor, _passForward, _passCopy;\r\n\r\n\t// for Light Pre-Pass\r\n\tvar _compReconstruction;\r\n\tvar _passReconstruction;\r\n\r\n\t// for Common\r\n\tvar _compNormalDepth, _compLight, _compFinal;\r\n\tvar _passNormalDepth, _passLight, _passLightFullscreen, _passFinal, _passFXAA;\r\n\r\n\tvar _depthTexture;\r\n\r\n\tvar _currentCamera;\r\n\r\n\tvar _lightScene, _lightFullscreenScene;\r\n\r\n\tvar _antialias = false;\r\n\tvar _hasTransparentObject = false;\r\n\tvar _lightPrePass = false;\r\n\tvar _cacheKeepAlive = false;\r\n\r\n\tvar _tmpMaterial = new ShaderMaterial( { visible: false } );\r\n\tvar _tmpVector3 = new Vector3();\r\n\r\n\t// scene/material/light cache for deferred rendering.\r\n\t// save them at the creation and release\r\n\t// if they're unused removeThresholdCount frames\r\n\t// unless _cacheKeepAlive is true.\r\n\r\n\t// scene.uuid -> lightScene, lightFullscreenScene\r\n\tvar _lightScenesCache = {};\r\n\tvar _lightFullscreenScenesCache = {};\r\n\r\n\t// object.material.uuid -> deferredMaterial or\r\n\t// object.material[ n ].uuid -> deferredMaterial\r\n\tvar _normalDepthMaterialsCache = {};\r\n\tvar _normalDepthShininessMaterialsCache = {};\r\n\tvar _colorMaterialsCache = {};\r\n\tvar _reconstructionMaterialsCache = {};\r\n\r\n\t// originalLight.uuid -> deferredLight\r\n\tvar _deferredLightsCache = {};\r\n\r\n\t// deferredLight.uuid -> deferredLightMaterial\r\n\tvar _classicDeferredLightMaterialsCache = {};\r\n\tvar _lightPrePassMaterialsCache = {};\r\n\r\n\tvar _removeThresholdCount = 60;\r\n\r\n\t// deferredMaterials.uuid -> object.material or\r\n\t// deferredMaterials.uuid -> object.material[ n ]\r\n\t// save before render and release after render.\r\n\tvar _originalMaterialsTable = {};\r\n\r\n\t// object.uuid -> originalOnBeforeRender\r\n\t// save before render and release after render.\r\n\tvar _originalOnBeforeRendersTable = {};\r\n\r\n\t// object.material.uuid -> object.material.visible or\r\n\t// object.material[ i ].uuid -> object.material[ i ].visible or\r\n\t// save before render and release after render.\r\n\tvar _originalVisibleTable = {};\r\n\r\n\t// external properties\r\n\r\n\tthis.renderer = undefined;\r\n\tthis.domElement = undefined;\r\n\r\n\tthis.forwardRendering = false;  // for debug\r\n\r\n\t// private methods\r\n\r\n\tfunction init( parameters ) {\r\n\r\n\t\t_this.renderer = parameters.renderer !== undefined ? parameters.renderer : new WebGLRenderer();\r\n\t\t_this.domElement = _this.renderer.domElement;\r\n\r\n\t\t_gl = _this.renderer.context;\r\n\r\n\t\t_width = parameters.width !== undefined ? parameters.width : _this.renderer.getSize().width;\r\n\t\t_height = parameters.height !== undefined ? parameters.height : _this.renderer.getSize().height;\r\n\r\n\t\tvar antialias = parameters.antialias !== undefined ? parameters.antialias : false;\r\n\r\n\t\tif ( parameters.cacheKeepAlive !== undefined ) { _cacheKeepAlive = parameters.cacheKeepAlive; }\r\n\r\n\t\tinitDepthTexture();\r\n\r\n\t\tinitPassNormalDepth();\r\n\t\tinitPassColor();\r\n\t\tinitPassLight();\r\n\t\tinitPassReconstruction();\r\n\t\tinitPassFinal();\r\n\r\n\t\t_this.setSize( _width, _height );\r\n\t\t_this.setAntialias( antialias );\r\n\t\t_this.enableLightPrePass( false );\r\n\r\n\t}\r\n\r\n\tfunction initDepthTexture() {\r\n\r\n\t\t_depthTexture = new DepthTexture(\r\n\t\t\t_width,\r\n\t\t\t_height,\r\n\t\t\tUnsignedInt248Type,\r\n\t\t\tundefined,\r\n\t\t\tundefined,\r\n\t\t\tundefined,\r\n\t\t\tundefined,\r\n\t\t\tundefined,\r\n\t\t\tundefined,\r\n\t\t\tDepthStencilFormat\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tfunction initPassNormalDepth() {\r\n\r\n\t\t_passNormalDepth = new RenderPass();\r\n\t\t_passNormalDepth.clear = true;\r\n\r\n\t\tvar rt = new WebGLRenderTarget( _width, _height, {\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: FloatType,\r\n\t\t\tstencilBuffer: true,\r\n\t\t\tdepthTexture: _depthTexture\r\n\t\t} );\r\n\r\n\t\trt.texture.generateMipamps = false;\r\n\r\n\t\t_compNormalDepth = new EffectComposer( _this.renderer, rt );\r\n\t\t_compNormalDepth.addPass( _passNormalDepth );\r\n\r\n\t}\r\n\r\n\tfunction initPassColor() {\r\n\r\n\t\t_passColor = new RenderPass();\r\n\t\t_passColor.clear = true;\r\n\r\n\t\tvar rt = new WebGLRenderTarget( _width, _height, {\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: FloatType,\r\n\t\t\tdepthTexture: _depthTexture\r\n\t\t} );\r\n\r\n\t\trt.texture.generateMipamps = false;\r\n\r\n\t\t_compColor = new EffectComposer( _this.renderer, rt );\r\n\t\t_compColor.addPass( _passColor );\r\n\r\n\t}\r\n\r\n\tfunction initPassLight() {\r\n\r\n\t\t_passLightFullscreen = new RenderPass();\r\n\t\t_passLightFullscreen.clear = true;\r\n\t\t_passLightFullscreen.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\r\n\t\t_passLight = new RenderPass();\r\n\t\t_passLight.clear = false;\r\n\r\n\t\tvar rt = new WebGLRenderTarget( _width, _height, {\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: FloatType,\r\n\t\t\tdepthTexture: _depthTexture\r\n\t\t} );\r\n\r\n\t\trt.texture.generateMipamps = false;\r\n\r\n\t\t_compLight = new EffectComposer( _this.renderer, rt );\r\n\t\t_compLight.addPass( _passLightFullscreen );\r\n\t\t_compLight.addPass( _passLight );\r\n\r\n\t}\r\n\r\n\tfunction initPassReconstruction() {\r\n\r\n\t\t_passReconstruction = new RenderPass();\r\n\t\t_passReconstruction.clear = true;\r\n\r\n\t\tvar rt = new WebGLRenderTarget( _width, _height, {\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: FloatType,\r\n\t\t\tdepthTexture: _depthTexture\r\n\t\t} );\r\n\r\n\t\trt.texture.generateMipamps = false;\r\n\r\n\t\t_compReconstruction = new EffectComposer( _this.renderer, rt );\r\n\t\t_compReconstruction.addPass( _passReconstruction );\r\n\r\n\t}\r\n\r\n\tfunction initPassFinal() {\r\n\r\n\t\t_passFinal = new ShaderPass( ShaderDeferred[ 'final' ] );\r\n\t\t_passFinal.clear = true;\r\n\t\t_passFinal.uniforms.samplerResult.value = _compLight.renderTarget2.texture;\r\n\t\t_passFinal.material.blending = NoBlending;\r\n\t\t_passFinal.material.depthWrite = false;\r\n\t\t_passFinal.material.depthTest = false;\r\n\r\n\t\t_passForward = new RenderPass();\r\n\t\t_passForward.clear = false;\r\n\r\n\t\t_passCopy = new ShaderPass( CopyShader );\r\n\r\n\t\t_passFXAA = new ShaderPass( FXAAShader );\r\n\r\n\t\tvar rt = new WebGLRenderTarget( _width, _height, {\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: LinearFilter,\r\n\t\t\tformat: RGBFormat,\r\n\t\t\ttype: UnsignedByteType,\r\n\t\t\tdepthTexture: _depthTexture\r\n\t\t} );\r\n\r\n\t\trt.texture.generateMipamps = false;\r\n\r\n\t\t_compFinal = new EffectComposer( _this.renderer, rt );\r\n\t\t_compFinal.addPass( _passFinal );\r\n\t\t_compFinal.addPass( _passForward );\r\n\t\t_compFinal.addPass( _passCopy );\r\n\t\t_compFinal.addPass( _passFXAA );\r\n\r\n\t}\r\n\r\n\tfunction initLightScene( scene ) {\r\n\r\n\t\tvar lightSceneData = _lightScenesCache[ scene.uuid ];\r\n\t\tvar lightFullscreenSceneData = _lightFullscreenScenesCache[ scene.uuid ];\r\n\r\n\t\tif ( lightSceneData === undefined ) {\r\n\r\n\t\t\tvar s = new Scene();\r\n\t\t\ts.userData.lights = {};\r\n\r\n\t\t\tlightSceneData = createCacheData();\r\n\t\t\tlightSceneData.scene = s;\r\n\r\n\t\t\t_lightScenesCache[ scene.uuid ] = lightSceneData;\r\n\r\n\t\t}\r\n\r\n\t\tif ( lightFullscreenSceneData === undefined ) {\r\n\r\n\t\t\tvar s = new Scene();\r\n\t\t\ts.userData.lights = {};\r\n\r\n\t\t\tvar emissiveLight = createDeferredEmissiveLight();\r\n\r\n\t\t\ts.userData.emissiveLight = emissiveLight;\r\n\t\t\ts.add( emissiveLight );\r\n\r\n\t\t\tlightFullscreenSceneData = createCacheData();\r\n\t\t\tlightFullscreenSceneData.scene = s;\r\n\r\n\t\t\t_lightFullscreenScenesCache[ scene.uuid ] = lightFullscreenSceneData;\r\n\r\n\t\t}\r\n\r\n\t\tlightSceneData.used = true;\r\n\t\tlightFullscreenSceneData.used = true;\r\n\r\n\t\tvar lightScene = lightSceneData.scene;\r\n\t\tvar lightFullscreenScene = lightFullscreenSceneData.scene;\r\n\r\n\t\t// emissiveLight is only for Classic Deferred Rendering\r\n\t\tlightFullscreenScene.userData.emissiveLight.visible = ! _lightPrePass;\r\n\r\n\t\t_lightScene = lightScene;\r\n\t\t_lightFullscreenScene = lightFullscreenScene;\r\n\r\n\t}\r\n\r\n\tfunction getMaterialFromCacheOrCreate( originalMaterial, cache, createFunc, updateFunc ) {\r\n\r\n\t\tvar data = cache[ originalMaterial.uuid ];\r\n\r\n\t\tif ( data === undefined ) {\r\n\r\n\t\t\tdata = createCacheData();\r\n\t\t\tdata.material = createFunc( originalMaterial );\r\n\t\t\tcache[ originalMaterial.uuid ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tdata.used = true;\r\n\r\n\t\tupdateFunc( data.material, originalMaterial );\r\n\r\n\t\t_originalMaterialsTable[ data.material.uuid ] = originalMaterial;\r\n\r\n\t\treturn data.material;\r\n\r\n\t}\r\n\r\n\tfunction overrideMaterialAndOnBeforeRender( object, getMaterialFunc, onBeforeRender ) {\r\n\r\n\t\tif ( object.material === undefined ) { return; }\r\n\r\n\t\tif ( Array.isArray( object.material ) ) {\r\n\r\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tobject.material[ i ] = getMaterialFunc( object.material[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject.material = getMaterialFunc( object.material );\r\n\r\n\t\t}\r\n\r\n\t\tobject.onBeforeRender = onBeforeRender;\r\n\r\n\t}\r\n\r\n\tfunction restoreOriginalMaterial( object ) {\r\n\r\n\t\tif ( object.material === undefined ) { return; }\r\n\r\n\t\tif ( Array.isArray( object.material ) ) {\r\n\r\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tobject.material[ i ] = _originalMaterialsTable[ object.material[ i ].uuid ];\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject.material = _originalMaterialsTable[ object.material.uuid ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setMaterialNormalDepth( object ) {\r\n\r\n\t\toverrideMaterialAndOnBeforeRender( object, getNormalDepthMaterial, updateDeferredNormalDepthUniforms );\r\n\r\n\t}\r\n\r\n\tfunction getNormalDepthMaterial( originalMaterial ) {\r\n\r\n\t\treturn getMaterialFromCacheOrCreate(\r\n\t\t\toriginalMaterial,\r\n\t\t\t( _lightPrePass ) ? _normalDepthShininessMaterialsCache : _normalDepthMaterialsCache,\r\n\t\t\tcreateDeferredNormalDepthMaterial,\r\n\t\t\tupdateDeferredNormalDepthMaterial\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tfunction createDeferredNormalDepthMaterial( originalMaterial ) {\r\n\r\n\t\tvar shader = ( _lightPrePass ) ? ShaderDeferred[ 'normalDepthShininess' ] : ShaderDeferred[ 'normalDepth' ];\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\t\t\tuniforms: Object.assign( {}, shader.uniforms ),\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tblending: NoBlending\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredNormalDepthMaterial( material, originalMaterial ) {\r\n\r\n\t\tif ( originalMaterial.skinning !== undefined ) { material.skinning = originalMaterial.skinning; }\r\n\t\tif ( originalMaterial.morphTargets !== undefined ) { material.morphTargets = originalMaterial.morphTargets; }\r\n\r\n\t\tif ( originalMaterial.visible === true ) {\r\n\r\n\t\t\tmaterial.visible = ! originalMaterial.transparent;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.visible = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredNormalDepthUniforms( renderer, scene, camera, geometry, material, group ) {\r\n\r\n\t\tif ( ! _lightPrePass ) { return; }\r\n\r\n\t\tvar originalMaterial = _originalMaterialsTable[ material.uuid ];\r\n\r\n\t\tif ( originalMaterial === undefined || originalMaterial.shininess === undefined ) { return; }\r\n\r\n\t\tmaterial.uniforms.shininess.value = originalMaterial.shininess;\r\n\r\n\t}\r\n\r\n\tfunction setMaterialColor( object ) {\r\n\r\n\t\toverrideMaterialAndOnBeforeRender( object, getColorMaterial, updateDeferredColorUniforms );\r\n\r\n\t}\r\n\r\n\tfunction getColorMaterial( originalMaterial ) {\r\n\r\n\t\treturn getMaterialFromCacheOrCreate(\r\n\t\t\toriginalMaterial,\r\n\t\t\t_colorMaterialsCache,\r\n\t\t\tcreateDeferredColorMaterial,\r\n\t\t\tupdateDeferredColorMaterial\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tfunction createDeferredColorMaterial( originalMaterial ) {\r\n\r\n\t\tvar shader = ShaderDeferred[ 'color' ];\r\n\r\n\t\tvar material = new ShaderMaterial( {\r\n\t\t\tuniforms: Object.assign( {}, shader.uniforms ),\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tblending: NoBlending\r\n\t\t} );\r\n\r\n\t\tif ( originalMaterial.map !== undefined ) { material.map = originalMaterial.map; }\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredColorMaterial( material, originalMaterial ) {\r\n\r\n\t\tif ( originalMaterial.map !== undefined ) { material.map = originalMaterial.map; }\r\n\t\tif ( originalMaterial.skinning !== undefined ) { material.skinning = originalMaterial.skinning; }\r\n\t\tif ( originalMaterial.morphTargets !== undefined ) { material.morphTargets = originalMaterial.morphTargets; }\r\n\r\n\t\tif ( originalMaterial.visible === true ) {\r\n\r\n\t\t\tmaterial.visible = ! originalMaterial.transparent;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.visible = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredColorUniforms( renderer, scene, camera, geometry, material, group ) {\r\n\r\n\t\tvar originalMaterial = _originalMaterialsTable[ material.uuid ];\r\n\t\tvar uniforms = material.uniforms;\r\n\r\n\t\tvar diffuse, emissive;\r\n\r\n\t\tif ( originalMaterial.isMeshBasicMaterial === true ) {\r\n\r\n\t\t\temissive = originalMaterial.color;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdiffuse = originalMaterial.color;\r\n\t\t\temissive = originalMaterial.emissive;\r\n\r\n\t\t}\r\n\r\n\t\tvar specular = originalMaterial.specular;\r\n\t\tvar shininess = originalMaterial.shininess;\r\n\t\tvar map = originalMaterial.map;\r\n\r\n\t\tif ( diffuse !== undefined ) { uniforms.diffuse.value.copy( diffuse ); }\r\n\t\tif ( emissive !== undefined ) { uniforms.emissive.value.copy( emissive ); }\r\n\t\tif ( specular !== undefined ) { uniforms.specular.value.copy( specular ); }\r\n\t\tif ( shininess !== undefined && uniforms.shininess !== undefined ) { uniforms.shininess.value = shininess; }\r\n\t\tif ( map !== undefined ) { uniforms.map.value = map; }\r\n\r\n\t}\r\n\r\n\tfunction setMaterialReconstruction( object ) {\r\n\r\n\t\toverrideMaterialAndOnBeforeRender( object, getReconstructionMaterial, updateDeferredReconstructionUniforms );\r\n\r\n\t}\r\n\r\n\tfunction getReconstructionMaterial( originalMaterial ) {\r\n\r\n\t\tif ( originalMaterial.transparent === true ) {\r\n\r\n\t\t\t_originalMaterialsTable[ originalMaterial.uuid ] = originalMaterial;\r\n\t\t\treturn originalMaterial;\r\n\r\n\t\t}\r\n\r\n\t\treturn getMaterialFromCacheOrCreate(\r\n\t\t\toriginalMaterial,\r\n\t\t\t_reconstructionMaterialsCache,\r\n\t\t\tcreateDeferredReconstructionMaterial,\r\n\t\t\tupdateDeferredReconstructionMaterial\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tfunction createDeferredReconstructionMaterial( originalMaterial ) {\r\n\r\n\t\tvar shader = ShaderDeferred[ 'reconstruction' ];\r\n\r\n\t\tvar material = new ShaderMaterial( {\r\n\t\t\tuniforms: Object.assign( {}, shader.uniforms ),\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tblending: NoBlending\r\n\t\t} );\r\n\r\n\t\tif ( originalMaterial.map !== undefined ) { material.map = originalMaterial.map; }\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredReconstructionMaterial( material, originalMaterial ) {\r\n\r\n\t\tupdateDeferredColorMaterial( material, originalMaterial );\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredReconstructionUniforms( renderer, scene, camera, geometry, material, group ) {\r\n\r\n\t\tif ( material.transparent === true ) {\r\n\r\n\t\t\t// 'this' is object here because this method is set as object.onBefore()\r\n\t\t\tvar onBeforeRender = _originalOnBeforeRendersTable[ this.uuid ];\r\n\r\n\t\t\tif ( onBeforeRender ) {\r\n\r\n\t\t\t\tonBeforeRender.call( this, renderer, scene, camera, geometry, material, group );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tupdateDeferredColorUniforms( renderer, scene, camera, geometry, material, group );\r\n\r\n\t\tmaterial.uniforms.samplerLight.value = _compLight.renderTarget2.texture;\r\n\r\n\t}\r\n\r\n\tfunction setVisibleForForwardRendering( object ) {\r\n\r\n\t\tif ( object.material === undefined ) { return; }\r\n\r\n\t\tif ( Array.isArray( object.material ) ) {\r\n\r\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( _originalVisibleTable[ object.material[ i ].uuid ] === undefined ) {\r\n\r\n\t\t\t\t\t_originalVisibleTable[ object.material[ i ].uuid ] = object.material[ i ].visible;\r\n\t\t\t\t\tobject.material[ i ].visible = object.material[ i ].transparent && object.material[ i ].visible;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( _originalVisibleTable[ object.material.uuid ] === undefined ) {\r\n\r\n\t\t\t\t_originalVisibleTable[ object.material.uuid ] = object.material.visible;\r\n\t\t\t\tobject.material.visible = object.material.transparent && object.material.visible;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction restoreVisible( object ) {\r\n\r\n\t\tif ( object.material === undefined ) { return; }\r\n\r\n\t\tif ( Array.isArray( object.material ) ) {\r\n\r\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tobject.material[ i ].visible = _originalVisibleTable[ object.material[ i ].uuid ];\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject.material.visible = _originalVisibleTable[ object.material.uuid ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createDeferredEmissiveLight() {\r\n\r\n\t\tvar shader = ShaderDeferred[ 'emissiveLight' ];\r\n\r\n\t\tvar material = new ShaderMaterial( {\r\n\t\t\tuniforms: Object.assign( {}, shader.uniforms ),\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\tblending: NoBlending,\r\n\t\t\tdepthWrite: false\r\n\t\t} );\r\n\r\n\t\tvar geometry = new PlaneBufferGeometry( 2, 2 );\r\n\t\tvar mesh = new Mesh( geometry, material );\r\n\r\n\t\tmesh.onBeforeRender = function ( renderer, scene, camera, geometry, material, group ) {\r\n\r\n\t\t\tmaterial.uniforms.samplerColor.value = _compColor.renderTarget2.texture;\r\n\r\n\t\t};\r\n\r\n\t\treturn mesh;\r\n\r\n\t}\r\n\r\n\tfunction createDeferredLight( originalLight ) {\r\n\r\n\t\tif ( originalLight.isPointLight ) {\r\n\r\n\t\t\treturn createDeferredPointLight( originalLight );\r\n\r\n\t\t} else if ( originalLight.isSpotLight ) {\r\n\r\n\t\t\treturn createDeferredSpotLight( originalLight );\r\n\r\n\t\t} else if ( originalLight.isDirectionalLight ) {\r\n\r\n\t\t\treturn createDeferredDirectionalLight( originalLight );\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tfunction createDeferredLightMaterial( originalLight ) {\r\n\r\n\t\tif ( originalLight.isPointLight ) {\r\n\r\n\t\t\treturn createDeferredPointLightMaterial();\r\n\r\n\t\t} else if ( originalLight.isSpotLight ) {\r\n\r\n\t\t\treturn createDeferredSpotLightMaterial();\r\n\r\n\t\t} else if ( originalLight.isDirectionalLight ) {\r\n\r\n\t\t\treturn createDeferredDirectionalLightMaterial();\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tfunction getDeferredLightMaterial( light ) {\r\n\r\n\t\tvar cache = ( _lightPrePass ) ? _lightPrePassMaterialsCache : _classicDeferredLightMaterialsCache;\r\n\r\n\t\tvar data = cache[ light.uuid ];\r\n\r\n\t\tif ( data === undefined ) {\r\n\r\n\t\t\tdata = createCacheData();\r\n\t\t\tdata.material = createDeferredLightMaterial( light.userData.originalLight );\r\n\t\t\tcache[ light.uuid ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tdata.used = true;\r\n\r\n\t\treturn data.material;\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredLight( light ) {\r\n\r\n\t\tvar originalLight = light.userData.originalLight;\r\n\r\n\t\tif ( originalLight.isPointLight ) {\r\n\r\n\t\t\tupdateDeferredPointLight( light );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createDeferredLightMesh( light, geometry ) {\r\n\r\n\t\tvar mesh = new Mesh( geometry, _tmpMaterial );\r\n\r\n\t\tmesh.userData.originalLight = light;\r\n\r\n\t\treturn mesh;\r\n\r\n\t}\r\n\r\n\tfunction createDeferredLightShaderMaterial( shader ) {\r\n\r\n\t\tvar material = new ShaderMaterial( {\r\n\t\t\tuniforms: Object.assign( {}, shader.uniforms ),\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\ttransparent: true,\r\n\t\t\tblending: AdditiveBlending,\r\n\t\t\tdepthWrite: false\r\n\t\t} );\r\n\r\n\t\tif ( _lightPrePass ) { material.premultipliedAlpha = true; }\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredLightCommonUniforms( uniforms ) {\r\n\r\n\t\tif ( _lightPrePass ) {\r\n\r\n\t\t\tuniforms.samplerNormalDepthShininess.value = _compNormalDepth.renderTarget2.texture;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuniforms.samplerNormalDepth.value = _compNormalDepth.renderTarget2.texture;\r\n\t\t\tuniforms.samplerColor.value = _compColor.renderTarget2.texture;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createDeferredPointLight( light ) {\r\n\r\n\t\tvar mesh = createDeferredLightMesh( light, new SphereBufferGeometry( 1, 16, 8 ) );\r\n\t\tmesh.onBeforeRender = updateDeferredPointLightUniforms;\r\n\t\treturn mesh;\r\n\r\n\t}\r\n\t\r\n\tfunction createDeferredPointLightMaterial() {\r\n\r\n\t\tvar shader = ( _lightPrePass ) ? ShaderDeferred[ 'pointLightPre' ] : ShaderDeferred[ 'pointLight' ];\r\n\r\n\t\tvar material = createDeferredLightShaderMaterial( shader );\r\n\r\n\t\tmaterial.side = BackSide;\r\n\t\tmaterial.depthFunc = GreaterEqualDepth;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredPointLight( light ) {\r\n\r\n\t\tvar originalLight = light.userData.originalLight;\r\n\t\tvar distance = originalLight.distance;\r\n\r\n\t\tif ( distance > 0 ) {\r\n\r\n\t\t\tlight.scale.set( 1, 1, 1 ).multiplyScalar( distance );\r\n\t\t\tlight.position.setFromMatrixPosition( originalLight.matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredPointLightUniforms( renderer, scene, camera, geometry, material, group ) {\r\n\r\n\t\tvar light = this;\r\n\r\n\t\tvar originalLight = light.userData.originalLight;\r\n\t\tvar distance = originalLight.distance;\r\n\t\tvar uniforms = material.uniforms;\r\n\r\n\t\tuniforms.lightColor.value.copy( originalLight.color );\r\n\r\n\t\tif ( distance > 0 ) {\r\n\r\n\t\t\tuniforms.lightRadius.value = distance;\r\n\t\t\tuniforms.lightIntensity.value = originalLight.intensity;\r\n\t\t\tuniforms.lightPositionVS.value.setFromMatrixPosition( originalLight.matrixWorld ).applyMatrix4( _currentCamera.matrixWorldInverse );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuniforms.lightRadius.value = Infinity;\r\n\r\n\t\t}\r\n\r\n\t\tupdateDeferredLightCommonUniforms( uniforms );\r\n\r\n\t}\r\n\r\n\tfunction createDeferredSpotLight( light ) {\r\n\r\n\t\tvar mesh = createDeferredLightMesh( light, new PlaneBufferGeometry( 2, 2 ) );\r\n\t\tmesh.onBeforeRender = updateDeferredSpotLightUniforms;\r\n\t\treturn mesh;\r\n\r\n\t}\r\n\r\n\tfunction createDeferredSpotLightMaterial() {\r\n\r\n\t\tvar shader = ( _lightPrePass ) ? ShaderDeferred[ 'spotLightPre' ] : ShaderDeferred[ 'spotLight' ];\r\n\r\n\t\tvar material = createDeferredLightShaderMaterial( shader );\r\n\r\n\t\tmaterial.depthTest = false;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredSpotLightUniforms( renderer, scene, camera, geometry, material, group ) {\r\n\r\n\t\tvar light = this;\r\n\r\n\t\tvar originalLight = light.userData.originalLight;\r\n\t\tvar uniforms = light.material.uniforms;\r\n\r\n\t\tuniforms.lightAngle.value = originalLight.angle;\r\n\t\tuniforms.lightColor.value.copy( originalLight.color );\r\n\t\tuniforms.lightIntensity.value = originalLight.intensity;\r\n\t\tuniforms.lightPositionVS.value.setFromMatrixPosition( originalLight.matrixWorld ).applyMatrix4( _currentCamera.matrixWorldInverse );\r\n\r\n\t\tvar vec = uniforms.lightDirectionVS.value;\r\n\t\tvar vec2 = _tmpVector3;\r\n\r\n\t\tvec.setFromMatrixPosition( originalLight.matrixWorld );\r\n\t\tvec2.setFromMatrixPosition( originalLight.target.matrixWorld );\r\n\t\tvec.sub( vec2 ).normalize().transformDirection( _currentCamera.matrixWorldInverse );\r\n\r\n\t\tupdateDeferredLightCommonUniforms( uniforms );\r\n\r\n\t}\r\n\r\n\tfunction createDeferredDirectionalLight( light ) {\r\n\r\n\t\tvar mesh = createDeferredLightMesh( light, new PlaneBufferGeometry( 2, 2 ) );\r\n\t\tmesh.onBeforeRender = updateDeferredDirectionalLightUniforms;\r\n\t\treturn mesh;\r\n\r\n\t}\r\n\r\n\tfunction createDeferredDirectionalLightMaterial() {\r\n\r\n\t\tvar shader = ( _lightPrePass ) ? ShaderDeferred[ 'directionalLightPre' ] : ShaderDeferred[ 'directionalLight' ];\r\n\r\n\t\tvar material = createDeferredLightShaderMaterial( shader );\r\n\r\n\t\tmaterial.depthTest = false;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredDirectionalLightUniforms( renderer, scene, camera, geometry, material, group ) {\r\n\r\n\t\tvar light = this;\r\n\r\n\t\tvar originalLight = light.userData.originalLight;\r\n\t\tvar uniforms = light.material.uniforms;\r\n\r\n\t\tuniforms.lightColor.value.copy( originalLight.color );\r\n\t\tuniforms.lightIntensity.value = originalLight.intensity;\r\n\r\n\t\tvar vec = uniforms.lightDirectionVS.value;\r\n\t\tvar vec2 = _tmpVector3;\r\n\r\n\t\tvec.setFromMatrixPosition( originalLight.matrixWorld );\r\n\t\tvec2.setFromMatrixPosition( originalLight.target.matrixWorld );\r\n\t\tvec.sub( vec2 ).normalize().transformDirection( _currentCamera.matrixWorldInverse );\r\n\r\n\t\tupdateDeferredLightCommonUniforms( uniforms );\r\n\r\n\t}\r\n\r\n\tfunction saveOriginalOnBeforeRenderAndCheckTransparency( object ) {\r\n\r\n\t\tif ( object.material === undefined ) { return; }\r\n\r\n\t\t_originalOnBeforeRendersTable[ object.uuid ] = object.onBeforeRender;\r\n\r\n\t\t// _hasTransparentObject is used only for Classic Deferred Rendering\r\n\t\tif ( _hasTransparentObject || _lightPrePass ) { return; }\r\n\r\n\t\tif ( ! object.visible ) { return; }\r\n\r\n\t\tif ( Array.isArray( object.material ) ) {\r\n\r\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( object.material[ i ].visible === true && object.material[ i ].transparent === true ) {\r\n\r\n\t\t\t\t\t_hasTransparentObject = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( object.material.visible === true && object.material.transparent === true ) { _hasTransparentObject = true; }\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction restoreOriginalOnBeforeRender( object ) {\r\n\r\n\t\tif ( object.material === undefined ) { return; }\r\n\r\n\t\tobject.onBeforeRender = _originalOnBeforeRendersTable[ object.uuid ];\r\n\r\n\t}\r\n\r\n\tfunction addDeferredLightsToLightScene( object ) {\r\n\r\n\t\tif ( object.isLight !== true ) { return; }\r\n\r\n\t\tvar data = _deferredLightsCache[ object.uuid ];\r\n\r\n\t\tif ( data === undefined ) {\r\n\r\n\t\t\tdata = createCacheData();\r\n\t\t\tdata.light = createDeferredLight( object );\r\n\t\t\t_deferredLightsCache[ object.uuid ] = data;\r\n\r\n\t\t}\r\n\r\n\t\tdata.used = true;\r\n\r\n\t\tvar light = data.light;\r\n\r\n\t\tif ( light === null ) { return; }\r\n\r\n\t\tvar scene = ( object.isPointLight === true ) ? _lightScene : _lightFullscreenScene;\r\n\r\n\t\tvar lights = scene.userData.lights;\r\n\r\n\t\tif ( lights[ light.uuid ] === undefined ) {\r\n\r\n\t\t\tscene.add( light );\r\n\r\n\t\t\tlights[ light.uuid ] = {\r\n\t\t\t\tlight: light,\r\n\t\t\t\tfound: true\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tlights[ light.uuid ].found = true;\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredLightsInLightScene( scene ) {\r\n\r\n\t\tvar lights = scene.userData.lights;\r\n\t\tvar keys = Object.keys( lights );\r\n\r\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar key = keys[ i ];\r\n\r\n\t\t\tif ( lights[ key ].found === false ) {\r\n\r\n\t\t\t\tscene.remove( lights[ key ].light );\r\n\t\t\t\tdelete lights[ key ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar light = lights[ key ].light;\r\n\t\t\t\tlight.material = getDeferredLightMaterial( light );\r\n\r\n\t\t\t\tupdateDeferredLight( light );\r\n\t\t\t\tlights[ key ].found = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction updateDeferredCommonUniforms( camera ) {\r\n\r\n\t\tvar uniforms = ShaderDeferredCommon[ 'commonUniforms' ];\r\n\r\n\t\tuniforms.viewWidth.value = _width;\r\n\t\tuniforms.viewHeight.value = _height;\r\n\r\n\t\tuniforms.matProjInverse.value.getInverse( camera.projectionMatrix );\r\n\r\n\t}\r\n\r\n\tfunction enableFinalPasses() {\r\n\r\n\t\tif ( _lightPrePass ) {\r\n\r\n\t\t\t_passForward.renderToScreen = false;\r\n\t\t\t_passForward.enabled = false;\r\n\r\n\t\t\t_passCopy.renderToScreen = false;\r\n\t\t\t_passCopy.enabled = false;\r\n\r\n\t\t\tif ( _antialias ) {\r\n\r\n\t\t\t\t_passFinal.renderToScreen = false;\r\n\r\n\t\t\t\t_passFXAA.renderToScreen = true;\r\n\t\t\t\t_passFXAA.enabled = true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_passFinal.renderToScreen = true;\r\n\r\n\t\t\t\t_passFXAA.renderToScreen = false;\r\n\t\t\t\t_passFXAA.enabled = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( _hasTransparentObject ) {\r\n\r\n\t\t\t\tif ( _antialias ) {\r\n\r\n\t\t\t\t\t_passFinal.renderToScreen = false;\r\n\r\n\t\t\t\t\t_passForward.renderToScreen = false;\r\n\t\t\t\t\t_passForward.enabled = true;\r\n\r\n\t\t\t\t\t_passCopy.renderToScreen = false;\r\n\t\t\t\t\t_passCopy.enabled = false;\r\n\r\n\t\t\t\t\t_passFXAA.renderToScreen = true;\r\n\t\t\t\t\t_passFXAA.enabled = true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_passFinal.renderToScreen = false;\r\n\r\n\t\t\t\t\t_passForward.renderToScreen = false;\r\n\t\t\t\t\t_passForward.enabled = true;\r\n\r\n\t\t\t\t\t_passCopy.renderToScreen = true;\r\n\t\t\t\t\t_passCopy.enabled = true;\r\n\r\n\t\t\t\t\t_passFXAA.renderToScreen = false;\r\n\t\t\t\t\t_passFXAA.enabled = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( _antialias ) {\r\n\r\n\t\t\t\t\t_passFinal.renderToScreen = false;\r\n\r\n\t\t\t\t\t_passForward.renderToScreen = false;\r\n\t\t\t\t\t_passForward.enabled = false;\r\n\r\n\t\t\t\t\t_passCopy.renderToScreen = false;\r\n\t\t\t\t\t_passCopy.enabled = false;\r\n\r\n\t\t\t\t\t_passFXAA.renderToScreen = true;\r\n\t\t\t\t\t_passFXAA.enabled = true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_passFinal.renderToScreen = true;\r\n\r\n\t\t\t\t\t_passForward.renderToScreen = false;\r\n\t\t\t\t\t_passForward.enabled = false;\r\n\r\n\t\t\t\t\t_passCopy.renderToScreen = false;\r\n\t\t\t\t\t_passCopy.enabled = false;\r\n\r\n\t\t\t\t\t_passFXAA.renderToScreen = false;\r\n\t\t\t\t\t_passFXAA.enabled = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createCacheData() {\r\n\r\n\t\treturn {\r\n\t\t\tused: true,\r\n\t\t\tkeepAlive: _cacheKeepAlive,\r\n\t\t\tcount: 0\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction cleanupCache( cache ) {\r\n\r\n\t\tvar keys = Object.keys( cache );\r\n\r\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar key = keys[ i ];\r\n\r\n\t\t\tif ( cache[ key ].used === false ) {\r\n\r\n\t\t\t\tcache[ key ].count++;\r\n\r\n\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > _removeThresholdCount ) {\r\n\r\n\t\t\t\t\tdelete cache[ key ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcache[ key ].used = false;\r\n\t\t\t\tcache[ key ].count = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction cleanupTable( table ) {\r\n\r\n\t\tvar keys = Object.keys( table );\r\n\r\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar key = keys[ i ];\r\n\r\n\t\t\ttable[ key ] = undefined;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction cleanupCaches() {\r\n\r\n\t\tcleanupCache( _lightScenesCache );\r\n\t\tcleanupCache( _lightFullscreenScenesCache );\r\n\t\tcleanupCache( _normalDepthMaterialsCache );\r\n\t\tcleanupCache( _normalDepthShininessMaterialsCache );\r\n\t\tcleanupCache( _colorMaterialsCache );\r\n\t\tcleanupCache( _reconstructionMaterialsCache );\r\n\t\tcleanupCache( _classicDeferredLightMaterialsCache );\r\n\t\tcleanupCache( _lightPrePassMaterialsCache );\r\n\t\tcleanupCache( _deferredLightsCache );\r\n\r\n\t\tcleanupTable( _originalMaterialsTable );\r\n\t\tcleanupTable( _originalOnBeforeRendersTable );\r\n\t\tcleanupTable( _originalVisibleTable );\r\n\r\n\t}\r\n\r\n\tfunction renderNormalDepth( scene, camera ) {\r\n\r\n\t\tscene.traverse( setMaterialNormalDepth );\r\n\r\n\t\t_passNormalDepth.scene = scene;\r\n\t\t_passNormalDepth.camera = camera;\r\n\r\n\t\t_this.renderer.autoClearDepth = true;\r\n\t\t_this.renderer.autoClearStencil = true;\r\n\r\n\t\t_gl.enable( _gl.STENCIL_TEST );\r\n\t\t_gl.stencilFunc( _gl.ALWAYS, 1, 0xffffffff );\r\n\t\t_gl.stencilOp( _gl.REPLACE, _gl.REPLACE, _gl.REPLACE );\r\n\r\n\t\t_compNormalDepth.render();\r\n\r\n\t\tscene.traverse( restoreOriginalMaterial );\r\n\r\n\t}\r\n\r\n\tfunction renderColor( scene, camera ) {\r\n\r\n\t\tscene.traverse( setMaterialColor );\r\n\r\n\t\t_passColor.scene = scene;\r\n\t\t_passColor.camera = camera;\r\n\r\n\t\t_this.renderer.autoClearDepth = false;\r\n\t\t_this.renderer.autoClearStencil = false;\r\n\r\n\t\t_gl.stencilFunc( _gl.EQUAL, 1, 0xffffffff );\r\n\t\t_gl.stencilOp( _gl.KEEP, _gl.KEEP, _gl.KEEP );\r\n\r\n\t\t_compColor.render();\r\n\r\n\t\tscene.traverse( restoreOriginalMaterial );\r\n\r\n\t}\r\n\r\n\tfunction renderLight( scene, camera ) {\r\n\r\n\t\tscene.traverse( addDeferredLightsToLightScene );\r\n\r\n\t\tupdateDeferredLightsInLightScene( _lightScene );\r\n\t\tupdateDeferredLightsInLightScene( _lightFullscreenScene );\r\n\r\n\t\t_passLight.scene = _lightScene;\r\n\t\t_passLight.camera = camera;\r\n\r\n\t\t_passLightFullscreen.scene = _lightFullscreenScene;\r\n\r\n\t\t_this.renderer.autoClearDepth = false;\r\n\t\t_this.renderer.autoClearStencil = false;\r\n\r\n\t\t_compLight.render();\r\n\r\n\t\t_gl.disable( _gl.STENCIL_TEST );\r\n\r\n\t}\r\n\r\n\tfunction renderLightPre( scene, camera ) {\r\n\r\n\t\tscene.traverse( addDeferredLightsToLightScene );\r\n\r\n\t\tupdateDeferredLightsInLightScene( _lightScene );\r\n\t\tupdateDeferredLightsInLightScene( _lightFullscreenScene );\r\n\r\n\t\t_passLight.scene = _lightScene;\r\n\t\t_passLight.camera = camera;\r\n\r\n\t\t_passLightFullscreen.scene = _lightFullscreenScene;\r\n\r\n\t\t_this.renderer.autoClearDepth = false;\r\n\t\t_this.renderer.autoClearStencil = false;\r\n\r\n\t\t_gl.stencilFunc( _gl.EQUAL, 1, 0xffffffff );\r\n\t\t_gl.stencilOp( _gl.KEEP, _gl.KEEP, _gl.KEEP );\r\n\r\n\t\t_compLight.render();\r\n\r\n\t}\r\n\r\n\tfunction renderReconstruction( scene, camera ) {\r\n\r\n\t\tscene.traverse( setMaterialReconstruction );\r\n\r\n\t\t_passReconstruction.scene = scene;\r\n\t\t_passReconstruction.camera = camera;\r\n\r\n\t\t_this.renderer.autoClearDepth = false;\r\n\t\t_this.renderer.autoClearStencil = false;\r\n\r\n\t\t_compReconstruction.render();\r\n\r\n\t\t_gl.disable( _gl.STENCIL_TEST );\r\n\r\n\t\tscene.traverse( restoreOriginalMaterial );\r\n\r\n\t}\r\n\r\n\tfunction renderFinal( scene, camera ) {\r\n\r\n\t\tif ( ! _lightPrePass && _hasTransparentObject ) {\r\n\r\n\t\t\tscene.traverse( setVisibleForForwardRendering );\r\n\t\t\tscene.traverse( restoreOriginalOnBeforeRender );\r\n\r\n\t\t\t_passForward.scene = scene;\r\n\t\t\t_passForward.camera = camera;\r\n\r\n\t\t}\r\n\r\n\t\tenableFinalPasses();\r\n\r\n\t\t_this.renderer.autoClearDepth = false;\r\n\t\t_this.renderer.autoClearStencil = false;\r\n\r\n\t\t_compFinal.render();\r\n\r\n\t\tif ( ! _lightPrePass && _hasTransparentObject ) {\r\n\r\n\t\t\tscene.traverse( restoreVisible );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// external APIs\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\tthis.renderer.setSize( _width, _height );\r\n\r\n\t\t_compNormalDepth.setSize( _width, _height );\r\n\t\t_compColor.setSize( _width, _height );\r\n\t\t_compLight.setSize( _width, _height );\r\n\t\t_compReconstruction.setSize( _width, _height );\r\n\t\t_compFinal.setSize( _width, _height );\r\n\r\n\t\t_depthTexture.image.width = _width;\r\n\t\t_depthTexture.image.height = _height;\r\n\t\t_depthTexture.needsUpdate = true;\r\n\r\n\t\t_passFXAA.uniforms.resolution.value.set( 1 / _width, 1 / _height );\r\n\r\n\t};\r\n\r\n\tthis.setAntialias = function ( enabled ) {\r\n\r\n\t\t_antialias = enabled;\r\n\r\n\t};\r\n\r\n\tthis.enableLightPrePass = function ( enabled ) {\r\n\r\n\t\t_lightPrePass = enabled;\r\n\r\n\t\t_passFinal.uniforms.samplerResult.value = ( _lightPrePass ) ? _compReconstruction.renderTarget2.texture : _compLight.renderTarget2.texture;\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\t// for debug to compare with normal forward rendering\r\n\r\n\t\tif ( this.forwardRendering ) {\r\n\r\n\t\t\tthis.renderer.render( scene, camera );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar currentSceneAutoUpdate = scene.autoUpdate;\r\n\t\tvar currentAutoClearColor = this.renderer.autoClearColor;\r\n\t\tvar currentAutoClearDepth = this.renderer.autoClearDepth;\r\n\t\tvar currentAutoClearStencil = this.renderer.autoClearStencil;\r\n\r\n\t\t_currentCamera = camera;\r\n\r\n\t\tinitLightScene( scene );\r\n\r\n\t\tscene.autoUpdate = false;\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\t_hasTransparentObject = false;\r\n\r\n\t\tscene.traverse( saveOriginalOnBeforeRenderAndCheckTransparency );\r\n\r\n\t\tupdateDeferredCommonUniforms( camera );\r\n\r\n\t\trenderNormalDepth( scene, camera );\r\n\r\n\t\tif ( _lightPrePass ) {\r\n\r\n\t\t\trenderLightPre( scene, camera );\r\n\t\t\trenderReconstruction( scene, camera );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderColor( scene, camera );\r\n\t\t\trenderLight( scene, camera );\r\n\r\n\t\t}\r\n\r\n\t\trenderFinal( scene, camera );\r\n\r\n\t\tscene.traverse( restoreOriginalOnBeforeRender );\r\n\r\n\t\tcleanupCaches();\r\n\r\n\t\tscene.autoUpdate = currentSceneAutoUpdate;\r\n\t\tthis.renderer.autoClearColor = currentAutoClearColor;\r\n\t\tthis.renderer.autoClearDepth = currentAutoClearDepth;\r\n\t\tthis.renderer.autoClearStencil = currentAutoClearStencil;\r\n\r\n\t};\r\n\r\n\t// initialize\r\n\r\n\tinit( parameters );\r\n\r\n};\r\n\r\nvar DeferredShaderChunk = {\r\n\r\n\tpackVector3: [\r\n\r\n\t\t\"float vec3_to_float( vec3 data ) {\",\r\n\r\n\t\t\"\tconst float unit = 255.0/256.0;\",\r\n\t\t\"\thighp float compressed = fract( data.x * unit ) + floor( data.y * unit * 255.0 ) + floor( data.z * unit * 255.0 ) * 255.0;\",\r\n\t\t\"\treturn compressed;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tunpackFloat: [\r\n\r\n\t\t\"vec3 float_to_vec3( float data ) {\",\r\n\r\n\t\t\"\tconst float unit = 255.0;\",\r\n\t\t\"\tvec3 uncompressed;\",\r\n\t\t\"\tuncompressed.x = fract( data );\",\r\n\t\t\"\tfloat zInt = floor( data / unit );\",\r\n\t\t\"\tuncompressed.z = fract( zInt / unit );\",\r\n\t\t\"\tuncompressed.y = fract( floor( data - ( zInt * unit ) ) / unit );\",\r\n\t\t\"\treturn uncompressed;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\t// Refer to http://aras-p.info/texts/CompactNormalStorage.html\r\n\tpackNormal: [\r\n\r\n\t\t\"vec2 normal_to_vec2( vec3 normal ) {\",\r\n\r\n\t\t\"\treturn normal.xy / sqrt( normal.z * 8.0 + 8.0 ) + 0.5;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tunpackVector2: [\r\n\r\n\t\t\"vec3 vec2_to_normal( vec2 data ) {\",\r\n\r\n\t\t\"\tvec2 fenc = data * 4.0 - 2.0;\",\r\n\t\t\"\tfloat f = dot( fenc, fenc );\",\r\n\t\t\"\tfloat g = sqrt( 1.0 - f / 4.0 );\",\r\n\t\t\"\tvec3 normal;\",\r\n\t\t\"\tnormal.xy = fenc * g;\",\r\n\t\t\"\tnormal.z = 1.0 - f / 2.0;\",\r\n\t\t\"\treturn normal;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tcomputeTextureCoord: [\r\n\r\n\t\t\"vec2 texCoord = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tpackNormalDepth: [\r\n\r\n\t\t\"vec4 packedNormalDepth;\",\r\n\t\t\"packedNormalDepth.xyz = normal * 0.5 + 0.5;\",\r\n\t\t\"packedNormalDepth.w = position.z / position.w;\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tunpackNormalDepth: [\r\n\r\n\t\t\"vec4 normalDepthMap = texture2D( samplerNormalDepth, texCoord );\",\r\n\t\t\"float depth = normalDepthMap.w;\",\r\n\r\n\t\t\"if ( depth == 0.0 ) discard;\",\r\n\r\n\t\t\"vec3 normal = normalDepthMap.xyz * 2.0 - 1.0;\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tpackNormalDepthShininess: [\r\n\r\n\t\t\"vec4 packedNormalDepthShininess;\",\r\n\t\t\"packedNormalDepthShininess.xy = normal_to_vec2( normal );\",\r\n\t\t\"packedNormalDepthShininess.z = shininess;\",\r\n\t\t\"packedNormalDepthShininess.w = position.z / position.w;\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tunpackNormalDepthShininess: [\r\n\r\n\t\t\"vec4 normalDepthMap = texture2D( samplerNormalDepthShininess, texCoord );\",\r\n\t\t\"float depth = normalDepthMap.w;\",\r\n\r\n\t\t\"if ( depth == 0.0 ) discard;\",\r\n\r\n\t\t\"vec3 normal = vec2_to_normal( normalDepthMap.xy );\",\r\n\t\t\"float shininess = normalDepthMap.z;\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tpackColor: [\r\n\r\n\t\t\"vec4 packedColor;\",\r\n\t\t\"packedColor.x = vec3_to_float( diffuseColor.rgb );\",\r\n\t\t\"packedColor.y = vec3_to_float( emissiveColor );\",\r\n\t\t\"packedColor.z = vec3_to_float( specularColor );\",\r\n\t\t\"packedColor.w = shininess;\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tunpackColor: [\r\n\r\n\t\t\"vec4 colorMap = texture2D( samplerColor, texCoord );\",\r\n\t\t\"vec3 diffuseColor = float_to_vec3( colorMap.x );\",\r\n\t\t\"vec3 emissiveColor = float_to_vec3( colorMap.y );\",\r\n\t\t\"vec3 specularColor = float_to_vec3( colorMap.z );\",\r\n\t\t\"float shininess = colorMap.w;\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tpackLight: [\r\n\r\n\t\t\"vec4 packedLight;\",\r\n\t\t\"packedLight.xyz = lightIntensity * lightColor * max( dot( lightVector, normal ), 0.0 ) * attenuation;\",\r\n\t\t\"packedLight.w = lightIntensity * specular * max( dot( lightVector, normal ), 0.0 ) * attenuation;\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tcomputeVertexPositionVS: [\r\n\r\n\t\t\"vec2 xy = texCoord * 2.0 - 1.0;\",\r\n\t\t\"vec4 vertexPositionProjected = vec4( xy, depth, 1.0 );\",\r\n\t\t\"vec4 vertexPositionVS = matProjInverse * vertexPositionProjected;\",\r\n\t\t\"vertexPositionVS.xyz /= vertexPositionVS.w;\",\r\n\t\t\"vertexPositionVS.w = 1.0;\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\t// TODO: calculate schlick\r\n\tcomputeSpecular: [\r\n\r\n\t\t\"vec3 halfVector = normalize( lightVector - normalize( vertexPositionVS.xyz ) );\",\r\n\t\t\"float dotNormalHalf = max( dot( normal, halfVector ), 0.0 );\",\r\n\t\t\"float specular = 0.31830988618 * ( shininess * 0.5 + 1.0 ) * pow( dotNormalHalf, shininess );\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tcombine: [\r\n\r\n\t\t\"gl_FragColor = vec4( lightIntensity * lightColor * max( dot( lightVector, normal ), 0.0 ) * ( diffuseColor + specular * specularColor ) * attenuation, 1.0 );\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\r\n\r\nvar ShaderDeferredCommon = {\r\n\r\n\tcommonUniforms: {\r\n\r\n\t\tmatProjInverse: new Uniform( new Matrix4() ),\r\n\r\n\t\tviewWidth: new Uniform( 800 ),\r\n\t\tviewHeight: new Uniform( 600 )\r\n\r\n\t}\r\n\r\n};\r\n\r\nvar ShaderDeferred = {\r\n\r\n\tnormalDepth: {\r\n\r\n\t\tuniforms: {},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec4 vPosition;\",\r\n\r\n\t\t\t\"#include <morphtarget_pars_vertex>\",\r\n\t\t\t\"#include <skinning_pars_vertex>\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"#include <begin_vertex>\",\r\n\t\t\t\"#include <beginnormal_vertex>\",\r\n\t\t\t\"#include <skinbase_vertex>\",\r\n\t\t\t\"#include <skinnormal_vertex>\",\r\n\t\t\t\"#include <defaultnormal_vertex>\",\r\n\t\t\t\"#include <morphtarget_vertex>\",\r\n\t\t\t\"#include <skinning_vertex>\",\r\n\t\t\t\"#include <project_vertex>\",\r\n\r\n\t\t\t\"\tvNormal = normalize( transformedNormal );\",\r\n\t\t\t\"\tvPosition = gl_Position;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec4 vPosition;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec3 normal = vNormal;\",\r\n\t\t\t\"\tvec4 position = vPosition;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"packNormalDepth\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = packedNormalDepth;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\tcolor: {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\tmap: new Uniform( null ),\r\n\t\t\toffsetRepeat: new Uniform( new Vector4( 0, 0, 1, 1 ) ),\r\n\r\n\t\t\tdiffuse: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\temissive: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\tspecular: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\tshininess: new Uniform( 30.0 )\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#include <uv_pars_vertex>\",\r\n\t\t\t\"#include <morphtarget_pars_vertex>\",\r\n\t\t\t\"#include <skinning_pars_vertex>\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"#include <uv_vertex>\",\r\n\t\t\t\"#include <begin_vertex>\",\r\n\t\t\t\"#include <beginnormal_vertex>\",\r\n\t\t\t\"#include <skinbase_vertex>\",\r\n\t\t\t\"#include <skinnormal_vertex>\",\r\n\t\t\t\"#include <defaultnormal_vertex>\",\r\n\t\t\t\"#include <morphtarget_vertex>\",\r\n\t\t\t\"#include <skinning_vertex>\",\r\n\t\t\t\"#include <project_vertex>\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float shininess;\",\r\n\r\n\t\t\t\"#include <uv_pars_fragment>\",\r\n\t\t\t\"#include <map_pars_fragment>\",\r\n\t\t\tDeferredShaderChunk[ \"packVector3\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, 1.0 );\",\r\n\t\t\t\"\tvec3 emissiveColor = emissive;\",\r\n\t\t\t\"\tvec3 specularColor = specular;\",\r\n\r\n\t\t\t\"#include <map_fragment>\",\r\n\t\t\tDeferredShaderChunk[ \"packColor\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = packedColor;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\temissiveLight: {\r\n\r\n\t\tuniforms: Object.assign(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tsamplerColor: new Uniform( null )\r\n\r\n\t\t\t},\r\n\r\n\t\t\tShaderDeferredCommon[ 'commonUniforms' ]\r\n\r\n\t\t),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() { \",\r\n\r\n\t\t\t\"\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( '\\n' ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D samplerColor;\",\r\n\r\n\t\t\t\"uniform float viewHeight;\",\r\n\t\t\t\"uniform float viewWidth;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"unpackFloat\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeTextureCoord\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackColor\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( emissiveColor, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( '\\n' )\r\n\r\n\t},\r\n\r\n\tpointLight: {\r\n\r\n\t\tuniforms: Object.assign(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tsamplerNormalDepth: new Uniform( null ),\r\n\t\t\t\tsamplerColor: new Uniform( null ),\r\n\r\n\t\t\t\tlightColor: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\t\tlightPositionVS: new Uniform( new Vector3( 0, 1, 0 ) ),\r\n\t\t\t\tlightIntensity: new Uniform( 1.0 ),\r\n\t\t\t\tlightRadius: new Uniform( 1.0 )\r\n\r\n\t\t\t},\r\n\r\n\t\t\tShaderDeferredCommon[ 'commonUniforms' ]\r\n\r\n\t\t),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D samplerNormalDepth;\",\r\n\t\t\t\"uniform sampler2D samplerColor;\",\r\n\r\n\t\t\t\"uniform float viewHeight;\",\r\n\t\t\t\"uniform float viewWidth;\",\r\n\r\n\t\t\t\"uniform vec3 lightColor;\",\r\n\t\t\t\"uniform vec3 lightPositionVS;\",\r\n\t\t\t\"uniform float lightIntensity;\",\r\n\t\t\t\"uniform float lightRadius;\",\r\n\r\n\t\t\t\"uniform mat4 matProjInverse;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"unpackFloat\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeTextureCoord\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackNormalDepth\" ],\r\n\t\t\tDeferredShaderChunk[ \"computeVertexPositionVS\" ],\r\n\r\n\t\t\t\"\tvec3 lightVector = lightPositionVS - vertexPositionVS.xyz;\",\r\n\t\t\t\"\tfloat distance = length( lightVector );\",\r\n\r\n\t\t\t\"\tif ( distance > lightRadius ) discard;\",\r\n\r\n\t\t\t\"\tlightVector = normalize( lightVector );\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"unpackColor\" ],\r\n\t\t\tDeferredShaderChunk[ \"computeSpecular\" ],\r\n\r\n\t\t\t\"\t//float cutoff = 0.3;\",\r\n\t\t\t\"\t//float denom = distance / lightRadius + 1.0;\",\r\n\t\t\t\"\t//float attenuation = 1.0 / ( denom * denom );\",\r\n\t\t\t\"\t//attenuation = ( attenuation - cutoff ) / ( 1.0 - cutoff );\",\r\n\t\t\t\"\t//attenuation = max( attenuation, 0.0 );\",\r\n\t\t\t\"\t//attenuation *= attenuation;\",\r\n\r\n\t\t\t\"\t//diffuseColor *= saturate( -distance / lightRadius + 1.0 );\",\r\n\t\t\t\"\t//float attenuation = 1.0;\",\r\n\r\n\t\t\t\"\tfloat attenuation = saturate( -distance / lightRadius + 1.0 );\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"combine\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\tspotLight: {\r\n\r\n\t\tuniforms: Object.assign(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tsamplerNormalDepth: new Uniform( null ),\r\n\t\t\t\tsamplerColor: new Uniform( null ),\r\n\r\n\t\t\t\tlightColor: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\t\tlightDirectionVS: new Uniform( new Vector3( 0, 1, 0 ) ),\r\n\t\t\t\tlightPositionVS: new Uniform( new Vector3( 0, 1, 0 ) ),\r\n\t\t\t\tlightAngle: new Uniform( 1.0 ),\r\n\t\t\t\tlightIntensity: new Uniform( 1.0 )\r\n\r\n\t\t\t},\r\n\r\n\t\t\tShaderDeferredCommon[ 'commonUniforms' ]\r\n\r\n\t\t),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() { \",\r\n\r\n\t\t\t\"\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D samplerNormalDepth;\",\r\n\t\t\t\"uniform sampler2D samplerColor;\",\r\n\r\n\t\t\t\"uniform float viewHeight;\",\r\n\t\t\t\"uniform float viewWidth;\",\r\n\r\n\t\t\t\"uniform vec3 lightColor;\",\r\n\t\t\t\"uniform vec3 lightPositionVS;\",\r\n\t\t\t\"uniform vec3 lightDirectionVS;\",\r\n\t\t\t\"uniform float lightAngle;\",\r\n\t\t\t\"uniform float lightIntensity;\",\r\n\r\n\t\t\t\"uniform mat4 matProjInverse;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"unpackFloat\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeTextureCoord\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackNormalDepth\" ],\r\n\t\t\tDeferredShaderChunk[ \"computeVertexPositionVS\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackColor\" ],\r\n\r\n\t\t\t\"\tvec3 lightVector = normalize( lightPositionVS.xyz - vertexPositionVS.xyz );\",\r\n\r\n\t\t\t\"\tfloat rho = dot( lightDirectionVS, lightVector );\",\r\n\t\t\t\"\tfloat rhoMax = cos( lightAngle );\",\r\n\r\n\t\t\t\"\tif ( rho <= rhoMax ) discard;\",\r\n\r\n\t\t\t\"\tfloat theta = rhoMax + 0.0001;\",\r\n\t\t\t\"\tfloat phi = rhoMax + 0.05;\",\r\n\t\t\t\"\tfloat falloff = 4.0;\",\r\n\r\n\t\t\t\"\tfloat spot = 0.0;\",\r\n\r\n\t\t\t\"\tif ( rho >= phi ) {\",\r\n\r\n\t\t\t\"\t\tspot = 1.0;\",\r\n\r\n\t\t\t\"\t} else if ( rho <= theta ) {\",\r\n\r\n\t\t\t\"\t\tspot = 0.0;\",\r\n\r\n\t\t\t\"\t} else { \",\r\n\r\n\t\t\t\"\t\tspot = pow( ( rho - theta ) / ( phi - theta ), falloff );\",\r\n\r\n\t\t\t\"\t}\",\r\n\r\n\t\t\t\"\tdiffuseColor *= spot;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeSpecular\" ],\r\n\r\n\t\t\t\"\tconst float attenuation = 1.0;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"combine\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\tdirectionalLight: {\r\n\r\n\t\tuniforms: Object.assign(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tsamplerNormalDepth: new Uniform( null ),\r\n\t\t\t\tsamplerColor: new Uniform( null ),\r\n\r\n\t\t\t\tlightColor: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\t\tlightDirectionVS: new Uniform( new Vector3( 0, 1, 0 ) ),\r\n\t\t\t\tlightIntensity: new Uniform( 1.0 )\r\n\t\t\t},\r\n\r\n\t\t\tShaderDeferredCommon[ 'commonUniforms' ]\r\n\r\n\t\t),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() { \",\r\n\r\n\t\t\t\"\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( '\\n' ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D samplerNormalDepth;\",\r\n\t\t\t\"uniform sampler2D samplerColor;\",\r\n\r\n\t\t\t\"uniform float viewHeight;\",\r\n\t\t\t\"uniform float viewWidth;\",\r\n\r\n\t\t\t\"uniform vec3 lightColor;\",\r\n\t\t\t\"uniform vec3 lightDirectionVS;\",\r\n\t\t\t\"uniform float lightIntensity;\",\r\n\r\n\t\t\t\"uniform mat4 matProjInverse;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"unpackFloat\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeTextureCoord\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackNormalDepth\" ],\r\n\t\t\tDeferredShaderChunk[ \"computeVertexPositionVS\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackColor\" ],\r\n\r\n\t\t\t\"\tvec3 lightVector = normalize( lightDirectionVS );\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeSpecular\" ],\r\n\r\n\t\t\t\"\tconst float attenuation = 1.0;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"combine\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( '\\n' )\r\n\r\n\t},\r\n\r\n\tnormalDepthShininess: {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\tshininess: new Uniform( 30.0 )\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec4 vPosition;\",\r\n\r\n\t\t\t\"#include <morphtarget_pars_vertex>\",\r\n\t\t\t\"#include <skinning_pars_vertex>\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"#include <begin_vertex>\",\r\n\t\t\t\"#include <beginnormal_vertex>\",\r\n\t\t\t\"#include <skinbase_vertex>\",\r\n\t\t\t\"#include <skinnormal_vertex>\",\r\n\t\t\t\"#include <defaultnormal_vertex>\",\r\n\t\t\t\"#include <morphtarget_vertex>\",\r\n\t\t\t\"#include <skinning_vertex>\",\r\n\t\t\t\"#include <project_vertex>\",\r\n\r\n\t\t\t\"\tvNormal = normalize( transformedNormal );\",\r\n\t\t\t\"\tvPosition = gl_Position;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec4 vPosition;\",\r\n\r\n\t\t\t\"uniform float shininess;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"packNormal\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec3 normal = vNormal;\",\r\n\t\t\t\"\tvec4 position = vPosition;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"packNormalDepthShininess\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = packedNormalDepthShininess;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\tpointLightPre: {\r\n\r\n\t\tuniforms: Object.assign(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tsamplerNormalDepthShininess: new Uniform( null ),\r\n\r\n\t\t\t\tlightColor: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\t\tlightPositionVS: new Uniform( new Vector3( 0, 1, 0 ) ),\r\n\t\t\t\tlightIntensity: new Uniform( 1.0 ),\r\n\t\t\t\tlightRadius: new Uniform( 1.0 )\r\n\t\t\t},\r\n\r\n\t\t\tShaderDeferredCommon[ 'commonUniforms' ]\r\n\r\n\t\t),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D samplerNormalDepthShininess;\",\r\n\r\n\t\t\t\"uniform float viewHeight;\",\r\n\t\t\t\"uniform float viewWidth;\",\r\n\r\n\t\t\t\"uniform vec3 lightColor;\",\r\n\t\t\t\"uniform vec3 lightPositionVS;\",\r\n\t\t\t\"uniform float lightIntensity;\",\r\n\t\t\t\"uniform float lightRadius;\",\r\n\r\n\t\t\t\"uniform mat4 matProjInverse;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"unpackFloat\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackVector2\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeTextureCoord\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackNormalDepthShininess\" ],\r\n\t\t\tDeferredShaderChunk[ \"computeVertexPositionVS\" ],\r\n\r\n\t\t\t\"\tvec3 lightVector = lightPositionVS - vertexPositionVS.xyz;\",\r\n\t\t\t\"\tfloat distance = length( lightVector );\",\r\n\r\n\t\t\t\"\tif ( distance > lightRadius ) discard;\",\r\n\r\n\t\t\t\"\tlightVector = normalize( lightVector );\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeSpecular\" ],\r\n\r\n\t\t\t\"\tfloat attenuation = saturate( -distance / lightRadius + 1.0 );\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"packLight\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = packedLight;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\tspotLightPre: {\r\n\r\n\t\tuniforms: Object.assign(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tsamplerNormalDepthShininess: new Uniform( null ),\r\n\r\n\t\t\t\tlightColor: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\t\tlightDirectionVS: new Uniform( new Vector3( 0, 1, 0 ) ),\r\n\t\t\t\tlightPositionVS: new Uniform( new Vector3( 0, 1, 0 ) ),\r\n\t\t\t\tlightAngle: new Uniform( 1.0 ),\r\n\t\t\t\tlightIntensity: new Uniform( 1.0 )\r\n\r\n\t\t\t},\r\n\r\n\t\t\tShaderDeferredCommon[ 'commonUniforms' ]\r\n\r\n\t\t),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() { \",\r\n\r\n\t\t\t\"\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D samplerNormalDepthShininess;\",\r\n\r\n\t\t\t\"uniform float viewHeight;\",\r\n\t\t\t\"uniform float viewWidth;\",\r\n\r\n\t\t\t\"uniform vec3 lightColor;\",\r\n\t\t\t\"uniform vec3 lightPositionVS;\",\r\n\t\t\t\"uniform vec3 lightDirectionVS;\",\r\n\t\t\t\"uniform float lightAngle;\",\r\n\t\t\t\"uniform float lightIntensity;\",\r\n\r\n\t\t\t\"uniform mat4 matProjInverse;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"unpackFloat\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackVector2\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeTextureCoord\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackNormalDepthShininess\" ],\r\n\t\t\tDeferredShaderChunk[ \"computeVertexPositionVS\" ],\r\n\r\n\t\t\t\"\tvec3 lightVector = normalize( lightPositionVS.xyz - vertexPositionVS.xyz );\",\r\n\r\n\t\t\t\"\tfloat rho = dot( lightDirectionVS, lightVector );\",\r\n\t\t\t\"\tfloat rhoMax = cos( lightAngle );\",\r\n\r\n\t\t\t\"\tif ( rho <= rhoMax ) discard;\",\r\n\r\n\t\t\t\"\tfloat theta = rhoMax + 0.0001;\",\r\n\t\t\t\"\tfloat phi = rhoMax + 0.05;\",\r\n\t\t\t\"\tfloat falloff = 4.0;\",\r\n\r\n\t\t\t\"\tfloat spot = 0.0;\",\r\n\r\n\t\t\t\"\tif ( rho >= phi ) {\",\r\n\r\n\t\t\t\"\t\tspot = 1.0;\",\r\n\r\n\t\t\t\"\t} else if ( rho <= theta ) {\",\r\n\r\n\t\t\t\"\t\tspot = 0.0;\",\r\n\r\n\t\t\t\"\t} else { \",\r\n\r\n\t\t\t\"\t\tspot = pow( ( rho - theta ) / ( phi - theta ), falloff );\",\r\n\r\n\t\t\t\"\t}\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeSpecular\" ],\r\n\r\n\t\t\t\"\tconst float attenuation = 1.0;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"packLight\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = spot * packedLight;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\tdirectionalLightPre: {\r\n\r\n\t\tuniforms: Object.assign(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tsamplerNormalDepthShininess: new Uniform( null ),\r\n\r\n\t\t\t\tlightColor: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\t\tlightDirectionVS: new Uniform( new Vector3( 0, 1, 0 ) ),\r\n\t\t\t\tlightIntensity: new Uniform( 1.0 )\r\n\r\n\t\t\t},\r\n\r\n\t\t\tShaderDeferredCommon[ 'commonUniforms' ]\r\n\r\n\t\t),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() { \",\r\n\r\n\t\t\t\"\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( '\\n' ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D samplerNormalDepthShininess;\",\r\n\r\n\t\t\t\"uniform float viewHeight;\",\r\n\t\t\t\"uniform float viewWidth;\",\r\n\r\n\t\t\t\"uniform vec3 lightColor;\",\r\n\t\t\t\"uniform vec3 lightDirectionVS;\",\r\n\t\t\t\"uniform float lightIntensity;\",\r\n\r\n\t\t\t\"uniform mat4 matProjInverse;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"unpackFloat\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackVector2\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeTextureCoord\" ],\r\n\t\t\tDeferredShaderChunk[ \"unpackNormalDepthShininess\" ],\r\n\t\t\tDeferredShaderChunk[ \"computeVertexPositionVS\" ],\r\n\r\n\t\t\t\"\tvec3 lightVector = normalize( lightDirectionVS );\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeSpecular\" ],\r\n\r\n\t\t\t\"\tconst float attenuation = 1.0;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"packLight\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = packedLight;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( '\\n' )\r\n\r\n\t},\r\n\r\n\treconstruction: {\r\n\r\n\t\tuniforms: Object.assign(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tsamplerLight: new Uniform( null ),\r\n\r\n\t\t\t\tmap: new Uniform( null ),\r\n\t\t\t\toffsetRepeat: new Uniform( new Vector4( 0, 0, 1, 1 ) ),\r\n\r\n\t\t\t\tdiffuse: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\t\temissive: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\t\tspecular: new Uniform( new Color( 0x000000 ) ),\r\n\t\t\t\tshininess: new Uniform( 30.0 )\r\n\r\n\t\t\t},\r\n\r\n\t\t\tShaderDeferredCommon[ 'commonUniforms' ]\r\n\r\n\t\t),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#include <uv_pars_vertex>\",\r\n\t\t\t\"#include <morphtarget_pars_vertex>\",\r\n\t\t\t\"#include <skinning_pars_vertex>\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"#include <uv_vertex>\",\r\n\t\t\t\"#include <begin_vertex>\",\r\n\t\t\t\"#include <beginnormal_vertex>\",\r\n\t\t\t\"#include <skinbase_vertex>\",\r\n\t\t\t\"#include <skinnormal_vertex>\",\r\n\t\t\t\"#include <defaultnormal_vertex>\",\r\n\t\t\t\"#include <morphtarget_vertex>\",\r\n\t\t\t\"#include <skinning_vertex>\",\r\n\t\t\t\"#include <project_vertex>\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D samplerLight;\",\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float shininess;\",\r\n\r\n\t\t\t\"uniform float viewHeight;\",\r\n\t\t\t\"uniform float viewWidth;\",\r\n\r\n\t\t\t\"#include <uv_pars_fragment>\",\r\n\t\t\t\"#include <map_pars_fragment>\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"unpackFloat\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, 1.0 );\",\r\n\t\t\t\"\tvec3 emissiveColor = emissive;\",\r\n\t\t\t\"\tvec3 specularColor = specular;\",\r\n\r\n\t\t\tDeferredShaderChunk[ \"computeTextureCoord\" ],\r\n\r\n\t\t\t\"\tvec4 light = texture2D( samplerLight, texCoord );\",\r\n\r\n\t\t\t\"#include <map_fragment>\",\r\n\r\n\t\t\t\"\tvec3 diffuseFinal = diffuseColor.rgb * light.rgb;\",\r\n\t\t\t\"\tvec3 emissiveFinal = emissiveColor;\",\r\n\t\t\t\"\tvec3 specularFinal = specularColor * light.rgb * light.a;\",\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( diffuseFinal + emissiveFinal + specularFinal, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\t// TODO: implement tone mapping\r\n\tfinal: {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\tsamplerResult: new Uniform( null )\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 texCoord;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec4 pos = vec4( sign( position.xy ), 0.0, 1.0 );\",\r\n\t\t\t\"\ttexCoord = pos.xy * vec2( 0.5 ) + 0.5;\",\r\n\t\t\t\"\tgl_Position = pos;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"varying vec2 texCoord;\",\r\n\t\t\t\"uniform sampler2D samplerResult;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tgl_FragColor = texture2D( samplerResult, texCoord );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction RollerCoasterGeometry( curve, divisions ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar colors = [];\r\n\r\n\tvar color1 = [ 1, 1, 1 ];\r\n\tvar color2 = [ 1, 1, 0 ];\r\n\r\n\tvar up = new Vector3( 0, 1, 0 );\r\n\tvar forward = new Vector3();\r\n\tvar right = new Vector3();\r\n\r\n\tvar quaternion = new Quaternion();\r\n\tvar prevQuaternion = new Quaternion();\r\n\tprevQuaternion.setFromAxisAngle( up, Math.PI / 2 );\r\n\r\n\tvar point = new Vector3();\r\n\tvar prevPoint = new Vector3();\r\n\tprevPoint.copy( curve.getPointAt( 0 ) );\r\n\r\n\t// shapes\r\n\r\n\tvar step = [\r\n\t\tnew Vector3( - 0.225, 0, 0 ),\r\n\t\tnew Vector3( 0, - 0.050, 0 ),\r\n\t\tnew Vector3( 0, - 0.175, 0 ),\r\n\r\n\t\tnew Vector3( 0, - 0.050, 0 ),\r\n\t\tnew Vector3( 0.225, 0, 0 ),\r\n\t\tnew Vector3( 0, - 0.175, 0 )\r\n\t];\r\n\r\n\tvar PI2 = Math.PI * 2;\r\n\r\n\tvar sides = 5;\r\n\tvar tube1 = [];\r\n\r\n\tfor ( var i = 0; i < sides; i ++ ) {\r\n\r\n\t\tvar angle = ( i / sides ) * PI2;\r\n\t\ttube1.push( new Vector3( Math.sin( angle ) * 0.06, Math.cos( angle ) * 0.06, 0 ) );\r\n\r\n\t}\r\n\r\n\tvar sides = 6;\r\n\tvar tube2 = [];\r\n\r\n\tfor ( var i = 0; i < sides; i ++ ) {\r\n\r\n\t\tvar angle = ( i / sides ) * PI2;\r\n\t\ttube2.push( new Vector3( Math.sin( angle ) * 0.025, Math.cos( angle ) * 0.025, 0 ) );\r\n\r\n\t}\r\n\r\n\tvar vector = new Vector3();\r\n\tvar normal = new Vector3();\r\n\r\n\tfunction drawShape( shape, color ) {\r\n\r\n\t\tnormal.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n\t\tfor ( var j = 0; j < shape.length; j ++ ) {\r\n\r\n\t\t\tvector.copy( shape[ j ] );\r\n\t\t\tvector.applyQuaternion( quaternion );\r\n\t\t\tvector.add( point );\r\n\r\n\t\t\tvertices.push( vector.x, vector.y, vector.z );\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\t\t\tcolors.push( color[ 0 ], color[ 1 ], color[ 2 ] );\r\n\r\n\t\t}\r\n\r\n\t\tnormal.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\r\n\t\tfor ( var j = shape.length - 1; j >= 0; j -- ) {\r\n\r\n\t\t\tvector.copy( shape[ j ] );\r\n\t\t\tvector.applyQuaternion( quaternion );\r\n\t\t\tvector.add( point );\r\n\r\n\t\t\tvertices.push( vector.x, vector.y, vector.z );\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\t\t\tcolors.push( color[ 0 ], color[ 1 ], color[ 2 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar vector1 = new Vector3();\r\n\tvar vector2 = new Vector3();\r\n\tvar vector3 = new Vector3();\r\n\tvar vector4 = new Vector3();\r\n\r\n\tvar normal1 = new Vector3();\r\n\tvar normal2 = new Vector3();\r\n\tvar normal3 = new Vector3();\r\n\tvar normal4 = new Vector3();\r\n\r\n\tfunction extrudeShape( shape, offset, color ) {\r\n\r\n\t\tfor ( var j = 0, jl = shape.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar point1 = shape[ j ];\r\n\t\t\tvar point2 = shape[ ( j + 1 ) % jl ];\r\n\r\n\t\t\tvector1.copy( point1 ).add( offset );\r\n\t\t\tvector1.applyQuaternion( quaternion );\r\n\t\t\tvector1.add( point );\r\n\r\n\t\t\tvector2.copy( point2 ).add( offset );\r\n\t\t\tvector2.applyQuaternion( quaternion );\r\n\t\t\tvector2.add( point );\r\n\r\n\t\t\tvector3.copy( point2 ).add( offset );\r\n\t\t\tvector3.applyQuaternion( prevQuaternion );\r\n\t\t\tvector3.add( prevPoint );\r\n\r\n\t\t\tvector4.copy( point1 ).add( offset );\r\n\t\t\tvector4.applyQuaternion( prevQuaternion );\r\n\t\t\tvector4.add( prevPoint );\r\n\r\n\t\t\tvertices.push( vector1.x, vector1.y, vector1.z );\r\n\t\t\tvertices.push( vector2.x, vector2.y, vector2.z );\r\n\t\t\tvertices.push( vector4.x, vector4.y, vector4.z );\r\n\r\n\t\t\tvertices.push( vector2.x, vector2.y, vector2.z );\r\n\t\t\tvertices.push( vector3.x, vector3.y, vector3.z );\r\n\t\t\tvertices.push( vector4.x, vector4.y, vector4.z );\r\n\r\n\t\t\t//\r\n\r\n\t\t\tnormal1.copy( point1 );\r\n\t\t\tnormal1.applyQuaternion( quaternion );\r\n\t\t\tnormal1.normalize();\r\n\r\n\t\t\tnormal2.copy( point2 );\r\n\t\t\tnormal2.applyQuaternion( quaternion );\r\n\t\t\tnormal2.normalize();\r\n\r\n\t\t\tnormal3.copy( point2 );\r\n\t\t\tnormal3.applyQuaternion( prevQuaternion );\r\n\t\t\tnormal3.normalize();\r\n\r\n\t\t\tnormal4.copy( point1 );\r\n\t\t\tnormal4.applyQuaternion( prevQuaternion );\r\n\t\t\tnormal4.normalize();\r\n\r\n\t\t\tnormals.push( normal1.x, normal1.y, normal1.z );\r\n\t\t\tnormals.push( normal2.x, normal2.y, normal2.z );\r\n\t\t\tnormals.push( normal4.x, normal4.y, normal4.z );\r\n\r\n\t\t\tnormals.push( normal2.x, normal2.y, normal2.z );\r\n\t\t\tnormals.push( normal3.x, normal3.y, normal3.z );\r\n\t\t\tnormals.push( normal4.x, normal4.y, normal4.z );\r\n\r\n\t\t\tcolors.push( color[ 0 ], color[ 1 ], color[ 2 ] );\r\n\t\t\tcolors.push( color[ 0 ], color[ 1 ], color[ 2 ] );\r\n\t\t\tcolors.push( color[ 0 ], color[ 1 ], color[ 2 ] );\r\n\r\n\t\t\tcolors.push( color[ 0 ], color[ 1 ], color[ 2 ] );\r\n\t\t\tcolors.push( color[ 0 ], color[ 1 ], color[ 2 ] );\r\n\t\t\tcolors.push( color[ 0 ], color[ 1 ], color[ 2 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar offset = new Vector3();\r\n\r\n\tfor ( var i = 1; i <= divisions; i ++ ) {\r\n\r\n\t\tpoint.copy( curve.getPointAt( i / divisions ) );\r\n\r\n\t\tup.set( 0, 1, 0 );\r\n\r\n\t\tforward.subVectors( point, prevPoint ).normalize();\r\n\t\tright.crossVectors( up, forward ).normalize();\r\n\t\tup.crossVectors( forward, right );\r\n\r\n\t\tvar angle = Math.atan2( forward.x, forward.z );\r\n\r\n\t\tquaternion.setFromAxisAngle( up, angle );\r\n\r\n\t\tif ( i % 2 === 0 ) {\r\n\r\n\t\t\tdrawShape( step, color2 );\r\n\r\n\t\t}\r\n\r\n\t\textrudeShape( tube1, offset.set( 0, - 0.125, 0 ), color2 );\r\n\t\textrudeShape( tube2, offset.set( 0.2, 0, 0 ), color1 );\r\n\t\textrudeShape( tube2, offset.set( - 0.2, 0, 0 ), color1 );\r\n\r\n\t\tprevPoint.copy( point );\r\n\t\tprevQuaternion.copy( quaternion );\r\n\r\n\t}\r\n\r\n\t// console.log( vertices.length );\r\n\r\n\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );\r\n\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3 ) );\r\n\tthis.addAttribute( 'color', new BufferAttribute( new Float32Array( colors ), 3 ) );\r\n\r\n}\r\n\r\nRollerCoasterGeometry.prototype = Object.create( BufferGeometry.prototype );\r\n\r\nfunction RollerCoasterLiftersGeometry( curve, divisions ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\r\n\tvar quaternion = new Quaternion();\r\n\r\n\tvar up = new Vector3( 0, 1, 0 );\r\n\r\n\tvar point = new Vector3();\r\n\tvar tangent = new Vector3();\r\n\r\n\t// shapes\r\n\r\n\tvar tube1 = [\r\n\t\tnew Vector3( 0, 0.05, - 0.05 ),\r\n\t\tnew Vector3( 0, 0.05, 0.05 ),\r\n\t\tnew Vector3( 0, - 0.05, 0 )\r\n\t];\r\n\r\n\tvar tube2 = [\r\n\t\tnew Vector3( - 0.05, 0, 0.05 ),\r\n\t\tnew Vector3( - 0.05, 0, - 0.05 ),\r\n\t\tnew Vector3( 0.05, 0, 0 )\r\n\t];\r\n\r\n\tvar tube3 = [\r\n\t\tnew Vector3( 0.05, 0, - 0.05 ),\r\n\t\tnew Vector3( 0.05, 0, 0.05 ),\r\n\t\tnew Vector3( - 0.05, 0, 0 )\r\n\t];\r\n\r\n\tvar vector1 = new Vector3();\r\n\tvar vector2 = new Vector3();\r\n\tvar vector3 = new Vector3();\r\n\tvar vector4 = new Vector3();\r\n\r\n\tvar normal1 = new Vector3();\r\n\tvar normal2 = new Vector3();\r\n\tvar normal3 = new Vector3();\r\n\tvar normal4 = new Vector3();\r\n\r\n\tfunction extrudeShape( shape, fromPoint, toPoint ) {\r\n\r\n\t\tfor ( var j = 0, jl = shape.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar point1 = shape[ j ];\r\n\t\t\tvar point2 = shape[ ( j + 1 ) % jl ];\r\n\r\n\t\t\tvector1.copy( point1 );\r\n\t\t\tvector1.applyQuaternion( quaternion );\r\n\t\t\tvector1.add( fromPoint );\r\n\r\n\t\t\tvector2.copy( point2 );\r\n\t\t\tvector2.applyQuaternion( quaternion );\r\n\t\t\tvector2.add( fromPoint );\r\n\r\n\t\t\tvector3.copy( point2 );\r\n\t\t\tvector3.applyQuaternion( quaternion );\r\n\t\t\tvector3.add( toPoint );\r\n\r\n\t\t\tvector4.copy( point1 );\r\n\t\t\tvector4.applyQuaternion( quaternion );\r\n\t\t\tvector4.add( toPoint );\r\n\r\n\t\t\tvertices.push( vector1.x, vector1.y, vector1.z );\r\n\t\t\tvertices.push( vector2.x, vector2.y, vector2.z );\r\n\t\t\tvertices.push( vector4.x, vector4.y, vector4.z );\r\n\r\n\t\t\tvertices.push( vector2.x, vector2.y, vector2.z );\r\n\t\t\tvertices.push( vector3.x, vector3.y, vector3.z );\r\n\t\t\tvertices.push( vector4.x, vector4.y, vector4.z );\r\n\r\n\t\t\t//\r\n\r\n\t\t\tnormal1.copy( point1 );\r\n\t\t\tnormal1.applyQuaternion( quaternion );\r\n\t\t\tnormal1.normalize();\r\n\r\n\t\t\tnormal2.copy( point2 );\r\n\t\t\tnormal2.applyQuaternion( quaternion );\r\n\t\t\tnormal2.normalize();\r\n\r\n\t\t\tnormal3.copy( point2 );\r\n\t\t\tnormal3.applyQuaternion( quaternion );\r\n\t\t\tnormal3.normalize();\r\n\r\n\t\t\tnormal4.copy( point1 );\r\n\t\t\tnormal4.applyQuaternion( quaternion );\r\n\t\t\tnormal4.normalize();\r\n\r\n\t\t\tnormals.push( normal1.x, normal1.y, normal1.z );\r\n\t\t\tnormals.push( normal2.x, normal2.y, normal2.z );\r\n\t\t\tnormals.push( normal4.x, normal4.y, normal4.z );\r\n\r\n\t\t\tnormals.push( normal2.x, normal2.y, normal2.z );\r\n\t\t\tnormals.push( normal3.x, normal3.y, normal3.z );\r\n\t\t\tnormals.push( normal4.x, normal4.y, normal4.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar fromPoint = new Vector3();\r\n\tvar toPoint = new Vector3();\r\n\r\n\tfor ( var i = 1; i <= divisions; i ++ ) {\r\n\r\n\t\tpoint.copy( curve.getPointAt( i / divisions ) );\r\n\t\ttangent.copy( curve.getTangentAt( i / divisions ) );\r\n\r\n\t\tvar angle = Math.atan2( tangent.x, tangent.z );\r\n\r\n\t\tquaternion.setFromAxisAngle( up, angle );\r\n\r\n\t\t//\r\n\r\n\t\tif ( point.y > 10 ) {\r\n\r\n\t\t\tfromPoint.set( - 0.75, - 0.35, 0 );\r\n\t\t\tfromPoint.applyQuaternion( quaternion );\r\n\t\t\tfromPoint.add( point );\r\n\r\n\t\t\ttoPoint.set( 0.75, - 0.35, 0 );\r\n\t\t\ttoPoint.applyQuaternion( quaternion );\r\n\t\t\ttoPoint.add( point );\r\n\r\n\t\t\textrudeShape( tube1, fromPoint, toPoint );\r\n\r\n\t\t\tfromPoint.set( - 0.7, - 0.3, 0 );\r\n\t\t\tfromPoint.applyQuaternion( quaternion );\r\n\t\t\tfromPoint.add( point );\r\n\r\n\t\t\ttoPoint.set( - 0.7, - point.y, 0 );\r\n\t\t\ttoPoint.applyQuaternion( quaternion );\r\n\t\t\ttoPoint.add( point );\r\n\r\n\t\t\textrudeShape( tube2, fromPoint, toPoint );\r\n\r\n\t\t\tfromPoint.set( 0.7, - 0.3, 0 );\r\n\t\t\tfromPoint.applyQuaternion( quaternion );\r\n\t\t\tfromPoint.add( point );\r\n\r\n\t\t\ttoPoint.set( 0.7, - point.y, 0 );\r\n\t\t\ttoPoint.applyQuaternion( quaternion );\r\n\t\t\ttoPoint.add( point );\r\n\r\n\t\t\textrudeShape( tube3, fromPoint, toPoint );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfromPoint.set( 0, - 0.2, 0 );\r\n\t\t\tfromPoint.applyQuaternion( quaternion );\r\n\t\t\tfromPoint.add( point );\r\n\r\n\t\t\ttoPoint.set( 0, - point.y, 0 );\r\n\t\t\ttoPoint.applyQuaternion( quaternion );\r\n\t\t\ttoPoint.add( point );\r\n\r\n\t\t\textrudeShape( tube3, fromPoint, toPoint );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );\r\n\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3 ) );\r\n\r\n}\r\n\r\nRollerCoasterLiftersGeometry.prototype = Object.create( BufferGeometry.prototype );\r\n\r\nfunction RollerCoasterShadowGeometry( curve, divisions ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tvar vertices = [];\r\n\r\n\tvar up = new Vector3( 0, 1, 0 );\r\n\tvar forward = new Vector3();\r\n\r\n\tvar quaternion = new Quaternion();\r\n\tvar prevQuaternion = new Quaternion();\r\n\tprevQuaternion.setFromAxisAngle( up, Math.PI / 2 );\r\n\r\n\tvar point = new Vector3();\r\n\r\n\tvar prevPoint = new Vector3();\r\n\tprevPoint.copy( curve.getPointAt( 0 ) );\r\n\tprevPoint.y = 0;\r\n\r\n\tvar vector1 = new Vector3();\r\n\tvar vector2 = new Vector3();\r\n\tvar vector3 = new Vector3();\r\n\tvar vector4 = new Vector3();\r\n\r\n\tfor ( var i = 1; i <= divisions; i ++ ) {\r\n\r\n\t\tpoint.copy( curve.getPointAt( i / divisions ) );\r\n\t\tpoint.y = 0;\r\n\r\n\t\tforward.subVectors( point, prevPoint );\r\n\r\n\t\tvar angle = Math.atan2( forward.x, forward.z );\r\n\r\n\t\tquaternion.setFromAxisAngle( up, angle );\r\n\r\n\t\tvector1.set( - 0.3, 0, 0 );\r\n\t\tvector1.applyQuaternion( quaternion );\r\n\t\tvector1.add( point );\r\n\r\n\t\tvector2.set( 0.3, 0, 0 );\r\n\t\tvector2.applyQuaternion( quaternion );\r\n\t\tvector2.add( point );\r\n\r\n\t\tvector3.set( 0.3, 0, 0 );\r\n\t\tvector3.applyQuaternion( prevQuaternion );\r\n\t\tvector3.add( prevPoint );\r\n\r\n\t\tvector4.set( - 0.3, 0, 0 );\r\n\t\tvector4.applyQuaternion( prevQuaternion );\r\n\t\tvector4.add( prevPoint );\r\n\r\n\t\tvertices.push( vector1.x, vector1.y, vector1.z );\r\n\t\tvertices.push( vector2.x, vector2.y, vector2.z );\r\n\t\tvertices.push( vector4.x, vector4.y, vector4.z );\r\n\r\n\t\tvertices.push( vector2.x, vector2.y, vector2.z );\r\n\t\tvertices.push( vector3.x, vector3.y, vector3.z );\r\n\t\tvertices.push( vector4.x, vector4.y, vector4.z );\r\n\r\n\t\tprevPoint.copy( point );\r\n\t\tprevQuaternion.copy( quaternion );\r\n\r\n\t}\r\n\r\n\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );\r\n\r\n}\r\n\r\nRollerCoasterShadowGeometry.prototype = Object.create( BufferGeometry.prototype );\r\n\r\nfunction SkyGeometry() {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tvar vertices = [];\r\n\r\n\tfor ( var i = 0; i < 100; i ++ ) {\r\n\r\n\t\tvar x = Math.random() * 800 - 400;\r\n\t\tvar y = Math.random() * 50 + 50;\r\n\t\tvar z = Math.random() * 800 - 400;\r\n\r\n\t\tvar size = Math.random() * 40 + 20;\r\n\r\n\t\tvertices.push( x - size, y, z - size );\r\n\t\tvertices.push( x + size, y, z - size );\r\n\t\tvertices.push( x - size, y, z + size );\r\n\r\n\t\tvertices.push( x + size, y, z - size );\r\n\t\tvertices.push( x + size, y, z + size );\r\n\t\tvertices.push( x - size, y, z + size );\r\n\r\n\t}\r\n\r\n\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );\r\n\r\n}\r\n\r\nSkyGeometry.prototype = Object.create( BufferGeometry.prototype );\r\n\r\nfunction TreesGeometry( landscape ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tvar vertices = [];\r\n\tvar colors = [];\r\n\r\n\tvar raycaster = new Raycaster();\r\n\traycaster.ray.direction.set( 0, - 1, 0 );\r\n\r\n\tfor ( var i = 0; i < 2000; i ++ ) {\r\n\r\n\t\tvar x = Math.random() * 500 - 250;\r\n\t\tvar z = Math.random() * 500 - 250;\r\n\r\n\t\traycaster.ray.origin.set( x, 50, z );\r\n\r\n\t\tvar intersections = raycaster.intersectObject( landscape );\r\n\r\n\t\tif ( intersections.length === 0 ) { continue; }\r\n\r\n\t\tvar y = intersections[ 0 ].point.y;\r\n\r\n\t\tvar height = Math.random() * 5 + 0.5;\r\n\r\n\t\tvar angle = Math.random() * Math.PI * 2;\r\n\r\n\t\tvertices.push( x + Math.sin( angle ), y, z + Math.cos( angle ) );\r\n\t\tvertices.push( x, y + height, z );\r\n\t\tvertices.push( x + Math.sin( angle + Math.PI ), y, z + Math.cos( angle + Math.PI ) );\r\n\r\n\t\tangle += Math.PI / 2;\r\n\r\n\t\tvertices.push( x + Math.sin( angle ), y, z + Math.cos( angle ) );\r\n\t\tvertices.push( x, y + height, z );\r\n\t\tvertices.push( x + Math.sin( angle + Math.PI ), y, z + Math.cos( angle + Math.PI ) );\r\n\r\n\t\tvar random = Math.random() * 0.1;\r\n\r\n\t\tfor ( var j = 0; j < 6; j ++ ) {\r\n\r\n\t\t\tcolors.push( 0.2 + random, 0.4 + random, 0 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );\r\n\tthis.addAttribute( 'color', new BufferAttribute( new Float32Array( colors ), 3 ) );\r\n\r\n}\r\n\r\nTreesGeometry.prototype = Object.create( BufferGeometry.prototype );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ShaderGodRays = {\r\n\r\n\t'godrays_depthMask': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttInput: {\r\n\t\t\t\tvalue: null\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\" vUv = uv;\",\r\n\t\t\t\" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"uniform sampler2D tInput;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\t'godrays_generate': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttInput: {\r\n\t\t\t\tvalue: null\r\n\t\t\t},\r\n\t\t\tfStepSize: {\r\n\t\t\t\tvalue: 1.0\r\n\t\t\t},\r\n\t\t\tvSunPositionScreenSpace: {\r\n\t\t\t\tvalue: new Vector2( 0.5, 0.5 )\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"#define TAPS_PER_PASS 6.0\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"uniform sampler2D tInput;\",\r\n\r\n\t\t\t\"uniform vec2 vSunPositionScreenSpace;\",\r\n\t\t\t\"uniform float fStepSize;\", // filter step size\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// delta from current pixel to \"sun\" position\r\n\r\n\t\t\t\t\"vec2 delta = vSunPositionScreenSpace - vUv;\",\r\n\t\t\t\t\"float dist = length( delta );\",\r\n\r\n\t\t\t\t// Step vector (uv space)\r\n\r\n\t\t\t\t\"vec2 stepv = fStepSize * delta / dist;\",\r\n\r\n\t\t\t\t// Number of iterations between pixel and sun\r\n\r\n\t\t\t\t\"float iters = dist/fStepSize;\",\r\n\r\n\t\t\t\t\"vec2 uv = vUv.xy;\",\r\n\t\t\t\t\"float col = 0.0;\",\r\n\r\n\t\t\t\t// This breaks ANGLE in Chrome 22\r\n\t\t\t\t//\t- see http://code.google.com/p/chromium/issues/detail?id=153105\r\n\r\n\t\t\t\t// Unrolling loop manually makes it work in ANGLE\r\n\r\n\t\t\t\t\"if ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\r\n\t\t\t\t\"uv += stepv;\",\r\n\r\n\t\t\t\t\"if ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\r\n\t\t\t\t\"uv += stepv;\",\r\n\r\n\t\t\t\t\"if ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\r\n\t\t\t\t\"uv += stepv;\",\r\n\r\n\t\t\t\t\"if ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\r\n\t\t\t\t\"uv += stepv;\",\r\n\r\n\t\t\t\t\"if ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\r\n\t\t\t\t\"uv += stepv;\",\r\n\r\n\t\t\t\t\"if ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\r\n\t\t\t\t\"uv += stepv;\",\r\n\r\n\t\t\t\t// Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\r\n\t\t\t\t// objectionable artifacts, in particular near the sun position. The side\r\n\t\t\t\t// effect is that the result is darker than it should be around the sun, as\r\n\t\t\t\t// TAPS_PER_PASS is greater than the number of samples actually accumulated.\r\n\t\t\t\t// When the result is inverted (in the shader 'godrays_combine', this produces\r\n\t\t\t\t// a slight bright spot at the position of the sun, even when it is occluded.\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( col/TAPS_PER_PASS );\",\r\n\t\t\t\t\"gl_FragColor.a = 1.0;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\t'godrays_combine': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\ttColors: {\r\n\t\t\t\tvalue: null\r\n\t\t\t},\r\n\r\n\t\t\ttGodRays: {\r\n\t\t\t\tvalue: null\r\n\t\t\t},\r\n\r\n\t\t\tfGodRayIntensity: {\r\n\t\t\t\tvalue: 0.69\r\n\t\t\t},\r\n\r\n\t\t\tvSunPositionScreenSpace: {\r\n\t\t\t\tvalue: new Vector2( 0.5, 0.5 )\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"uniform sampler2D tColors;\",\r\n\t\t\t\"uniform sampler2D tGodRays;\",\r\n\r\n\t\t\t\"uniform vec2 vSunPositionScreenSpace;\",\r\n\t\t\t\"uniform float fGodRayIntensity;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// Since MeshDepthMaterial renders foreground objects white and background\r\n\t\t\t\t// objects black, the god-rays will be white streaks. Therefore value is inverted\r\n\t\t\t\t// before being combined with tColors\r\n\r\n\t\t\t\t\"gl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\",\r\n\t\t\t\t\"gl_FragColor.a = 1.0;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\t'godrays_fake_sun': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\tvSunPositionScreenSpace: {\r\n\t\t\t\tvalue: new Vector2( 0.5, 0.5 )\r\n\t\t\t},\r\n\r\n\t\t\tfAspect: {\r\n\t\t\t\tvalue: 1.0\r\n\t\t\t},\r\n\r\n\t\t\tsunColor: {\r\n\t\t\t\tvalue: new Color( 0xffee00 )\r\n\t\t\t},\r\n\r\n\t\t\tbgColor: {\r\n\t\t\t\tvalue: new Color( 0x000000 )\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"uniform vec2 vSunPositionScreenSpace;\",\r\n\t\t\t\"uniform float fAspect;\",\r\n\r\n\t\t\t\"uniform vec3 sunColor;\",\r\n\t\t\t\"uniform vec3 bgColor;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec2 diff = vUv - vSunPositionScreenSpace;\",\r\n\r\n\t\t\t\t// Correct for aspect ratio\r\n\r\n\t\t\t\t\"diff.x *= fAspect;\",\r\n\r\n\t\t\t\t\"float prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\",\r\n\t\t\t\t\"prop = 0.35 * pow( 1.0 - prop, 3.0 );\",\r\n\r\n\t\t\t\t\"gl_FragColor.xyz = mix( sunColor, bgColor, 1.0 - prop );\",\r\n\t\t\t\t\"gl_FragColor.w = 1.0;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BasicShader = {\r\n\r\n\tuniforms: {},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BleachBypassShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"opacity\":  { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float opacity;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 base = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\",\r\n\t\t\t\"float lum = dot( lumCoeff, base.rgb );\",\r\n\t\t\t\"vec3 blend = vec3( lum );\",\r\n\r\n\t\t\t\"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\",\r\n\r\n\t\t\t\"vec3 result1 = 2.0 * base.rgb * blend;\",\r\n\t\t\t\"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\",\r\n\r\n\t\t\t\"vec3 newColor = mix( result1, result2, L );\",\r\n\r\n\t\t\t\"float A2 = opacity * base.a;\",\r\n\t\t\t\"vec3 mixRGB = A2 * newColor.rgb;\",\r\n\t\t\t\"mixRGB += ( ( 1.0 - A2 ) * base.rgb );\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( mixRGB, base.a );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BlendShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse1\": { value: null },\r\n\t\t\"tDiffuse2\": { value: null },\r\n\t\t\"mixRatio\":  { value: 0.5 },\r\n\t\t\"opacity\":   { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float opacity;\",\r\n\t\t\"uniform float mixRatio;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse1;\",\r\n\t\t\"uniform sampler2D tDiffuse2;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texel1 = texture2D( tDiffuse1, vUv );\",\r\n\t\t\t\"vec4 texel2 = texture2D( tDiffuse2, vUv );\",\r\n\t\t\t\"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar BrightnessContrastShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":   { value: null },\r\n\t\t\"brightness\": { value: 0 },\r\n\t\t\"contrast\":   { value: 0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform float brightness;\",\r\n\t\t\"uniform float contrast;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\"gl_FragColor.rgb += brightness;\",\r\n\r\n\t\t\t\"if (contrast > 0.0) {\",\r\n\t\t\t\t\"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;\",\r\n\t\t\t\"} else {\",\r\n\t\t\t\t\"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ColorCorrectionShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"powRGB\":   { value: new Vector3( 2, 2, 2 ) },\r\n\t\t\"mulRGB\":   { value: new Vector3( 1, 1, 1 ) },\r\n\t\t\"addRGB\":   { value: new Vector3( 0, 0, 0 ) }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform vec3 powRGB;\",\r\n\t\t\"uniform vec3 mulRGB;\",\r\n\t\t\"uniform vec3 addRGB;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\"gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ColorifyShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"color\":    { value: new Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform vec3 color;\",\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\r\n\t\t\t\"float v = dot( texel.xyz, luma );\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( v * color, texel.w );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar DOFMipMapShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tColor\":   { value: null },\r\n\t\t\"tDepth\":   { value: null },\r\n\t\t\"focus\":    { value: 1.0 },\r\n\t\t\"maxblur\":  { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float focus;\",\r\n\t\t\"uniform float maxblur;\",\r\n\r\n\t\t\"uniform sampler2D tColor;\",\r\n\t\t\"uniform sampler2D tDepth;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 depth = texture2D( tDepth, vUv );\",\r\n\r\n\t\t\t\"float factor = depth.x - focus;\",\r\n\r\n\t\t\t\"vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );\",\r\n\r\n\t\t\t\"gl_FragColor = col;\",\r\n\t\t\t\"gl_FragColor.a = 1.0;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar FocusShader = {\r\n\r\n\tuniforms : {\r\n\r\n\t\t\"tDiffuse\":       { value: null },\r\n\t\t\"screenWidth\":    { value: 1024 },\r\n\t\t\"screenHeight\":   { value: 1024 },\r\n\t\t\"sampleDistance\": { value: 0.94 },\r\n\t\t\"waveFactor\":     { value: 0.00125 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float screenWidth;\",\r\n\t\t\"uniform float screenHeight;\",\r\n\t\t\"uniform float sampleDistance;\",\r\n\t\t\"uniform float waveFactor;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 color, org, tmp, add;\",\r\n\t\t\t\"float sample_dist, f;\",\r\n\t\t\t\"vec2 vin;\",\r\n\t\t\t\"vec2 uv = vUv;\",\r\n\r\n\t\t\t\"add = color = org = texture2D( tDiffuse, uv );\",\r\n\r\n\t\t\t\"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );\",\r\n\t\t\t\"sample_dist = dot( vin, vin ) * 2.0;\",\r\n\r\n\t\t\t\"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;\",\r\n\r\n\t\t\t\"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );\",\r\n\r\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );\",\r\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );\",\r\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );\",\r\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );\",\r\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );\",\r\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );\",\r\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );\",\r\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\r\n\r\n\t\t\t\"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );\",\r\n\t\t\t\"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar FreiChenShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"aspect\":    { value: new Vector2( 512, 512 ) }\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"uniform vec2 aspect;\",\r\n\r\n\t\t\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\r\n\r\n\t\t\"mat3 G[9];\",\r\n\r\n\t\t// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\r\n\r\n\t\t\"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\",\r\n\t\t\"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\",\r\n\t\t\"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\",\r\n\t\t\"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\",\r\n\t\t\"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\",\r\n\t\t\"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\",\r\n\t\t\"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\",\r\n\t\t\"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\",\r\n\t\t\"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\",\r\n\r\n\t\t\"void main(void)\",\r\n\t\t\"{\",\r\n\r\n\t\t\t\"G[0] = g0,\",\r\n\t\t\t\"G[1] = g1,\",\r\n\t\t\t\"G[2] = g2,\",\r\n\t\t\t\"G[3] = g3,\",\r\n\t\t\t\"G[4] = g4,\",\r\n\t\t\t\"G[5] = g5,\",\r\n\t\t\t\"G[6] = g6,\",\r\n\t\t\t\"G[7] = g7,\",\r\n\t\t\t\"G[8] = g8;\",\r\n\r\n\t\t\t\"mat3 I;\",\r\n\t\t\t\"float cnv[9];\",\r\n\t\t\t\"vec3 sample;\",\r\n\t\t\t\r\n\t\t\t\"for (float i=0.0; i<3.0; i++) {\",\r\n\t\t\t\t\"for (float j=0.0; j<3.0; j++) {\",\r\n\t\t\t\t\t\"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\r\n\t\t\t\t\t\"I[int(i)][int(j)] = length(sample);\",\r\n\t\t\t\t\"}\",\r\n\t\t\t\"}\",\r\n\t\t\t\r\n\t\t\t\"for (int i=0; i<9; i++) {\",\r\n\t\t\t\t\"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\r\n\t\t\t\t\"cnv[i] = dp3 * dp3;\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\",\r\n\t\t\t\"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\",\r\n\r\n\t\t\t\"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\",\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar FresnelShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"mRefractionRatio\": { value: 1.02 },\r\n\t\t\"mFresnelBias\": { value: 0.1 },\r\n\t\t\"mFresnelPower\": { value: 2.0 },\r\n\t\t\"mFresnelScale\": { value: 1.0 },\r\n\t\t\"tCube\": { value: null }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform float mRefractionRatio;\",\r\n\t\t\"uniform float mFresnelBias;\",\r\n\t\t\"uniform float mFresnelScale;\",\r\n\t\t\"uniform float mFresnelPower;\",\r\n\r\n\t\t\"varying vec3 vReflect;\",\r\n\t\t\"varying vec3 vRefract[3];\",\r\n\t\t\"varying float vReflectionFactor;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\",\r\n\r\n\t\t\t\"vec3 I = worldPosition.xyz - cameraPosition;\",\r\n\r\n\t\t\t\"vReflect = reflect( I, worldNormal );\",\r\n\t\t\t\"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\",\r\n\t\t\t\"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\",\r\n\t\t\t\"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\",\r\n\t\t\t\"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform samplerCube tCube;\",\r\n\r\n\t\t\"varying vec3 vReflect;\",\r\n\t\t\"varying vec3 vRefract[3];\",\r\n\t\t\"varying float vReflectionFactor;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\r\n\t\t\t\"vec4 refractedColor = vec4( 1.0 );\",\r\n\r\n\t\t\t\"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\",\r\n\t\t\t\"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\",\r\n\t\t\t\"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\",\r\n\r\n\t\t\t\"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar GammaCorrectionShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\",\r\n\r\n\t\t\t\"gl_FragColor = LinearToGamma( tex, float( GAMMA_FACTOR ) );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar HorizontalBlurShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"h\":        { value: 1.0 / 512.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform float h;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\r\n\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\",\r\n\r\n\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar HorizontalTiltShiftShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"h\":        { value: 1.0 / 512.0 },\r\n\t\t\"r\":        { value: 0.35 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform float h;\",\r\n\t\t\"uniform float r;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\r\n\r\n\t\t\t\"float hh = h * abs( r - vUv.y );\",\r\n\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;\",\r\n\r\n\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar HueSaturationShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":   { value: null },\r\n\t\t\"hue\":        { value: 0 },\r\n\t\t\"saturation\": { value: 0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform float hue;\",\r\n\t\t\"uniform float saturation;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t// hue\r\n\t\t\t\"float angle = hue * 3.14159265;\",\r\n\t\t\t\"float s = sin(angle), c = cos(angle);\",\r\n\t\t\t\"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\",\r\n\t\t\t\"float len = length(gl_FragColor.rgb);\",\r\n\t\t\t\"gl_FragColor.rgb = vec3(\",\r\n\t\t\t\t\"dot(gl_FragColor.rgb, weights.xyz),\",\r\n\t\t\t\t\"dot(gl_FragColor.rgb, weights.zxy),\",\r\n\t\t\t\t\"dot(gl_FragColor.rgb, weights.yzx)\",\r\n\t\t\t\");\",\r\n\r\n\t\t\t// saturation\r\n\t\t\t\"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\",\r\n\t\t\t\"if (saturation > 0.0) {\",\r\n\t\t\t\t\"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\",\r\n\t\t\t\"} else {\",\r\n\t\t\t\t\"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\",\r\n\t\t\t\"}\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar KaleidoShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"sides\":    { value: 6.0 },\r\n\t\t\"angle\":    { value: 0.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform float sides;\",\r\n\t\t\"uniform float angle;\",\r\n\t\t\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 p = vUv - 0.5;\",\r\n\t\t\t\"float r = length(p);\",\r\n\t\t\t\"float a = atan(p.y, p.x) + angle;\",\r\n\t\t\t\"float tau = 2. * 3.1416 ;\",\r\n\t\t\t\"a = mod(a, tau/sides);\",\r\n\t\t\t\"a = abs(a - tau/sides/2.) ;\",\r\n\t\t\t\"p = r * vec2(cos(a), sin(a));\",\r\n\t\t\t\"vec4 color = texture2D(tDiffuse, p + 0.5);\",\r\n\t\t\t\"gl_FragColor = color;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MirrorShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"side\":     { value: 1 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform int side;\",\r\n\t\t\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 p = vUv;\",\r\n\t\t\t\"if (side == 0){\",\r\n\t\t\t\t\"if (p.x > 0.5) p.x = 1.0 - p.x;\",\r\n\t\t\t\"}else if (side == 1){\",\r\n\t\t\t\t\"if (p.x < 0.5) p.x = 1.0 - p.x;\",\r\n\t\t\t\"}else if (side == 2){\",\r\n\t\t\t\t\"if (p.y < 0.5) p.y = 1.0 - p.y;\",\r\n\t\t\t\"}else if (side == 3){\",\r\n\t\t\t\t\"if (p.y > 0.5) p.y = 1.0 - p.y;\",\r\n\t\t\t\"} \",\r\n\t\t\t\"vec4 color = texture2D(tDiffuse, p);\",\r\n\t\t\t\"gl_FragColor = color;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar NormalMapShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"heightMap\":  { value: null },\r\n\t\t\"resolution\": { value: new Vector2( 512, 512 ) },\r\n\t\t\"scale\":      { value: new Vector2( 1, 1 ) },\r\n\t\t\"height\":     { value: 0.05 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float height;\",\r\n\t\t\"uniform vec2 resolution;\",\r\n\t\t\"uniform sampler2D heightMap;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"float val = texture2D( heightMap, vUv ).x;\",\r\n\r\n\t\t\t\"float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\",\r\n\t\t\t\"float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// Parallax Occlusion shaders from\r\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\r\n// No tangent-space transforms logic based on\r\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\r\n\r\nvar ParallaxShader = {\r\n\t// Ordered from fastest to best quality.\r\n\tmodes: {\r\n\t\tnone:  'NO_PARALLAX',\r\n\t\tbasic: 'USE_BASIC_PARALLAX',\r\n\t\tsteep: 'USE_STEEP_PARALLAX',\r\n\t\tocclusion: 'USE_OCLUSION_PARALLAX', // a.k.a. POM\r\n\t\trelief: 'USE_RELIEF_PARALLAX'\r\n\t},\r\n\r\n\tuniforms: {\r\n\t\t\"bumpMap\": { value: null },\r\n\t\t\"map\": { value: null },\r\n\t\t\"parallaxScale\": { value: null },\r\n\t\t\"parallaxMinLayers\": { value: null },\r\n\t\t\"parallaxMaxLayers\": { value: null }\r\n\t},\r\n\r\n\tvertexShader: [\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\"varying vec3 vViewPosition;\",\r\n\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\"}\"\r\n\r\n  ].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\t\t\"uniform sampler2D bumpMap;\",\r\n\t\t\"uniform sampler2D map;\",\r\n\r\n\t\t\"uniform float parallaxScale;\",\r\n\t\t\"uniform float parallaxMinLayers;\",\r\n\t\t\"uniform float parallaxMaxLayers;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\t\t\"varying vec3 vViewPosition;\",\r\n\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\"#ifdef USE_BASIC_PARALLAX\",\r\n\r\n\t\t\t\"vec2 parallaxMap( in vec3 V ) {\",\r\n\r\n\t\t\t\t\"float initialHeight = texture2D( bumpMap, vUv ).r;\",\r\n\r\n\t\t\t\t// No Offset Limitting: messy, floating output at grazing angles.\r\n\t\t\t\t//\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\r\n\r\n\t\t\t\t// Offset Limiting\r\n\t\t\t\t\"vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\",\r\n\t\t\t\t\"return vUv - texCoordOffset;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#else\",\r\n\r\n\t\t\t\"vec2 parallaxMap( in vec3 V ) {\",\r\n\r\n\t\t\t\t// Determine number of layers from angle between V and N\r\n\t\t\t\t\"float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\",\r\n\r\n\t\t\t\t\"float layerHeight = 1.0 / numLayers;\",\r\n\t\t\t\t\"float currentLayerHeight = 0.0;\",\r\n\t\t\t\t// Shift of texture coordinates for each iteration\r\n\t\t\t\t\"vec2 dtex = parallaxScale * V.xy / V.z / numLayers;\",\r\n\r\n\t\t\t\t\"vec2 currentTextureCoords = vUv;\",\r\n\r\n\t\t\t\t\"float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\r\n\r\n\t\t\t\t// while ( heightFromTexture > currentLayerHeight )\r\n\t\t\t\t// Infinite loops are not well supported. Do a \"large\" finite\r\n\t\t\t\t// loop, but not too large, as it slows down some compilers.\r\n\t\t\t\t\"for ( int i = 0; i < 30; i += 1 ) {\",\r\n\t\t\t\t\t\"if ( heightFromTexture <= currentLayerHeight ) {\",\r\n\t\t\t\t\t\t\"break;\",\r\n\t\t\t\t\t\"}\",\r\n\t\t\t\t\t\"currentLayerHeight += layerHeight;\",\r\n\t\t\t\t\t// Shift texture coordinates along vector V\r\n\t\t\t\t\t\"currentTextureCoords -= dtex;\",\r\n\t\t\t\t\t\"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#ifdef USE_STEEP_PARALLAX\",\r\n\r\n\t\t\t\t\t\"return currentTextureCoords;\",\r\n\r\n\t\t\t\t\"#elif defined( USE_RELIEF_PARALLAX )\",\r\n\r\n\t\t\t\t\t\"vec2 deltaTexCoord = dtex / 2.0;\",\r\n\t\t\t\t\t\"float deltaHeight = layerHeight / 2.0;\",\r\n\r\n\t\t\t\t\t// Return to the mid point of previous layer\r\n\t\t\t\t\t\"currentTextureCoords += deltaTexCoord;\",\r\n\t\t\t\t\t\"currentLayerHeight -= deltaHeight;\",\r\n\r\n\t\t\t\t\t// Binary search to increase precision of Steep Parallax Mapping\r\n\t\t\t\t\t\"const int numSearches = 5;\",\r\n\t\t\t\t\t\"for ( int i = 0; i < numSearches; i += 1 ) {\",\r\n\r\n\t\t\t\t\t\t\"deltaTexCoord /= 2.0;\",\r\n\t\t\t\t\t\t\"deltaHeight /= 2.0;\",\r\n\t\t\t\t\t\t\"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\r\n\t\t\t\t\t\t// Shift along or against vector V\r\n\t\t\t\t\t\t\"if( heightFromTexture > currentLayerHeight ) {\", // Below the surface\r\n\r\n\t\t\t\t\t\t\t\"currentTextureCoords -= deltaTexCoord;\",\r\n\t\t\t\t\t\t\t\"currentLayerHeight += deltaHeight;\",\r\n\r\n\t\t\t\t\t\t\"} else {\", // above the surface\r\n\r\n\t\t\t\t\t\t\t\"currentTextureCoords += deltaTexCoord;\",\r\n\t\t\t\t\t\t\t\"currentLayerHeight -= deltaHeight;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\t\t\t\t\t\"return currentTextureCoords;\",\r\n\r\n\t\t\t\t\"#elif defined( USE_OCLUSION_PARALLAX )\",\r\n\r\n\t\t\t\t\t\"vec2 prevTCoords = currentTextureCoords + dtex;\",\r\n\r\n\t\t\t\t\t// Heights for linear interpolation\r\n\t\t\t\t\t\"float nextH = heightFromTexture - currentLayerHeight;\",\r\n\t\t\t\t\t\"float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\",\r\n\r\n\t\t\t\t\t// Proportions for linear interpolation\r\n\t\t\t\t\t\"float weight = nextH / ( nextH - prevH );\",\r\n\r\n\t\t\t\t\t// Interpolation of texture coordinates\r\n\t\t\t\t\t\"return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\",\r\n\r\n\t\t\t\t\"#else\", // NO_PARALLAX\r\n\r\n\t\t\t\t\t\"return vUv;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\",\r\n\r\n \t\t\t\"vec2 texDx = dFdx( vUv );\",\r\n\t\t\t\"vec2 texDy = dFdy( vUv );\",\r\n\r\n\t\t\t\"vec3 vSigmaX = dFdx( surfPosition );\",\r\n\t\t\t\"vec3 vSigmaY = dFdy( surfPosition );\",\r\n\t\t\t\"vec3 vR1 = cross( vSigmaY, surfNormal );\",\r\n\t\t\t\"vec3 vR2 = cross( surfNormal, vSigmaX );\",\r\n\t\t\t\"float fDet = dot( vSigmaX, vR1 );\",\r\n\r\n\t\t\t\"vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\",\r\n\t\t\t\"vec3 vProjVtex;\",\r\n\t\t\t\"vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\",\r\n\t\t\t\"vProjVtex.z = dot( surfNormal, viewPosition );\",\r\n\r\n\t\t\t\"return parallaxMap( vProjVtex );\",\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\",\r\n\t\t\t\"gl_FragColor = texture2D( map, mapUv );\",\r\n\r\n\t\t\"}\"\r\n\r\n  ].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PixelShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"resolution\": { value: null },\r\n\t\t\"pixelSize\": { value: 1. },\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying highp vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\"vUv = uv;\",\r\n\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform float pixelSize;\",\r\n\t\t\"uniform vec2 resolution;\",\r\n\r\n\t\t\"varying highp vec2 vUv;\",\r\n\r\n\t\t\"void main(){\",\r\n\r\n\t\t\"vec2 dxy = pixelSize / resolution;\",\r\n\t\t\"vec2 coord = dxy * floor( vUv / dxy );\",\r\n\t\t\"gl_FragColor = texture2D(tDiffuse, coord);\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar RGBShiftShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"amount\":   { value: 0.005 },\r\n\t\t\"angle\":    { value: 0.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform float amount;\",\r\n\t\t\"uniform float angle;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 offset = amount * vec2( cos(angle), sin(angle));\",\r\n\t\t\t\"vec4 cr = texture2D(tDiffuse, vUv + offset);\",\r\n\t\t\t\"vec4 cga = texture2D(tDiffuse, vUv);\",\r\n\t\t\t\"vec4 cb = texture2D(tDiffuse, vUv - offset);\",\r\n\t\t\t\"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SepiaShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"amount\":   { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float amount;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\"vec3 c = color.rgb;\",\r\n\r\n\t\t\t\"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\",\r\n\t\t\t\"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\",\r\n\t\t\t\"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SobelOperatorShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"resolution\": { value: new Vector2() }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform vec2 resolution;\",\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\",\r\n\r\n\t\t\t// kernel definition (in glsl matrices are filled in column-major order)\r\n\r\n\t\t\t\"const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );\", // x direction kernel\r\n\t\t\t\"const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );\", // y direction kernel\r\n\r\n\t\t\t// fetch the 3x3 neighbourhood of a fragment\r\n\r\n\t\t\t// first column\r\n\r\n\t\t\t\"float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\",\r\n\t\t\t\"float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\",\r\n\t\t\t\"float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\",\r\n\r\n\t\t\t// second column\r\n\r\n\t\t\t\"float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\",\r\n\t\t\t\"float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\",\r\n\t\t\t\"float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\",\r\n\r\n\t\t\t// third column\r\n\r\n\t\t\t\"float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\",\r\n\t\t\t\"float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\",\r\n\t\t\t\"float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\",\r\n\r\n\t\t\t// gradient value in x direction\r\n\r\n\t\t\t\"float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \",\r\n\t\t\t\t\"Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \",\r\n\t\t\t\t\"Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \",\r\n\r\n\t\t\t// gradient value in y direction\r\n\r\n\t\t\t\"float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \",\r\n\t\t\t\t\"Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \",\r\n\t\t\t\t\"Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \",\r\n\r\n\t\t\t// magnitute of the total gradient\r\n\r\n\t\t\t\"float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\",\r\n\r\n\t\t\t\"gl_FragColor = vec4( vec3( G ), 1 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TechnicolorShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\",\r\n\t\t\t\"vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);\",\r\n\r\n\t\t\t\"gl_FragColor = newTex;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TriangleBlurShader = {\r\n\r\n\tuniforms : {\r\n\r\n\t\t\"texture\": { value: null },\r\n\t\t\"delta\":   { value: new Vector2( 1, 1 ) }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"#include <common>\",\r\n\r\n\t\t\"#define ITERATIONS 10.0\",\r\n\r\n\t\t\"uniform sampler2D texture;\",\r\n\t\t\"uniform vec2 delta;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 color = vec4( 0.0 );\",\r\n\r\n\t\t\t\"float total = 0.0;\",\r\n\r\n\t\t\t// randomize the lookup values to hide the fixed number of samples\r\n\r\n\t\t\t\"float offset = rand( vUv );\",\r\n\r\n\t\t\t\"for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {\",\r\n\r\n\t\t\t\t\"float percent = ( t + offset - 0.5 ) / ITERATIONS;\",\r\n\t\t\t\t\"float weight = 1.0 - abs( percent );\",\r\n\r\n\t\t\t\t\"color += texture2D( texture, vUv + delta * percent ) * weight;\",\r\n\t\t\t\t\"total += weight;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor = color / total;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar VerticalBlurShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"v\":        { value: 1.0 / 512.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform float v;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\r\n\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\",\r\n\r\n\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar VerticalTiltShiftShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"v\":        { value: 1.0 / 512.0 },\r\n\t\t\"r\":        { value: 0.35 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform float v;\",\r\n\t\t\"uniform float r;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\r\n\r\n\t\t\t\"float vv = v * abs( r - vUv.y );\",\r\n\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;\",\r\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;\",\r\n\r\n\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar VignetteShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\": { value: null },\r\n\t\t\"offset\":   { value: 1.0 },\r\n\t\t\"darkness\": { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float offset;\",\r\n\t\t\"uniform float darkness;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t// Eskil's vignette\r\n\r\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\"vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\",\r\n\t\t\t\"gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar WaterRefractionShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'color': {\r\n\t\t\ttype: 'c',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'time': {\r\n\t\t\ttype: 'f',\r\n\t\t\tvalue: 0\r\n\t\t},\r\n\r\n\t\t'tDiffuse': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tDudv': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'textureMatrix': {\r\n\t\t\ttype: 'm4',\r\n\t\t\tvalue: null\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t'uniform mat4 textureMatrix;',\r\n\r\n\t\t'varying vec2 vUv;',\r\n\t\t'varying vec4 vUvRefraction;',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvUv = uv;',\r\n\r\n\t\t'\tvUvRefraction = textureMatrix * vec4( position, 1.0 );',\r\n\r\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n\r\n\t\t'}'\r\n\r\n\t].join( '\\n' ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t'uniform vec3 color;',\r\n\t\t'uniform float time;',\r\n\t\t'uniform sampler2D tDiffuse;',\r\n\t\t'uniform sampler2D tDudv;',\r\n\r\n\t\t'varying vec2 vUv;',\r\n\t\t'varying vec4 vUvRefraction;',\r\n\r\n\t\t'float blendOverlay( float base, float blend ) {',\r\n\r\n\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\r\n\r\n\t\t'}',\r\n\r\n\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\r\n\r\n\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );',\r\n\r\n\t\t'}',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t' float waveStrength = 0.1;',\r\n\t\t' float waveSpeed = 0.03;',\r\n\r\n\t\t// simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)\r\n\r\n\t\t'\tvec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;',\r\n\t\t'\tdistortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );',\r\n\t\t'\tvec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;',\r\n\r\n\t\t// new uv coords\r\n\r\n\t\t' vec4 uv = vec4( vUvRefraction );',\r\n\t\t' uv.xy += distortion;',\r\n\r\n\t\t'\tvec4 base = texture2DProj( tDiffuse, uv );',\r\n\r\n\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\r\n\r\n\t\t'}'\r\n\r\n\t].join( '\\n' )\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ShaderSkin = {\r\n\r\n\t'skinSimple' : {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\r\n\t\t\tUniformsLib[ \"fog\" ],\r\n\t\t\tUniformsLib[ \"lights\" ],\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\t\"enableBump\": { value: 0 },\r\n\t\t\t\t\"enableSpecular\": { value: 0 },\r\n\r\n\t\t\t\t\"tDiffuse\": { value: null },\r\n\t\t\t\t\"tBeckmann\": { value: null },\r\n\r\n\t\t\t\t\"diffuse\": { value: new Color( 0xeeeeee ) },\r\n\t\t\t\t\"specular\": { value: new Color( 0x111111 ) },\r\n\t\t\t\t\"opacity\": { value: 1 },\r\n\r\n\t\t\t\t\"uRoughness\": { value: 0.15 },\r\n\t\t\t\t\"uSpecularBrightness\": { value: 0.75 },\r\n\r\n\t\t\t\t\"bumpMap\": { value: null },\r\n\t\t\t\t\"bumpScale\": { value: 1 },\r\n\r\n\t\t\t\t\"specularMap\": { value: null },\r\n\r\n\t\t\t\t\"offsetRepeat\": { value: new Vector4( 0, 0, 1, 1 ) },\r\n\r\n\t\t\t\t\"uWrapRGB\": { value: new Vector3( 0.75, 0.375, 0.1875 ) }\r\n\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"#define USE_BUMPMAP\",\r\n\r\n\t\t\t\"uniform bool enableBump;\",\r\n\t\t\t\"uniform bool enableSpecular;\",\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform float uRoughness;\",\r\n\t\t\t\"uniform float uSpecularBrightness;\",\r\n\r\n\t\t\t\"uniform vec3 uWrapRGB;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform sampler2D tBeckmann;\",\r\n\r\n\t\t\t\"uniform sampler2D specularMap;\",\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tShaderChunk[ \"common\" ],\r\n\t\t\tShaderChunk[ \"bsdfs\" ],\r\n\t\t\tShaderChunk[ \"packing\" ],\r\n\t\t\tShaderChunk[ \"lights_pars_begin\" ],\r\n\t\t\tShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n\r\n\t\t\t// Fresnel term\r\n\r\n\t\t\t\"float fresnelReflectance( vec3 H, vec3 V, float F0 ) {\",\r\n\r\n\t\t\t\t\"float base = 1.0 - dot( V, H );\",\r\n\t\t\t\t\"float exponential = pow( base, 5.0 );\",\r\n\r\n\t\t\t\t\"return exponential + F0 * ( 1.0 - exponential );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t// Kelemen/Szirmay-Kalos specular BRDF\r\n\r\n\t\t\t\"float KS_Skin_Specular( vec3 N,\", \t\t// Bumped surface normal\r\n\t\t\t\t\t\t\t\t\t\"vec3 L,\", \t\t// Points to light\r\n\t\t\t\t\t\t\t\t\t\"vec3 V,\", \t\t// Points to eye\r\n\t\t\t\t\t\t\t\t\t\"float m,\",  \t// Roughness\r\n\t\t\t\t\t\t\t\t\t\"float rho_s\", \t// Specular brightness\r\n\t\t\t\t\t\t\t\t\t\") {\",\r\n\r\n\t\t\t\t\"float result = 0.0;\",\r\n\t\t\t\t\"float ndotl = dot( N, L );\",\r\n\r\n\t\t\t\t\"if( ndotl > 0.0 ) {\",\r\n\r\n\t\t\t\t\t\"vec3 h = L + V;\", // Unnormalized half-way vector\r\n\t\t\t\t\t\"vec3 H = normalize( h );\",\r\n\r\n\t\t\t\t\t\"float ndoth = dot( N, H );\",\r\n\r\n\t\t\t\t\t\"float PH = pow( 2.0 * texture2D( tBeckmann, vec2( ndoth, m ) ).x, 10.0 );\",\r\n\r\n\t\t\t\t\t\"float F = fresnelReflectance( H, V, 0.028 );\",\r\n\t\t\t\t\t\"float frSpec = max( PH * F / dot( h, h ), 0.0 );\",\r\n\r\n\t\t\t\t\t\"result = ndotl * rho_s * frSpec;\", // BRDF * dot(N,L) * rho_s\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"return result;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\t\"vec4 colDiffuse = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\t\"colDiffuse.rgb *= colDiffuse.rgb;\",\r\n\r\n\t\t\t\t\"diffuseColor = diffuseColor * colDiffuse;\",\r\n\r\n\t\t\t\t\"vec3 normal = normalize( vNormal );\",\r\n\t\t\t\t\"vec3 viewerDirection = normalize( vViewPosition );\",\r\n\r\n\t\t\t\t\"float specularStrength;\",\r\n\r\n\t\t\t\t\"if ( enableSpecular ) {\",\r\n\r\n\t\t\t\t\t\"vec4 texelSpecular = texture2D( specularMap, vUv );\",\r\n\t\t\t\t\t\"specularStrength = texelSpecular.r;\",\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"specularStrength = 1.0;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#ifdef USE_BUMPMAP\",\r\n\r\n\t\t\t\t\t\"if ( enableBump ) normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// point lights\r\n\r\n\t\t\t\t\"vec3 totalSpecularLight = vec3( 0.0 );\",\r\n\t\t\t\t\"vec3 totalDiffuseLight = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\"#if NUM_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 lVector = pointLights[ i ].position + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\t\"float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );\",\r\n\r\n\t\t\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\t\t\"float pointDiffuseWeightFull = max( dot( normal, lVector ), 0.0 );\",\r\n\t\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, lVector ) + 0.5, 0.0 );\",\r\n\t\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), uWrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"float pointSpecularWeight = KS_Skin_Specular( normal, lVector, viewerDirection, uRoughness, uSpecularBrightness );\",\r\n\r\n\t\t\t\t\t\t\"totalDiffuseLight += pointLight[ i ].color * ( pointDiffuseWeight * attenuation );\",\r\n\t\t\t\t\t\t\"totalSpecularLight += pointLight[ i ].color * specular * ( pointSpecularWeight * specularStrength * attenuation );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// directional lights\r\n\r\n\t\t\t\t\"#if NUM_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 dirVector = directionalLights[ i ].direction;\",\r\n\r\n\t\t\t\t\t\t\"float dirDiffuseWeightFull = max( dot( normal, dirVector ), 0.0 );\",\r\n\t\t\t\t\t\t\"float dirDiffuseWeightHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\r\n\t\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3 ( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), uWrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"float dirSpecularWeight = KS_Skin_Specular( normal, dirVector, viewerDirection, uRoughness, uSpecularBrightness );\",\r\n\r\n\t\t\t\t\t\t\"totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;\",\r\n\t\t\t\t\t\t\"totalSpecularLight += directionalLights[ i ].color * ( dirSpecularWeight * specularStrength );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// hemisphere lights\r\n\r\n\t\t\t\t\"#if NUM_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 lVector = hemisphereLightDirection[ i ];\",\r\n\r\n\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\t\t\"totalDiffuseLight += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\t\t// specular (sky light)\r\n\r\n\t\t\t\t\t\t\"float hemiSpecularWeight = 0.0;\",\r\n\t\t\t\t\t\t\"hemiSpecularWeight += KS_Skin_Specular( normal, lVector, viewerDirection, uRoughness, uSpecularBrightness );\",\r\n\r\n\t\t\t\t\t\t// specular (ground light)\r\n\r\n\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\r\n\t\t\t\t\t\t\"hemiSpecularWeight += KS_Skin_Specular( normal, lVectorGround, viewerDirection, uRoughness, uSpecularBrightness );\",\r\n\r\n\t\t\t\t\t\t\"vec3 hemiSpecularColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\t\t\"totalSpecularLight += hemiSpecularColor * specular * ( hemiSpecularWeight * specularStrength );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor * diffuse ) + totalSpecularLight;\",\r\n\r\n\t\t\t\t\"gl_FragColor = linearToOutputTexel( vec4( outgoingLight, diffuseColor.a ) );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\tShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform vec4 offsetRepeat;\",\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tShaderChunk[ \"common\" ],\r\n\t\t\tShaderChunk[ \"lights_pars_begin\" ],\r\n\t\t\tShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tShaderChunk[ \"fog_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\t\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\tShaderChunk[ \"shadowmap_vertex\" ],\r\n\t\t\t\tShaderChunk[ \"fog_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\t'skin' : {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\r\n\t\t\tUniformsLib[ \"fog\" ],\r\n\t\t\tUniformsLib[ \"lights\" ],\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\t\"passID\": { value: 0 },\r\n\r\n\t\t\t\t\"tDiffuse\"\t: { value: null },\r\n\t\t\t\t\"tNormal\"\t: { value: null },\r\n\r\n\t\t\t\t\"tBlur1\"\t: { value: null },\r\n\t\t\t\t\"tBlur2\"\t: { value: null },\r\n\t\t\t\t\"tBlur3\"\t: { value: null },\r\n\t\t\t\t\"tBlur4\"\t: { value: null },\r\n\r\n\t\t\t\t\"tBeckmann\"\t: { value: null },\r\n\r\n\t\t\t\t\"uNormalScale\": { value: 1.0 },\r\n\r\n\t\t\t\t\"diffuse\":  { value: new Color( 0xeeeeee ) },\r\n\t\t\t\t\"specular\": { value: new Color( 0x111111 ) },\r\n\t\t\t\t\"opacity\": \t  { value: 1 },\r\n\r\n\t\t\t\t\"uRoughness\": \t  \t\t{ value: 0.15 },\r\n\t\t\t\t\"uSpecularBrightness\": \t{ value: 0.75 }\r\n\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform float uRoughness;\",\r\n\t\t\t\"uniform float uSpecularBrightness;\",\r\n\r\n\t\t\t\"uniform int passID;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform sampler2D tNormal;\",\r\n\r\n\t\t\t\"uniform sampler2D tBlur1;\",\r\n\t\t\t\"uniform sampler2D tBlur2;\",\r\n\t\t\t\"uniform sampler2D tBlur3;\",\r\n\t\t\t\"uniform sampler2D tBlur4;\",\r\n\r\n\t\t\t\"uniform sampler2D tBeckmann;\",\r\n\r\n\t\t\t\"uniform float uNormalScale;\",\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tShaderChunk[ \"common\" ],\r\n\t\t\tShaderChunk[ \"lights_pars_begin\" ],\r\n\t\t\tShaderChunk[ \"fog_pars_fragment\" ],\r\n\r\n\t\t\t\"float fresnelReflectance( vec3 H, vec3 V, float F0 ) {\",\r\n\r\n\t\t\t\t\"float base = 1.0 - dot( V, H );\",\r\n\t\t\t\t\"float exponential = pow( base, 5.0 );\",\r\n\r\n\t\t\t\t\"return exponential + F0 * ( 1.0 - exponential );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t// Kelemen/Szirmay-Kalos specular BRDF\r\n\r\n\t\t\t\"float KS_Skin_Specular( vec3 N,\", \t\t// Bumped surface normal\r\n\t\t\t\t\t\t\t\t\t\"vec3 L,\", \t\t// Points to light\r\n\t\t\t\t\t\t\t\t\t\"vec3 V,\", \t\t// Points to eye\r\n\t\t\t\t\t\t\t\t\t\"float m,\",  \t// Roughness\r\n\t\t\t\t\t\t\t\t\t\"float rho_s\", \t// Specular brightness\r\n\t\t\t\t\t\t\t\t\t\") {\",\r\n\r\n\t\t\t\t\"float result = 0.0;\",\r\n\t\t\t\t\"float ndotl = dot( N, L );\",\r\n\r\n\t\t\t\t\"if( ndotl > 0.0 ) {\",\r\n\r\n\t\t\t\t\t\"vec3 h = L + V;\", // Unnormalized half-way vector\r\n\t\t\t\t\t\"vec3 H = normalize( h );\",\r\n\r\n\t\t\t\t\t\"float ndoth = dot( N, H );\",\r\n\r\n\t\t\t\t\t\"float PH = pow( 2.0 * texture2D( tBeckmann, vec2( ndoth, m ) ).x, 10.0 );\",\r\n\t\t\t\t\t\"float F = fresnelReflectance( H, V, 0.028 );\",\r\n\t\t\t\t\t\"float frSpec = max( PH * F / dot( h, h ), 0.0 );\",\r\n\r\n\t\t\t\t\t\"result = ndotl * rho_s * frSpec;\", // BRDF * dot(N,L) * rho_s\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"return result;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\t\"vec4 mSpecular = vec4( specular, opacity );\",\r\n\r\n\t\t\t\t\"vec4 colDiffuse = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\t\"colDiffuse *= colDiffuse;\",\r\n\r\n\t\t\t\t\"diffuseColor *= colDiffuse;\",\r\n\r\n\t\t\t\t// normal mapping\r\n\r\n\t\t\t\t\"vec4 posAndU = vec4( -vViewPosition, vUv.x );\",\r\n\t\t\t\t\"vec4 posAndU_dx = dFdx( posAndU ),  posAndU_dy = dFdy( posAndU );\",\r\n\t\t\t\t\"vec3 tangent = posAndU_dx.w * posAndU_dx.xyz + posAndU_dy.w * posAndU_dy.xyz;\",\r\n\t\t\t\t\"vec3 normal = normalize( vNormal );\",\r\n\t\t\t\t\"vec3 binormal = normalize( cross( tangent, normal ) );\",\r\n\t\t\t\t\"tangent = cross( normal, binormal );\",\t// no normalization required\r\n\t\t\t\t\"mat3 tsb = mat3( tangent, binormal, normal );\",\r\n\r\n\t\t\t\t\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\r\n\t\t\t\t\"normalTex.xy *= uNormalScale;\",\r\n\t\t\t\t\"normalTex = normalize( normalTex );\",\r\n\r\n\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\r\n\t\t\t\t\"normal = normalize( finalNormal );\",\r\n\r\n\t\t\t\t\"vec3 viewerDirection = normalize( vViewPosition );\",\r\n\r\n\t\t\t\t// point lights\r\n\r\n\t\t\t\t\"vec3 totalDiffuseLight = vec3( 0.0 );\",\r\n\t\t\t\t\"vec3 totalSpecularLight = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\"#if NUM_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 pointVector = normalize( pointLights[ i ].direction );\",\r\n\t\t\t\t\t\t\"float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );\",\r\n\r\n\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"totalDiffuseLight += pointLightColor[ i ] * ( pointDiffuseWeight * attenuation );\",\r\n\r\n\t\t\t\t\t\t\"if ( passID == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"float pointSpecularWeight = KS_Skin_Specular( normal, pointVector, viewerDirection, uRoughness, uSpecularBrightness );\",\r\n\r\n\t\t\t\t\t\t\t\"totalSpecularLight += pointLightColor[ i ] * mSpecular.xyz * ( pointSpecularWeight * attenuation );\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// directional lights\r\n\r\n\t\t\t\t\"#if NUM_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 dirVector = directionalLights[ i ].direction;\",\r\n\r\n\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t\"if ( passID == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"float dirSpecularWeight = KS_Skin_Specular( normal, dirVector, viewerDirection, uRoughness, uSpecularBrightness );\",\r\n\r\n\t\t\t\t\t\t\t\"totalSpecularLight += directionalLights[ i ].color * mSpecular.xyz * dirSpecularWeight;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalSpecularLight );\",\r\n\r\n\t\t\t\t\"if ( passID == 0 ) {\",\r\n\r\n\t\t\t\t\t\"outgoingLight = sqrt( outgoingLight );\",\r\n\r\n\t\t\t\t\"} else if ( passID == 1 ) {\",\r\n\r\n\t\t\t\t\t//\"#define VERSION1\",\r\n\r\n\t\t\t\t\t\"#ifdef VERSION1\",\r\n\r\n\t\t\t\t\t\t\"vec3 nonblurColor = sqrt(outgoingLight );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"vec3 nonblurColor = outgoingLight;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"vec3 blur1Color = texture2D( tBlur1, vUv ).xyz;\",\r\n\t\t\t\t\t\"vec3 blur2Color = texture2D( tBlur2, vUv ).xyz;\",\r\n\t\t\t\t\t\"vec3 blur3Color = texture2D( tBlur3, vUv ).xyz;\",\r\n\t\t\t\t\t\"vec3 blur4Color = texture2D( tBlur4, vUv ).xyz;\",\r\n\r\n\t\t\t\t\t//\"gl_FragColor = vec4( blur1Color, gl_FragColor.w );\",\r\n\r\n\t\t\t\t\t//\"gl_FragColor = vec4( vec3( 0.22, 0.5, 0.7 ) * nonblurColor + vec3( 0.2, 0.5, 0.3 ) * blur1Color + vec3( 0.58, 0.0, 0.0 ) * blur2Color, gl_FragColor.w );\",\r\n\r\n\t\t\t\t\t//\"gl_FragColor = vec4( vec3( 0.25, 0.6, 0.8 ) * nonblurColor + vec3( 0.15, 0.25, 0.2 ) * blur1Color + vec3( 0.15, 0.15, 0.0 ) * blur2Color + vec3( 0.45, 0.0, 0.0 ) * blur3Color, gl_FragColor.w );\",\r\n\r\n\t\t\t\t\t\"outgoingLight = vec3( vec3( 0.22,  0.437, 0.635 ) * nonblurColor + \",\r\n\t\t\t\t\t\t\t\t\t\t \"vec3( 0.101, 0.355, 0.365 ) * blur1Color + \",\r\n\t\t\t\t\t\t\t\t\t\t \"vec3( 0.119, 0.208, 0.0 )   * blur2Color + \",\r\n\t\t\t\t\t\t\t\t\t\t \"vec3( 0.114, 0.0,   0.0 )   * blur3Color + \",\r\n\t\t\t\t\t\t\t\t\t\t \"vec3( 0.444, 0.0,   0.0 )   * blur4Color );\",\r\n\r\n\t\t\t\t\t\"outgoingLight *= sqrt( colDiffuse.xyz );\",\r\n\r\n\t\t\t\t\t\"outgoingLight += ambientLightColor * diffuse * colDiffuse.xyz + totalSpecularLight;\",\r\n\r\n\t\t\t\t\t\"#ifndef VERSION1\",\r\n\r\n\t\t\t\t\t\t\"outgoingLight = sqrt( outgoingLight );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\tShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#ifdef VERTEX_TEXTURES\",\r\n\r\n\t\t\t\t\"uniform sampler2D tDisplacement;\",\r\n\t\t\t\t\"uniform float uDisplacementScale;\",\r\n\t\t\t\t\"uniform float uDisplacementBias;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tShaderChunk[ \"common\" ],\r\n\t\t\tShaderChunk[ \"fog_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\t// displacement mapping\r\n\r\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\r\n\r\n\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\r\n\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\r\n\t\t\t\t\t\"vec4 displacedPosition = vec4( vNormal.xyz * df, 0.0 ) + mvPosition;\",\r\n\t\t\t\t\t\"gl_Position = projectionMatrix * displacedPosition;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\tShaderChunk[ \"fog_vertex\" ],\r\n\r\n\t\t\t\"}\" ].join( \"\\n\" ),\r\n\r\n\t\tvertexShaderUV: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tShaderChunk[ \"common\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\t\"gl_Position = vec4( uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 0.0, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\t\"beckmann\" : {\r\n\r\n\t\tuniforms: {},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"float PHBeckmann( float ndoth, float m ) {\",\r\n\r\n\t\t\t\t\"float alpha = acos( ndoth );\",\r\n\t\t\t\t\"float ta = tan( alpha );\",\r\n\r\n\t\t\t\t\"float val = 1.0 / ( m * m * pow( ndoth, 4.0 ) ) * exp( -( ta * ta ) / ( m * m ) );\",\r\n\t\t\t\t\"return val;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"float KSTextureCompute( vec2 tex ) {\",\r\n\r\n\t\t\t\t// Scale the value to fit within [0,1]  invert upon lookup.\r\n\r\n\t\t\t\t\"return 0.5 * pow( PHBeckmann( tex.x, tex.y ), 0.1 );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"float x = KSTextureCompute( vUv );\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( x, x, x, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ShaderTerrain = {\r\n\r\n\t'terrain' : {\r\n\r\n\t\tuniforms: UniformsUtils.merge( [\r\n\r\n\t\t\tUniformsLib[ \"fog\" ],\r\n\t\t\tUniformsLib[ \"lights\" ],\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\t\"enableDiffuse1\": { value: 0 },\r\n\t\t\t\t\"enableDiffuse2\": { value: 0 },\r\n\t\t\t\t\"enableSpecular\": { value: 0 },\r\n\t\t\t\t\"enableReflection\": { value: 0 },\r\n\r\n\t\t\t\t\"tDiffuse1\": { value: null },\r\n\t\t\t\t\"tDiffuse2\": { value: null },\r\n\t\t\t\t\"tDetail\": { value: null },\r\n\t\t\t\t\"tNormal\": { value: null },\r\n\t\t\t\t\"tSpecular\": { value: null },\r\n\t\t\t\t\"tDisplacement\": { value: null },\r\n\r\n\t\t\t\t\"uNormalScale\": { value: 1.0 },\r\n\r\n\t\t\t\t\"uDisplacementBias\": { value: 0.0 },\r\n\t\t\t\t\"uDisplacementScale\": { value: 1.0 },\r\n\r\n\t\t\t\t\"diffuse\": { value: new Color( 0xeeeeee ) },\r\n\t\t\t\t\"specular\": { value: new Color( 0x111111 ) },\r\n\t\t\t\t\"shininess\": { value: 30 },\r\n\t\t\t\t\"opacity\": { value: 1 },\r\n\r\n\t\t\t\t\"uRepeatBase\": { value: new Vector2( 1, 1 ) },\r\n\t\t\t\t\"uRepeatOverlay\": { value: new Vector2( 1, 1 ) },\r\n\r\n\t\t\t\t\"uOffset\": { value: new Vector2( 0, 0 ) }\r\n\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float shininess;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform bool enableDiffuse1;\",\r\n\t\t\t\"uniform bool enableDiffuse2;\",\r\n\t\t\t\"uniform bool enableSpecular;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse1;\",\r\n\t\t\t\"uniform sampler2D tDiffuse2;\",\r\n\t\t\t\"uniform sampler2D tDetail;\",\r\n\t\t\t\"uniform sampler2D tNormal;\",\r\n\t\t\t\"uniform sampler2D tSpecular;\",\r\n\t\t\t\"uniform sampler2D tDisplacement;\",\r\n\r\n\t\t\t\"uniform float uNormalScale;\",\r\n\r\n\t\t\t\"uniform vec2 uRepeatOverlay;\",\r\n\t\t\t\"uniform vec2 uRepeatBase;\",\r\n\r\n\t\t\t\"uniform vec2 uOffset;\",\r\n\r\n\t\t\t\"varying vec3 vTangent;\",\r\n\t\t\t\"varying vec3 vBinormal;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tShaderChunk[ \"common\" ],\r\n\t\t\tShaderChunk[ \"bsdfs\" ],\r\n\t\t\tShaderChunk[ \"lights_pars_begin\" ],\r\n\t\t\tShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tShaderChunk[ \"fog_pars_fragment\" ],\r\n\r\n\t\t\t\"float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\",\r\n \t\t\t\t\"if ( decayExponent > 0.0 ) {\",\r\n \t\t\t\t\t\"return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\",\r\n \t\t\t\t\"}\",\r\n \t\t\t\t\"return 1.0;\",\r\n \t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"vec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\t\"vec3 specularTex = vec3( 1.0 );\",\r\n\r\n\t\t\t\t\"vec2 uvOverlay = uRepeatOverlay * vUv + uOffset;\",\r\n\t\t\t\t\"vec2 uvBase = uRepeatBase * vUv;\",\r\n\r\n\t\t\t\t\"vec3 normalTex = texture2D( tDetail, uvOverlay ).xyz * 2.0 - 1.0;\",\r\n\t\t\t\t\"normalTex.xy *= uNormalScale;\",\r\n\t\t\t\t\"normalTex = normalize( normalTex );\",\r\n\r\n\t\t\t\t\"if( enableDiffuse1 && enableDiffuse2 ) {\",\r\n\r\n\t\t\t\t\t\"vec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );\",\r\n\t\t\t\t\t\"vec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );\",\r\n\r\n\t\t\t\t\t\"colDiffuse1 = GammaToLinear( colDiffuse1, float( GAMMA_FACTOR ) );\",\r\n\t\t\t\t\t\"colDiffuse2 = GammaToLinear( colDiffuse2, float( GAMMA_FACTOR ) );\",\r\n\r\n\t\t\t\t\t\"diffuseColor *= mix ( colDiffuse1, colDiffuse2, 1.0 - texture2D( tDisplacement, uvBase ) );\",\r\n\r\n\t\t\t\t\" } else if( enableDiffuse1 ) {\",\r\n\r\n\t\t\t\t\t\"diffuseColor *= texture2D( tDiffuse1, uvOverlay );\",\r\n\r\n\t\t\t\t\"} else if( enableDiffuse2 ) {\",\r\n\r\n\t\t\t\t\t\"diffuseColor *= texture2D( tDiffuse2, uvOverlay );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if( enableSpecular )\",\r\n\t\t\t\t\t\"specularTex = texture2D( tSpecular, uvOverlay ).xyz;\",\r\n\r\n\t\t\t\t\"mat3 tsb = mat3( vTangent, vBinormal, vNormal );\",\r\n\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\r\n\r\n\t\t\t\t\"vec3 normal = normalize( finalNormal );\",\r\n\t\t\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\r\n\r\n\t\t\t\t\"vec3 totalDiffuseLight = vec3( 0.0 );\",\r\n\t\t\t\t\"vec3 totalSpecularLight = vec3( 0.0 );\",\r\n\r\n\t\t\t\t// point lights\r\n\r\n\t\t\t\t\"#if NUM_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 lVector = pointLights[ i ].position + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\t\"float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );\",\r\n\r\n\t\t\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\t\t\"vec3 pointHalfVector = normalize( lVector + viewPosition );\",\r\n\r\n\t\t\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"totalDiffuseLight += attenuation * pointLights[ i ].color * pointDiffuseWeight;\",\r\n\t\t\t\t\t\t\"totalSpecularLight += attenuation * pointLights[ i ].color * specular * pointSpecularWeight * pointDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// directional lights\r\n\r\n\t\t\t\t\"#if NUM_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 dirDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 dirVector = directionalLights[ i ].direction;\",\r\n\t\t\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\r\n\r\n\t\t\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;\",\r\n\t\t\t\t\t\t\"totalSpecularLight += directionalLights[ i ].color * specular * dirSpecularWeight * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// hemisphere lights\r\n\r\n\t\t\t\t\"#if NUM_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 lVector = hemisphereLightDirection[ i ];\",\r\n\r\n\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\t\t\"totalDiffuseLight += mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\t\t// specular (sky light)\r\n\r\n\t\t\t\t\t\t\"float hemiSpecularWeight = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\r\n\t\t\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\r\n\t\t\t\t\t\t\"hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t// specular (ground light)\r\n\r\n\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\r\n\r\n\t\t\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\r\n\t\t\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\r\n\t\t\t\t\t\t\"hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"totalSpecularLight += specular * mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight ) * hemiSpecularWeight * hemiDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor + totalSpecularLight );\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\tShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"attribute vec4 tangent;\",\r\n\r\n\t\t\t\"uniform vec2 uRepeatBase;\",\r\n\r\n\t\t\t\"uniform sampler2D tNormal;\",\r\n\r\n\t\t\t\"#ifdef VERTEX_TEXTURES\",\r\n\r\n\t\t\t\t\"uniform sampler2D tDisplacement;\",\r\n\t\t\t\t\"uniform float uDisplacementScale;\",\r\n\t\t\t\t\"uniform float uDisplacementBias;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"varying vec3 vTangent;\",\r\n\t\t\t\"varying vec3 vBinormal;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tShaderChunk[ \"fog_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\t// tangent and binormal vectors\r\n\r\n\t\t\t\t\"vTangent = normalize( normalMatrix * tangent.xyz );\",\r\n\r\n\t\t\t\t\"vBinormal = cross( vNormal, vTangent ) * tangent.w;\",\r\n\t\t\t\t\"vBinormal = normalize( vBinormal );\",\r\n\r\n\t\t\t\t// texture coordinates\r\n\r\n\t\t\t\t\"vUv = uv;\",\r\n\r\n\t\t\t\t\"vec2 uvBase = uv * uRepeatBase;\",\r\n\r\n\t\t\t\t// displacement mapping\r\n\r\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\r\n\r\n\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uvBase ).xyz;\",\r\n\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\r\n\t\t\t\t\t\"vec3 displacedPosition = normal * df + position;\",\r\n\r\n\t\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\r\n\t\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"vec3 normalTex = texture2D( tNormal, uvBase ).xyz * 2.0 - 1.0;\",\r\n\t\t\t\t\"vNormal = normalMatrix * normalTex;\",\r\n\r\n\t\t\t\tShaderChunk[ \"shadowmap_vertex\" ],\r\n\t\t\t\tShaderChunk[ \"fog_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ShaderToon = {\r\n\r\n\t'toon1' : {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"uDirLightPos\": { value: new Vector3() },\r\n\t\t\t\"uDirLightColor\": { value: new Color( 0xeeeeee ) },\r\n\r\n\t\t\t\"uAmbientLightColor\": { value: new Color( 0x050505 ) },\r\n\r\n\t\t\t\"uBaseColor\": { value: new Color( 0xffffff ) }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec3 vRefract;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\",\r\n\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\t\"vec3 I = worldPosition.xyz - cameraPosition;\",\r\n\t\t\t\t\"vRefract = refract( normalize( I ), worldNormal, 1.02 );\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 uBaseColor;\",\r\n\r\n\t\t\t\"uniform vec3 uDirLightPos;\",\r\n\t\t\t\"uniform vec3 uDirLightColor;\",\r\n\r\n\t\t\t\"uniform vec3 uAmbientLightColor;\",\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"varying vec3 vRefract;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"float directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);\",\r\n\t\t\t\t\"vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;\",\r\n\r\n\t\t\t\t\"float intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );\",\r\n\t\t\t\t\"intensity += length(lightWeighting) * 0.2;\",\r\n\r\n\t\t\t\t\"float cameraWeighting = dot( normalize( vNormal ), vRefract );\",\r\n\t\t\t\t\"intensity += pow( 1.0 - length( cameraWeighting ), 6.0 );\",\r\n\t\t\t\t\"intensity = intensity * 0.2 + 0.3;\",\r\n\r\n\t\t\t\t\"if ( intensity < 0.50 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );\",\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\t'toon2' : {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"uDirLightPos\": { value: new Vector3() },\r\n\t\t\t\"uDirLightColor\": { value: new Color( 0xeeeeee ) },\r\n\r\n\t\t\t\"uAmbientLightColor\": { value: new Color( 0x050505 ) },\r\n\r\n\t\t\t\"uBaseColor\": { value: new Color( 0xeeeeee ) },\r\n\t\t\t\"uLineColor1\": { value: new Color( 0x808080 ) },\r\n\t\t\t\"uLineColor2\": { value: new Color( 0x000000 ) },\r\n\t\t\t\"uLineColor3\": { value: new Color( 0x000000 ) },\r\n\t\t\t\"uLineColor4\": { value: new Color( 0x000000 ) }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 uBaseColor;\",\r\n\t\t\t\"uniform vec3 uLineColor1;\",\r\n\t\t\t\"uniform vec3 uLineColor2;\",\r\n\t\t\t\"uniform vec3 uLineColor3;\",\r\n\t\t\t\"uniform vec3 uLineColor4;\",\r\n\r\n\t\t\t\"uniform vec3 uDirLightPos;\",\r\n\t\t\t\"uniform vec3 uDirLightColor;\",\r\n\r\n\t\t\t\"uniform vec3 uAmbientLightColor;\",\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"float camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);\",\r\n\t\t\t\t\"float light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( uBaseColor, 1.0 );\",\r\n\r\n\t\t\t\t\"if ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor *= vec4( uLineColor1, 1.0 );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor *= vec4( uLineColor2, 1.0 );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\t'hatching' : {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"uDirLightPos\":\t{ value: new Vector3() },\r\n\t\t\t\"uDirLightColor\": { value: new Color( 0xeeeeee ) },\r\n\r\n\t\t\t\"uAmbientLightColor\": { value: new Color( 0x050505 ) },\r\n\r\n\t\t\t\"uBaseColor\":  { value: new Color( 0xffffff ) },\r\n\t\t\t\"uLineColor1\": { value: new Color( 0x000000 ) },\r\n\t\t\t\"uLineColor2\": { value: new Color( 0x000000 ) },\r\n\t\t\t\"uLineColor3\": { value: new Color( 0x000000 ) },\r\n\t\t\t\"uLineColor4\": { value: new Color( 0x000000 ) }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 uBaseColor;\",\r\n\t\t\t\"uniform vec3 uLineColor1;\",\r\n\t\t\t\"uniform vec3 uLineColor2;\",\r\n\t\t\t\"uniform vec3 uLineColor3;\",\r\n\t\t\t\"uniform vec3 uLineColor4;\",\r\n\r\n\t\t\t\"uniform vec3 uDirLightPos;\",\r\n\t\t\t\"uniform vec3 uDirLightColor;\",\r\n\r\n\t\t\t\"uniform vec3 uAmbientLightColor;\",\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);\",\r\n\t\t\t\t\"vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( uBaseColor, 1.0 );\",\r\n\r\n\t\t\t\t\"if ( length(lightWeighting) < 1.00 ) {\",\r\n\r\n\t\t\t\t\t\"if ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = vec4( uLineColor1, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if ( length(lightWeighting) < 0.75 ) {\",\r\n\r\n\t\t\t\t\t\"if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = vec4( uLineColor2, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if ( length(lightWeighting) < 0.50 ) {\",\r\n\r\n\t\t\t\t\t\"if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = vec4( uLineColor3, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if ( length(lightWeighting) < 0.3465 ) {\",\r\n\r\n\t\t\t\t\t\"if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = vec4( uLineColor4, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\t'dotted' : {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"uDirLightPos\":\t{ value: new Vector3() },\r\n\t\t\t\"uDirLightColor\": { value: new Color( 0xeeeeee ) },\r\n\r\n\t\t\t\"uAmbientLightColor\": { value: new Color( 0x050505 ) },\r\n\r\n\t\t\t\"uBaseColor\":  { value: new Color( 0xffffff ) },\r\n\t\t\t\"uLineColor1\": { value: new Color( 0x000000 ) }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 uBaseColor;\",\r\n\t\t\t\"uniform vec3 uLineColor1;\",\r\n\t\t\t\"uniform vec3 uLineColor2;\",\r\n\t\t\t\"uniform vec3 uLineColor3;\",\r\n\t\t\t\"uniform vec3 uLineColor4;\",\r\n\r\n\t\t\t\"uniform vec3 uDirLightPos;\",\r\n\t\t\t\"uniform vec3 uDirLightColor;\",\r\n\r\n\t\t\t\"uniform vec3 uAmbientLightColor;\",\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);\",\r\n\t\t\t\t\"vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( uBaseColor, 1.0 );\",\r\n\r\n\t\t\t\t\"if ( length(lightWeighting) < 1.00 ) {\",\r\n\r\n\t\t\t\t\t\"if ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = vec4( uLineColor1, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if ( length(lightWeighting) < 0.50 ) {\",\r\n\r\n\t\t\t\t\t\"if ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = vec4( uLineColor1, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TranslucentShader = function TranslucentShader() {\r\n\r\n\tthis.uniforms = UniformsUtils.merge( [\r\n\r\n\t\tUniformsLib[ \"common\" ],\r\n\t\tUniformsLib[ \"lights\" ],\r\n\r\n\t\t{\r\n\t\t\t\"color\":  { value: new Color( 0xffffff ) },\r\n\t\t\t\"diffuse\":  { value: new Color( 0xffffff ) },\r\n\t\t\t\"specular\": { value: new Color( 0xffffff ) },\r\n\t\t\t\"emissive\": { value: new Color( 0x000000 ) },\r\n\t\t\t\"opacity\": { value: 1 },\r\n\t\t\t\"shininess\": { value: 1 },\r\n\r\n\t\t\t\"thicknessMap\": { value: null },\r\n\t\t\t\"thicknessColor\": { value: new Color( 0xffffff ) },\r\n\t\t\t\"thicknessDistortion\": { value: 0.1 },\r\n\t\t\t\"thicknessAmbient\": { value: 0.0 },\r\n\t\t\t\"thicknessAttenuation\": { value: 0.1 },\r\n\t\t\t\"thicknessPower\": { value: 2.0 },\r\n\t\t\t\"thicknessScale\": { value: 10.0 }\r\n\t\t}\r\n\r\n\t] );\r\n\r\n\tthis.fragmentShader = [\r\n\t\t\"#define USE_MAP\",\r\n\t\t\"#define PHONG\",\r\n\t\t\"#define TRANSLUCENT\",\r\n\t\t\"#include <common>\",\r\n\t\t\"#include <bsdfs>\",\r\n\t\t\"#include <uv_pars_fragment>\",\r\n\t\t\"#include <map_pars_fragment>\",\r\n\t\t\"#include <lights_phong_pars_fragment>\",\r\n\r\n\t\t\"varying vec3 vColor;\",\r\n\r\n\t\t\"uniform vec3 diffuse;\",\r\n\t\t\"uniform vec3 specular;\",\r\n\t\t\"uniform vec3 emissive;\",\r\n\t\t\"uniform float opacity;\",\r\n\t\t\"uniform float shininess;\",\r\n\r\n\t\t// Translucency\r\n\t\t\"uniform sampler2D thicknessMap;\",\r\n\t\t\"uniform float thicknessPower;\",\r\n\t\t\"uniform float thicknessScale;\",\r\n\t\t\"uniform float thicknessDistortion;\",\r\n\t\t\"uniform float thicknessAmbient;\",\r\n\t\t\"uniform float thicknessAttenuation;\",\r\n\t\t\"uniform vec3 thicknessColor;\",\r\n\r\n\t\tShaderChunk[ \"lights_pars_begin\" ],\r\n\r\n\t\t\"void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\",\r\n\t\t\"\tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;\",\r\n\t\t\"\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\",\r\n\t\t\"\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\",\r\n\t\t\"\tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\",\r\n\t\t\"\treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\",\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\"\tvec3 normal = normalize( vNormal );\",\r\n\r\n\t\t\"\tvec3 viewerDirection = normalize( vViewPosition );\",\r\n\r\n\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\t\t\"\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\",\r\n\r\n\t\t\tShaderChunk[ \"map_fragment\" ],\r\n\t\t\tShaderChunk[ \"color_fragment\" ],\r\n\t\t\tShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\"\tvec3 totalEmissiveRadiance = emissive;\",\r\n\r\n\t\t\tShaderChunk[\"lights_phong_fragment\"],\r\n\r\n\t\t// Doing lights fragment begin.\r\n\t\t\"\tGeometricContext geometry;\",\r\n\t\t\"\tgeometry.position = - vViewPosition;\",\r\n\t\t\"\tgeometry.normal = normal;\",\r\n\t\t\"\tgeometry.viewDir = normalize( vViewPosition );\",\r\n\r\n\t\t\"\tIncidentLight directLight;\",\r\n\r\n\t\t\"\t#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\",\r\n\r\n\t\t\"\t\tPointLight pointLight;\",\r\n\r\n\t\t\"\t\t#pragma unroll_loop\",\r\n\t\t\"\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\",\r\n\t\t\"\t\t \tpointLight = pointLights[ i ];\",\r\n\t\t\"\t\t \tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\",\r\n\r\n\t\t\"\t\t\t#ifdef USE_SHADOWMAP\",\r\n\t\t\"\t\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\",\r\n\t\t\"\t\t\t#endif\",\r\n\r\n\t\t\"\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\",\r\n\r\n\t\t\"\t\t\t#if defined( TRANSLUCENT ) && defined( USE_MAP )\",\r\n\t\t\"\t\t\tRE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\",\r\n\t\t\"\t\t\t#endif\",\r\n\t\t\"\t\t}\",\r\n\r\n\t\t\"\t\t#endif\",\r\n\r\n\t\t\"\t#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\",\r\n\r\n\t\t\"\t\tDirectionalLight directionalLight;\",\r\n\r\n\t\t\"\t\t#pragma unroll_loop\",\r\n\t\t\"\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\",\r\n\t\t\"\t\t\tdirectionalLight = directionalLights[ i ];\",\r\n\t\t\"\t\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\",\r\n\r\n\t\t\"\t\t\t#ifdef USE_SHADOWMAP\",\r\n\t\t\"\t\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\",\r\n\t\t\"\t\t\t#endif\",\r\n\r\n\t\t\"\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\",\r\n\r\n\t\t\"\t\t\t#if defined( TRANSLUCENT ) && defined( USE_MAP )\",\r\n\t\t\"\t\t\tRE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\",\r\n\t\t\"\t\t\t#endif\",\r\n\t\t\"\t\t}\",\r\n\r\n\t\t\"\t#endif\",\r\n\r\n\t\t\"\t#if defined( RE_IndirectDiffuse )\",\r\n\r\n\t\t\"\t\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\",\r\n\r\n\t\t\"\t\t#if ( NUM_HEMI_LIGHTS > 0 )\",\r\n\r\n\t\t\"\t\t\t#pragma unroll_loop\",\r\n\t\t\"\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\"\t\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\",\r\n\r\n\t\t\"\t\t\t}\",\r\n\r\n\t\t\"\t\t#endif\",\r\n\r\n\t\t\"\t#endif\",\r\n\r\n\t\t\"\t#if defined( RE_IndirectSpecular )\",\r\n\r\n\t\t\"\t\tvec3 radiance = vec3( 0.0 );\",\r\n\t\t\"\t\tvec3 clearCoatRadiance = vec3( 0.0 );\",\r\n\r\n\t\t\"\t#endif\",\r\n\t\t\tShaderChunk[\"lights_fragment_end\"],\r\n\r\n\t\t\"\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\",\r\n\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\tShaderChunk[\"encodings_fragment\"],\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tthis.vertexShader = [\r\n\r\n\t\t\"varying vec3 vNormal;\",\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\tShaderChunk[ \"common\" ],\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\"\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"\tvViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\"\tvNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\"\tvUv = uv;\",\r\n\r\n\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\"}\" ].join( \"\\n\" );\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// Ported from Stefan Gustavson's java implementation\r\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\r\n// Read Stefan's excellent paper for details on how this code works.\r\n//\r\n// Sean McCullough banksean@gmail.com\r\n//\r\n// Added 4D noise\r\n// Joshua Koo zz85nus@gmail.com \r\n\r\nvar SimplexNoise = function(r) {\n\tvar this$1 = this;\n\r\n\tif (r == undefined) { r = Math; }\r\n\tthis.grad3 = [[ 1,1,0 ],[ -1,1,0 ],[ 1,-1,0 ],[ -1,-1,0 ], \r\n                                 [ 1,0,1 ],[ -1,0,1 ],[ 1,0,-1 ],[ -1,0,-1 ], \r\n                                 [ 0,1,1 ],[ 0,-1,1 ],[ 0,1,-1 ],[ 0,-1,-1 ]]; \r\n\r\n\tthis.grad4 = [[ 0,1,1,1 ], [ 0,1,1,-1 ], [ 0,1,-1,1 ], [ 0,1,-1,-1 ],\r\n\t     [ 0,-1,1,1 ], [ 0,-1,1,-1 ], [ 0,-1,-1,1 ], [ 0,-1,-1,-1 ],\r\n\t     [ 1,0,1,1 ], [ 1,0,1,-1 ], [ 1,0,-1,1 ], [ 1,0,-1,-1 ],\r\n\t     [ -1,0,1,1 ], [ -1,0,1,-1 ], [ -1,0,-1,1 ], [ -1,0,-1,-1 ],\r\n\t     [ 1,1,0,1 ], [ 1,1,0,-1 ], [ 1,-1,0,1 ], [ 1,-1,0,-1 ],\r\n\t     [ -1,1,0,1 ], [ -1,1,0,-1 ], [ -1,-1,0,1 ], [ -1,-1,0,-1 ],\r\n\t     [ 1,1,1,0 ], [ 1,1,-1,0 ], [ 1,-1,1,0 ], [ 1,-1,-1,0 ],\r\n\t     [ -1,1,1,0 ], [ -1,1,-1,0 ], [ -1,-1,1,0 ], [ -1,-1,-1,0 ]];\r\n\r\n\tthis.p = [];\r\n\tfor (var i = 0; i < 256; i ++) {\r\n\t\tthis$1.p[i] = Math.floor(r.random() * 256);\r\n\t}\r\n  // To remove the need for index wrapping, double the permutation table length \r\n\tthis.perm = []; \r\n\tfor (var i = 0; i < 512; i ++) {\r\n\t\tthis$1.perm[i] = this$1.p[i & 255];\r\n\t} \r\n\r\n  // A lookup table to traverse the simplex around a given point in 4D. \r\n  // Details can be found where this table is used, in the 4D noise method. \r\n\tthis.simplex = [ \r\n    [ 0,1,2,3 ],[ 0,1,3,2 ],[ 0,0,0,0 ],[ 0,2,3,1 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 1,2,3,0 ], \r\n    [ 0,2,1,3 ],[ 0,0,0,0 ],[ 0,3,1,2 ],[ 0,3,2,1 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 1,3,2,0 ], \r\n    [ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ], \r\n    [ 1,2,0,3 ],[ 0,0,0,0 ],[ 1,3,0,2 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 2,3,0,1 ],[ 2,3,1,0 ], \r\n    [ 1,0,2,3 ],[ 1,0,3,2 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 2,0,3,1 ],[ 0,0,0,0 ],[ 2,1,3,0 ], \r\n    [ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ], \r\n    [ 2,0,1,3 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 3,0,1,2 ],[ 3,0,2,1 ],[ 0,0,0,0 ],[ 3,1,2,0 ], \r\n    [ 2,1,0,3 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 3,1,0,2 ],[ 0,0,0,0 ],[ 3,2,0,1 ],[ 3,2,1,0 ]]; \r\n};\r\n\r\nSimplexNoise.prototype.dot = function(g, x, y) { \r\n\treturn g[0] * x + g[1] * y;\r\n};\r\n\r\nSimplexNoise.prototype.dot3 = function(g, x, y, z) {\r\n\treturn g[0] * x + g[1] * y + g[2] * z; \r\n};\r\n\r\nSimplexNoise.prototype.dot4 = function(g, x, y, z, w) {\r\n\treturn g[0] * x + g[1] * y + g[2] * z + g[3] * w;\r\n};\r\n\r\nSimplexNoise.prototype.noise = function(xin, yin) { \r\n\tvar n0, n1, n2; // Noise contributions from the three corners \r\n  // Skew the input space to determine which simplex cell we're in \r\n\tvar F2 = 0.5 * (Math.sqrt(3.0) - 1.0); \r\n\tvar s = (xin + yin) * F2; // Hairy factor for 2D \r\n\tvar i = Math.floor(xin + s); \r\n\tvar j = Math.floor(yin + s); \r\n\tvar G2 = (3.0 - Math.sqrt(3.0)) / 6.0; \r\n\tvar t = (i + j) * G2; \r\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space \r\n\tvar Y0 = j - t; \r\n\tvar x0 = xin - X0; // The x,y distances from the cell origin \r\n\tvar y0 = yin - Y0; \r\n  // For the 2D case, the simplex shape is an equilateral triangle. \r\n  // Determine which simplex we are in. \r\n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords \r\n\tif (x0 > y0) {i1 = 1; j1 = 0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1) \r\n\telse {i1 = 0; j1 = 1;}      // upper triangle, YX order: (0,0)->(0,1)->(1,1) \r\n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and \r\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where \r\n  // c = (3-sqrt(3))/6 \r\n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords \r\n\tvar y1 = y0 - j1 + G2; \r\n\tvar x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords \r\n\tvar y2 = y0 - 1.0 + 2.0 * G2; \r\n  // Work out the hashed gradient indices of the three simplex corners \r\n\tvar ii = i & 255; \r\n\tvar jj = j & 255; \r\n\tvar gi0 = this.perm[ii + this.perm[jj]] % 12; \r\n\tvar gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12; \r\n\tvar gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12; \r\n  // Calculate the contribution from the three corners \r\n\tvar t0 = 0.5 - x0 * x0 - y0 * y0; \r\n\tif (t0 < 0) { n0 = 0.0; } \r\n\telse { \r\n\t\tt0 *= t0; \r\n\t\tn0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient \r\n\t} \r\n\tvar t1 = 0.5 - x1 * x1 - y1 * y1; \r\n\tif (t1 < 0) { n1 = 0.0; } \r\n\telse { \r\n\t\tt1 *= t1; \r\n\t\tn1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); \r\n\t}\r\n\tvar t2 = 0.5 - x2 * x2 - y2 * y2; \r\n\tif (t2 < 0) { n2 = 0.0; } \r\n\telse { \r\n\t\tt2 *= t2; \r\n\t\tn2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); \r\n\t} \r\n  // Add contributions from each corner to get the final noise value. \r\n  // The result is scaled to return values in the interval [-1,1]. \r\n\treturn 70.0 * (n0 + n1 + n2); \r\n};\r\n\r\n// 3D simplex noise \r\nSimplexNoise.prototype.noise3d = function(xin, yin, zin) { \r\n\tvar n0, n1, n2, n3; // Noise contributions from the four corners \r\n  // Skew the input space to determine which simplex cell we're in \r\n\tvar F3 = 1.0 / 3.0; \r\n\tvar s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D \r\n\tvar i = Math.floor(xin + s); \r\n\tvar j = Math.floor(yin + s); \r\n\tvar k = Math.floor(zin + s); \r\n\tvar G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too \r\n\tvar t = (i + j + k) * G3; \r\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y,z) space \r\n\tvar Y0 = j - t; \r\n\tvar Z0 = k - t; \r\n\tvar x0 = xin - X0; // The x,y,z distances from the cell origin \r\n\tvar y0 = yin - Y0; \r\n\tvar z0 = zin - Z0; \r\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron. \r\n  // Determine which simplex we are in. \r\n\tvar i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords \r\n\tvar i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords \r\n\tif (x0 >= y0) { \r\n\t\tif (y0 >= z0) \r\n      { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // X Y Z order \r\n      else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } // X Z Y order \r\n\t\telse { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } // Z X Y order \r\n\t} \r\n\telse { // x0<y0 \r\n\t\tif (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } // Z Y X order \r\n    else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } // Y Z X order \r\n\t\telse { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // Y X Z order \r\n\t} \r\n  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z), \r\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and \r\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where \r\n  // c = 1/6.\r\n\tvar x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords \r\n\tvar y1 = y0 - j1 + G3; \r\n\tvar z1 = z0 - k1 + G3; \r\n\tvar x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords \r\n\tvar y2 = y0 - j2 + 2.0 * G3; \r\n\tvar z2 = z0 - k2 + 2.0 * G3; \r\n\tvar x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords \r\n\tvar y3 = y0 - 1.0 + 3.0 * G3; \r\n\tvar z3 = z0 - 1.0 + 3.0 * G3; \r\n  // Work out the hashed gradient indices of the four simplex corners \r\n\tvar ii = i & 255; \r\n\tvar jj = j & 255; \r\n\tvar kk = k & 255; \r\n\tvar gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12; \r\n\tvar gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12; \r\n\tvar gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12; \r\n\tvar gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12; \r\n  // Calculate the contribution from the four corners \r\n\tvar t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0; \r\n\tif (t0 < 0) { n0 = 0.0; } \r\n\telse { \r\n\t\tt0 *= t0; \r\n\t\tn0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0); \r\n\t}\r\n\tvar t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1; \r\n\tif (t1 < 0) { n1 = 0.0; } \r\n\telse { \r\n\t\tt1 *= t1; \r\n\t\tn1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1); \r\n\t} \r\n\tvar t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2; \r\n\tif (t2 < 0) { n2 = 0.0; } \r\n\telse { \r\n\t\tt2 *= t2; \r\n\t\tn2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2); \r\n\t} \r\n\tvar t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3; \r\n\tif (t3 < 0) { n3 = 0.0; } \r\n\telse { \r\n\t\tt3 *= t3; \r\n\t\tn3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3); \r\n\t} \r\n  // Add contributions from each corner to get the final noise value. \r\n  // The result is scaled to stay just inside [-1,1] \r\n\treturn 32.0 * (n0 + n1 + n2 + n3); \r\n};\r\n\r\n// 4D simplex noise\r\nSimplexNoise.prototype.noise4d = function( x, y, z, w ) {\r\n\t// For faster and easier lookups\r\n\tvar grad4 = this.grad4;\r\n\tvar simplex = this.simplex;\r\n\tvar perm = this.perm;\r\n\t\r\n   // The skewing and unskewing factors are hairy again for the 4D case\r\n\tvar F4 = (Math.sqrt(5.0) - 1.0) / 4.0;\r\n\tvar G4 = (5.0 - Math.sqrt(5.0)) / 20.0;\r\n\tvar n0, n1, n2, n3, n4; // Noise contributions from the five corners\r\n   // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\r\n\tvar s = (x + y + z + w) * F4; // Factor for 4D skewing\r\n\tvar i = Math.floor(x + s);\r\n\tvar j = Math.floor(y + s);\r\n\tvar k = Math.floor(z + s);\r\n\tvar l = Math.floor(w + s);\r\n\tvar t = (i + j + k + l) * G4; // Factor for 4D unskewing\r\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\r\n\tvar Y0 = j - t;\r\n\tvar Z0 = k - t;\r\n\tvar W0 = l - t;\r\n\tvar x0 = x - X0;  // The x,y,z,w distances from the cell origin\r\n\tvar y0 = y - Y0;\r\n\tvar z0 = z - Z0;\r\n\tvar w0 = w - W0;\r\n\r\n   // For the 4D case, the simplex is a 4D shape I won't even try to describe.\r\n   // To find out which of the 24 possible simplices we're in, we need to\r\n   // determine the magnitude ordering of x0, y0, z0 and w0.\r\n   // The method below is a good way of finding the ordering of x,y,z,w and\r\n   // then find the correct traversal order for the simplex we’re in.\r\n   // First, six pair-wise comparisons are performed between each possible pair\r\n   // of the four coordinates, and the results are used to add up binary bits\r\n   // for an integer index.\r\n\tvar c1 = (x0 > y0) ? 32 : 0;\r\n\tvar c2 = (x0 > z0) ? 16 : 0;\r\n\tvar c3 = (y0 > z0) ? 8 : 0;\r\n\tvar c4 = (x0 > w0) ? 4 : 0;\r\n\tvar c5 = (y0 > w0) ? 2 : 0;\r\n\tvar c6 = (z0 > w0) ? 1 : 0;\r\n\tvar c = c1 + c2 + c3 + c4 + c5 + c6;\r\n\tvar i1, j1, k1, l1; // The integer offsets for the second simplex corner\r\n\tvar i2, j2, k2, l2; // The integer offsets for the third simplex corner\r\n\tvar i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\r\n   // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\r\n   // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\r\n   // impossible. Only the 24 indices which have non-zero entries make any sense.\r\n   // We use a thresholding to set the coordinates in turn from the largest magnitude.\r\n   // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\r\n\ti1 = simplex[c][0] >= 3 ? 1 : 0;\r\n\tj1 = simplex[c][1] >= 3 ? 1 : 0;\r\n\tk1 = simplex[c][2] >= 3 ? 1 : 0;\r\n\tl1 = simplex[c][3] >= 3 ? 1 : 0;\r\n   // The number 2 in the \"simplex\" array is at the second largest coordinate.\r\n\ti2 = simplex[c][0] >= 2 ? 1 : 0;\r\n\tj2 = simplex[c][1] >= 2 ? 1 : 0;    k2 = simplex[c][2] >= 2 ? 1 : 0;\r\n\tl2 = simplex[c][3] >= 2 ? 1 : 0;\r\n   // The number 1 in the \"simplex\" array is at the second smallest coordinate.\r\n\ti3 = simplex[c][0] >= 1 ? 1 : 0;\r\n\tj3 = simplex[c][1] >= 1 ? 1 : 0;\r\n\tk3 = simplex[c][2] >= 1 ? 1 : 0;\r\n\tl3 = simplex[c][3] >= 1 ? 1 : 0;\r\n   // The fifth corner has all coordinate offsets = 1, so no need to look that up.\r\n\tvar x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\r\n\tvar y1 = y0 - j1 + G4;\r\n\tvar z1 = z0 - k1 + G4;\r\n\tvar w1 = w0 - l1 + G4;\r\n\tvar x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\r\n\tvar y2 = y0 - j2 + 2.0 * G4;\r\n\tvar z2 = z0 - k2 + 2.0 * G4;\r\n\tvar w2 = w0 - l2 + 2.0 * G4;\r\n\tvar x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\r\n\tvar y3 = y0 - j3 + 3.0 * G4;\r\n\tvar z3 = z0 - k3 + 3.0 * G4;\r\n\tvar w3 = w0 - l3 + 3.0 * G4;\r\n\tvar x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\r\n\tvar y4 = y0 - 1.0 + 4.0 * G4;\r\n\tvar z4 = z0 - 1.0 + 4.0 * G4;\r\n\tvar w4 = w0 - 1.0 + 4.0 * G4;\r\n   // Work out the hashed gradient indices of the five simplex corners\r\n\tvar ii = i & 255;\r\n\tvar jj = j & 255;\r\n\tvar kk = k & 255;\r\n\tvar ll = l & 255;\r\n\tvar gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;\r\n\tvar gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;\r\n\tvar gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;\r\n\tvar gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;\r\n\tvar gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;\r\n   // Calculate the contribution from the five corners\r\n\tvar t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\r\n\tif (t0 < 0) { n0 = 0.0; }\r\n\telse {\r\n\t\tt0 *= t0;\r\n\t\tn0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);\r\n\t}\r\n\tvar t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\r\n\tif (t1 < 0) { n1 = 0.0; }\r\n\telse {\r\n\t\tt1 *= t1;\r\n\t\tn1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);\r\n\t}\r\n\tvar t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\r\n\tif (t2 < 0) { n2 = 0.0; }\r\n\telse {\r\n\t\tt2 *= t2;\r\n\t\tn2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);\r\n\t}   var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\r\n\tif (t3 < 0) { n3 = 0.0; }\r\n\telse {\r\n\t\tt3 *= t3;\r\n\t\tn3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);\r\n\t}\r\n\tvar t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\r\n\tif (t4 < 0) { n4 = 0.0; }\r\n\telse {\r\n\t\tt4 *= t4;\r\n\t\tn4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);\r\n\t}\r\n   // Sum up and scale the result to cover the range [-1,1]\r\n\treturn 27.0 * (n0 + n1 + n2 + n3 + n4);\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TimelinerController = function TimelinerController( scene, trackInfo, onUpdate ) {\r\n\r\n\tthis._scene = scene;\r\n\tthis._trackInfo = trackInfo;\r\n\r\n\tthis._onUpdate = onUpdate;\r\n\r\n\tthis._mixer = new AnimationMixer( scene );\r\n\tthis._clip = null;\r\n\tthis._action = null;\r\n\r\n\tthis._tracks = {};\r\n\tthis._propRefs = {};\r\n\tthis._channelNames = [];\r\n\r\n};\r\n\r\nTimelinerController.prototype = {\r\n\r\n\tconstructor: TimelinerController,\r\n\r\n\tinit: function( timeliner ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar tracks = [],\r\n\t\t\ttrackInfo = this._trackInfo;\r\n\r\n\t\tfor ( var i = 0, n = trackInfo.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar spec = trackInfo[ i ];\r\n\r\n\t\t\ttracks.push( this$1._addTrack(\r\n\t\t\t\t\tspec.type, spec.propertyPath,\r\n\t\t\t\t\tspec.initialValue, spec.interpolation ) );\r\n\t\t}\r\n\r\n\t\tthis._clip = new AnimationClip( 'editclip', 0, tracks );\r\n\t\tthis._action = this._mixer.clipAction( this._clip ).play();\r\n\r\n\t},\r\n\r\n\tsetDisplayTime: function( time ) {\r\n\r\n\t\tthis._action.time = time;\r\n\t\tthis._mixer.update( 0 );\r\n\r\n\t\tthis._onUpdate();\r\n\r\n\t},\r\n\r\n\tsetDuration: function( duration ) {\r\n\r\n\t\tthis._clip.duration = duration;\r\n\r\n\t},\r\n\r\n\tgetChannelNames: function() {\r\n\r\n\t\treturn this._channelNames;\r\n\r\n\t},\r\n\r\n\tgetChannelKeyTimes: function( channelName ) {\r\n\r\n\t\treturn this._tracks[ channelName ].times;\r\n\r\n\t},\r\n\r\n\tsetKeyframe: function( channelName, time ) {\r\n\r\n\t\tvar track = this._tracks[ channelName ],\r\n\t\t\ttimes = track.times,\r\n\t\t\tindex = Timeliner.binarySearch( times, time ),\r\n\t\t\tvalues = track.values,\r\n\t\t\tstride = track.getValueSize(),\r\n\t\t\toffset = index * stride;\r\n\r\n\t\tif ( index < 0 ) {\r\n\r\n\t\t\t// insert new keyframe\r\n\r\n\t\t\tindex = ~ index;\r\n\t\t\toffset = index * stride;\r\n\r\n\t\t\tvar nTimes = times.length + 1,\r\n\t\t\t\tnValues = values.length + stride;\r\n\r\n\t\t\tfor ( var i = nTimes - 1; i !== index; -- i ) {\r\n\r\n\t\t\t\ttimes[ i ] = times[ i - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = nValues - 1,\r\n\t\t\t\t\te = offset + stride - 1; i !== e; -- i ) {\r\n\r\n\t\t\t\tvalues[ i ] = values[ i - stride ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ttimes[ index ] = time;\r\n\t\tthis._propRefs[ channelName ].getValue( values, offset );\r\n\r\n\t},\r\n\r\n\tdelKeyframe: function( channelName, time ) {\r\n\r\n\t\tvar track = this._tracks[ channelName ],\r\n\t\t\ttimes = track.times,\r\n\t\t\tindex = Timeliner.binarySearch( times, time );\r\n\r\n\t\t// we disallow to remove the keyframe when it is the last one we have,\r\n\t\t// since the animation system is designed to always produce a defined\r\n\t\t// state\r\n\r\n\t\tif ( times.length > 1 && index >= 0 ) {\r\n\r\n\t\t\tvar nTimes = times.length - 1,\r\n\t\t\t\tvalues = track.values,\r\n\t\t\t\tstride = track.getValueSize(),\r\n\t\t\t\tnValues = values.length - stride;\r\n\r\n\t\t\t// note: no track.getValueSize when array sizes are out of sync\r\n\r\n\t\t\tfor ( var i = index; i !== nTimes; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] = times[ i + 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttimes.pop();\r\n\r\n\t\t\tfor ( var offset = index * stride; offset !== nValues; ++ offset ) {\r\n\r\n\t\t\t\tvalues[ offset ] = values[ offset + stride ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvalues.length = nValues;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmoveKeyframe: function( channelName, time, delta, moveRemaining ) {\r\n\r\n\t\tvar track = this._tracks[ channelName ],\r\n\t\t\ttimes = track.times,\r\n\t\t\tindex = Timeliner.binarySearch( times, time );\r\n\r\n\t\tif ( index >= 0 ) {\r\n\r\n\t\t\tvar endAt = moveRemaining ? times.length : index + 1,\r\n\t\t\t\tneedsSort = times[ index - 1 ] <= time ||\r\n\t\t\t\t\t! moveRemaining && time >= times[ index + 1 ];\r\n\r\n\t\t\twhile ( index !== endAt ) { times[ index ++ ] += delta; }\r\n\r\n\t\t\tif ( needsSort ) { this._sort( track ); }\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tserialize: function() {\r\n\r\n\t\tvar result = {\r\n\t\t\t\tduration: this._clip.duration,\r\n\t\t\t\tchannels: {}\r\n\t\t\t},\r\n\r\n\t\t\tnames = this._channelNames,\r\n\t\t\ttracks = this._tracks,\r\n\r\n\t\t\tchannels = result.channels;\r\n\r\n\t\tfor ( var i = 0, n = names.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar name = names[ i ],\r\n\t\t\t\ttrack = tracks[ name ];\r\n\r\n\t\t\tchannels[ name ] = {\r\n\r\n\t\t\t\ttimes: track.times,\r\n\t\t\t\tvalues: track.values\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tdeserialize: function( structs ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar names = this._channelNames,\r\n\t\t\ttracks = this._tracks,\r\n\r\n\t\t\tchannels = structs.channels;\r\n\r\n\t\tthis.setDuration( structs.duration );\r\n\r\n\t\tfor ( var i = 0, n = names.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar name = names[ i ],\r\n\t\t\t\ttrack = tracks[ name ],\r\n\t\t\t\tdata = channels[ name ];\r\n\r\n\t\t\tthis$1._setArray( track.times, data.times );\r\n\t\t\tthis$1._setArray( track.values, data.values );\r\n\r\n\t\t}\r\n\r\n\t\t// update display\r\n\t\tthis.setDisplayTime( this._mixer.time );\r\n\r\n\t},\r\n\r\n\t_sort: function( track ) {\r\n\r\n\t\tvar times = track.times,\r\n\t\t\torder = AnimationUtils.getKeyframeOrder( times );\r\n\r\n\t\tthis._setArray( times,\r\n\t\t\t\tAnimationUtils.sortedArray( times, 1, order ) );\r\n\r\n\t\tvar values = track.values,\r\n\t\t\tstride = track.getValueSize();\r\n\r\n\t\tthis._setArray( values,\r\n\t\t\t\tAnimationUtils.sortedArray( values, stride, order ) );\r\n\r\n\t},\r\n\r\n\t_setArray: function( dst, src ) {\r\n\r\n\t\tdst.length = 0;\r\n\t\tdst.push.apply( dst, src );\r\n\r\n\t},\r\n\r\n\t_addTrack: function( type, prop, initialValue, interpolation ) {\r\n\r\n\t\tvar track = new type(\r\n\t\t\t\tprop, [ 0 ], initialValue, interpolation );\r\n\r\n\t\t// data must be in JS arrays so it can be resized\r\n\t\ttrack.times = Array.prototype.slice.call( track.times );\r\n\t\ttrack.values = Array.prototype.slice.call( track.values );\r\n\r\n\t\tthis._channelNames.push( prop );\r\n\t\tthis._tracks[ prop ] = track;\r\n\r\n\t\t// for recording the state:\r\n\t\tthis._propRefs[ prop ] =\r\n\t\t\t\tnew PropertyBinding( this._scene, prop );\r\n\r\n\t\treturn track;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar TypedArrayUtils = {};\r\n\r\nTypedArrayUtils.quicksortIP = function ( arr, eleSize, orderElement ) {\r\n\r\n\tvar stack = [];\r\n\tvar sp = - 1;\r\n\tvar left = 0;\r\n\tvar right = arr.length / eleSize - 1;\r\n\tvar tmp = 0.0, x = 0, y = 0;\r\n\r\n\tvar swapF = function ( a, b ) {\r\n\r\n\t\ta *= eleSize; b *= eleSize;\r\n\r\n\t\tfor ( y = 0; y < eleSize; y ++ ) {\r\n\r\n\t\t\ttmp = arr[ a + y ];\r\n\t\t\tarr[ a + y ] = arr[ b + y ];\r\n\t\t\tarr[ b + y ] = tmp;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n\tvar i, j, swap = new Float32Array( eleSize ), temp = new Float32Array( eleSize );\r\n\r\n\twhile ( true ) {\r\n\r\n\t\tif ( right - left <= 25 ) {\r\n\r\n\t\t\tfor ( j = left + 1; j <= right; j ++ ) {\r\n\r\n\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\r\n\t\t\t\r\n\t\t\t\t\tswap[ x ] = arr[ j * eleSize + x ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ti = j - 1;\r\n\t\t\t\t\r\n\t\t\t\twhile ( i >= left && arr[ i * eleSize + orderElement ] > swap[ orderElement ] ) {\r\n\r\n\t\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\r\n\r\n\t\t\t\t\t\tarr[ ( i + 1 ) * eleSize + x ] = arr[ i * eleSize + x ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ti --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\r\n\r\n\t\t\t\t\tarr[ ( i + 1 ) * eleSize + x ] = swap[ x ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( sp == - 1 ) { break; }\r\n\r\n\t\t\tright = stack[ sp -- ]; //?\r\n\t\t\tleft = stack[ sp -- ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar median = ( left + right ) >> 1;\r\n\r\n\t\t\ti = left + 1;\r\n\t\t\tj = right;\r\n\t\r\n\t\t\tswapF( median, i );\r\n\r\n\t\t\tif ( arr[ left * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {\r\n\t\t\r\n\t\t\t\tswapF( left, right );\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tif ( arr[ i * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {\r\n\t\t\r\n\t\t\t\tswapF( i, right );\r\n\t\t\r\n\t\t\t}\r\n\r\n\t\t\tif ( arr[ left * eleSize + orderElement ] > arr[ i * eleSize + orderElement ] ) {\r\n\t\t\r\n\t\t\t\tswapF( left, i );\r\n\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\r\n\r\n\t\t\t\ttemp[ x ] = arr[ i * eleSize + x ];\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\twhile ( true ) {\r\n\t\t\t\t\r\n\t\t\t\tdo { i ++; } while ( arr[ i * eleSize + orderElement ] < temp[ orderElement ] );\r\n\t\t\t\tdo { j --; } while ( arr[ j * eleSize + orderElement ] > temp[ orderElement ] );\r\n\t\t\t\t\r\n\t\t\t\tif ( j < i ) { break; }\r\n\t\t\r\n\t\t\t\tswapF( i, j );\r\n\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\r\n\r\n\t\t\t\tarr[ ( left + 1 ) * eleSize + x ] = arr[ j * eleSize + x ];\r\n\t\t\t\tarr[ j * eleSize + x ] = temp[ x ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( right - i + 1 >= j - left ) {\r\n\r\n\t\t\t\tstack[ ++ sp ] = i;\r\n\t\t\t\tstack[ ++ sp ] = right;\r\n\t\t\t\tright = j - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstack[ ++ sp ] = left;\r\n\t\t\t\tstack[ ++ sp ] = j - 1;\r\n\t\t\t\tleft = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn arr;\r\n\r\n};\r\n\r\n TypedArrayUtils.Kdtree = function ( points, metric, eleSize ) {\r\n\r\n\tvar self = this;\r\n\t\r\n\tvar maxDepth = 0;\r\n\t\r\n\tvar getPointSet = function ( points, pos ) {\r\n\r\n\t\treturn points.subarray( pos * eleSize, pos * eleSize + eleSize );\r\n\r\n\t};\r\n\t\t\r\n\tfunction buildTree( points, depth, parent, pos ) {\r\n\r\n\t\tvar dim = depth % eleSize,\r\n\t\t\tmedian,\r\n\t\t\tnode,\r\n\t\t\tplength = points.length / eleSize;\r\n\r\n\t\tif ( depth > maxDepth ) { maxDepth = depth; }\r\n\t\t\r\n\t\tif ( plength === 0 ) { return null; }\r\n\t\tif ( plength === 1 ) {\r\n\r\n\t\t\treturn new self.Node( getPointSet( points, 0 ), depth, parent, pos );\r\n\r\n\t\t}\r\n\r\n\t\tTypedArrayUtils.quicksortIP( points, eleSize, dim );\r\n\t\t\r\n\t\tmedian = Math.floor( plength / 2 );\r\n\t\t\r\n\t\tnode = new self.Node( getPointSet( points, median ), depth, parent, median + pos );\r\n\t\tnode.left = buildTree( points.subarray( 0, median * eleSize ), depth + 1, node, pos );\r\n\t\tnode.right = buildTree( points.subarray( ( median + 1 ) * eleSize, points.length ), depth + 1, node, pos + median + 1 );\r\n\r\n\t\treturn node;\r\n\t\r\n\t}\r\n\r\n\tthis.root = buildTree( points, 0, null, 0 );\r\n\t\t\r\n\tthis.getMaxDepth = function () {\r\n\r\n\t\treturn maxDepth;\r\n\r\n\t};\r\n\t\r\n\tthis.nearest = function ( point, maxNodes, maxDistance ) {\r\n\r\n\t\tvar i,\r\n\t\t\tresult,\r\n\t\t\tbestNodes;\r\n\r\n\t\tbestNodes = new TypedArrayUtils.Kdtree.BinaryHeap(\r\n\r\n\t\t\tfunction ( e ) {\r\n\r\n\t\t\t\treturn - e[ 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t\t\t);\r\n\r\n\t\tfunction nearestSearch( node ) {\r\n\r\n\t\t\tvar bestChild,\r\n\t\t\t\tdimension = node.depth % eleSize,\r\n\t\t\t\townDistance = metric( point, node.obj ),\r\n\t\t\t\tlinearDistance = 0,\r\n\t\t\t\totherChild,\r\n\t\t\t\ti,\r\n\t\t\t\tlinearPoint = [];\r\n\r\n\t\t\tfunction saveNode( node, distance ) {\r\n\r\n\t\t\t\tbestNodes.push( [ node, distance ] );\r\n\r\n\t\t\t\tif ( bestNodes.size() > maxNodes ) {\r\n\r\n\t\t\t\t\tbestNodes.pop();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < eleSize; i += 1 ) {\r\n\r\n\t\t\t\tif ( i === node.depth % eleSize ) {\r\n\r\n\t\t\t\t\tlinearPoint[ i ] = point[ i ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tlinearPoint[ i ] = node.obj[ i ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlinearDistance = metric( linearPoint, node.obj );\r\n\r\n\t\t\t// if it's a leaf\r\n\r\n\t\t\tif ( node.right === null && node.left === null ) {\r\n\r\n\t\t\t\tif ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {\r\n\r\n\t\t\t\t\tsaveNode( node, ownDistance );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.right === null ) {\r\n\r\n\t\t\t\tbestChild = node.left;\r\n\r\n\t\t\t} else if ( node.left === null ) {\r\n\r\n\t\t\t\tbestChild = node.right;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( point[ dimension ] < node.obj[ dimension ] ) {\r\n\r\n\t\t\t\t\tbestChild = node.left;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbestChild = node.right;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// recursive search\r\n\r\n\t\t\tnearestSearch( bestChild );\r\n\r\n\t\t\tif ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {\r\n\r\n\t\t\t\tsaveNode( node, ownDistance );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if there's still room or the current distance is nearer than the best distance\r\n\r\n\t\t\tif ( bestNodes.size() < maxNodes || Math.abs( linearDistance ) < bestNodes.peek()[ 1 ] ) {\r\n\r\n\t\t\t\tif ( bestChild === node.left ) {\r\n\r\n\t\t\t\t\totherChild = node.right;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\totherChild = node.left;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( otherChild !== null ) {\r\n\r\n\t\t\t\t\tnearestSearch( otherChild );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( maxDistance ) {\r\n\r\n\t\t\tfor ( i = 0; i < maxNodes; i += 1 ) {\r\n\r\n\t\t\t\tbestNodes.push( [ null, maxDistance ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tnearestSearch( self.root );\r\n\r\n\t\tresult = [];\r\n\r\n\t\tfor ( i = 0; i < maxNodes; i += 1 ) {\r\n\r\n\t\t\tif ( bestNodes.content[ i ][ 0 ] ) {\r\n\r\n\t\t\t\tresult.push( [ bestNodes.content[ i ][ 0 ], bestNodes.content[ i ][ 1 ] ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t\r\n\t};\r\n\t\r\n};\r\n\r\nTypedArrayUtils.Kdtree.prototype.Node = function ( obj, depth, parent, pos ) {\r\n\r\n\tthis.obj = obj;\r\n\tthis.left = null;\r\n\tthis.right = null;\r\n\tthis.parent = parent;\r\n\tthis.depth = depth;\r\n\tthis.pos = pos;\r\n\r\n}; \r\n\r\nTypedArrayUtils.Kdtree.BinaryHeap = function ( scoreFunction ) {\r\n\r\n\tthis.content = [];\r\n\tthis.scoreFunction = scoreFunction;\r\n\r\n};\r\n\r\nTypedArrayUtils.Kdtree.BinaryHeap.prototype = {\r\n\r\n\tpush: function ( element ) {\r\n\r\n\t\t// Add the new element to the end of the array.\r\n\t\tthis.content.push( element );\r\n\r\n\t\t// Allow it to bubble up.\r\n\t\tthis.bubbleUp( this.content.length - 1 );\r\n\r\n\t},\r\n\r\n\tpop: function () {\r\n\r\n\t\t// Store the first element so we can return it later.\r\n\t\tvar result = this.content[ 0 ];\r\n\r\n\t\t// Get the element at the end of the array.\r\n\t\tvar end = this.content.pop();\r\n\r\n\t\t// If there are any elements left, put the end element at the\r\n\t\t// start, and let it sink down.\r\n\t\tif ( this.content.length > 0 ) {\r\n\r\n\t\t\tthis.content[ 0 ] = end;\r\n\t\t\tthis.sinkDown( 0 );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tpeek: function () {\r\n\r\n\t\treturn this.content[ 0 ];\r\n\r\n\t},\r\n\r\n\tremove: function ( node ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar len = this.content.length;\r\n\r\n\t\t// To remove a value, we must search through the array to find it.\r\n\t\tfor ( var i = 0; i < len; i ++ ) {\r\n\r\n\t\t\tif ( this$1.content[ i ] == node ) {\r\n\r\n\t\t\t\t// When it is found, the process seen in 'pop' is repeated\r\n\t\t\t\t// to fill up the hole.\r\n\t\t\t\tvar end = this$1.content.pop();\r\n\r\n\t\t\t\tif ( i != len - 1 ) {\r\n\r\n\t\t\t\t\tthis$1.content[ i ] = end;\r\n\r\n\t\t\t\t\tif ( this$1.scoreFunction( end ) < this$1.scoreFunction( node ) ) {\r\n\r\n\t\t\t\t\t\tthis$1.bubbleUp( i );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis$1.sinkDown( i );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthrow new Error( \"Node not found.\" );\r\n\r\n\t},\r\n\r\n\tsize: function () {\r\n\r\n\t\treturn this.content.length;\r\n\r\n\t},\r\n\r\n\tbubbleUp: function ( n ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\t// Fetch the element that has to be moved.\r\n\t\tvar element = this.content[ n ];\r\n\r\n\t\t// When at 0, an element can not go up any further.\r\n\t\twhile ( n > 0 ) {\r\n\r\n\t\t\t// Compute the parent element's index, and fetch it.\r\n\t\t\tvar parentN = Math.floor( ( n + 1 ) / 2 ) - 1,\r\n\t\t\t\tparent = this$1.content[ parentN ];\r\n\r\n\t\t\t// Swap the elements if the parent is greater.\r\n\t\t\tif ( this$1.scoreFunction( element ) < this$1.scoreFunction( parent ) ) {\r\n\r\n\t\t\t\tthis$1.content[ parentN ] = element;\r\n\t\t\t\tthis$1.content[ n ] = parent;\r\n\r\n\t\t\t\t// Update 'n' to continue at the new position.\r\n\t\t\t\tn = parentN;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Found a parent that is less, no need to move it further.\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsinkDown: function ( n ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\t// Look up the target element and its score.\r\n\t\tvar length = this.content.length,\r\n\t\t\telement = this.content[ n ],\r\n\t\t\telemScore = this.scoreFunction( element );\r\n\r\n\t\twhile ( true ) {\r\n\r\n\t\t\t// Compute the indices of the child elements.\r\n\t\t\tvar child2N = ( n + 1 ) * 2, child1N = child2N - 1;\r\n\r\n\t\t\t// This is used to store the new position of the element, if any.\r\n\t\t\tvar swap = null;\r\n\r\n\t\t\t// If the first child exists (is inside the array)...\r\n\t\t\tif ( child1N < length ) {\r\n\r\n\t\t\t\t// Look it up and compute its score.\r\n\t\t\t\tvar child1 = this$1.content[ child1N ],\r\n\t\t\t\t\tchild1Score = this$1.scoreFunction( child1 );\r\n\r\n\t\t\t\t// If the score is less than our element's, we need to swap.\r\n\t\t\t\tif ( child1Score < elemScore ) { swap = child1N; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Do the same checks for the other child.\r\n\t\t\tif ( child2N < length ) {\r\n\r\n\t\t\t\tvar child2 = this$1.content[ child2N ],\r\n\t\t\t\t\tchild2Score = this$1.scoreFunction( child2 );\r\n\r\n\t\t\t\tif ( child2Score < ( swap === null ? elemScore : child1Score ) ) { swap = child2N; }\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// If the element needs to be moved, swap it, and continue.\r\n\t\t\tif ( swap !== null ) {\r\n\r\n\t\t\t\tthis$1.content[ n ] = this$1.content[ swap ];\r\n\t\t\t\tthis$1.content[ swap ] = element;\r\n\t\t\t\tn = swap;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Otherwise, we are done.\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvar UCSCharacter = function () {\n\n\tvar scope = this;\n\n\tvar mesh;\n\n\tthis.scale = 1;\n\n\tthis.root = new Object3D();\n\n\tthis.numSkins = undefined;\n\tthis.numMorphs = undefined;\n\n\tthis.skins = [];\n\tthis.materials = [];\n\tthis.morphs = [];\n\n\tthis.mixer = new AnimationMixer( this.root );\n\n\tthis.onLoadComplete = function () {};\n\n\tthis.loadCounter = 0;\n\n\tthis.loadParts = function ( config ) {\n\n\t\tthis.numSkins = config.skins.length;\n\t\tthis.numMorphs = config.morphs.length;\n\n\t\t// Character geometry + number of skins\n\t\tthis.loadCounter = 1 + config.skins.length;\n\n\t\t// SKINS\n\t\tthis.skins = loadTextures( config.baseUrl + \"skins/\", config.skins );\n\t\tthis.materials = createMaterials( this.skins );\n\n\t\t// MORPHS\n\t\tthis.morphs = config.morphs;\n\n\t\t// CHARACTER\n\t\tvar loader = new JSONLoader();\n\t\tconsole.log( config.baseUrl + config.character );\n\t\tloader.load( config.baseUrl + config.character, function ( geometry ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\tmesh = new SkinnedMesh( geometry, [] );\n\t\t\tmesh.name = config.character;\n\t\t\tscope.root.add( mesh );\n\n\t\t\tvar bb = geometry.boundingBox;\n\t\t\tscope.root.scale.set( config.s, config.s, config.s );\n\t\t\tscope.root.position.set( config.x, config.y - bb.min.y * config.s, config.z );\n\n\t\t\tmesh.castShadow = true;\n\t\t\tmesh.receiveShadow = true;\n\n\t\t\tscope.mixer.clipAction( geometry.animations[ 0 ], mesh ).play();\n\n\t\t\tscope.setSkin( 0 );\n\n\t\t\tscope.checkLoadComplete();\n\n\t\t} );\n\n\t};\n\n\tthis.setSkin = function ( index ) {\n\n\t\tif ( mesh && scope.materials ) {\n\n\t\t\tmesh.material = scope.materials[ index ];\n\n\t\t}\n\n\t};\n\n\tthis.updateMorphs = function ( influences ) {\n\n\t\tif ( mesh ) {\n\n\t\t\tfor ( var i = 0; i < scope.numMorphs; i ++ ) {\n\n\t\t\t\tmesh.morphTargetInfluences[ i ] = influences[ scope.morphs[ i ] ] / 100;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction loadTextures( baseUrl, textureUrls ) {\n\n\t\tvar textureLoader = new TextureLoader();\n\t\tvar textures = [];\n\n\t\tfor ( var i = 0; i < textureUrls.length; i ++ ) {\n\n\t\t\ttextures[ i ] = textureLoader.load( baseUrl + textureUrls[ i ], scope.checkLoadComplete );\n\t\t\ttextures[ i ].mapping = UVMapping;\n\t\t\ttextures[ i ].name = textureUrls[ i ];\n\n\t\t}\n\n\t\treturn textures;\n\n\t}\n\n\tfunction createMaterials( skins ) {\n\n\t\tvar materials = [];\n\n\t\tfor ( var i = 0; i < skins.length; i ++ ) {\n\n\t\t\tmaterials[ i ] = new MeshLambertMaterial( {\n\t\t\t\tcolor: 0xeeeeee,\n\t\t\t\tspecular: 10.0,\n\t\t\t\tmap: skins[ i ],\n\t\t\t\tskinning: true,\n\t\t\t\tmorphTargets: true\n\t\t\t} );\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tthis.checkLoadComplete = function () {\n\n\t\tscope.loadCounter -= 1;\n\n\t\tif ( scope.loadCounter === 0 ) {\n\n\t\t\tscope.onLoadComplete();\n\n\t\t}\n\n\t};\n\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar GeometryUtils = {\r\n\r\n\t// Merge two geometries or geometry and geometry from object (using object's transform)\r\n\r\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\r\n\t\tconsole.warn( 'GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\r\n\t\tvar matrix;\r\n\r\n\t\tif ( geometry2 instanceof Mesh ) {\r\n\r\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\r\n\t\t\tmatrix = geometry2.matrix;\r\n\t\t\tgeometry2 = geometry2.geometry;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\r\n\t},\r\n\r\n\t// Get random point in triangle (via barycentric coordinates)\r\n\t// \t(uniform distribution)\r\n\t// \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\r\n\r\n\trandomPointInTriangle: function () {\r\n\r\n\t\tvar vector = new Vector3();\r\n\r\n\t\treturn function ( vectorA, vectorB, vectorC ) {\r\n\r\n\t\t\tvar point = new Vector3();\r\n\r\n\t\t\tvar a = Math.random();\r\n\t\t\tvar b = Math.random();\r\n\r\n\t\t\tif ( ( a + b ) > 1 ) {\r\n\r\n\t\t\t\ta = 1 - a;\r\n\t\t\t\tb = 1 - b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar c = 1 - a - b;\r\n\r\n\t\t\tpoint.copy( vectorA );\r\n\t\t\tpoint.multiplyScalar( a );\r\n\r\n\t\t\tvector.copy( vectorB );\r\n\t\t\tvector.multiplyScalar( b );\r\n\r\n\t\t\tpoint.add( vector );\r\n\r\n\t\t\tvector.copy( vectorC );\r\n\t\t\tvector.multiplyScalar( c );\r\n\r\n\t\t\tpoint.add( vector );\r\n\r\n\t\t\treturn point;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\t// Get random point in face (triangle)\r\n\t// (uniform distribution)\r\n\r\n\trandomPointInFace: function ( face, geometry ) {\r\n\r\n\t\tvar vA, vB, vC;\r\n\r\n\t\tvA = geometry.vertices[ face.a ];\r\n\t\tvB = geometry.vertices[ face.b ];\r\n\t\tvC = geometry.vertices[ face.c ];\r\n\r\n\t\treturn GeometryUtils.randomPointInTriangle( vA, vB, vC );\r\n\r\n\t},\r\n\r\n\t// Get uniformly distributed random points in mesh\r\n\t// \t- create array with cumulative sums of face areas\r\n\t//  - pick random number from 0 to total area\r\n\t//  - find corresponding place in area array by binary search\r\n\t//\t- get random point in face\r\n\r\n\trandomPointsInGeometry: function ( geometry, n ) {\r\n\r\n\t\tvar face, i,\r\n\t\t\tfaces = geometry.faces,\r\n\t\t\tvertices = geometry.vertices,\r\n\t\t\til = faces.length,\r\n\t\t\ttotalArea = 0,\r\n\t\t\tcumulativeAreas = [],\r\n\t\t\tvA, vB, vC;\r\n\r\n\t\t// precompute face areas\r\n\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tface = faces[ i ];\r\n\r\n\t\t\tvA = vertices[ face.a ];\r\n\t\t\tvB = vertices[ face.b ];\r\n\t\t\tvC = vertices[ face.c ];\r\n\r\n\t\t\tface._area = GeometryUtils.triangleArea( vA, vB, vC );\r\n\r\n\t\t\ttotalArea += face._area;\r\n\r\n\t\t\tcumulativeAreas[ i ] = totalArea;\r\n\r\n\t\t}\r\n\r\n\t\t// binary search cumulative areas array\r\n\r\n\t\tfunction binarySearchIndices( value ) {\r\n\r\n\t\t\tfunction binarySearch( start, end ) {\r\n\r\n\t\t\t\t// return closest larger index\r\n\t\t\t\t// if exact number is not found\r\n\r\n\t\t\t\tif ( end < start )\r\n\t\t\t\t\t{ return start; }\r\n\r\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\r\n\r\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\r\n\r\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\r\n\r\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\r\n\r\n\t\t\t\t\treturn binarySearch( mid + 1, end );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn mid;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 );\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t// pick random face weighted by face area\r\n\r\n\t\tvar r, index,\r\n\t\t\tresult = [];\r\n\r\n\t\tfor ( i = 0; i < n; i ++ ) {\r\n\r\n\t\t\tr = Math.random() * totalArea;\r\n\r\n\t\t\tindex = binarySearchIndices( r );\r\n\r\n\t\t\tresult[ i ] = GeometryUtils.randomPointInFace( faces[ index ], geometry );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\trandomPointsInBufferGeometry: function ( geometry, n ) {\r\n\r\n\t\tvar i,\r\n\t\t\tvertices = geometry.attributes.position.array,\r\n\t\t\ttotalArea = 0,\r\n\t\t\tcumulativeAreas = [],\r\n\t\t\tvA, vB, vC;\r\n\r\n\t\t// precompute face areas\r\n\t\tvA = new Vector3();\r\n\t\tvB = new Vector3();\r\n\t\tvC = new Vector3();\r\n\r\n\t\t// geometry._areas = [];\r\n\t\tvar il = vertices.length / 9;\r\n\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tvA.set( vertices[ i * 9 + 0 ], vertices[ i * 9 + 1 ], vertices[ i * 9 + 2 ] );\r\n\t\t\tvB.set( vertices[ i * 9 + 3 ], vertices[ i * 9 + 4 ], vertices[ i * 9 + 5 ] );\r\n\t\t\tvC.set( vertices[ i * 9 + 6 ], vertices[ i * 9 + 7 ], vertices[ i * 9 + 8 ] );\r\n\r\n\t\t\ttotalArea += GeometryUtils.triangleArea( vA, vB, vC );\r\n\r\n\t\t\tcumulativeAreas.push( totalArea );\r\n\r\n\t\t}\r\n\r\n\t\t// binary search cumulative areas array\r\n\r\n\t\tfunction binarySearchIndices( value ) {\r\n\r\n\t\t\tfunction binarySearch( start, end ) {\r\n\r\n\t\t\t\t// return closest larger index\r\n\t\t\t\t// if exact number is not found\r\n\r\n\t\t\t\tif ( end < start )\r\n\t\t\t\t\t{ return start; }\r\n\r\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\r\n\r\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\r\n\r\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\r\n\r\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\r\n\r\n\t\t\t\t\treturn binarySearch( mid + 1, end );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn mid;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 );\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t// pick random face weighted by face area\r\n\r\n\t\tvar r, index,\r\n\t\t\tresult = [];\r\n\r\n\t\tfor ( i = 0; i < n; i ++ ) {\r\n\r\n\t\t\tr = Math.random() * totalArea;\r\n\r\n\t\t\tindex = binarySearchIndices( r );\r\n\r\n\t\t\t// result[ i ] = GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\r\n\t\t\tvA.set( vertices[ index * 9 + 0 ], vertices[ index * 9 + 1 ], vertices[ index * 9 + 2 ] );\r\n\t\t\tvB.set( vertices[ index * 9 + 3 ], vertices[ index * 9 + 4 ], vertices[ index * 9 + 5 ] );\r\n\t\t\tvC.set( vertices[ index * 9 + 6 ], vertices[ index * 9 + 7 ], vertices[ index * 9 + 8 ] );\r\n\t\t\tresult[ i ] = GeometryUtils.randomPointInTriangle( vA, vB, vC );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// Get triangle area (half of parallelogram)\r\n\t// http://mathworld.wolfram.com/TriangleArea.html\r\n\r\n\ttriangleArea: function () {\r\n\r\n\t\tvar vector1 = new Vector3();\r\n\t\tvar vector2 = new Vector3();\r\n\r\n\t\treturn function ( vectorA, vectorB, vectorC ) {\r\n\r\n\t\t\tvector1.subVectors( vectorB, vectorA );\r\n\t\t\tvector2.subVectors( vectorC, vectorA );\r\n\t\t\tvector1.cross( vector2 );\r\n\r\n\t\t\treturn 0.5 * vector1.length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcenter: function ( geometry ) {\r\n\r\n\t\tconsole.warn( 'GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\treturn geometry.center();\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar MathUtils = {\r\n\r\n    setQuaternionFromProperEuler: function ( q, a, b, c, order ) {\r\n\r\n        // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\r\n\r\n        // rotations are applied to the axes in the order specified by 'order'\r\n        // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\r\n        // angles are in radians\r\n\r\n        var cos = Math.cos;\r\n        var sin = Math.sin;\r\n\r\n        var c2 = cos( b / 2 );\r\n        var s2 = sin( b / 2 );\r\n\r\n        var c13 = cos( ( a + c ) / 2 );\r\n        var s13 = sin( ( a + c ) / 2 );\r\n\r\n        var c1_3 = cos( ( a - c ) / 2 );\r\n        var s1_3 = sin( ( a - c ) / 2 );\r\n\r\n        var c3_1 = cos( ( c - a ) / 2 );\r\n        var s3_1 = sin( ( c - a ) / 2 );\r\n\r\n        if ( order === 'XYX' ) {\r\n\r\n            q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\r\n\r\n        } else if ( order === 'YZY' ) {\r\n\r\n            q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\r\n\r\n        } else if ( order === 'ZXZ' ) {\r\n\r\n            q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\r\n\r\n        } else if ( order === 'XZX' ) {\r\n\r\n            q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\r\n\r\n        } else if ( order === 'YXY' ) {\r\n\r\n            q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\r\n\r\n        } else if ( order === 'ZYZ' ) {\r\n\r\n            q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\r\n\r\n        } else {\r\n\r\n            console.warn( 'MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );\r\n\r\n        }\r\n\r\n    }\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SceneUtils = {\r\n\r\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n\t\tvar group = new Group();\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn group;\r\n\r\n\t},\r\n\r\n\tdetach: function ( child, parent, scene ) {\r\n\r\n\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\tparent.remove( child );\r\n\t\tscene.add( child );\r\n\r\n\t},\r\n\r\n\tattach: function ( child, scene, parent ) {\r\n\r\n\t\tchild.applyMatrix( new Matrix4().getInverse( parent.matrixWorld ) );\r\n\r\n\t\tscene.remove( child );\r\n\t\tparent.add( child );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ShadowMapViewer = function ( light ) {\r\n\r\n\t//- Internals\r\n\tvar scope = this;\r\n\tvar doRenderLabel = ( light.name !== undefined && light.name !== '' );\r\n\tvar userAutoClearSetting;\r\n\r\n\t//Holds the initial position and dimension of the HUD\r\n\tvar frame = {\r\n\t\tx: 10,\r\n\t\ty: 10,\r\n\t\twidth: 256,\r\n\t\theight: 256\r\n\t};\r\n\r\n\tvar camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 10 );\r\n\tcamera.position.set( 0, 0, 2 );\r\n\tvar scene = new Scene();\r\n\r\n\t//HUD for shadow map\r\n\tvar shader = UnpackDepthRGBAShader;\r\n\r\n\tvar uniforms = new UniformsUtils.clone( shader.uniforms );\r\n\tvar material = new ShaderMaterial( {\r\n\t\tuniforms: uniforms,\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader\r\n\t} );\r\n\tvar plane = new PlaneBufferGeometry( frame.width, frame.height );\r\n\tvar mesh = new Mesh( plane, material );\r\n\r\n\tscene.add( mesh );\r\n\r\n\t//Label for light's name\r\n\tvar labelCanvas, labelMesh;\r\n\r\n\tif ( doRenderLabel ) {\r\n\r\n\t\tlabelCanvas = document.createElement( 'canvas' );\r\n\r\n\t\tvar context = labelCanvas.getContext( '2d' );\r\n\t\tcontext.font = 'Bold 20px Arial';\r\n\r\n\t\tvar labelWidth = context.measureText( light.name ).width;\r\n\t\tlabelCanvas.width = labelWidth;\r\n\t\tlabelCanvas.height = 25;\t//25 to account for g, p, etc.\r\n\r\n\t\tcontext.font = 'Bold 20px Arial';\r\n\t\tcontext.fillStyle = 'rgba( 255, 0, 0, 1 )';\r\n\t\tcontext.fillText( light.name, 0, 20 );\r\n\r\n\t\tvar labelTexture = new Texture( labelCanvas );\r\n\t\tlabelTexture.magFilter = LinearFilter;\r\n\t\tlabelTexture.minFilter = LinearFilter;\r\n\t\tlabelTexture.needsUpdate = true;\r\n\r\n\t\tvar labelMaterial = new MeshBasicMaterial( { map: labelTexture, side: DoubleSide } );\r\n\t\tlabelMaterial.transparent = true;\r\n\r\n\t\tvar labelPlane = new PlaneBufferGeometry( labelCanvas.width, labelCanvas.height );\r\n\t\tlabelMesh = new Mesh( labelPlane, labelMaterial );\r\n\r\n\t\tscene.add( labelMesh );\r\n\r\n\t}\r\n\r\n\tfunction resetPosition () {\r\n\r\n\t\tscope.position.set( scope.position.x, scope.position.y );\r\n\r\n\t}\r\n\r\n\t//- API\r\n\t// Set to false to disable displaying this shadow map\r\n\tthis.enabled = true;\r\n\r\n\t// Set the size of the displayed shadow map on the HUD\r\n\tthis.size = {\r\n\t\twidth: frame.width,\r\n\t\theight: frame.height,\r\n\t\tset: function ( width, height ) {\r\n\r\n\t\t\tthis.width = width;\r\n\t\t\tthis.height = height;\r\n\r\n\t\t\tmesh.scale.set( this.width / frame.width, this.height / frame.height, 1 );\r\n\r\n\t\t\t//Reset the position as it is off when we scale stuff\r\n\t\t\tresetPosition();\r\n\r\n\t\t}\r\n\t};\r\n\r\n\t// Set the position of the displayed shadow map on the HUD\r\n\tthis.position = {\r\n\t\tx: frame.x,\r\n\t\ty: frame.y,\r\n\t\tset: function ( x, y ) {\r\n\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\r\n\t\t\tvar width = scope.size.width;\r\n\t\t\tvar height = scope.size.height;\r\n\r\n\t\t\tmesh.position.set( - window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0 );\r\n\r\n\t\t\tif ( doRenderLabel ) { labelMesh.position.set( mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0 ); }\r\n\r\n\t\t}\r\n\t};\r\n\r\n\tthis.render = function ( renderer ) {\r\n\r\n\t\tif ( this.enabled ) {\r\n\r\n\t\t\t//Because a light's .shadowMap is only initialised after the first render pass\r\n\t\t\t//we have to make sure the correct map is sent into the shader, otherwise we\r\n\t\t\t//always end up with the scene's first added shadow casting light's shadowMap\r\n\t\t\t//in the shader\r\n\t\t\t//See: https://github.com/mrdoob/three.js/issues/5932\r\n\t\t\tuniforms.tDiffuse.value = light.shadow.map.texture;\r\n\r\n\t\t\tuserAutoClearSetting = renderer.autoClear;\r\n\t\t\trenderer.autoClear = false; // To allow render overlay\r\n\t\t\trenderer.clearDepth();\r\n\t\t\trenderer.render( scene, camera );\r\n\t\t\trenderer.autoClear = userAutoClearSetting;\t//Restore user's setting\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.updateForWindowResize = function () {\r\n\r\n\t\tif ( this.enabled ) {\r\n\r\n\t\t\t camera.left = window.innerWidth / - 2;\r\n\t\t\t camera.right = window.innerWidth / 2;\r\n\t\t\t camera.top = window.innerHeight / 2;\r\n\t\t\t camera.bottom = window.innerHeight / - 2;\r\n\t\t\t camera.updateProjectionMatrix();\r\n\r\n\t\t\t this.update();\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n\r\n\t\tthis.position.set( this.position.x, this.position.y );\r\n\t\tthis.size.set( this.size.width, this.size.height );\r\n\r\n\t};\r\n\r\n\t//Force an update to set position/size\r\n\tthis.update();\r\n\r\n};\r\n\r\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction getBoneList( object ) {\r\n\r\n\tvar boneList = [];\r\n\r\n\tif ( object && object.isBone ) {\r\n\r\n\t\tboneList.push( object );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\r\n\r\n\t}\r\n\r\n\treturn boneList;\r\n\r\n}\r\n\r\nfunction SkeletonHelper( object ) {\r\n\r\n\tvar bones = getBoneList( object );\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\r\n\tvar vertices = [];\r\n\tvar colors = [];\r\n\r\n\tvar color1 = new Color( 0, 0, 1 );\r\n\tvar color2 = new Color( 0, 1, 0 );\r\n\r\n\tfor ( var i = 0; i < bones.length; i ++ ) {\r\n\r\n\t\tvar bone = bones[ i ];\r\n\r\n\t\tif ( bone.parent && bone.parent.isBone ) {\r\n\r\n\t\t\tvertices.push( 0, 0, 0 );\r\n\t\t\tvertices.push( 0, 0, 0 );\r\n\t\t\tcolors.push( color1.r, color1.g, color1.b );\r\n\t\t\tcolors.push( color2.r, color2.g, color2.b );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\r\n\r\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\r\n\tLineSegments.call( this, geometry, material );\r\n\r\n\tthis.root = object;\r\n\tthis.bones = bones;\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n}\r\n\r\nSkeletonHelper.prototype = Object.create( LineSegments.prototype );\r\nSkeletonHelper.prototype.constructor = SkeletonHelper;\r\n\r\nSkeletonHelper.prototype.updateMatrixWorld = function () {\r\n\r\n\tvar vector = new Vector3();\r\n\r\n\tvar boneMatrix = new Matrix4();\r\n\tvar matrixWorldInv = new Matrix4();\r\n\r\n\treturn function updateMatrixWorld( force ) {\r\n\r\n\t\tvar bones = this.bones;\r\n\r\n\t\tvar geometry = this.geometry;\r\n\t\tvar position = geometry.getAttribute( 'position' );\r\n\r\n\t\tmatrixWorldInv.getInverse( this.root.matrixWorld );\r\n\r\n\t\tfor ( var i = 0, j = 0; i < bones.length; i ++ ) {\r\n\r\n\t\t\tvar bone = bones[ i ];\r\n\r\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\r\n\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\t\tvector.setFromMatrixPosition( boneMatrix );\r\n\t\t\t\tposition.setXYZ( j, vector.x, vector.y, vector.z );\r\n\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\t\tvector.setFromMatrixPosition( boneMatrix );\r\n\t\t\t\tposition.setXYZ( j + 1, vector.x, vector.y, vector.z );\r\n\r\n\t\t\t\tj += 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\r\n\r\n\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t};\r\n\r\n}();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar SkeletonUtils = {\r\n\r\n\tretarget: function () {\r\n\r\n\t\tvar pos = new Vector3(),\r\n\t\t\tquat = new Quaternion(),\r\n\t\t\tscale = new Vector3(),\r\n\t\t\tbindBoneMatrix = new Matrix4(),\r\n\t\t\trelativeMatrix = new Matrix4(),\r\n\t\t\tglobalMatrix = new Matrix4();\r\n\r\n\t\treturn function ( target, source, options ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\toptions = options || {};\r\n\t\t\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\r\n\t\t\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\r\n\t\t\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\r\n\t\t\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\r\n\t\t\toptions.hip = options.hip !== undefined ? options.hip : \"hip\";\r\n\t\t\toptions.names = options.names || {};\r\n\r\n\t\t\tvar sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\r\n\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\r\n\t\t\t\tbindBones,\r\n\t\t\t\tbone, name, boneTo,\r\n\t\t\t\tbonesPosition, i;\r\n\r\n\t\t\t// reset bones\r\n\r\n\t\t\tif ( target.isObject3D ) {\r\n\r\n\t\t\t\ttarget.skeleton.pose();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\toptions.useTargetMatrix = true;\r\n\t\t\t\toptions.preserveMatrix = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.preservePosition ) {\r\n\r\n\t\t\t\tbonesPosition = [];\r\n\r\n\t\t\t\tfor ( i = 0; i < bones.length; i ++ ) {\r\n\r\n\t\t\t\t\tbonesPosition.push( bones[ i ].position.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.preserveMatrix ) {\r\n\r\n\t\t\t\t// reset matrix\r\n\r\n\t\t\t\ttarget.updateMatrixWorld();\r\n\r\n\t\t\t\ttarget.matrixWorld.identity();\r\n\r\n\t\t\t\t// reset children matrix\r\n\r\n\t\t\t\tfor ( i = 0; i < target.children.length; ++ i ) {\r\n\r\n\t\t\t\t\ttarget.children[ i ].updateMatrixWorld( true );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.offsets ) {\r\n\r\n\t\t\t\tbindBones = [];\r\n\r\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\t\t\tbone = bones[ i ];\r\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\r\n\r\n\t\t\t\t\tif ( options.offsets && options.offsets[ name ] ) {\r\n\r\n\t\t\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\r\n\r\n\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t\t\t\t\tbone.updateMatrixWorld();\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tbindBones.push( bone.matrixWorld.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\t\tbone = bones[ i ];\r\n\t\t\t\tname = options.names[ bone.name ] || bone.name;\r\n\r\n\t\t\t\tboneTo = this$1.getBoneByName( name, sourceBones );\r\n\r\n\t\t\t\tglobalMatrix.copy( bone.matrixWorld );\r\n\r\n\t\t\t\tif ( boneTo ) {\r\n\r\n\t\t\t\t\tboneTo.updateMatrixWorld();\r\n\t\t\t\t\t\r\n\t\t\t\t\tif ( options.useTargetMatrix ) {\r\n\r\n\t\t\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\trelativeMatrix.getInverse( target.matrixWorld );\r\n\t\t\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// ignore scale to extract rotation\r\n\r\n\t\t\t\t\tscale.setFromMatrixScale( relativeMatrix );\r\n\t\t\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\r\n\r\n\t\t\t\t\t// apply to global matrix\r\n\r\n\t\t\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\r\n\r\n\t\t\t\t\tif ( target.isObject3D ) {\r\n\r\n\t\t\t\t\t\tvar boneIndex = bones.indexOf( bone ),\r\n\t\t\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.getInverse( target.skeleton.boneInverses[ boneIndex ] );\r\n\r\n\t\t\t\t\t\tglobalMatrix.multiply( wBindMatrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tglobalMatrix.copyPosition( relativeMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\r\n\r\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\t\tbone.matrix.multiply( globalMatrix );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbone.matrix.copy( globalMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( options.preserveHipPosition && name === options.hip ) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t\t\tbone.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.preservePosition ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\t\t\tbone = bones[ i ];\r\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\r\n\r\n\t\t\t\t\tif ( name !== options.hip ) {\r\n\r\n\t\t\t\t\t\tbone.position.copy( bonesPosition[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.preserveMatrix ) {\r\n\r\n\t\t\t\t// restore matrix\r\n\r\n\t\t\t\ttarget.updateMatrixWorld( true );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tretargetClip: function ( target, source, clip, options ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\toptions = options || {};\r\n\t\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\r\n\t\toptions.fps = options.fps !== undefined ? options.fps : 30;\r\n\t\toptions.names = options.names || [];\r\n\r\n\t\tif ( ! source.isObject3D ) {\r\n\r\n\t\t\tsource = this.getHelperFromSkeleton( source );\r\n\r\n\t\t}\r\n\r\n\t\tvar numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\r\n\t\t\tdelta = 1 / options.fps,\r\n\t\t\tconvertedTracks = [],\r\n\t\t\tmixer = new AnimationMixer( source ),\r\n\t\t\tbones = this.getBones( target.skeleton ),\r\n\t\t\tboneDatas = [],\r\n\t\t\tpositionOffset,\r\n\t\t\tbone, boneTo, boneData, \r\n\t\t\tname, i, j;\r\n\r\n\t\tmixer.clipAction( clip ).play();\r\n\t\tmixer.update( 0 );\r\n\r\n\t\tsource.updateMatrixWorld();\r\n\r\n\t\tfor ( i = 0; i < numFrames; ++ i ) {\r\n\r\n\t\t\tvar time = i * delta;\r\n\r\n\t\t\tthis$1.retarget( target, source, options );\r\n\r\n\t\t\tfor ( j = 0; j < bones.length; ++ j ) {\r\n\r\n\t\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\r\n\t\t\t\t\r\n\t\t\t\tboneTo = this$1.getBoneByName( name, source.skeleton );\r\n\r\n\t\t\t\tif ( boneTo ) {\r\n\r\n\t\t\t\t\tbone = bones[ j ];\r\n\t\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\r\n\r\n\t\t\t\t\tif ( options.hip === name ) {\r\n\r\n\t\t\t\t\t\tif ( ! boneData.pos ) {\r\n\r\n\t\t\t\t\t\t\tboneData.pos = {\r\n\t\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\r\n\t\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( options.useFirstFramePosition ) {\r\n\r\n\t\t\t\t\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbone.position.sub( positionOffset );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tboneData.pos.times[ i ] = time;\r\n\r\n\t\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ! boneData.quat ) {\r\n\r\n\t\t\t\t\t\tboneData.quat = {\r\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\r\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tboneData.quat.times[ i ] = time;\r\n\r\n\t\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmixer.update( delta );\r\n\r\n\t\t\tsource.updateMatrixWorld();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; i < boneDatas.length; ++ i ) {\r\n\r\n\t\t\tboneData = boneDatas[ i ];\r\n\r\n\t\t\tif ( boneData ) {\r\n\r\n\t\t\t\tif ( boneData.pos ) {\r\n\r\n\t\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack$1(\r\n\t\t\t\t\t\t\".bones[\" + boneData.bone.name + \"].position\",\r\n\t\t\t\t\t\tboneData.pos.times,\r\n\t\t\t\t\t\tboneData.pos.values\r\n\t\t\t\t\t) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack$1(\r\n\t\t\t\t\t\".bones[\" + boneData.bone.name + \"].quaternion\",\r\n\t\t\t\t\tboneData.quat.times,\r\n\t\t\t\t\tboneData.quat.values\r\n\t\t\t\t) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmixer.uncacheAction( clip );\r\n\r\n\t\treturn new AnimationClip( clip.name, - 1, convertedTracks );\r\n\r\n\t},\r\n\t\r\n\tgetHelperFromSkeleton: function( skeleton ) {\r\n\t\t\r\n\t\tvar source = new SkeletonHelper( skeleton.bones[ 0 ] );\r\n\t\tsource.skeleton = skeleton;\r\n\t\t\r\n\t\treturn source;\r\n\t\t\r\n\t},\r\n\t\r\n\tgetSkeletonOffsets: function () {\r\n\r\n\t\tvar targetParentPos = new Vector3(),\r\n\t\t\ttargetPos = new Vector3(),\r\n\t\t\tsourceParentPos = new Vector3(),\r\n\t\t\tsourcePos = new Vector3(),\r\n\t\t\ttargetDir = new Vector2(),\r\n\t\t\tsourceDir = new Vector2();\r\n\r\n\t\treturn function ( target, source, options ) {\n\t\t\tvar this$1 = this;\n\r\n\r\n\t\t\toptions = options || {};\r\n\t\t\toptions.hip = options.hip !== undefined ? options.hip : \"hip\";\r\n\t\t\toptions.names = options.names || {};\r\n\r\n\t\t\tif ( ! source.isObject3D ) {\r\n\r\n\t\t\t\tsource = this.getHelperFromSkeleton( source );\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar nameKeys = Object.keys( options.names ),\r\n\t\t\t\tnameValues = Object.values( options.names ),\r\n\t\t\t\tsourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\r\n\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\r\n\t\t\t\toffsets = [],\r\n\t\t\t\tbone, boneTo, \r\n\t\t\t\tname, i;\r\n\t\t\t\r\n\t\t\ttarget.skeleton.pose();\r\n\t\t\t\r\n\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\t\tbone = bones[ i ];\r\n\t\t\t\tname = options.names[ bone.name ] || bone.name;\r\n\r\n\t\t\t\tboneTo = this$1.getBoneByName( name, sourceBones );\r\n\t\t\t\t\r\n\t\t\t\tif ( boneTo && name !== options.hip ) {\r\n\t\t\t\t\r\n\t\t\t\t\tvar boneParent = this$1.getNearestBone( bone.parent, nameKeys ),\r\n\t\t\t\t\t\tboneToParent = this$1.getNearestBone( boneTo.parent, nameValues );\r\n\t\t\t\t\r\n\t\t\t\t\tboneParent.updateMatrixWorld();\r\n\t\t\t\t\tboneToParent.updateMatrixWorld();\r\n\t\t\t\t\r\n\t\t\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld  );\r\n\t\t\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\r\n\t\t\t\t\t\r\n\t\t\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\r\n\t\t\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\r\n\t\t\t\t\t\r\n\t\t\t\t\ttargetDir.subVectors( \r\n\t\t\t\t\t\tnew Vector2( targetPos.x, targetPos.y ),\r\n\t\t\t\t\t\tnew Vector2( targetParentPos.x, targetParentPos.y ) \r\n\t\t\t\t\t).normalize();\r\n\t\t\t\t\t\r\n\t\t\t\t\tsourceDir.subVectors( \r\n\t\t\t\t\t\tnew Vector2( sourcePos.x, sourcePos.y ),\r\n\t\t\t\t\t\tnew Vector2( sourceParentPos.x, sourceParentPos.y )\r\n\t\t\t\t\t).normalize();\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar laterialAngle = targetDir.angle() - sourceDir.angle();\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar offset = new Matrix4().makeRotationFromEuler(\r\n\t\t\t\t\t\tnew Euler(\r\n\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\tlaterialAngle\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbone.matrix.multiply( offset );\r\n\r\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t\t\t\tbone.updateMatrixWorld();\r\n\t\t\t\t\t\r\n\t\t\t\t\toffsets[ name ] = offset;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn offsets;\r\n\t\t\t\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\trenameBones: function ( skeleton, names ) {\r\n\r\n\t\tvar bones = this.getBones( skeleton );\r\n\r\n\t\tfor ( var i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\tvar bone = bones[ i ];\r\n\r\n\t\t\tif ( names[ bone.name ] ) {\r\n\r\n\t\t\t\tbone.name = names[ bone.name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetBones: function ( skeleton ) {\r\n\r\n\t\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\r\n\r\n\t},\r\n\r\n\tgetBoneByName: function ( name, skeleton ) {\r\n\r\n\t\tfor ( var i = 0, bones = this.getBones( skeleton ); i < bones.length; i ++ ) {\r\n\r\n\t\t\tif ( name === bones[ i ].name )\r\n\t\t\t\t\r\n\t\t\t\t{ return bones[ i ]; }\r\n\r\n\t\t}\r\n\r\n\t},\r\n\t\r\n\tgetNearestBone: function ( bone, names ) {\r\n\r\n\t\twhile( bone.isBone ) {\r\n\t\t\t\r\n\t\t\tif ( names.indexOf( bone.name ) !== -1 ) {\r\n\t\t\t\t\r\n\t\t\t\treturn bone;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tbone = bone.parent;\r\n\t\t\t\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tfindBoneTrackData: function ( name, tracks ) {\r\n\r\n\t\tvar regexp = /\\[(.*)\\]\\.(.*)/,\r\n\t\t\tresult = { name: name };\r\n\r\n\t\tfor ( var i = 0; i < tracks.length; ++ i ) {\r\n\r\n\t\t\t// 1 is track name\r\n\t\t\t// 2 is track type\r\n\t\t\tvar trackData = regexp.exec( tracks[ i ].name );\r\n\r\n\t\t\tif ( trackData && name === trackData[ 1 ] ) {\r\n\r\n\t\t\t\tresult[ trackData[ 2 ] ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tgetEqualsBonesNames: function ( skeleton, targetSkeleton ) {\r\n\r\n\t\tvar sourceBones = this.getBones( skeleton ),\r\n\t\t\ttargetBones = this.getBones( targetSkeleton ),\r\n\t\t\tbones = [];\r\n\r\n\t\tsearch : for ( var i = 0; i < sourceBones.length; i ++ ) {\r\n\r\n\t\t\tvar boneName = sourceBones[ i ].name;\r\n\r\n\t\t\tfor ( var j = 0; j < targetBones.length; j ++ ) {\r\n\r\n\t\t\t\tif ( boneName === targetBones[ j ].name ) {\r\n\r\n\t\t\t\t\tbones.push( boneName );\r\n\r\n\t\t\t\t\tcontinue search;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bones;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar UVsDebug = function ( geometry, size ) {\r\n\r\n\t// handles wrapping of uv.x > 1 only\r\n\r\n\tvar abc = 'abc';\r\n\tvar a = new Vector2();\r\n\tvar b = new Vector2();\r\n\r\n\tvar uvs = [\r\n\t\tnew Vector2(),\r\n\t\tnew Vector2(),\r\n\t\tnew Vector2()\r\n\t];\r\n\r\n\tvar face = [];\r\n\r\n\tvar canvas = document.createElement( 'canvas' );\r\n\tvar width = size || 1024; // power of 2 required for wrapping\r\n\tvar height = size || 1024;\r\n\tcanvas.width = width;\r\n\tcanvas.height = height;\r\n\r\n\tvar ctx = canvas.getContext( '2d' );\r\n\tctx.lineWidth = 2;\r\n\tctx.strokeStyle = 'rgba( 0, 0, 0, 1.0 )';\r\n\tctx.textAlign = 'center';\r\n\r\n\t// paint background white\r\n\r\n\tctx.fillStyle = 'rgba( 255, 255, 255, 1.0 )';\r\n\tctx.fillRect( 0, 0, width, height );\r\n\r\n\tif ( geometry.isGeometry ) {\r\n\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar uvSet = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\tfor ( var i = 0, il = uvSet.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\t\t\tvar uv = uvSet[ i ];\r\n\r\n\t\t\tface[ 0 ] = face.a;\r\n\t\t\tface[ 1 ] = face.b;\r\n\t\t\tface[ 2 ] = face.c;\r\n\r\n\t\t\tuvs[ 0 ].copy( uv[ 0 ] );\r\n\t\t\tuvs[ 1 ].copy( uv[ 1 ] );\r\n\t\t\tuvs[ 2 ].copy( uv[ 2 ] );\r\n\r\n\t\t\tprocessFace( face, uvs, i );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar uvAttribute = geometry.attributes.uv;\r\n\r\n\t\tif ( index ) {\r\n\r\n\t\t\t// indexed geometry\r\n\r\n\t\t\tfor ( var i = 0, il = index.count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tface[ 0 ] = index.getX( i );\r\n\t\t\t\tface[ 1 ] = index.getX( i + 1 );\r\n\t\t\t\tface[ 2 ] = index.getX( i + 2 );\r\n\r\n\t\t\t\tuvs[ 0 ].fromBufferAttribute( uvAttribute, face[ 0 ] );\r\n\t\t\t\tuvs[ 1 ].fromBufferAttribute( uvAttribute, face[ 1 ] );\r\n\t\t\t\tuvs[ 2 ].fromBufferAttribute( uvAttribute, face[ 2 ] );\r\n\r\n\t\t\t\tprocessFace( face, uvs, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// non-indexed geometry\r\n\r\n\t\t\tfor ( var i = 0, il = uvAttribute.count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tface[ 0 ] = i;\r\n\t\t\t\tface[ 1 ] = i + 1;\r\n\t\t\t\tface[ 2 ] = i + 2;\r\n\r\n\t\t\t\tuvs[ 0 ].fromBufferAttribute( uvAttribute, face[ 0 ] );\r\n\t\t\t\tuvs[ 1 ].fromBufferAttribute( uvAttribute, face[ 1 ] );\r\n\t\t\t\tuvs[ 2 ].fromBufferAttribute( uvAttribute, face[ 2 ] );\r\n\r\n\t\t\t\tprocessFace( face, uvs, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn canvas;\r\n\r\n\tfunction processFace( face, uvs, index ) {\r\n\r\n\t\t// draw contour of face\r\n\r\n\t\tctx.beginPath();\r\n\r\n\t\ta.set( 0, 0 );\r\n\r\n\t\tfor ( var j = 0, jl = uvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar uv = uvs[ j ];\r\n\r\n\t\t\ta.x += uv.x;\r\n\t\t\ta.y += uv.y;\r\n\r\n\t\t\tif ( j === 0 ) {\r\n\r\n\t\t\t\tctx.moveTo( uv.x * width, ( 1 - uv.y ) * height );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tctx.lineTo( uv.x * width, ( 1 - uv.y ) * height );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tctx.closePath();\r\n\t\tctx.stroke();\r\n\r\n\t\t// calculate center of face\r\n\r\n\t\ta.divideScalar( uvs.length );\r\n\r\n\t\t// label the face number\r\n\r\n\t\tctx.font = '12pt Arial bold';\r\n\t\tctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\r\n\t\tctx.fillText( index, a.x * width, ( 1 - a.y ) * height );\r\n\r\n\t\tif ( a.x > 0.95 ) {\r\n\r\n\t\t\t// wrap x // 0.95 is arbitrary\r\n\r\n\t\t\tctx.fillText( index, ( a.x % 1 ) * width, ( 1 - a.y ) * height );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tctx.font = '8pt Arial bold';\r\n\t\tctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\r\n\r\n\t\t// label uv edge orders\r\n\r\n\t\tfor ( j = 0, jl = uvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar uv = uvs[ j ];\r\n\t\t\tb.addVectors( a, uv ).divideScalar( 2 );\r\n\r\n\t\t\tvar vnum = face[ j ];\r\n\t\t\tctx.fillText( abc[ j ] + vnum, b.x * width, ( 1 - b.y ) * height );\r\n\r\n\t\t\tif ( b.x > 0.95 ) {\r\n\r\n\t\t\t\t// wrap x\r\n\r\n\t\t\t\tctx.fillText( abc[ j ] + vnum, ( b.x % 1 ) * width, ( 1 - b.y ) * height );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar VolumeSlice = function ( volume, index, axis ) {\r\n\r\n\tvar slice = this;\r\n\t\r\n\tthis.volume = volume;\r\n\t\r\n\tindex = index || 0;\r\n\tObject.defineProperty( this, 'index', {\r\n\t\tget: function () {\r\n\r\n\t\t\treturn index;\r\n\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tindex = value;\r\n\t\t\tslice.geometryNeedsUpdate = true;\r\n\t\t\treturn index;\r\n\r\n\t\t}\r\n\t} );\r\n\t\r\n\tthis.axis = axis || 'z';\r\n\t\r\n\tthis.canvas = document.createElement( 'canvas' );\r\n\t\r\n\tthis.canvasBuffer = document.createElement( 'canvas' );\r\n\tthis.updateGeometry();\r\n\r\n\tvar canvasMap = new Texture( this.canvas );\r\n\tcanvasMap.minFilter = LinearFilter;\r\n\tcanvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\r\n\tvar material = new MeshBasicMaterial( { map: canvasMap, side: DoubleSide, transparent: true } );\r\n\t\r\n\tthis.mesh = new Mesh( this.geometry, material );\r\n\t\r\n\tthis.geometryNeedsUpdate = true;\r\n\tthis.repaint();\r\n\r\n};\r\n\r\nVolumeSlice.prototype = {\r\n\r\n\tconstructor: VolumeSlice,\r\n\t\r\n\trepaint: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( this.geometryNeedsUpdate ) {\r\n\r\n\t\t\tthis.updateGeometry();\r\n\r\n\t\t}\r\n\r\n\t\tvar iLength = this.iLength,\r\n\t\t\tjLength = this.jLength,\r\n\t\t\tsliceAccess = this.sliceAccess,\r\n\t\t\tvolume = this.volume,\r\n\t\t\tcanvas = this.canvasBuffer,\r\n\t\t\tctx = this.ctxBuffer;\r\n\r\n\t\t// get the imageData and pixel array from the canvas\r\n\t\tvar imgData = ctx.getImageData( 0, 0, iLength, jLength );\r\n\t\tvar data = imgData.data;\r\n\t\tvar volumeData = volume.data;\r\n\t\tvar upperThreshold = volume.upperThreshold;\r\n\t\tvar lowerThreshold = volume.lowerThreshold;\r\n\t\tvar windowLow = volume.windowLow;\r\n\t\tvar windowHigh = volume.windowHigh;\r\n\r\n\t\t// manipulate some pixel elements\r\n\t\tvar pixelCount = 0;\r\n\r\n\t\tif ( volume.dataType === 'label' ) {\r\n\r\n\t\t\t//this part is currently useless but will be used when colortables will be handled\r\n\t\t\tfor ( var j = 0; j < jLength; j ++ ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < iLength; i ++ ) {\r\n\r\n\t\t\t\t\tvar label = volumeData[ sliceAccess( i, j ) ];\r\n\t\t\t\t\tlabel = label >= this$1.colorMap.length ? ( label % this$1.colorMap.length ) + 1 : label;\r\n\t\t\t\t\tvar color = this$1.colorMap[ label ];\r\n\t\t\t\t\tdata[ 4 * pixelCount ] = ( color >> 24 ) & 0xff;\r\n\t\t\t\t\tdata[ 4 * pixelCount + 1 ] = ( color >> 16 ) & 0xff;\r\n\t\t\t\t\tdata[ 4 * pixelCount + 2 ] = ( color >> 8 ) & 0xff;\r\n\t\t\t\t\tdata[ 4 * pixelCount + 3 ] = color & 0xff;\r\n\t\t\t\t\tpixelCount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( var j = 0; j < jLength; j ++ ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < iLength; i ++ ) {\r\n\r\n\t\t\t\t\tvar value = volumeData[ sliceAccess( i, j ) ];\r\n\t\t\t\t\tvar alpha = 0xff;\r\n\t\t\t\t\t//apply threshold\r\n\t\t\t\t\talpha = upperThreshold >= value ? ( lowerThreshold <= value ? alpha : 0 ) : 0;\r\n\t\t\t\t\t//apply window level\r\n\t\t\t\t\tvalue = Math.floor( 255 * ( value - windowLow ) / ( windowHigh - windowLow ) );\r\n\t\t\t\t\tvalue = value > 255 ? 255 : ( value < 0 ? 0 : value | 0 );\r\n\r\n\t\t\t\t\tdata[ 4 * pixelCount ] = value;\r\n\t\t\t\t\tdata[ 4 * pixelCount + 1 ] = value;\r\n\t\t\t\t\tdata[ 4 * pixelCount + 2 ] = value;\r\n\t\t\t\t\tdata[ 4 * pixelCount + 3 ] = alpha;\r\n\t\t\t\t\tpixelCount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tctx.putImageData( imgData, 0, 0 );\r\n\t\tthis.ctx.drawImage( canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height );\r\n\r\n\t\tthis.mesh.material.map.needsUpdate = true;\r\n\r\n\t},\r\n\t\r\n\tupdateGeometry: function () {\r\n\r\n\t\tvar extracted = this.volume.extractPerpendicularPlane( this.axis, this.index );\r\n\t\tthis.sliceAccess = extracted.sliceAccess;\r\n\t\tthis.jLength = extracted.jLength;\r\n\t\tthis.iLength = extracted.iLength;\r\n\t\tthis.matrix = extracted.matrix;\r\n\r\n\t\tthis.canvas.width = extracted.planeWidth;\r\n\t\tthis.canvas.height = extracted.planeHeight;\r\n\t\tthis.canvasBuffer.width = this.iLength;\r\n\t\tthis.canvasBuffer.height = this.jLength;\r\n\t\tthis.ctx = this.canvas.getContext( '2d' );\r\n\t\tthis.ctxBuffer = this.canvasBuffer.getContext( '2d' );\r\n\r\n\t\tthis.geometry = new PlaneBufferGeometry( extracted.planeWidth, extracted.planeHeight );\r\n\r\n\t\tif ( this.mesh ) {\r\n\r\n\t\t\tthis.mesh.geometry = this.geometry;\r\n\t\t\t//reset mesh matrix\r\n\t\t\tthis.mesh.matrix = ( new Matrix4() ).identity();\r\n\t\t\tthis.mesh.applyMatrix( this.matrix );\r\n\r\n\t\t}\r\n\r\n\t\tthis.geometryNeedsUpdate = false;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar DaydreamController = function () {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tvar scope = this;\r\n\tvar gamepad;\r\n\r\n\tvar axes = [ 0, 0 ];\r\n\tvar touchpadIsPressed = false;\r\n\tvar angularVelocity = new Vector3();\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tfunction findGamepad() {\r\n\r\n\t\t// iterate across gamepads as the Daydream Controller may not be\r\n\t\t// in position 0\r\n\r\n\t\tvar gamepads = navigator.getGamepads && navigator.getGamepads();\r\n\r\n\t\tfor ( var i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tvar gamepad = gamepads[ i ];\r\n\r\n\t\t\tif ( gamepad && ( gamepad.id === 'Daydream Controller' ) ) {\r\n\r\n\t\t\t\treturn gamepad;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.getGamepad = function () {\r\n\r\n\t\treturn gamepad;\r\n\r\n\t};\r\n\r\n\tthis.getTouchpadState = function () {\r\n\r\n\t\treturn touchpadIsPressed;\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n\r\n\t\tgamepad = findGamepad();\r\n\r\n\t\tif ( gamepad !== undefined && gamepad.pose !== undefined ) {\r\n\r\n\t\t\tvar pose = gamepad.pose;\r\n\r\n\t\t\tif ( pose === null ) { return; } // no user action yet\r\n\r\n\t\t\t//  orientation\r\n\r\n\t\t\tif ( pose.orientation !== null ) { scope.quaternion.fromArray( pose.orientation ); }\r\n\r\n\t\t\tscope.updateMatrix();\r\n\t\t\tscope.visible = true;\r\n\r\n\t\t\t// angular velocity\r\n\r\n\t\t\tif ( pose.angularVelocity !== null && ! angularVelocity.equals( pose.angularVelocity ) ) {\r\n\r\n\t\t\t\tangularVelocity.fromArray( pose.angularVelocity );\r\n\t\t\t\tscope.dispatchEvent( { type: 'angularvelocitychanged', angularVelocity: angularVelocity } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// axes (touchpad)\r\n\r\n\t\t\tif ( axes[ 0 ] !== gamepad.axes[ 0 ] || axes[ 1 ] !== gamepad.axes[ 1 ] ) {\r\n\r\n\t\t\t\taxes[ 0 ] = gamepad.axes[ 0 ];\r\n\t\t\t\taxes[ 1 ] = gamepad.axes[ 1 ];\r\n\t\t\t\tscope.dispatchEvent( { type: 'axischanged', axes: axes } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// button (touchpad)\r\n\r\n\t\t\tif ( touchpadIsPressed !== gamepad.buttons[ 0 ].pressed ) {\r\n\r\n\t\t\t\ttouchpadIsPressed = gamepad.buttons[ 0 ].pressed;\r\n\t\t\t\tscope.dispatchEvent( { type: touchpadIsPressed ? 'touchpaddown' : 'touchpadup' } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// app button not available, reserved for use by the browser\r\n\r\n\t\t} else {\r\n\r\n\t\t\tscope.visible = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// DEPRECATED\r\n\r\n\tthis.getTouchPadState = function () {\r\n\r\n\t\tconsole.warn( 'DaydreamController: getTouchPadState() is now getTouchpadState()' );\r\n\t\treturn touchpadIsPressed;\r\n\r\n\t};\r\n\r\n};\r\n\r\nDaydreamController.prototype = Object.create( Object3D.prototype );\r\nDaydreamController.prototype.constructor = DaydreamController;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar GearVRController = function () {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tvar scope = this;\r\n\tvar gamepad;\r\n\r\n\tvar axes = [ 0, 0 ];\r\n\tvar touchpadIsPressed = false;\r\n\tvar triggerIsPressed = false;\r\n\tvar angularVelocity = new Vector3();\r\n\r\n\tthis.matrixAutoUpdate = true;\r\n\r\n\tfunction findGamepad() {\r\n\r\n\t\tvar gamepads = navigator.getGamepads && navigator.getGamepads();\r\n\r\n\t\tfor ( var i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tvar gamepad = gamepads[ i ];\r\n\r\n\t\t\tif ( gamepad && ( gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ) ) {\r\n\r\n\t\t\t\treturn gamepad;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.getGamepad = function () {\r\n\r\n\t\treturn gamepad;\r\n\r\n\t};\r\n\r\n\tthis.getTouchpadState = function () {\r\n\r\n\t\treturn touchpadIsPressed;\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n\r\n\t\tgamepad = findGamepad();\r\n\r\n\t\tif ( gamepad !== undefined && gamepad.pose !== undefined ) {\r\n\r\n\t\t\tvar pose = gamepad.pose;\r\n\r\n\t\t\tif ( pose === null ) { return; } // no user action yet\r\n\r\n\t\t\t//  orientation\r\n\r\n\t\t\tif ( pose.orientation !== null ) { scope.quaternion.fromArray( pose.orientation ); }\r\n\r\n\t\t\tscope.updateMatrix();\r\n\t\t\tscope.visible = true;\r\n\r\n\t\t\t// angular velocity\r\n\r\n\t\t\tif ( pose.angularVelocity !== null && ! angularVelocity.equals( pose.angularVelocity ) ) {\r\n\r\n\t\t\t\tangularVelocity.fromArray( pose.angularVelocity );\r\n\t\t\t\tscope.dispatchEvent( { type: 'angularvelocitychanged', angularVelocity: angularVelocity } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// axes (touchpad)\r\n\r\n\t\t\tif ( axes[ 0 ] !== gamepad.axes[ 0 ] || axes[ 1 ] !== gamepad.axes[ 1 ] ) {\r\n\r\n\t\t\t\taxes[ 0 ] = gamepad.axes[ 0 ];\r\n\t\t\t\taxes[ 1 ] = gamepad.axes[ 1 ];\r\n\t\t\t\tscope.dispatchEvent( { type: 'axischanged', axes: axes } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// button (touchpad)\r\n\r\n\t\t\tif ( touchpadIsPressed !== gamepad.buttons[ 0 ].pressed ) {\r\n\r\n\t\t\t\ttouchpadIsPressed = gamepad.buttons[ 0 ].pressed;\r\n\t\t\t\tscope.dispatchEvent( { type: touchpadIsPressed ? 'touchpaddown' : 'touchpadup', axes: axes } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// trigger\r\n\r\n\t\t\tif ( triggerIsPressed !== gamepad.buttons[ 1 ].pressed ) {\r\n\r\n\t\t\t\ttriggerIsPressed = gamepad.buttons[ 1 ].pressed;\r\n\t\t\t\tscope.dispatchEvent( { type: triggerIsPressed ? 'triggerdown' : 'triggerup' } );\r\n\r\n\t\t\t}\r\n\r\n\t\t// app button not available, reserved for use by the browser\r\n\r\n\t\t} else {\r\n\r\n\t\t\tscope.visible = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// DEPRECATED\r\n\r\n\tthis.getTouchPadState = function () {\r\n\r\n\t\tconsole.warn( 'GearVRController: getTouchPadState() is now getTouchpadState()' );\r\n\t\treturn touchpadIsPressed;\r\n\r\n\t};\r\n\r\n\tthis.setHand = function () {\r\n\r\n\t\tconsole.warn( 'GearVRController: setHand() has been removed.' );\r\n\r\n\t};\r\n\r\n};\r\n\r\nGearVRController.prototype = Object.create( Object3D.prototype );\r\nGearVRController.prototype.constructor = GearVRController;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar ViveController = function ( id ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tvar scope = this;\r\n\tvar gamepad;\r\n\r\n\tvar axes = [ 0, 0 ];\r\n\tvar thumbpadIsPressed = false;\r\n\tvar triggerIsPressed = false;\r\n\tvar gripsArePressed = false;\r\n\tvar menuIsPressed = false;\r\n\r\n\tfunction findGamepad( id ) {\r\n\r\n\t\t// Iterate across gamepads as Vive Controllers may not be\r\n\t\t// in position 0 and 1.\r\n\r\n\t\tvar gamepads = navigator.getGamepads && navigator.getGamepads();\r\n\r\n\t\tfor ( var i = 0, j = 0; i < gamepads.length; i ++ ) {\r\n\r\n\t\t\tvar gamepad = gamepads[ i ];\r\n\r\n\t\t\tif ( gamepad && ( gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) || gamepad.id.startsWith( 'Spatial Controller' ) ) ) {\r\n\r\n\t\t\t\tif ( j === id ) { return gamepad; }\r\n\r\n\t\t\t\tj ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\tthis.standingMatrix = new Matrix4();\r\n\r\n\tthis.getGamepad = function () {\r\n\r\n\t\treturn gamepad;\r\n\r\n\t};\r\n\r\n\tthis.getButtonState = function ( button ) {\r\n\r\n\t\tif ( button === 'thumbpad' ) { return thumbpadIsPressed; }\r\n\t\tif ( button === 'trigger' ) { return triggerIsPressed; }\r\n\t\tif ( button === 'grips' ) { return gripsArePressed; }\r\n\t\tif ( button === 'menu' ) { return menuIsPressed; }\r\n\r\n\t};\r\n\r\n\tthis.update = function () {\r\n\r\n\t\tgamepad = findGamepad( id );\r\n\r\n\t\tif ( gamepad !== undefined && gamepad.pose !== undefined ) {\r\n\r\n\t\t\tif ( gamepad.pose === null ) { return; } // No user action yet\r\n\r\n\t\t\t//  Position and orientation.\r\n\r\n\t\t\tvar pose = gamepad.pose;\r\n\r\n\t\t\tif ( pose.position !== null ) { scope.position.fromArray( pose.position ); }\r\n\t\t\tif ( pose.orientation !== null ) { scope.quaternion.fromArray( pose.orientation ); }\r\n\t\t\tscope.matrix.compose( scope.position, scope.quaternion, scope.scale );\r\n\t\t\tscope.matrix.premultiply( scope.standingMatrix );\t\r\n\t\t\tscope.matrixWorldNeedsUpdate = true;\r\n\t\t\tscope.visible = true;\r\n\r\n\t\t\t//  Thumbpad and Buttons.\r\n\r\n\t\t\tif ( axes[ 0 ] !== gamepad.axes[ 0 ] || axes[ 1 ] !== gamepad.axes[ 1 ] ) {\r\n\r\n\t\t\t\taxes[ 0 ] = gamepad.axes[ 0 ]; //  X axis: -1 = Left, +1 = Right.\r\n\t\t\t\taxes[ 1 ] = gamepad.axes[ 1 ]; //  Y axis: -1 = Bottom, +1 = Top.\r\n\t\t\t\tscope.dispatchEvent( { type: 'axischanged', axes: axes } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( thumbpadIsPressed !== gamepad.buttons[ 0 ].pressed ) {\r\n\r\n\t\t\t\tthumbpadIsPressed = gamepad.buttons[ 0 ].pressed;\r\n\t\t\t\tscope.dispatchEvent( { type: thumbpadIsPressed ? 'thumbpaddown' : 'thumbpadup', axes: axes } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( triggerIsPressed !== gamepad.buttons[ 1 ].pressed ) {\r\n\r\n\t\t\t\ttriggerIsPressed = gamepad.buttons[ 1 ].pressed;\r\n\t\t\t\tscope.dispatchEvent( { type: triggerIsPressed ? 'triggerdown' : 'triggerup' } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( gripsArePressed !== gamepad.buttons[ 2 ].pressed ) {\r\n\r\n\t\t\t\tgripsArePressed = gamepad.buttons[ 2 ].pressed;\r\n\t\t\t\tscope.dispatchEvent( { type: gripsArePressed ? 'gripsdown' : 'gripsup' } );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( menuIsPressed !== gamepad.buttons[ 3 ].pressed ) {\r\n\r\n\t\t\t\tmenuIsPressed = gamepad.buttons[ 3 ].pressed;\r\n\t\t\t\tscope.dispatchEvent( { type: menuIsPressed ? 'menudown' : 'menuup' } );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tscope.visible = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\nViveController.prototype = Object.create( Object3D.prototype );\r\nViveController.prototype.constructor = ViveController;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// CircleGeometry\r\n\r\nfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'CircleGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tsegments: segments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nCircleGeometry.prototype = Object.create( Geometry.prototype );\r\nCircleGeometry.prototype.constructor = CircleGeometry;\r\n\r\n// CircleBufferGeometry\r\n\r\nfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'CircleBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tsegments: segments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradius = radius || 1;\r\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\t// helper variables\r\n\r\n\tvar i, s;\r\n\tvar vertex = new Vector3();\r\n\tvar uv = new Vector2();\r\n\r\n\t// center point\r\n\r\n\tvertices.push( 0, 0, 0 );\r\n\tnormals.push( 0, 0, 1 );\r\n\tuvs.push( 0.5, 0.5 );\r\n\r\n\tfor ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\r\n\r\n\t\tvar segment = thetaStart + s / segments * thetaLength;\r\n\r\n\t\t// vertex\r\n\r\n\t\tvertex.x = radius * Math.cos( segment );\r\n\t\tvertex.y = radius * Math.sin( segment );\r\n\r\n\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t// normal\r\n\r\n\t\tnormals.push( 0, 0, 1 );\r\n\r\n\t\t// uvs\r\n\r\n\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\r\n\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\r\n\r\n\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t}\r\n\r\n\t// indices\r\n\r\n\tfor ( i = 1; i <= segments; i ++ ) {\r\n\r\n\t\tindices.push( i, i + 1, 0 );\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n}\r\n\r\nCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// IcosahedronGeometry\r\n\r\nfunction IcosahedronGeometry( radius, detail ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'IcosahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\r\nIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\r\n\r\n// IcosahedronBufferGeometry\r\n\r\nfunction IcosahedronBufferGeometry( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n\tvar vertices = [\r\n\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\r\n\t\t 0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\r\n\t\t t, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\r\n\t\t 1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\r\n\t\t 3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\r\n\t\t 4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\r\n\t];\r\n\r\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'IcosahedronBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n}\r\n\r\nIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\r\nIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// ShapeGeometry\r\n\r\nfunction ShapeGeometry( shapes, curveSegments ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'ShapeGeometry';\r\n\r\n\tif ( typeof curveSegments === 'object' ) {\r\n\r\n\t\tconsole.warn( 'ShapeGeometry: Options parameter has been removed.' );\r\n\r\n\t\tcurveSegments = curveSegments.curveSegments;\r\n\r\n\t}\r\n\r\n\tthis.parameters = {\r\n\t\tshapes: shapes,\r\n\t\tcurveSegments: curveSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nShapeGeometry.prototype = Object.create( Geometry.prototype );\r\nShapeGeometry.prototype.constructor = ShapeGeometry;\r\n\r\nShapeGeometry.prototype.toJSON = function () {\r\n\r\n\tvar data = Geometry.prototype.toJSON.call( this );\r\n\r\n\tvar shapes = this.parameters.shapes;\r\n\r\n\treturn toJSON( shapes, data );\r\n\r\n};\r\n\r\n// ShapeBufferGeometry\r\n\r\nfunction ShapeBufferGeometry( shapes, curveSegments ) {\n\tvar this$1 = this;\n\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'ShapeBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tshapes: shapes,\r\n\t\tcurveSegments: curveSegments\r\n\t};\r\n\r\n\tcurveSegments = curveSegments || 12;\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\t// helper variables\r\n\r\n\tvar groupStart = 0;\r\n\tvar groupCount = 0;\r\n\r\n\t// allow single and array values for \"shapes\" parameter\r\n\r\n\tif ( Array.isArray( shapes ) === false ) {\r\n\r\n\t\taddShape( shapes );\r\n\r\n\t} else {\r\n\r\n\t\tfor ( var i = 0; i < shapes.length; i ++ ) {\r\n\r\n\t\t\taddShape( shapes[ i ] );\r\n\r\n\t\t\tthis$1.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\r\n\r\n\t\t\tgroupStart += groupCount;\r\n\t\t\tgroupCount = 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t// helper functions\r\n\r\n\tfunction addShape( shape ) {\r\n\r\n\t\tvar i, l, shapeHole;\r\n\r\n\t\tvar indexOffset = vertices.length / 3;\r\n\t\tvar points = shape.extractPoints( curveSegments );\r\n\r\n\t\tvar shapeVertices = points.shape;\r\n\t\tvar shapeHoles = points.holes;\r\n\r\n\t\t// check direction of vertices\r\n\r\n\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\r\n\r\n\t\t\tshapeVertices = shapeVertices.reverse();\r\n\r\n\t\t\t// also check if holes are in the opposite direction\r\n\r\n\t\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tshapeHole = shapeHoles[ i ];\r\n\r\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\r\n\r\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\r\n\r\n\t\t// join vertices of inner and outer paths to a single array\r\n\r\n\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\r\n\r\n\t\t\tshapeHole = shapeHoles[ i ];\r\n\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\r\n\r\n\t\t}\r\n\r\n\t\t// vertices, normals, uvs\r\n\r\n\t\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vertex = shapeVertices[ i ];\r\n\r\n\t\t\tvertices.push( vertex.x, vertex.y, 0 );\r\n\t\t\tnormals.push( 0, 0, 1 );\r\n\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\r\n\r\n\t\t}\r\n\r\n\t\t// incides\r\n\r\n\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tvar a = face[ 0 ] + indexOffset;\r\n\t\t\tvar b = face[ 1 ] + indexOffset;\r\n\t\t\tvar c = face[ 2 ] + indexOffset;\r\n\r\n\t\t\tindices.push( a, b, c );\r\n\t\t\tgroupCount += 3;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\r\n\r\nShapeBufferGeometry.prototype.toJSON = function () {\r\n\r\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\r\n\r\n\tvar shapes = this.parameters.shapes;\r\n\r\n\treturn toJSON( shapes, data );\r\n\r\n};\r\n\r\n//\r\n\r\nfunction toJSON( shapes, data ) {\r\n\r\n\tdata.shapes = [];\r\n\r\n\tif ( Array.isArray( shapes ) ) {\r\n\r\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar shape = shapes[ i ];\r\n\r\n\t\t\tdata.shapes.push( shape.uuid );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tdata.shapes.push( shapes.uuid );\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar PaintViveController = function ( id ) {\r\n\r\n\tViveController.call( this, id );\r\n\r\n\tvar PI2 = Math.PI * 2;\r\n\r\n\tvar MODES = { COLOR: 0, SIZE: 1 };\r\n\tvar mode = MODES.COLOR;\r\n\r\n\tvar color = new Color( 1, 1, 1 );\r\n\tvar size = 1.0;\r\n\r\n\t//\r\n\r\n\tfunction generateHueTexture() {\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = 256;\r\n\t\tcanvas.height = 256;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tvar imageData = context.getImageData( 0, 0, 256, 256 );\r\n\t\tvar data = imageData.data;\r\n\t\tvar swatchColor = new Color();\r\n\r\n\t\tfor ( var i = 0, j = 0; i < data.length; i += 4, j ++ ) {\r\n\r\n\t\t\tvar x = ( ( j % 256 ) / 256 ) - 0.5;\r\n\t\t\tvar y = ( Math.floor( j / 256 ) / 256 ) - 0.5;\r\n\r\n\t\t\tswatchColor.setHSL( Math.atan2( y, x ) / PI2, 1, ( 0.5 - Math.sqrt( x * x + y * y ) ) * 2.0 );\r\n\r\n\t\t\tdata[ i + 0 ] = swatchColor.r * 256;\r\n\t\t\tdata[ i + 1 ] = swatchColor.g * 256;\r\n\t\t\tdata[ i + 2 ] = swatchColor.b * 256;\r\n\t\t\tdata[ i + 3 ] = 256;\r\n\r\n\t\t}\r\n\r\n\t\tcontext.putImageData( imageData, 0, 0 );\r\n\r\n\t\treturn new CanvasTexture( canvas );\r\n\r\n\t}\r\n\r\n\t// COLOR UI\r\n\r\n\tvar geometry = new CircleBufferGeometry( 1, 32 );\r\n\tvar material = new MeshBasicMaterial( { map: generateHueTexture() } );\r\n\tvar colorUI = new Mesh( geometry, material );\r\n\tcolorUI.position.set( 0, 0.005, 0.0495 );\r\n\tcolorUI.rotation.x = - 1.45;\r\n\tcolorUI.scale.setScalar( 0.02 );\r\n\tthis.add( colorUI );\r\n\r\n\tvar geometry = new IcosahedronBufferGeometry( 0.1, 2 );\r\n\tvar material = new MeshBasicMaterial();\r\n\tmaterial.color = color;\r\n\tvar ball = new Mesh( geometry, material );\r\n\tcolorUI.add( ball );\r\n\r\n\t// SIZE UI\r\n\tvar sizeUI = new Group();\r\n\tsizeUI.position.set( 0, 0.005, 0.0495 );\r\n\tsizeUI.rotation.x = - 1.45;\r\n\tsizeUI.scale.setScalar( 0.02 );\r\n\tthis.add( sizeUI );\r\n\r\n\tvar triangleShape = new Shape();\r\n\ttriangleShape.moveTo( 0, - 1 );\r\n\ttriangleShape.lineTo( 1, 1 );\r\n\ttriangleShape.lineTo( - 1, 1 );\r\n\r\n\tvar geometry = new ShapeBufferGeometry( triangleShape );\r\n\tvar material = new MeshBasicMaterial( { color: 0x222222, wireframe: true } );\r\n\tvar sizeUIOutline = new Mesh( geometry, material );\r\n\tsizeUIOutline.position.z = 0.001;\r\n\tresizeTriangleGeometry( sizeUIOutline.geometry, 1.0 );\r\n\tsizeUI.add( sizeUIOutline );\r\n\r\n\tvar geometry = new ShapeBufferGeometry( triangleShape );\r\n\tvar material = new MeshBasicMaterial( { side: DoubleSide } );\r\n\tmaterial.color = color;\r\n\tvar sizeUIFill = new Mesh( geometry, material );\r\n\tsizeUIFill.position.z = 0.0011;\r\n\tresizeTriangleGeometry( sizeUIFill.geometry, 0.5 );\r\n\tsizeUI.add( sizeUIFill );\r\n\r\n\tsizeUI.visible = false;\r\n\r\n\tfunction onAxisChanged( event ) {\r\n\r\n\t\tif ( this.getButtonState( 'thumbpad' ) === false ) { return; }\r\n\r\n\t\tvar x = event.axes[ 0 ] / 2.0;\r\n\t\tvar y = - event.axes[ 1 ] / 2.0;\r\n\r\n\t\tif ( mode === MODES.COLOR ) {\r\n\r\n\t\t\tcolor.setHSL( Math.atan2( y, x ) / PI2, 1, ( 0.5 - Math.sqrt( x * x + y * y ) ) * 2.0 );\r\n\r\n\t\t\tball.position.set( event.axes[ 0 ], event.axes[ 1 ], 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( mode === MODES.SIZE ) {\r\n\r\n\t\t\tvar ratio = 0.5 - y;\r\n\t\t\tsize = ratio * 2;\r\n\r\n\t\t\tresizeTriangleGeometry( sizeUIFill.geometry, ratio );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction resizeTriangleGeometry( geometry, ratio ) {\r\n\r\n\t\tvar x = 0, y = 0;\r\n\t\tvar fullWidth = 0.75, fullHeight = 1.5;\r\n\t\tvar angle = Math.atan( ( fullWidth / 2 ) / fullHeight );\r\n\r\n\t\tvar bottomY = y - fullHeight / 2;\r\n\t\tvar height = fullHeight * ratio;\r\n\t\tvar width = ( Math.tan( angle ) * height ) * 2;\r\n\r\n\t\tvar position = geometry.attributes.position;\r\n\r\n\t\tposition.setXYZ( 0, x, bottomY, 0 );\r\n\t\tposition.setXYZ( 1, x + width / 2, bottomY + height, 0 );\r\n\t\tposition.setXYZ( 2, x - width / 2, bottomY + height, 0 );\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tfunction onGripsDown() {\r\n\r\n\t\tif ( mode === MODES.COLOR ) {\r\n\r\n\t\t\tmode = MODES.SIZE;\r\n\t\t\tcolorUI.visible = false;\r\n\t\t\tsizeUI.visible = true;\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( mode === MODES.SIZE ) {\r\n\r\n\t\t\tmode = MODES.COLOR;\r\n\t\t\tcolorUI.visible = true;\r\n\t\t\tsizeUI.visible = false;\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.getColor = function () {\r\n\r\n\t\treturn color;\r\n\r\n\t};\r\n\r\n\tthis.getSize = function () {\r\n\r\n\t\treturn size;\r\n\r\n\t };\r\n\r\n\tthis.addEventListener( 'axischanged', onAxisChanged );\r\n\tthis.addEventListener( 'gripsdown', onGripsDown );\r\n\r\n};\r\n\r\nPaintViveController.prototype = Object.create( ViveController.prototype );\r\nPaintViveController.prototype.constructor = PaintViveController;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar WebVR = {\r\n\r\n\tcreateButton: function ( renderer, options ) {\r\n\r\n\t\tif ( options && options.frameOfReferenceType ) {\r\n\r\n\t\t\trenderer.vr.setFrameOfReferenceType( options.frameOfReferenceType );\r\n\r\n\t\t}\r\n\r\n\t\tfunction showEnterVR( device ) {\r\n\r\n\t\t\tbutton.style.display = '';\r\n\r\n\t\t\tbutton.style.cursor = 'pointer';\r\n\t\t\tbutton.style.left = 'calc(50% - 50px)';\r\n\t\t\tbutton.style.width = '100px';\r\n\r\n\t\t\tbutton.textContent = 'ENTER VR';\r\n\r\n\t\t\tbutton.onmouseenter = function () { button.style.opacity = '1.0'; };\r\n\t\t\tbutton.onmouseleave = function () { button.style.opacity = '0.5'; };\r\n\r\n\t\t\tbutton.onclick = function () {\r\n\r\n\t\t\t\tdevice.isPresenting ? device.exitPresent() : device.requestPresent( [ { source: renderer.domElement } ] );\r\n\r\n\t\t\t};\r\n\r\n\t\t\trenderer.vr.setDevice( device );\r\n\r\n\t\t}\r\n\r\n\t\tfunction showEnterXR( device ) {\r\n\r\n\t\t\tvar currentSession = null;\r\n\r\n\t\t\tfunction onSessionStarted( session ) {\r\n\r\n\t\t\t\tsession.addEventListener( 'end', onSessionEnded );\r\n\r\n\t\t\t\trenderer.vr.setSession( session );\r\n\t\t\t\tbutton.textContent = 'EXIT VR';\r\n\r\n\t\t\t\tcurrentSession = session;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction onSessionEnded( event ) {\r\n\r\n\t\t\t\tcurrentSession.removeEventListener( 'end', onSessionEnded );\r\n\r\n\t\t\t\trenderer.vr.setSession( null );\r\n\t\t\t\tbutton.textContent = 'ENTER VR';\r\n\r\n\t\t\t\tcurrentSession = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tbutton.style.display = '';\r\n\r\n\t\t\tbutton.style.cursor = 'pointer';\r\n\t\t\tbutton.style.left = 'calc(50% - 50px)';\r\n\t\t\tbutton.style.width = '100px';\r\n\r\n\t\t\tbutton.textContent = 'ENTER VR';\r\n\r\n\t\t\tbutton.onmouseenter = function () { button.style.opacity = '1.0'; };\r\n\t\t\tbutton.onmouseleave = function () { button.style.opacity = '0.5'; };\r\n\r\n\t\t\tbutton.onclick = function () {\r\n\r\n\t\t\t\tif ( currentSession === null ) {\r\n\r\n\t\t\t\t\tdevice.requestSession( { immersive: true, exclusive: true  } ).then( onSessionStarted );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcurrentSession.end();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t\trenderer.vr.setDevice( device );\r\n\r\n\t\t}\r\n\r\n\t\tfunction showVRNotFound() {\r\n\r\n\t\t\tbutton.style.display = '';\r\n\r\n\t\t\tbutton.style.cursor = 'auto';\r\n\t\t\tbutton.style.left = 'calc(50% - 75px)';\r\n\t\t\tbutton.style.width = '150px';\r\n\r\n\t\t\tbutton.textContent = 'VR NOT FOUND';\r\n\r\n\t\t\tbutton.onmouseenter = null;\r\n\t\t\tbutton.onmouseleave = null;\r\n\r\n\t\t\tbutton.onclick = null;\r\n\r\n\t\t\trenderer.vr.setDevice( null );\r\n\r\n\t\t}\r\n\r\n\t\tfunction stylizeElement( element ) {\r\n\r\n\t\t\telement.style.position = 'absolute';\r\n\t\t\telement.style.bottom = '20px';\r\n\t\t\telement.style.padding = '12px 6px';\r\n\t\t\telement.style.border = '1px solid #fff';\r\n\t\t\telement.style.borderRadius = '4px';\r\n\t\t\telement.style.background = 'rgba(0,0,0,0.1)';\r\n\t\t\telement.style.color = '#fff';\r\n\t\t\telement.style.font = 'normal 13px sans-serif';\r\n\t\t\telement.style.textAlign = 'center';\r\n\t\t\telement.style.opacity = '0.5';\r\n\t\t\telement.style.outline = 'none';\r\n\t\t\telement.style.zIndex = '999';\r\n\r\n\t\t}\r\n\r\n\t\tif ( 'xr' in navigator ) {\r\n\r\n\t\t\tvar button = document.createElement( 'button' );\r\n\t\t\tbutton.style.display = 'none';\r\n\r\n\t\t\tstylizeElement( button );\r\n\r\n\t\t\tnavigator.xr.requestDevice().then( function ( device ) {\r\n\r\n\t\t\t\tdevice.supportsSession( { immersive: true, exclusive: true  } )\r\n\t\t\t\t\t.then( function () { showEnterXR( device ); } )\r\n\t\t\t\t\t.catch( showVRNotFound );\r\n\r\n\t\t\t} ).catch( showVRNotFound );\r\n\r\n\t\t\treturn button;\r\n\r\n\t\t} else if ( 'getVRDisplays' in navigator ) {\r\n\r\n\t\t\tvar button = document.createElement( 'button' );\r\n\t\t\tbutton.style.display = 'none';\r\n\r\n\t\t\tstylizeElement( button );\r\n\r\n\t\t\twindow.addEventListener( 'vrdisplayconnect', function ( event ) {\r\n\r\n\t\t\t\tshowEnterVR( event.display );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t\twindow.addEventListener( 'vrdisplaydisconnect', function ( event ) {\r\n\r\n\t\t\t\tshowVRNotFound();\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t\twindow.addEventListener( 'vrdisplaypresentchange', function ( event ) {\r\n\r\n\t\t\t\tbutton.textContent = event.display.isPresenting ? 'EXIT VR' : 'ENTER VR';\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t\twindow.addEventListener( 'vrdisplayactivate', function ( event ) {\r\n\r\n\t\t\t\tevent.display.requestPresent( [ { source: renderer.domElement } ] );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t\tnavigator.getVRDisplays()\r\n\t\t\t\t.then( function ( displays ) {\r\n\r\n\t\t\t\t\tif ( displays.length > 0 ) {\r\n\r\n\t\t\t\t\t\tshowEnterVR( displays[ 0 ] );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tshowVRNotFound();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} ).catch( showVRNotFound );\r\n\r\n\t\t\treturn button;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar message = document.createElement( 'a' );\r\n\t\t\tmessage.href = 'https://webvr.info';\r\n\t\t\tmessage.innerHTML = 'WEBVR NOT SUPPORTED';\r\n\r\n\t\t\tmessage.style.left = 'calc(50% - 90px)';\r\n\t\t\tmessage.style.width = '180px';\r\n\t\t\tmessage.style.textDecoration = 'none';\r\n\r\n\t\t\tstylizeElement( message );\r\n\r\n\t\t\treturn message;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// DEPRECATED\r\n\r\n\tcheckAvailability: function () {\r\n\t\tconsole.warn( 'WEBVR.checkAvailability has been deprecated.' );\r\n\t\treturn new Promise( function () {} );\r\n\t},\r\n\r\n\tgetMessageContainer: function () {\r\n\t\tconsole.warn( 'WEBVR.getMessageContainer has been deprecated.' );\r\n\t\treturn document.createElement( 'div' );\r\n\t},\r\n\r\n\tgetButton: function () {\r\n\t\tconsole.warn( 'WEBVR.getButton has been deprecated.' );\r\n\t\treturn document.createElement( 'div' );\r\n\t},\r\n\r\n\tgetVRDisplay: function () {\r\n\t\tconsole.warn( 'WEBVR.getVRDisplay has been deprecated.' );\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AnimationObjectGroup() {\n\tvar arguments$1 = arguments;\n\r\n\r\n\tthis.uuid = _Math.generateUUID();\r\n\r\n\t// cached objects followed by the active ones\r\n\tthis._objects = Array.prototype.slice.call( arguments );\r\n\r\n\tthis.nCachedObjects_ = 0;\t\t\t// threshold\r\n\t// note: read by PropertyBinding.Composite\r\n\r\n\tvar indices = {};\r\n\tthis._indicesByUUID = indices;\t\t// for bookkeeping\r\n\r\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\tindices[ arguments$1[ i ].uuid ] = i;\r\n\r\n\t}\r\n\r\n\tthis._paths = [];\t\t\t\t\t// inside: string\r\n\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\r\n\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\r\n\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.stats = {\r\n\r\n\t\tobjects: {\r\n\t\t\tget total() {\r\n\r\n\t\t\t\treturn scope._objects.length;\r\n\r\n\t\t\t},\r\n\t\t\tget inUse() {\r\n\r\n\t\t\t\treturn this.total - scope.nCachedObjects_;\r\n\r\n\t\t\t}\r\n\t\t},\r\n\t\tget bindingsPerObject() {\r\n\r\n\t\t\treturn scope._bindings.length;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\r\n\r\nObject.assign( AnimationObjectGroup.prototype, {\r\n\r\n\tisAnimationObjectGroup: true,\r\n\r\n\tadd: function () {\n\t\tvar arguments$1 = arguments;\n\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tpaths = this._paths,\r\n\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length,\r\n\t\t\tknownObject = undefined;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments$1[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index === undefined ) {\r\n\r\n\t\t\t\t// unknown object -> add it to the ACTIVE region\r\n\r\n\t\t\t\tindex = nObjects ++;\r\n\t\t\t\tindicesByUUID[ uuid ] = index;\r\n\t\t\t\tobjects.push( object );\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( index < nCachedObjects ) {\r\n\r\n\t\t\t\tknownObject = objects[ index ];\r\n\r\n\t\t\t\t// move existing object to the ACTIVE region\r\n\r\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\r\n\r\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\r\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\r\n\t\t\t\tobjects[ firstActiveIndex ] = object;\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\r\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\r\n\t\t\t\t\tif ( binding === undefined ) {\r\n\r\n\t\t\t\t\t\t// since we do not bother to create new bindings\r\n\t\t\t\t\t\t// for objects that are cached, the binding may\r\n\t\t\t\t\t\t// or may not exist\r\n\r\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\r\n\r\n\t\t\t\tconsole.error( 'AnimationObjectGroup: Different objects with the same UUID ' +\r\n\t\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\r\n\r\n\t\t\t} // else the object is already where we want it to be\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\tremove: function () {\n\t\tvar arguments$1 = arguments;\n\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments$1[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\r\n\r\n\t\t\t\t// move existing object into the CACHED region\r\n\r\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\r\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\r\n\r\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\r\n\t\t\t\tobjects[ index ] = firstActiveObject;\r\n\r\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\r\n\t\t\t\tobjects[ lastCachedIndex ] = object;\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\r\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\r\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\r\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\t// remove & forget\r\n\tuncache: function () {\n\t\tvar arguments$1 = arguments;\n\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments$1[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\tdelete indicesByUUID[ uuid ];\r\n\r\n\t\t\t\tif ( index < nCachedObjects ) {\r\n\r\n\t\t\t\t\t// object is cached, shrink the CACHED region\r\n\r\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\r\n\t\t\t\t\t\tlastIndex = -- nObjects,\r\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\r\n\t\t\t\t\t// last cached object takes this object's place\r\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\r\n\t\t\t\t\t// last object goes to the activated slot and pop\r\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\r\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\r\n\t\t\t\t\tobjects.pop();\r\n\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\r\n\r\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\r\n\t\t\t\t\t\tbindingsForPath.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// object is active, just swap with the last and pop\r\n\r\n\t\t\t\t\tvar lastIndex = -- nObjects,\r\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\r\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastObject;\r\n\t\t\t\t\tobjects.pop();\r\n\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\r\n\r\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\r\n\t\t\t\t\t\tbindingsForPath.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // cached or active\r\n\r\n\t\t\t} // if object is known\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\t// Internal interface used by befriended PropertyBinding.Composite:\r\n\r\n\tsubscribe_: function ( path, parsedPath ) {\r\n\r\n\t\t// returns an array of bindings for the given path that is changed\r\n\t\t// according to the contained objects in the group\r\n\r\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\tindex = indicesByPath[ path ],\r\n\t\t\tbindings = this._bindings;\r\n\r\n\t\tif ( index !== undefined ) { return bindings[ index ]; }\r\n\r\n\t\tvar paths = this._paths,\r\n\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\tobjects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tbindingsForPath = new Array( nObjects );\r\n\r\n\t\tindex = bindings.length;\r\n\r\n\t\tindicesByPath[ path ] = index;\r\n\r\n\t\tpaths.push( path );\r\n\t\tparsedPaths.push( parsedPath );\r\n\t\tbindings.push( bindingsForPath );\r\n\r\n\t\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = objects[ i ];\r\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\r\n\r\n\t\t}\r\n\r\n\t\treturn bindingsForPath;\r\n\r\n\t},\r\n\r\n\tunsubscribe_: function ( path ) {\r\n\r\n\t\t// tells the group to forget about a property path and no longer\r\n\t\t// update the array previously obtained with 'subscribe_'\r\n\r\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\tindex = indicesByPath[ path ];\r\n\r\n\t\tif ( index !== undefined ) {\r\n\r\n\t\t\tvar paths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\r\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\r\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\r\n\r\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\r\n\r\n\t\t\tbindings[ index ] = lastBindings;\r\n\t\t\tbindings.pop();\r\n\r\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\r\n\t\t\tparsedPaths.pop();\r\n\r\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\r\n\t\t\tpaths.pop();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Audio( listener ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'Audio';\r\n\r\n\tthis.context = listener.context;\r\n\r\n\tthis.gain = this.context.createGain();\r\n\tthis.gain.connect( listener.getInput() );\r\n\r\n\tthis.autoplay = false;\r\n\r\n\tthis.buffer = null;\r\n\tthis.loop = false;\r\n\tthis.startTime = 0;\r\n\tthis.offset = 0;\r\n\tthis.playbackRate = 1;\r\n\tthis.isPlaying = false;\r\n\tthis.hasPlaybackControl = true;\r\n\tthis.sourceType = 'empty';\r\n\r\n\tthis.filters = [];\r\n\r\n}\r\n\r\nAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: Audio,\r\n\r\n\tgetOutput: function () {\r\n\r\n\t\treturn this.gain;\r\n\r\n\t},\r\n\r\n\tsetNodeSource: function ( audioNode ) {\r\n\r\n\t\tthis.hasPlaybackControl = false;\r\n\t\tthis.sourceType = 'audioNode';\r\n\t\tthis.source = audioNode;\r\n\t\tthis.connect();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetMediaElementSource: function ( mediaElement ) {\r\n\r\n\t\tthis.hasPlaybackControl = false;\r\n\t\tthis.sourceType = 'mediaNode';\r\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\r\n\t\tthis.connect();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetBuffer: function ( audioBuffer ) {\r\n\r\n\t\tthis.buffer = audioBuffer;\r\n\t\tthis.sourceType = 'buffer';\r\n\r\n\t\tif ( this.autoplay ) { this.play(); }\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tplay: function () {\r\n\r\n\t\tif ( this.isPlaying === true ) {\r\n\r\n\t\t\tconsole.warn( 'Audio: Audio is already playing.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar source = this.context.createBufferSource();\r\n\r\n\t\tsource.buffer = this.buffer;\r\n\t\tsource.loop = this.loop;\r\n\t\tsource.onended = this.onEnded.bind( this );\r\n\t\tsource.playbackRate.setValueAtTime( this.playbackRate, this.startTime );\r\n\t\tthis.startTime = this.context.currentTime;\r\n\t\tsource.start( this.startTime, this.offset );\r\n\r\n\t\tthis.isPlaying = true;\r\n\r\n\t\tthis.source = source;\r\n\r\n\t\treturn this.connect();\r\n\r\n\t},\r\n\r\n\tpause: function () {\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.isPlaying === true ) {\r\n\r\n\t\t\tthis.source.stop();\r\n\t\t\tthis.source.onended = null;\r\n\t\t\tthis.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;\r\n\t\t\tthis.isPlaying = false;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.source.stop();\r\n\t\tthis.source.onended = null;\r\n\t\tthis.offset = 0;\r\n\t\tthis.isPlaying = false;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconnect: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( this.filters.length > 0 ) {\r\n\r\n\t\t\tthis.source.connect( this.filters[ 0 ] );\r\n\r\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis$1.filters[ i - 1 ].connect( this$1.filters[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.source.connect( this.getOutput() );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdisconnect: function () {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tif ( this.filters.length > 0 ) {\r\n\r\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\r\n\r\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis$1.filters[ i - 1 ].disconnect( this$1.filters[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.source.disconnect( this.getOutput() );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetFilters: function () {\r\n\r\n\t\treturn this.filters;\r\n\r\n\t},\r\n\r\n\tsetFilters: function ( value ) {\r\n\r\n\t\tif ( ! value ) { value = []; }\r\n\r\n\t\tif ( this.isPlaying === true ) {\r\n\r\n\t\t\tthis.disconnect();\r\n\t\t\tthis.filters = value;\r\n\t\t\tthis.connect();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.filters = value;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetFilter: function () {\r\n\r\n\t\treturn this.getFilters()[ 0 ];\r\n\r\n\t},\r\n\r\n\tsetFilter: function ( filter ) {\r\n\r\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\r\n\r\n\t},\r\n\r\n\tsetPlaybackRate: function ( value ) {\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.playbackRate = value;\r\n\r\n\t\tif ( this.isPlaying === true ) {\r\n\r\n\t\t\tthis.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetPlaybackRate: function () {\r\n\r\n\t\treturn this.playbackRate;\r\n\r\n\t},\r\n\r\n\tonEnded: function () {\r\n\r\n\t\tthis.isPlaying = false;\r\n\r\n\t},\r\n\r\n\tgetLoop: function () {\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'Audio: this Audio has no playback control.' );\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.loop;\r\n\r\n\t},\r\n\r\n\tsetLoop: function ( value ) {\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.loop = value;\r\n\r\n\t\tif ( this.isPlaying === true ) {\r\n\r\n\t\t\tthis.source.loop = this.loop;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetVolume: function () {\r\n\r\n\t\treturn this.gain.gain.value;\r\n\r\n\t},\r\n\r\n\tsetVolume: function ( value ) {\r\n\r\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AudioAnalyser( audio, fftSize ) {\r\n\r\n\tthis.analyser = audio.context.createAnalyser();\r\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\r\n\r\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\r\n\r\n\taudio.getOutput().connect( this.analyser );\r\n\r\n}\r\n\r\nObject.assign( AudioAnalyser.prototype, {\r\n\r\n\tgetFrequencyData: function () {\r\n\r\n\t\tthis.analyser.getByteFrequencyData( this.data );\r\n\r\n\t\treturn this.data;\r\n\r\n\t},\r\n\r\n\tgetAverageFrequency: function () {\r\n\r\n\t\tvar value = 0, data = this.getFrequencyData();\r\n\r\n\t\tfor ( var i = 0; i < data.length; i ++ ) {\r\n\r\n\t\t\tvalue += data[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn value / data.length;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar context;\r\n\r\nvar AudioContext = {\r\n\r\n\tgetContext: function () {\r\n\r\n\t\tif ( context === undefined ) {\r\n\r\n\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\r\n\r\n\t\t}\r\n\r\n\t\treturn context;\r\n\r\n\t},\r\n\r\n\tsetContext: function ( value ) {\r\n\r\n\t\tcontext = value;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AudioListener() {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'AudioListener';\r\n\r\n\tthis.context = AudioContext.getContext();\r\n\r\n\tthis.gain = this.context.createGain();\r\n\tthis.gain.connect( this.context.destination );\r\n\r\n\tthis.filter = null;\r\n\r\n}\r\n\r\nAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: AudioListener,\r\n\r\n\tgetInput: function () {\r\n\r\n\t\treturn this.gain;\r\n\r\n\t},\r\n\r\n\tremoveFilter: function ( ) {\r\n\r\n\t\tif ( this.filter !== null ) {\r\n\r\n\t\t\tthis.gain.disconnect( this.filter );\r\n\t\t\tthis.filter.disconnect( this.context.destination );\r\n\t\t\tthis.gain.connect( this.context.destination );\r\n\t\t\tthis.filter = null;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetFilter: function () {\r\n\r\n\t\treturn this.filter;\r\n\r\n\t},\r\n\r\n\tsetFilter: function ( value ) {\r\n\r\n\t\tif ( this.filter !== null ) {\r\n\r\n\t\t\tthis.gain.disconnect( this.filter );\r\n\t\t\tthis.filter.disconnect( this.context.destination );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.gain.disconnect( this.context.destination );\r\n\r\n\t\t}\r\n\r\n\t\tthis.filter = value;\r\n\t\tthis.gain.connect( this.filter );\r\n\t\tthis.filter.connect( this.context.destination );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMasterVolume: function () {\r\n\r\n\t\treturn this.gain.gain.value;\r\n\r\n\t},\r\n\r\n\tsetMasterVolume: function ( value ) {\r\n\r\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: ( function () {\r\n\r\n\t\tvar position = new Vector3();\r\n\t\tvar quaternion = new Quaternion();\r\n\t\tvar scale = new Vector3();\r\n\r\n\t\tvar orientation = new Vector3();\r\n\r\n\t\treturn function updateMatrixWorld( force ) {\r\n\r\n\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\t\tvar listener = this.context.listener;\r\n\t\t\tvar up = this.up;\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n\t\t\tif ( listener.positionX ) {\r\n\r\n\t\t\t\tlistener.positionX.setValueAtTime( position.x, this.context.currentTime );\r\n\t\t\t\tlistener.positionY.setValueAtTime( position.y, this.context.currentTime );\r\n\t\t\t\tlistener.positionZ.setValueAtTime( position.z, this.context.currentTime );\r\n\t\t\t\tlistener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );\r\n\t\t\t\tlistener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );\r\n\t\t\t\tlistener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );\r\n\t\t\t\tlistener.upX.setValueAtTime( up.x, this.context.currentTime );\r\n\t\t\t\tlistener.upY.setValueAtTime( up.y, this.context.currentTime );\r\n\t\t\t\tlistener.upZ.setValueAtTime( up.z, this.context.currentTime );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PositionalAudio( listener ) {\r\n\r\n\tAudio.call( this, listener );\r\n\r\n\tthis.panner = this.context.createPanner();\r\n\tthis.panner.connect( this.gain );\r\n\r\n}\r\n\r\nPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\r\n\r\n\tconstructor: PositionalAudio,\r\n\r\n\tgetOutput: function () {\r\n\r\n\t\treturn this.panner;\r\n\r\n\t},\r\n\r\n\tgetRefDistance: function () {\r\n\r\n\t\treturn this.panner.refDistance;\r\n\r\n\t},\r\n\r\n\tsetRefDistance: function ( value ) {\r\n\r\n\t\tthis.panner.refDistance = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetRolloffFactor: function () {\r\n\r\n\t\treturn this.panner.rolloffFactor;\r\n\r\n\t},\r\n\r\n\tsetRolloffFactor: function ( value ) {\r\n\r\n\t\tthis.panner.rolloffFactor = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetDistanceModel: function () {\r\n\r\n\t\treturn this.panner.distanceModel;\r\n\r\n\t},\r\n\r\n\tsetDistanceModel: function ( value ) {\r\n\r\n\t\tthis.panner.distanceModel = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMaxDistance: function () {\r\n\r\n\t\treturn this.panner.maxDistance;\r\n\r\n\t},\r\n\r\n\tsetMaxDistance: function ( value ) {\r\n\r\n\t\tthis.panner.maxDistance = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\r\n\r\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\r\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\r\n\t\tthis.panner.coneOuterGain = coneOuterGain;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: ( function () {\r\n\r\n\t\tvar position = new Vector3();\r\n\t\tvar quaternion = new Quaternion();\r\n\t\tvar scale = new Vector3();\r\n\r\n\t\tvar orientation = new Vector3();\r\n\r\n\t\treturn function updateMatrixWorld( force ) {\r\n\r\n\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\t\tvar panner = this.panner;\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n\t\t\torientation.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\r\n\t\t\tpanner.setPosition( position.x, position.y, position.z );\r\n\t\t\tpanner.setOrientation( orientation.x, orientation.y, orientation.z );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CubeCamera( near, far, cubeResolution ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'CubeCamera';\r\n\r\n\tvar fov = 90, aspect = 1;\r\n\r\n\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPX.up.set( 0, - 1, 0 );\r\n\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\r\n\tthis.add( cameraPX );\r\n\r\n\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNX.up.set( 0, - 1, 0 );\r\n\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\r\n\tthis.add( cameraNX );\r\n\r\n\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPY.up.set( 0, 0, 1 );\r\n\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\r\n\tthis.add( cameraPY );\r\n\r\n\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNY.up.set( 0, 0, - 1 );\r\n\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\r\n\tthis.add( cameraNY );\r\n\r\n\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPZ.up.set( 0, - 1, 0 );\r\n\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\r\n\tthis.add( cameraPZ );\r\n\r\n\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNZ.up.set( 0, - 1, 0 );\r\n\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\r\n\tthis.add( cameraNZ );\r\n\r\n\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\r\n\r\n\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\r\n\tthis.renderTarget.texture.name = \"CubeCamera\";\r\n\r\n\tthis.update = function ( renderer, scene ) {\r\n\r\n\t\tif ( this.parent === null ) { this.updateMatrixWorld(); }\r\n\r\n\t\tvar renderTarget = this.renderTarget;\r\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\r\n\r\n\t\trenderTarget.texture.generateMipmaps = false;\r\n\r\n\t\trenderTarget.activeCubeFace = 0;\r\n\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 1;\r\n\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 2;\r\n\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 3;\r\n\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 4;\r\n\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\r\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\r\n\r\n\t\trenderTarget.activeCubeFace = 5;\r\n\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\r\n\t\trenderer.setRenderTarget( null );\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( renderer, color, depth, stencil ) {\r\n\r\n\t\tvar renderTarget = this.renderTarget;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\trenderTarget.activeCubeFace = i;\r\n\t\t\trenderer.setRenderTarget( renderTarget );\r\n\r\n\t\t\trenderer.clear( color, depth, stencil );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setRenderTarget( null );\r\n\r\n\t};\r\n\r\n}\r\n\r\nCubeCamera.prototype = Object.create( Object3D.prototype );\r\nCubeCamera.prototype.constructor = CubeCamera;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {\r\n\r\n\tif ( typeof ( normalized ) === 'number' ) {\r\n\r\n\t\tmeshPerAttribute = normalized;\r\n\r\n\t\tnormalized = false;\r\n\r\n\t\tconsole.error( 'InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );\r\n\r\n\t}\r\n\r\n\tBufferAttribute.call( this, array, itemSize, normalized );\r\n\r\n\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n}\r\n\r\nInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\r\n\r\n\tconstructor: InstancedBufferAttribute,\r\n\r\n\tisInstancedBufferAttribute: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tBufferAttribute.prototype.copy.call( this, source );\r\n\r\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Font( data ) {\r\n\r\n\tthis.type = 'Font';\r\n\r\n\tthis.data = data;\r\n\r\n}\r\n\r\nObject.assign( Font.prototype, {\r\n\r\n\tisFont: true,\r\n\r\n\tgenerateShapes: function ( text, size ) {\r\n\r\n\t\tif ( size === undefined ) { size = 100; }\r\n\r\n\t\tvar shapes = [];\r\n\t\tvar paths = createPaths( text, size, this.data );\r\n\r\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n\t\t}\r\n\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nfunction createPaths( text, size, data ) {\r\n\r\n\tvar chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988\r\n\tvar scale = size / data.resolution;\r\n\tvar line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\r\n\r\n\tvar paths = [];\r\n\r\n\tvar offsetX = 0, offsetY = 0;\r\n\r\n\tfor ( var i = 0; i < chars.length; i ++ ) {\r\n\r\n\t\tvar char = chars[ i ];\r\n\r\n\t\tif ( char === '\\n' ) {\r\n\r\n\t\t\toffsetX = 0;\r\n\t\t\toffsetY -= line_height;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar ret = createPath( char, scale, offsetX, offsetY, data );\r\n\t\t\toffsetX += ret.offsetX;\r\n\t\t\tpaths.push( ret.path );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn paths;\r\n\r\n}\r\n\r\nfunction createPath( char, scale, offsetX, offsetY, data ) {\r\n\r\n\tvar glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\r\n\r\n\tif ( ! glyph ) { return; }\r\n\r\n\tvar path = new ShapePath();\r\n\r\n\tvar x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\r\n\r\n\tif ( glyph.o ) {\r\n\r\n\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\r\n\t\tfor ( var i = 0, l = outline.length; i < l; ) {\r\n\r\n\t\t\tvar action = outline[ i ++ ];\r\n\r\n\t\t\tswitch ( action ) {\r\n\r\n\t\t\t\tcase 'm': // moveTo\r\n\r\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\r\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'l': // lineTo\r\n\r\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\r\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\r\n\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'q': // quadraticCurveTo\r\n\r\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\r\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\r\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\r\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\r\n\r\n\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'b': // bezierCurveTo\r\n\r\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\r\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\r\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\r\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\r\n\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offsetX;\r\n\t\t\t\t\tcpy2 = outline[ i ++ ] * scale + offsetY;\r\n\r\n\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn { offsetX: glyph.ha * scale, path: path };\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// ConeGeometry\r\n\r\nfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\r\n\r\n\tthis.type = 'ConeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n}\r\n\r\nConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\r\nConeGeometry.prototype.constructor = ConeGeometry;\r\n\r\n// ConeBufferGeometry\r\n\r\nfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\r\n\r\n\tthis.type = 'ConeBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n}\r\n\r\nConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\r\nConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// DodecahedronGeometry\r\n\r\nfunction DodecahedronGeometry( radius, detail ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'DodecahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\r\nDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\r\n\r\n// DodecahedronBufferGeometry\r\n\r\nfunction DodecahedronBufferGeometry( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\tvar r = 1 / t;\r\n\r\n\tvar vertices = [\r\n\r\n\t\t// (±1, ±1, ±1)\r\n\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\r\n\t\t- 1, 1, - 1, - 1, 1, 1,\r\n\t\t1, - 1, - 1, 1, - 1, 1,\r\n\t\t1, 1, - 1, 1, 1, 1,\r\n\r\n\t\t// (0, ±1/φ, ±φ)\r\n\t\t 0, - r, - t, 0, - r, t,\r\n\t\t 0, r, - t, 0, r, t,\r\n\r\n\t\t// (±1/φ, ±φ, 0)\r\n\t\t- r, - t, 0, - r, t, 0,\r\n\t\t r, - t, 0, r, t, 0,\r\n\r\n\t\t// (±φ, 0, ±1/φ)\r\n\t\t- t, 0, - r, t, 0, - r,\r\n\t\t- t, 0, r, t, 0, r\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\r\n\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\r\n\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\r\n\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\r\n\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\r\n\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\r\n\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\r\n\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\r\n\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\r\n\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\r\n\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\r\n\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\r\n\t];\r\n\r\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'DodecahedronBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n}\r\n\r\nDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\r\nDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction EdgesGeometry( geometry, thresholdAngle ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'EdgesGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tthresholdAngle: thresholdAngle\r\n\t};\r\n\r\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\r\n\t// buffer\r\n\r\n\tvar vertices = [];\r\n\r\n\t// helper variables\r\n\r\n\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\r\n\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\r\n\tvar key, keys = [ 'a', 'b', 'c' ];\r\n\r\n\t// prepare source geometry\r\n\r\n\tvar geometry2;\r\n\r\n\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\tgeometry2 = new Geometry();\r\n\t\tgeometry2.fromBufferGeometry( geometry );\r\n\r\n\t} else {\r\n\r\n\t\tgeometry2 = geometry.clone();\r\n\r\n\t}\r\n\r\n\tgeometry2.mergeVertices();\r\n\tgeometry2.computeFaceNormals();\r\n\r\n\tvar sourceVertices = geometry2.vertices;\r\n\tvar faces = geometry2.faces;\r\n\r\n\t// now create a data structure where each entry represents an edge with its adjoining faces\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\tedge1 = face[ keys[ j ] ];\r\n\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\tedge[ 0 ] = Math.min( edge1, edge2 );\r\n\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\r\n\r\n\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\r\n\r\n\t\t\tif ( edges[ key ] === undefined ) {\r\n\r\n\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tedges[ key ].face2 = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate vertices\r\n\r\n\tfor ( key in edges ) {\r\n\r\n\t\tvar e = edges[ key ];\r\n\r\n\t\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\r\n\r\n\t\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\r\n\r\n\t\t\tvar vertex = sourceVertices[ e.index1 ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\tvertex = sourceVertices[ e.index2 ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\r\n}\r\n\r\nEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nEdgesGeometry.prototype.constructor = EdgesGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// ExtrudeGeometry\r\n\r\nfunction ExtrudeGeometry( shapes, options ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tshapes: shapes,\r\n\t\toptions: options\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nExtrudeGeometry.prototype = Object.create( Geometry.prototype );\r\nExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\r\n\r\nExtrudeGeometry.prototype.toJSON = function () {\r\n\r\n\tvar data = Geometry.prototype.toJSON.call( this );\r\n\r\n\tvar shapes = this.parameters.shapes;\r\n\tvar options = this.parameters.options;\r\n\r\n\treturn toJSON$1( shapes, options, data );\r\n\r\n};\r\n\r\n// ExtrudeBufferGeometry\r\n\r\nfunction ExtrudeBufferGeometry( shapes, options ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tshapes: shapes,\r\n\t\toptions: options\r\n\t};\r\n\r\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\r\n\tvar scope = this;\r\n\r\n\tvar verticesArray = [];\r\n\tvar uvArray = [];\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\tvar shape = shapes[ i ];\r\n\t\taddShape( shape );\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\r\n\r\n\tthis.computeVertexNormals();\r\n\r\n\t// functions\r\n\r\n\tfunction addShape( shape ) {\r\n\r\n\t\tvar placeholder = [];\r\n\r\n\t\t// options\r\n\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\t\tvar depth = options.depth !== undefined ? options.depth : 100;\r\n\r\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\r\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\r\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\r\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\t\tvar extrudePath = options.extrudePath;\r\n\r\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\r\n\r\n\t\t// deprecated options\r\n\r\n\t\tif ( options.amount !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'ExtrudeBufferGeometry: amount has been renamed to depth.' );\r\n\t\t\tdepth = options.amount;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar extrudePts, extrudeByPath = false;\r\n\t\tvar splineTube, binormal, normal, position2;\r\n\r\n\t\tif ( extrudePath ) {\r\n\r\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\t\textrudeByPath = true;\r\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t\t// SETUP TNB variables\r\n\r\n\t\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\r\n\r\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\t\tbinormal = new Vector3();\r\n\t\t\tnormal = new Vector3();\r\n\t\t\tposition2 = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\t// Safeguards if bevels are not enabled\r\n\r\n\t\tif ( ! bevelEnabled ) {\r\n\r\n\t\t\tbevelSegments = 0;\r\n\t\t\tbevelThickness = 0;\r\n\t\t\tbevelSize = 0;\r\n\r\n\t\t}\r\n\r\n\t\t// Variables initialization\r\n\r\n\t\tvar ahole, h, hl; // looping of holes\r\n\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\r\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\r\n\r\n\t\tif ( reverse ) {\r\n\r\n\t\t\tvertices = vertices.reverse();\r\n\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\r\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tvertices = vertices.concat( ahole );\r\n\r\n\t\t}\r\n\r\n\t\tfunction scalePt2( pt, vec, size ) {\r\n\r\n\t\t\tif ( ! vec ) { console.error( \"ExtrudeGeometry: vec does not exist\" ); }\r\n\r\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t\t}\r\n\r\n\t\tvar b, bs, t, z,\r\n\t\t\tvert, vlen = vertices.length,\r\n\t\t\tface, flen = faces.length;\r\n\r\n\t\t// Find directions for point movement\r\n\r\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\r\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t\t//\r\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\r\n\t\t\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\r\n\r\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n\t\t\tvar v_prev_x = inPt.x - inPrev.x,\r\n\t\t\t\tv_prev_y = inPt.y - inPrev.y;\r\n\t\t\tvar v_next_x = inNext.x - inPt.x,\r\n\t\t\t\tv_next_y = inNext.y - inPt.y;\r\n\r\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\r\n\t\t\t// check for collinear edges\r\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// not collinear\r\n\r\n\t\t\t\t// length of vectors for normalizing\r\n\r\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\r\n\t\t\t\t// shift adjacent points by unit vectors to the left\r\n\r\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\r\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\r\n\t\t\t\t// scaling factor for v_prev to intersection point\r\n\r\n\t\t\t\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\r\n\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\t\t// vector from inPt to intersection point\r\n\r\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\r\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t\t//  but prevent crazy spikes\r\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\r\n\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// handle special case of collinear edges\r\n\r\n\t\t\t\tvar direction_eq = false; // assumes: opposite\r\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( direction_eq ) {\r\n\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\t\tv_trans_y = v_prev_x;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n\t\t}\r\n\r\n\t\tvar contourMovements = [];\r\n\r\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) { j = 0; }\r\n\t\t\tif ( k === il ) { k = 0; }\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tvar holesMovements = [],\r\n\t\t\toneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\toneHoleMovements = [];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\t\tif ( j === il ) { j = 0; }\r\n\t\t\t\tif ( k === il ) { k = 0; }\r\n\r\n\t\t\t\t//  (j)---(i)---(k)\r\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tholesMovements.push( oneHoleMovements );\r\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t\t}\r\n\r\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\r\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\r\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\r\n\r\n\t\t\t// contract shape\r\n\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n\t\t\t\tv( vert.x, vert.y, - z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// expand holes\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\t\tv( vert.x, vert.y, - z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tbs = bevelSize;\r\n\r\n\t\t// Back facing vertices\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Add stepped vertices...\r\n\t\t// Including front facing vertices\r\n\r\n\t\tvar s;\r\n\r\n\t\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Add bevel segments planes\r\n\r\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\r\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\r\n\r\n\t\t\t// contract shape\r\n\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t\tv( vert.x, vert.y, depth + z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// expand holes\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Top and bottom faces\r\n\r\n\t\tbuildLidFaces();\r\n\r\n\t\t// Sides faces\r\n\r\n\t\tbuildSideFaces();\r\n\r\n\t\t/////  Internal functions\r\n\r\n\t\tfunction buildLidFaces() {\r\n\r\n\t\t\tvar start = verticesArray.length / 3;\r\n\r\n\t\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\t\tvar layer = 0; // steps + 1\r\n\t\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t\t// Bottom faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t\t// Top faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Bottom faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Top faces\r\n\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t// Create faces for the z-sides of the shape\r\n\r\n\t\tfunction buildSideFaces() {\r\n\r\n\t\t\tvar start = verticesArray.length / 3;\r\n\t\t\tvar layeroffset = 0;\r\n\t\t\tsidewalls( contour, layeroffset );\r\n\t\t\tlayeroffset += contour.length;\r\n\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t\t//, true\r\n\t\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\t\tvar j, k;\r\n\t\t\ti = contour.length;\r\n\r\n\t\t\twhile ( -- i >= 0 ) {\r\n\r\n\t\t\t\tj = i;\r\n\t\t\t\tk = i - 1;\r\n\t\t\t\tif ( k < 0 ) { k = contour.length - 1; }\r\n\r\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\t\tvar s = 0,\r\n\t\t\t\t\tsl = steps + bevelSegments * 2;\r\n\r\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\t\tf4( a, b, c, d );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction v( x, y, z ) {\r\n\r\n\t\t\tplaceholder.push( x );\r\n\t\t\tplaceholder.push( y );\r\n\t\t\tplaceholder.push( z );\r\n\r\n\t\t}\r\n\r\n\t\tfunction f3( a, b, c ) {\r\n\r\n\t\t\taddVertex( a );\r\n\t\t\taddVertex( b );\r\n\t\t\taddVertex( c );\r\n\r\n\t\t\tvar nextIndex = verticesArray.length / 3;\r\n\t\t\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\r\n\r\n\t\t\taddUV( uvs[ 0 ] );\r\n\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\taddUV( uvs[ 2 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction f4( a, b, c, d ) {\r\n\r\n\t\t\taddVertex( a );\r\n\t\t\taddVertex( b );\r\n\t\t\taddVertex( d );\r\n\r\n\t\t\taddVertex( b );\r\n\t\t\taddVertex( c );\r\n\t\t\taddVertex( d );\r\n\r\n\t\t\tvar nextIndex = verticesArray.length / 3;\r\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\r\n\r\n\t\t\taddUV( uvs[ 0 ] );\r\n\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\taddUV( uvs[ 3 ] );\r\n\r\n\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\taddUV( uvs[ 2 ] );\r\n\t\t\taddUV( uvs[ 3 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction addVertex( index ) {\r\n\r\n\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\r\n\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\r\n\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction addUV( vector2 ) {\r\n\r\n\t\t\tuvArray.push( vector2.x );\r\n\t\t\tuvArray.push( vector2.y );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\r\n\r\nExtrudeBufferGeometry.prototype.toJSON = function () {\r\n\r\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\r\n\r\n\tvar shapes = this.parameters.shapes;\r\n\tvar options = this.parameters.options;\r\n\r\n\treturn toJSON$1( shapes, options, data );\r\n\r\n};\r\n\r\n//\r\n\r\nvar WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\r\n\r\n\t\tvar a_x = vertices[ indexA * 3 ];\r\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\r\n\t\tvar b_x = vertices[ indexB * 3 ];\r\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\r\n\t\tvar c_x = vertices[ indexC * 3 ];\r\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\r\n\r\n\t\treturn [\r\n\t\t\tnew Vector2( a_x, a_y ),\r\n\t\t\tnew Vector2( b_x, b_y ),\r\n\t\t\tnew Vector2( c_x, c_y )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\r\n\r\n\t\tvar a_x = vertices[ indexA * 3 ];\r\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\r\n\t\tvar a_z = vertices[ indexA * 3 + 2 ];\r\n\t\tvar b_x = vertices[ indexB * 3 ];\r\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\r\n\t\tvar b_z = vertices[ indexB * 3 + 2 ];\r\n\t\tvar c_x = vertices[ indexC * 3 ];\r\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\r\n\t\tvar c_z = vertices[ indexC * 3 + 2 ];\r\n\t\tvar d_x = vertices[ indexD * 3 ];\r\n\t\tvar d_y = vertices[ indexD * 3 + 1 ];\r\n\t\tvar d_z = vertices[ indexD * 3 + 2 ];\r\n\r\n\t\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\r\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\r\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\r\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\r\n\t\t\t];\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\r\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\r\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\r\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\r\n\t\t\t];\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n\r\nfunction toJSON$1( shapes, options, data ) {\r\n\r\n\t//\r\n\r\n\tdata.shapes = [];\r\n\r\n\tif ( Array.isArray( shapes ) ) {\r\n\r\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar shape = shapes[ i ];\r\n\r\n\t\t\tdata.shapes.push( shape.uuid );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tdata.shapes.push( shapes.uuid );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tif ( options.extrudePath !== undefined ) { data.options.extrudePath = options.extrudePath.toJSON(); }\r\n\r\n\treturn data;\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// LatheGeometry\r\n\r\nfunction LatheGeometry( points, segments, phiStart, phiLength ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'LatheGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpoints: points,\r\n\t\tsegments: segments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nLatheGeometry.prototype = Object.create( Geometry.prototype );\r\nLatheGeometry.prototype.constructor = LatheGeometry;\r\n\r\n// LatheBufferGeometry\r\n\r\nfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'LatheBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpoints: points,\r\n\t\tsegments: segments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength\r\n\t};\r\n\r\n\tsegments = Math.floor( segments ) || 12;\r\n\tphiStart = phiStart || 0;\r\n\tphiLength = phiLength || Math.PI * 2;\r\n\r\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\r\n\r\n\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar uvs = [];\r\n\r\n\t// helper variables\r\n\r\n\tvar base;\r\n\tvar inverseSegments = 1.0 / segments;\r\n\tvar vertex = new Vector3();\r\n\tvar uv = new Vector2();\r\n\tvar i, j;\r\n\r\n\t// generate vertices and uvs\r\n\r\n\tfor ( i = 0; i <= segments; i ++ ) {\r\n\r\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n\t\tvar sin = Math.sin( phi );\r\n\t\tvar cos = Math.cos( phi );\r\n\r\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\t// vertex\r\n\r\n\t\t\tvertex.x = points[ j ].x * sin;\r\n\t\t\tvertex.y = points[ j ].y;\r\n\t\t\tvertex.z = points[ j ].x * cos;\r\n\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// uv\r\n\r\n\t\t\tuv.x = i / segments;\r\n\t\t\tuv.y = j / ( points.length - 1 );\r\n\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// indices\r\n\r\n\tfor ( i = 0; i < segments; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\tbase = j + i * points.length;\r\n\r\n\t\t\tvar a = base;\r\n\t\t\tvar b = base + points.length;\r\n\t\t\tvar c = base + points.length + 1;\r\n\t\t\tvar d = base + 1;\r\n\r\n\t\t\t// faces\r\n\r\n\t\t\tindices.push( a, b, d );\r\n\t\t\tindices.push( b, c, d );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t// generate normals\r\n\r\n\tthis.computeVertexNormals();\r\n\r\n\t// if the geometry is closed, we need to average the normals along the seam.\r\n\t// because the corresponding vertices are identical (but still have different UVs).\r\n\r\n\tif ( phiLength === Math.PI * 2 ) {\r\n\r\n\t\tvar normals = this.attributes.normal.array;\r\n\t\tvar n1 = new Vector3();\r\n\t\tvar n2 = new Vector3();\r\n\t\tvar n = new Vector3();\r\n\r\n\t\t// this is the buffer offset for the last line of vertices\r\n\r\n\t\tbase = segments * points.length * 3;\r\n\r\n\t\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\r\n\r\n\t\t\t// select the normal of the vertex in the first line\r\n\r\n\t\t\tn1.x = normals[ j + 0 ];\r\n\t\t\tn1.y = normals[ j + 1 ];\r\n\t\t\tn1.z = normals[ j + 2 ];\r\n\r\n\t\t\t// select the normal of the vertex in the last line\r\n\r\n\t\t\tn2.x = normals[ base + j + 0 ];\r\n\t\t\tn2.y = normals[ base + j + 1 ];\r\n\t\t\tn2.z = normals[ base + j + 2 ];\r\n\r\n\t\t\t// average normals\r\n\r\n\t\t\tn.addVectors( n1, n2 ).normalize();\r\n\r\n\t\t\t// assign the new values to both normals\r\n\r\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\r\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\r\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// ParametricGeometry\r\n\r\nfunction ParametricGeometry( func, slices, stacks ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'ParametricGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tfunc: func,\r\n\t\tslices: slices,\r\n\t\tstacks: stacks\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nParametricGeometry.prototype = Object.create( Geometry.prototype );\r\nParametricGeometry.prototype.constructor = ParametricGeometry;\r\n\r\n// ParametricBufferGeometry\r\n\r\nfunction ParametricBufferGeometry( func, slices, stacks ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'ParametricBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tfunc: func,\r\n\t\tslices: slices,\r\n\t\tstacks: stacks\r\n\t};\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\tvar EPS = 0.00001;\r\n\r\n\tvar normal = new Vector3();\r\n\r\n\tvar p0 = new Vector3(), p1 = new Vector3();\r\n\tvar pu = new Vector3(), pv = new Vector3();\r\n\r\n\tvar i, j;\r\n\r\n\tif ( func.length < 3 ) {\r\n\r\n\t\tconsole.error( 'ParametricGeometry: Function must now modify a Vector3 as third parameter.' );\r\n\r\n\t}\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tvar sliceCount = slices + 1;\r\n\r\n\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\r\n\t\tvar v = i / stacks;\r\n\r\n\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\r\n\t\t\tvar u = j / slices;\r\n\r\n\t\t\t// vertex\r\n\r\n\t\t\tfunc( u, v, p0 );\r\n\t\t\tvertices.push( p0.x, p0.y, p0.z );\r\n\r\n\t\t\t// normal\r\n\r\n\t\t\t// approximate tangent vectors via finite differences\r\n\r\n\t\t\tif ( u - EPS >= 0 ) {\r\n\r\n\t\t\t\tfunc( u - EPS, v, p1 );\r\n\t\t\t\tpu.subVectors( p0, p1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfunc( u + EPS, v, p1 );\r\n\t\t\t\tpu.subVectors( p1, p0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( v - EPS >= 0 ) {\r\n\r\n\t\t\t\tfunc( u, v - EPS, p1 );\r\n\t\t\t\tpv.subVectors( p0, p1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfunc( u, v + EPS, p1 );\r\n\t\t\t\tpv.subVectors( p1, p0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// cross product of tangent vectors returns surface normal\r\n\r\n\t\t\tnormal.crossVectors( pu, pv ).normalize();\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t// uv\r\n\r\n\t\t\tuvs.push( u, v );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( i = 0; i < stacks; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\r\n\t\t\tvar a = i * sliceCount + j;\r\n\t\t\tvar b = i * sliceCount + j + 1;\r\n\t\t\tvar c = ( i + 1 ) * sliceCount + j + 1;\r\n\t\t\tvar d = ( i + 1 ) * sliceCount + j;\r\n\r\n\t\t\t// faces one and two\r\n\r\n\t\t\tindices.push( a, b, d );\r\n\t\t\tindices.push( b, c, d );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n}\r\n\r\nParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// RingGeometry\r\n\r\nfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'RingGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tinnerRadius: innerRadius,\r\n\t\touterRadius: outerRadius,\r\n\t\tthetaSegments: thetaSegments,\r\n\t\tphiSegments: phiSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nRingGeometry.prototype = Object.create( Geometry.prototype );\r\nRingGeometry.prototype.constructor = RingGeometry;\r\n\r\n// RingBufferGeometry\r\n\r\nfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'RingBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tinnerRadius: innerRadius,\r\n\t\touterRadius: outerRadius,\r\n\t\tthetaSegments: thetaSegments,\r\n\t\tphiSegments: phiSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tinnerRadius = innerRadius || 0.5;\r\n\touterRadius = outerRadius || 1;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\t// some helper variables\r\n\r\n\tvar segment;\r\n\tvar radius = innerRadius;\r\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\tvar vertex = new Vector3();\r\n\tvar uv = new Vector2();\r\n\tvar j, i;\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\r\n\r\n\t\t\t// values are generate from the inside of the ring to the outside\r\n\r\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\r\n\r\n\t\t\t// vertex\r\n\r\n\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\tvertex.y = radius * Math.sin( segment );\r\n\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\r\n\t\t\tnormals.push( 0, 0, 1 );\r\n\r\n\t\t\t// uv\r\n\r\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\r\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\r\n\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t}\r\n\r\n\t\t// increase the radius for next row of vertices\r\n\r\n\t\tradius += radiusStep;\r\n\r\n\t}\r\n\r\n\t// indices\r\n\r\n\tfor ( j = 0; j < phiSegments; j ++ ) {\r\n\r\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\r\n\r\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\r\n\r\n\t\t\tsegment = i + thetaSegmentLevel;\r\n\r\n\t\t\tvar a = segment;\r\n\t\t\tvar b = segment + thetaSegments + 1;\r\n\t\t\tvar c = segment + thetaSegments + 2;\r\n\t\t\tvar d = segment + 1;\r\n\r\n\t\t\t// faces\r\n\r\n\t\t\tindices.push( a, b, d );\r\n\t\t\tindices.push( b, c, d );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n}\r\n\r\nRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// TetrahedronGeometry\r\n\r\nfunction TetrahedronGeometry( radius, detail ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'TetrahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\r\nTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\r\n\r\n// TetrahedronBufferGeometry\r\n\r\nfunction TetrahedronBufferGeometry( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\r\n\t];\r\n\r\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'TetrahedronBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n}\r\n\r\nTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\r\nTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// TextGeometry\r\n\r\nfunction TextGeometry( text, parameters ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'TextGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\ttext: text,\r\n\t\tparameters: parameters\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nTextGeometry.prototype = Object.create( Geometry.prototype );\r\nTextGeometry.prototype.constructor = TextGeometry;\r\n\r\n// TextBufferGeometry\r\n\r\nfunction TextBufferGeometry( text, parameters ) {\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar font = parameters.font;\r\n\r\n\tif ( ! ( font && font.isFont ) ) {\r\n\r\n\t\tconsole.error( 'TextGeometry: font parameter is not an instance of Font.' );\r\n\t\treturn new Geometry();\r\n\r\n\t}\r\n\r\n\tvar shapes = font.generateShapes( text, parameters.size );\r\n\r\n\t// translate parameters to ExtrudeGeometry API\r\n\r\n\tparameters.depth = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n\t// defaults\r\n\r\n\tif ( parameters.bevelThickness === undefined ) { parameters.bevelThickness = 10; }\r\n\tif ( parameters.bevelSize === undefined ) { parameters.bevelSize = 8; }\r\n\tif ( parameters.bevelEnabled === undefined ) { parameters.bevelEnabled = false; }\r\n\r\n\tExtrudeBufferGeometry.call( this, shapes, parameters );\r\n\r\n\tthis.type = 'TextBufferGeometry';\r\n\r\n}\r\n\r\nTextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );\r\nTextBufferGeometry.prototype.constructor = TextBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// TorusKnotGeometry\r\n\r\nfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'TorusKnotGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tradialSegments: radialSegments,\r\n\t\tp: p,\r\n\t\tq: q\r\n\t};\r\n\r\n\tif ( heightScale !== undefined ) { console.warn( 'TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' ); }\r\n\r\n\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\r\nTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\r\n\r\n// TorusKnotBufferGeometry\r\n\r\nfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'TorusKnotBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tradialSegments: radialSegments,\r\n\t\tp: p,\r\n\t\tq: q\r\n\t};\r\n\r\n\tradius = radius || 1;\r\n\ttube = tube || 0.4;\r\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\tp = p || 2;\r\n\tq = q || 3;\r\n\r\n\t// buffers\r\n\r\n\tvar indices = [];\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\r\n\t// helper variables\r\n\r\n\tvar i, j;\r\n\r\n\tvar vertex = new Vector3();\r\n\tvar normal = new Vector3();\r\n\r\n\tvar P1 = new Vector3();\r\n\tvar P2 = new Vector3();\r\n\r\n\tvar B = new Vector3();\r\n\tvar T = new Vector3();\r\n\tvar N = new Vector3();\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\r\n\r\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\r\n\r\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\r\n\r\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\r\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\r\n\r\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\r\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\r\n\r\n\t\t// calculate orthonormal basis\r\n\r\n\t\tT.subVectors( P2, P1 );\r\n\t\tN.addVectors( P2, P1 );\r\n\t\tB.crossVectors( T, N );\r\n\t\tN.crossVectors( B, T );\r\n\r\n\t\t// normalize B, N. T can be ignored, we don't use it\r\n\r\n\t\tB.normalize();\r\n\t\tN.normalize();\r\n\r\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\r\n\r\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\r\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\r\n\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\t\tvar cx = - tube * Math.cos( v );\r\n\t\t\tvar cy = tube * Math.sin( v );\r\n\r\n\t\t\t// now calculate the final vertex position.\r\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\r\n\r\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\r\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\r\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\r\n\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\r\n\r\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\r\n\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t// uv\r\n\r\n\t\t\tuvs.push( i / tubularSegments );\r\n\t\t\tuvs.push( j / radialSegments );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\r\n\r\n\t\t\t// indices\r\n\r\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\r\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\r\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\r\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\r\n\r\n\t\t\t// faces\r\n\r\n\t\t\tindices.push( a, b, d );\r\n\t\t\tindices.push( b, c, d );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t// this function calculates the current position on the torus curve\r\n\r\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\r\n\r\n\t\tvar cu = Math.cos( u );\r\n\t\tvar su = Math.sin( u );\r\n\t\tvar quOverP = q / p * u;\r\n\t\tvar cs = Math.cos( quOverP );\r\n\r\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\r\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\r\n\r\n\t}\r\n\r\n}\r\n\r\nTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// TubeGeometry\r\n\r\nfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\r\n\r\n\tGeometry.call( this );\r\n\r\n\tthis.type = 'TubeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpath: path,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tradius: radius,\r\n\t\tradialSegments: radialSegments,\r\n\t\tclosed: closed\r\n\t};\r\n\r\n\tif ( taper !== undefined ) { console.warn( 'TubeGeometry: taper has been removed.' ); }\r\n\r\n\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\r\n\r\n\t// expose internals\r\n\r\n\tthis.tangents = bufferGeometry.tangents;\r\n\tthis.normals = bufferGeometry.normals;\r\n\tthis.binormals = bufferGeometry.binormals;\r\n\r\n\t// create geometry\r\n\r\n\tthis.fromBufferGeometry( bufferGeometry );\r\n\tthis.mergeVertices();\r\n\r\n}\r\n\r\nTubeGeometry.prototype = Object.create( Geometry.prototype );\r\nTubeGeometry.prototype.constructor = TubeGeometry;\r\n\r\n// TubeBufferGeometry\r\n\r\nfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\r\n\r\n\tBufferGeometry.call( this );\r\n\r\n\tthis.type = 'TubeBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpath: path,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tradius: radius,\r\n\t\tradialSegments: radialSegments,\r\n\t\tclosed: closed\r\n\t};\r\n\r\n\ttubularSegments = tubularSegments || 64;\r\n\tradius = radius || 1;\r\n\tradialSegments = radialSegments || 8;\r\n\tclosed = closed || false;\r\n\r\n\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\r\n\r\n\t// expose internals\r\n\r\n\tthis.tangents = frames.tangents;\r\n\tthis.normals = frames.normals;\r\n\tthis.binormals = frames.binormals;\r\n\r\n\t// helper variables\r\n\r\n\tvar vertex = new Vector3();\r\n\tvar normal = new Vector3();\r\n\tvar uv = new Vector2();\r\n\tvar P = new Vector3();\r\n\r\n\tvar i, j;\r\n\r\n\t// buffer\r\n\r\n\tvar vertices = [];\r\n\tvar normals = [];\r\n\tvar uvs = [];\r\n\tvar indices = [];\r\n\r\n\t// create buffer data\r\n\r\n\tgenerateBufferData();\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t// functions\r\n\r\n\tfunction generateBufferData() {\r\n\r\n\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\r\n\r\n\t\t\tgenerateSegment( i );\r\n\r\n\t\t}\r\n\r\n\t\t// if the geometry is not closed, generate the last row of vertices and normals\r\n\t\t// at the regular position on the given path\r\n\t\t//\r\n\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\r\n\r\n\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\r\n\r\n\t\t// uvs are generated in a separate function.\r\n\t\t// this makes it easy compute correct values for closed geometries\r\n\r\n\t\tgenerateUVs();\r\n\r\n\t\t// finally create faces\r\n\r\n\t\tgenerateIndices();\r\n\r\n\t}\r\n\r\n\tfunction generateSegment( i ) {\r\n\r\n\t\t// we use getPointAt to sample evenly distributed points from the given path\r\n\r\n\t\tP = path.getPointAt( i / tubularSegments, P );\r\n\r\n\t\t// retrieve corresponding normal and binormal\r\n\r\n\t\tvar N = frames.normals[ i ];\r\n\t\tvar B = frames.binormals[ i ];\r\n\r\n\t\t// generate normals and vertices for the current segment\r\n\r\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\r\n\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\r\n\t\t\tvar sin = Math.sin( v );\r\n\t\t\tvar cos = - Math.cos( v );\r\n\r\n\t\t\t// normal\r\n\r\n\t\t\tnormal.x = ( cos * N.x + sin * B.x );\r\n\t\t\tnormal.y = ( cos * N.y + sin * B.y );\r\n\t\t\tnormal.z = ( cos * N.z + sin * B.z );\r\n\t\t\tnormal.normalize();\r\n\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t// vertex\r\n\r\n\t\t\tvertex.x = P.x + radius * normal.x;\r\n\t\t\tvertex.y = P.y + radius * normal.y;\r\n\t\t\tvertex.z = P.z + radius * normal.z;\r\n\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction generateIndices() {\r\n\r\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\r\n\r\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\r\n\r\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\r\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\r\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\r\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\r\n\r\n\t\t\t\t// faces\r\n\r\n\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\tindices.push( b, c, d );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction generateUVs() {\r\n\r\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\r\n\r\n\t\t\t\tuv.x = i / tubularSegments;\r\n\t\t\t\tuv.y = j / radialSegments;\r\n\r\n\t\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\r\nTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar lineGeometry, coneGeometry;\r\n\r\nfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\r\n\r\n\t// dir is assumed to be normalized\r\n\r\n\tObject3D.call( this );\r\n\r\n\tif ( color === undefined ) { color = 0xffff00; }\r\n\tif ( length === undefined ) { length = 1; }\r\n\tif ( headLength === undefined ) { headLength = 0.2 * length; }\r\n\tif ( headWidth === undefined ) { headWidth = 0.2 * headLength; }\r\n\r\n\tif ( lineGeometry === undefined ) {\r\n\r\n\t\tlineGeometry = new BufferGeometry();\r\n\t\tlineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\r\n\r\n\t\tconeGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\r\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\r\n\r\n\t}\r\n\r\n\tthis.position.copy( origin );\r\n\r\n\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\r\n\tthis.line.matrixAutoUpdate = false;\r\n\tthis.add( this.line );\r\n\r\n\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\r\n\tthis.cone.matrixAutoUpdate = false;\r\n\tthis.add( this.cone );\r\n\r\n\tthis.setDirection( dir );\r\n\tthis.setLength( length, headLength, headWidth );\r\n\r\n}\r\n\r\nArrowHelper.prototype = Object.create( Object3D.prototype );\r\nArrowHelper.prototype.constructor = ArrowHelper;\r\n\r\nArrowHelper.prototype.setDirection = ( function () {\r\n\r\n\tvar axis = new Vector3();\r\n\tvar radians;\r\n\r\n\treturn function setDirection( dir ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tif ( dir.y > 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\r\n\t\t} else if ( dir.y < - 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\r\n\t\t\tradians = Math.acos( dir.y );\r\n\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\r\n\tif ( headLength === undefined ) { headLength = 0.2 * length; }\r\n\tif ( headWidth === undefined ) { headWidth = 0.2 * headLength; }\r\n\r\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\r\n\tthis.line.updateMatrix();\r\n\r\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\tthis.cone.position.y = length;\r\n\tthis.cone.updateMatrix();\r\n\r\n};\r\n\r\nArrowHelper.prototype.setColor = function ( color ) {\r\n\r\n\tthis.line.material.color.copy( color );\r\n\tthis.cone.material.color.copy( color );\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AxesHelper( size ) {\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar vertices = [\r\n\t\t0, 0, 0,\tsize, 0, 0,\r\n\t\t0, 0, 0,\t0, size, 0,\r\n\t\t0, 0, 0,\t0, 0, size\r\n\t];\r\n\r\n\tvar colors = [\r\n\t\t1, 0, 0,\t1, 0.6, 0,\r\n\t\t0, 1, 0,\t0.6, 1, 0,\r\n\t\t0, 0, 1,\t0, 0.6, 1\r\n\t];\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\r\n\r\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\r\n\r\n\tLineSegments.call( this, geometry, material );\r\n\r\n}\r\n\r\nAxesHelper.prototype = Object.create( LineSegments.prototype );\r\nAxesHelper.prototype.constructor = AxesHelper;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Box3Helper( box, hex ) {\r\n\r\n\tthis.type = 'Box3Helper';\r\n\r\n\tthis.box = box;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n\r\n\tvar positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\r\n\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\r\n\r\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\r\n\r\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\r\n\r\n\tthis.geometry.computeBoundingSphere();\r\n\r\n}\r\n\r\nBox3Helper.prototype = Object.create( LineSegments.prototype );\r\nBox3Helper.prototype.constructor = Box3Helper;\r\n\r\nBox3Helper.prototype.updateMatrixWorld = function ( force ) {\r\n\r\n\tvar box = this.box;\r\n\r\n\tif ( box.isEmpty() ) { return; }\r\n\r\n\tbox.getCenter( this.position );\r\n\r\n\tbox.getSize( this.scale );\r\n\r\n\tthis.scale.multiplyScalar( 0.5 );\r\n\r\n\tObject3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CameraHelper( camera ) {\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\r\n\r\n\tvar vertices = [];\r\n\tvar colors = [];\r\n\r\n\tvar pointMap = {};\r\n\r\n\t// colors\r\n\r\n\tvar colorFrustum = new Color( 0xffaa00 );\r\n\tvar colorCone = new Color( 0xff0000 );\r\n\tvar colorUp = new Color( 0x00aaff );\r\n\tvar colorTarget = new Color( 0xffffff );\r\n\tvar colorCross = new Color( 0x333333 );\r\n\r\n\t// near\r\n\r\n\taddLine( 'n1', 'n2', colorFrustum );\r\n\taddLine( 'n2', 'n4', colorFrustum );\r\n\taddLine( 'n4', 'n3', colorFrustum );\r\n\taddLine( 'n3', 'n1', colorFrustum );\r\n\r\n\t// far\r\n\r\n\taddLine( 'f1', 'f2', colorFrustum );\r\n\taddLine( 'f2', 'f4', colorFrustum );\r\n\taddLine( 'f4', 'f3', colorFrustum );\r\n\taddLine( 'f3', 'f1', colorFrustum );\r\n\r\n\t// sides\r\n\r\n\taddLine( 'n1', 'f1', colorFrustum );\r\n\taddLine( 'n2', 'f2', colorFrustum );\r\n\taddLine( 'n3', 'f3', colorFrustum );\r\n\taddLine( 'n4', 'f4', colorFrustum );\r\n\r\n\t// cone\r\n\r\n\taddLine( 'p', 'n1', colorCone );\r\n\taddLine( 'p', 'n2', colorCone );\r\n\taddLine( 'p', 'n3', colorCone );\r\n\taddLine( 'p', 'n4', colorCone );\r\n\r\n\t// up\r\n\r\n\taddLine( 'u1', 'u2', colorUp );\r\n\taddLine( 'u2', 'u3', colorUp );\r\n\taddLine( 'u3', 'u1', colorUp );\r\n\r\n\t// target\r\n\r\n\taddLine( 'c', 't', colorTarget );\r\n\taddLine( 'p', 'c', colorCross );\r\n\r\n\t// cross\r\n\r\n\taddLine( 'cn1', 'cn2', colorCross );\r\n\taddLine( 'cn3', 'cn4', colorCross );\r\n\r\n\taddLine( 'cf1', 'cf2', colorCross );\r\n\taddLine( 'cf3', 'cf4', colorCross );\r\n\r\n\tfunction addLine( a, b, color ) {\r\n\r\n\t\taddPoint( a, color );\r\n\t\taddPoint( b, color );\r\n\r\n\t}\r\n\r\n\tfunction addPoint( id, color ) {\r\n\r\n\t\tvertices.push( 0, 0, 0 );\r\n\t\tcolors.push( color.r, color.g, color.b );\r\n\r\n\t\tif ( pointMap[ id ] === undefined ) {\r\n\r\n\t\t\tpointMap[ id ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\r\n\r\n\t}\r\n\r\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\r\n\r\n\tLineSegments.call( this, geometry, material );\r\n\r\n\tthis.camera = camera;\r\n\tif ( this.camera.updateProjectionMatrix ) { this.camera.updateProjectionMatrix(); }\r\n\r\n\tthis.matrix = camera.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.pointMap = pointMap;\r\n\r\n\tthis.update();\r\n\r\n}\r\n\r\nCameraHelper.prototype = Object.create( LineSegments.prototype );\r\nCameraHelper.prototype.constructor = CameraHelper;\r\n\r\nCameraHelper.prototype.update = function () {\r\n\r\n\tvar geometry, pointMap;\r\n\r\n\tvar vector = new Vector3();\r\n\tvar camera = new Camera();\r\n\r\n\tfunction setPoint( point, x, y, z ) {\r\n\r\n\t\tvector.set( x, y, z ).unproject( camera );\r\n\r\n\t\tvar points = pointMap[ point ];\r\n\r\n\t\tif ( points !== undefined ) {\r\n\r\n\t\t\tvar position = geometry.getAttribute( 'position' );\r\n\r\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tposition.setXYZ( points[ i ], vector.x, vector.y, vector.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn function update() {\r\n\r\n\t\tgeometry = this.geometry;\r\n\t\tpointMap = this.pointMap;\r\n\r\n\t\tvar w = 1, h = 1;\r\n\r\n\t\t// we need just camera projection matrix\r\n\t\t// world matrix must be identity\r\n\r\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n\t\t// center / target\r\n\r\n\t\tsetPoint( 'c', 0, 0, - 1 );\r\n\t\tsetPoint( 't', 0, 0, 1 );\r\n\r\n\t\t// near\r\n\r\n\t\tsetPoint( 'n1', - w, - h, - 1 );\r\n\t\tsetPoint( 'n2', w, - h, - 1 );\r\n\t\tsetPoint( 'n3', - w, h, - 1 );\r\n\t\tsetPoint( 'n4', w, h, - 1 );\r\n\r\n\t\t// far\r\n\r\n\t\tsetPoint( 'f1', - w, - h, 1 );\r\n\t\tsetPoint( 'f2', w, - h, 1 );\r\n\t\tsetPoint( 'f3', - w, h, 1 );\r\n\t\tsetPoint( 'f4', w, h, 1 );\r\n\r\n\t\t// up\r\n\r\n\t\tsetPoint( 'u1', w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( 'u2', - w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( 'u3', 0, h * 2, - 1 );\r\n\r\n\t\t// cross\r\n\r\n\t\tsetPoint( 'cf1', - w, 0, 1 );\r\n\t\tsetPoint( 'cf2', w, 0, 1 );\r\n\t\tsetPoint( 'cf3', 0, - h, 1 );\r\n\t\tsetPoint( 'cf4', 0, h, 1 );\r\n\r\n\t\tsetPoint( 'cn1', - w, 0, - 1 );\r\n\t\tsetPoint( 'cn2', w, 0, - 1 );\r\n\t\tsetPoint( 'cn3', 0, - h, - 1 );\r\n\t\tsetPoint( 'cn4', 0, h, - 1 );\r\n\r\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\r\n\r\n\t};\r\n\r\n}();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction DirectionalLightHelper( light, size, color ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.color = color;\r\n\r\n\tif ( size === undefined ) { size = 1; }\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [\r\n\t\t- size, size, 0,\r\n\t\tsize, size, 0,\r\n\t\tsize, - size, 0,\r\n\t\t- size, - size, 0,\r\n\t\t- size, size, 0\r\n\t], 3 ) );\r\n\r\n\tvar material = new LineBasicMaterial( { fog: false } );\r\n\r\n\tthis.lightPlane = new Line( geometry, material );\r\n\tthis.add( this.lightPlane );\r\n\r\n\tgeometry = new BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\r\n\r\n\tthis.targetLine = new Line( geometry, material );\r\n\tthis.add( this.targetLine );\r\n\r\n\tthis.update();\r\n\r\n}\r\n\r\nDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\r\nDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\r\n\r\nDirectionalLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.lightPlane.geometry.dispose();\r\n\tthis.lightPlane.material.dispose();\r\n\tthis.targetLine.geometry.dispose();\r\n\tthis.targetLine.material.dispose();\r\n\r\n};\r\n\r\nDirectionalLightHelper.prototype.update = function () {\r\n\r\n\tvar v1 = new Vector3();\r\n\tvar v2 = new Vector3();\r\n\tvar v3 = new Vector3();\r\n\r\n\treturn function update() {\r\n\r\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\tv3.subVectors( v2, v1 );\r\n\r\n\t\tthis.lightPlane.lookAt( v3 );\r\n\r\n\t\tif ( this.color !== undefined ) {\r\n\r\n\t\t\tthis.lightPlane.material.color.set( this.color );\r\n\t\t\tthis.targetLine.material.color.set( this.color );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\r\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\r\n\r\n\t\t}\r\n\r\n\t\tthis.targetLine.lookAt( v3 );\r\n\t\tthis.targetLine.scale.z = v3.length();\r\n\r\n\t};\r\n\r\n}();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction FaceNormalsHelper( object, size, hex, linewidth ) {\r\n\r\n\t// FaceNormalsHelper only supports Geometry\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\t//\r\n\r\n\tvar nNormals = 0;\r\n\r\n\tvar objGeometry = this.object.geometry;\r\n\r\n\tif ( objGeometry && objGeometry.isGeometry ) {\r\n\r\n\t\tnNormals = objGeometry.faces.length;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( 'FaceNormalsHelper: only Geometry is supported. Use VertexNormalsHelper, instead.' );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\r\n\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\r\n\r\n\tgeometry.addAttribute( 'position', positions );\r\n\r\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n\t//\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\tthis.update();\r\n\r\n}\r\n\r\nFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\r\nFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\r\n\r\nFaceNormalsHelper.prototype.update = ( function () {\r\n\r\n\tvar v1 = new Vector3();\r\n\tvar v2 = new Vector3();\r\n\tvar normalMatrix = new Matrix3();\r\n\r\n\treturn function update() {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar matrixWorld = this.object.matrixWorld;\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\r\n\t\t//\r\n\r\n\t\tvar objGeometry = this.object.geometry;\r\n\r\n\t\tvar vertices = objGeometry.vertices;\r\n\r\n\t\tvar faces = objGeometry.faces;\r\n\r\n\t\tvar idx = 0;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tvar normal = face.normal;\r\n\r\n\t\t\tv1.copy( vertices[ face.a ] )\r\n\t\t\t\t.add( vertices[ face.b ] )\r\n\t\t\t\t.add( vertices[ face.c ] )\r\n\t\t\t\t.divideScalar( 3 )\r\n\t\t\t\t.applyMatrix4( matrixWorld );\r\n\r\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this$1.size ).add( v1 );\r\n\r\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\tidx = idx + 1;\r\n\r\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\tidx = idx + 1;\r\n\r\n\t\t}\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t};\r\n\r\n}() );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction GridHelper( size, divisions, color1, color2 ) {\r\n\r\n\tsize = size || 10;\r\n\tdivisions = divisions || 10;\r\n\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\r\n\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\r\n\r\n\tvar center = divisions / 2;\r\n\tvar step = size / divisions;\r\n\tvar halfSize = size / 2;\r\n\r\n\tvar vertices = [], colors = [];\r\n\r\n\tfor ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\r\n\r\n\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\r\n\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\r\n\r\n\t\tvar color = i === center ? color1 : color2;\r\n\r\n\t\tcolor.toArray( colors, j ); j += 3;\r\n\t\tcolor.toArray( colors, j ); j += 3;\r\n\t\tcolor.toArray( colors, j ); j += 3;\r\n\t\tcolor.toArray( colors, j ); j += 3;\r\n\r\n\t}\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\r\n\r\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\r\n\r\n\tLineSegments.call( this, geometry, material );\r\n\r\n}\r\n\r\nGridHelper.prototype = Object.create( LineSegments.prototype );\r\nGridHelper.prototype.constructor = GridHelper;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction HemisphereLightHelper( light, size, color ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.color = color;\r\n\r\n\tvar geometry = new OctahedronBufferGeometry( size );\r\n\tgeometry.rotateY( Math.PI * 0.5 );\r\n\r\n\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\tif ( this.color === undefined ) { this.material.vertexColors = VertexColors; }\r\n\r\n\tvar position = geometry.getAttribute( 'position' );\r\n\tvar colors = new Float32Array( position.count * 3 );\r\n\r\n\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\r\n\r\n\tthis.add( new Mesh( geometry, this.material ) );\r\n\r\n\tthis.update();\r\n\r\n}\r\n\r\nHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\r\nHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\r\n\r\nHemisphereLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.children[ 0 ].geometry.dispose();\r\n\tthis.children[ 0 ].material.dispose();\r\n\r\n};\r\n\r\nHemisphereLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new Vector3();\r\n\r\n\tvar color1 = new Color();\r\n\tvar color2 = new Color();\r\n\r\n\treturn function update() {\r\n\r\n\t\tvar mesh = this.children[ 0 ];\r\n\r\n\t\tif ( this.color !== undefined ) {\r\n\r\n\t\t\tthis.material.color.set( this.color );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar colors = mesh.geometry.getAttribute( 'color' );\r\n\r\n\t\t\tcolor1.copy( this.light.color );\r\n\t\t\tcolor2.copy( this.light.groundColor );\r\n\r\n\t\t\tfor ( var i = 0, l = colors.count; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar color = ( i < ( l / 2 ) ) ? color1 : color2;\r\n\r\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolors.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tmesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\r\n\t};\r\n\r\n}();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PlaneHelper( plane, size, hex ) {\r\n\r\n\tthis.type = 'PlaneHelper';\r\n\r\n\tthis.plane = plane;\r\n\r\n\tthis.size = ( size === undefined ) ? 1 : size;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n\tvar positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\r\n\tgeometry.computeBoundingSphere();\r\n\r\n\tLine.call( this, geometry, new LineBasicMaterial( { color: color } ) );\r\n\r\n\t//\r\n\r\n\tvar positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\r\n\r\n\tvar geometry2 = new BufferGeometry();\r\n\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\r\n\tgeometry2.computeBoundingSphere();\r\n\r\n\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );\r\n\r\n}\r\n\r\nPlaneHelper.prototype = Object.create( Line.prototype );\r\nPlaneHelper.prototype.constructor = PlaneHelper;\r\n\r\nPlaneHelper.prototype.updateMatrixWorld = function ( force ) {\r\n\r\n\tvar scale = - this.plane.constant;\r\n\r\n\tif ( Math.abs( scale ) < 1e-8 ) { scale = 1e-8; } // sign does not matter\r\n\r\n\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\r\n\r\n\tthis.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\r\n\r\n\tthis.lookAt( this.plane.normal );\r\n\r\n\tObject3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PointLightHelper( light, sphereSize, color ) {\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.color = color;\r\n\r\n\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\r\n\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\r\n\tMesh.call( this, geometry, material );\r\n\r\n\tthis.matrix = this.light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n}\r\n\r\nPointLightHelper.prototype = Object.create( Mesh.prototype );\r\nPointLightHelper.prototype.constructor = PointLightHelper;\r\n\r\nPointLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.geometry.dispose();\r\n\tthis.material.dispose();\r\n\r\n};\r\n\r\nPointLightHelper.prototype.update = function () {\r\n\r\n\tif ( this.color !== undefined ) {\r\n\r\n\t\tthis.material.color.set( this.color );\r\n\r\n\t} else {\r\n\r\n\t\tthis.material.color.copy( this.light.color );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\r\n\r\n\tradius = radius || 10;\r\n\tradials = radials || 16;\r\n\tcircles = circles || 8;\r\n\tdivisions = divisions || 64;\r\n\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\r\n\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\r\n\r\n\tvar vertices = [];\r\n\tvar colors = [];\r\n\r\n\tvar x, z;\r\n\tvar v, i, j, r, color;\r\n\r\n\t// create the radials\r\n\r\n\tfor ( i = 0; i <= radials; i ++ ) {\r\n\r\n\t\tv = ( i / radials ) * ( Math.PI * 2 );\r\n\r\n\t\tx = Math.sin( v ) * radius;\r\n\t\tz = Math.cos( v ) * radius;\r\n\r\n\t\tvertices.push( 0, 0, 0 );\r\n\t\tvertices.push( x, 0, z );\r\n\r\n\t\tcolor = ( i & 1 ) ? color1 : color2;\r\n\r\n\t\tcolors.push( color.r, color.g, color.b );\r\n\t\tcolors.push( color.r, color.g, color.b );\r\n\r\n\t}\r\n\r\n\t// create the circles\r\n\r\n\tfor ( i = 0; i <= circles; i ++ ) {\r\n\r\n\t\tcolor = ( i & 1 ) ? color1 : color2;\r\n\r\n\t\tr = radius - ( radius / circles * i );\r\n\r\n\t\tfor ( j = 0; j < divisions; j ++ ) {\r\n\r\n\t\t\t// first vertex\r\n\r\n\t\t\tv = ( j / divisions ) * ( Math.PI * 2 );\r\n\r\n\t\t\tx = Math.sin( v ) * r;\r\n\t\t\tz = Math.cos( v ) * r;\r\n\r\n\t\t\tvertices.push( x, 0, z );\r\n\t\t\tcolors.push( color.r, color.g, color.b );\r\n\r\n\t\t\t// second vertex\r\n\r\n\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\r\n\r\n\t\t\tx = Math.sin( v ) * r;\r\n\t\t\tz = Math.cos( v ) * r;\r\n\r\n\t\t\tvertices.push( x, 0, z );\r\n\t\t\tcolors.push( color.r, color.g, color.b );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\r\n\r\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\r\n\r\n\tLineSegments.call( this, geometry, material );\r\n\r\n}\r\n\r\nPolarGridHelper.prototype = Object.create( LineSegments.prototype );\r\nPolarGridHelper.prototype.constructor = PolarGridHelper;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction RectAreaLightHelper( light, color ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.color = color;\r\n\r\n\tvar material = new LineBasicMaterial( { fog: false } );\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\r\n\tgeometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );\r\n\r\n\tthis.line = new Line( geometry, material );\r\n\tthis.add( this.line );\r\n\r\n\tthis.update();\r\n\r\n}\r\n\r\nRectAreaLightHelper.prototype = Object.create( Object3D.prototype );\r\nRectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\r\n\r\nRectAreaLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.children[ 0 ].geometry.dispose();\r\n\tthis.children[ 0 ].material.dispose();\r\n\r\n};\r\n\r\nRectAreaLightHelper.prototype.update = function () {\r\n\r\n\t// calculate new dimensions of the helper\r\n\r\n\tvar hx = this.light.width * 0.5;\r\n\tvar hy = this.light.height * 0.5;\r\n\r\n\tvar position = this.line.geometry.attributes.position;\r\n\tvar array = position.array;\r\n\r\n\t// update vertices\r\n\r\n\tarray[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;\r\n\tarray[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;\r\n\tarray[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;\r\n\tarray[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;\r\n\tarray[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;\r\n\r\n\tposition.needsUpdate = true;\r\n\r\n\tif ( this.color !== undefined ) {\r\n\r\n\t\tthis.line.material.color.set( this.color );\r\n\r\n\t} else {\r\n\r\n\t\tthis.line.material.color.copy( this.light.color );\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction SpotLightHelper( light, color ) {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.color = color;\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\r\n\tvar positions = [\r\n\t\t0, 0, 0, \t0, 0, 1,\r\n\t\t0, 0, 0, \t1, 0, 1,\r\n\t\t0, 0, 0,\t- 1, 0, 1,\r\n\t\t0, 0, 0, \t0, 1, 1,\r\n\t\t0, 0, 0, \t0, - 1, 1\r\n\t];\r\n\r\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\r\n\r\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\r\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\r\n\r\n\t\tpositions.push(\r\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\r\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\r\n\r\n\tvar material = new LineBasicMaterial( { fog: false } );\r\n\r\n\tthis.cone = new LineSegments( geometry, material );\r\n\tthis.add( this.cone );\r\n\r\n\tthis.update();\r\n\r\n}\r\n\r\nSpotLightHelper.prototype = Object.create( Object3D.prototype );\r\nSpotLightHelper.prototype.constructor = SpotLightHelper;\r\n\r\nSpotLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.cone.geometry.dispose();\r\n\tthis.cone.material.dispose();\r\n\r\n};\r\n\r\nSpotLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new Vector3();\r\n\tvar vector2 = new Vector3();\r\n\r\n\treturn function update() {\r\n\r\n\t\tthis.light.updateMatrixWorld();\r\n\r\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\r\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\r\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\r\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\r\n\t\tif ( this.color !== undefined ) {\r\n\r\n\t\t\tthis.cone.material.color.set( this.color );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.cone.material.color.copy( this.light.color );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}();\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction VertexNormalsHelper( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\t//\r\n\r\n\tvar nNormals = 0;\r\n\r\n\tvar objGeometry = this.object.geometry;\r\n\r\n\tif ( objGeometry && objGeometry.isGeometry ) {\r\n\r\n\t\tnNormals = objGeometry.faces.length * 3;\r\n\r\n\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\r\n\r\n\t\tnNormals = objGeometry.attributes.normal.count;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar geometry = new BufferGeometry();\r\n\r\n\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\r\n\r\n\tgeometry.addAttribute( 'position', positions );\r\n\r\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n\t//\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n}\r\n\r\nVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\r\nVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\r\n\r\nVertexNormalsHelper.prototype.update = ( function () {\r\n\r\n\tvar v1 = new Vector3();\r\n\tvar v2 = new Vector3();\r\n\tvar normalMatrix = new Matrix3();\r\n\r\n\treturn function update() {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar matrixWorld = this.object.matrixWorld;\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\r\n\t\t//\r\n\r\n\t\tvar objGeometry = this.object.geometry;\r\n\r\n\t\tif ( objGeometry && objGeometry.isGeometry ) {\r\n\r\n\t\t\tvar vertices = objGeometry.vertices;\r\n\r\n\t\t\tvar faces = objGeometry.faces;\r\n\r\n\t\t\tvar idx = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\r\n\r\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\r\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this$1.size ).add( v1 );\r\n\r\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\r\n\r\n\t\t\tvar objPos = objGeometry.attributes.position;\r\n\r\n\t\t\tvar objNorm = objGeometry.attributes.normal;\r\n\r\n\t\t\tvar idx = 0;\r\n\r\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\r\n\r\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\r\n\r\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\r\n\r\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this$1.size ).add( v1 );\r\n\r\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t};\r\n\r\n}() );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction RectAreaLight( color, intensity, width, height ) {\r\n\r\n\tLight.call( this, color, intensity );\r\n\r\n\tthis.type = 'RectAreaLight';\r\n\r\n\tthis.width = ( width !== undefined ) ? width : 10;\r\n\tthis.height = ( height !== undefined ) ? height : 10;\r\n\r\n}\r\n\r\nRectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\r\n\r\n\tconstructor: RectAreaLight,\r\n\r\n\tisRectAreaLight: true,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tLight.prototype.copy.call( this, source );\r\n\r\n\t\tthis.width = source.width;\r\n\t\tthis.height = source.height;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar data = Light.prototype.toJSON.call( this, meta );\r\n\r\n\t\tdata.object.width = this.width;\r\n\t\tdata.object.height = this.height;\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AnimationLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n}\r\n\r\nObject.assign( AnimationLoader.prototype, {\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( json, onLoad ) {\r\n\r\n\t\tvar animations = [];\r\n\r\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\r\n\r\n\t\t\tvar clip = AnimationClip.parse( json[ i ] );\r\n\r\n\t\t\tanimations.push( clip );\r\n\r\n\t\t}\r\n\r\n\t\tonLoad( animations );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction AudioLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n}\r\n\r\nObject.assign( AudioLoader.prototype, {\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\r\n\t\t\t// detaches the buffer when complete, preventing reuse.\r\n\t\t\tvar bufferCopy = buffer.slice( 0 );\r\n\r\n\t\t\tvar context = AudioContext.getContext();\r\n\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\r\n\r\n\t\t\t\tonLoad( audioBuffer );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction BufferGeometryLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n}\r\n\r\nObject.assign( BufferGeometryLoader.prototype, {\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometry = new BufferGeometry();\r\n\r\n\t\tvar index = json.data.index;\r\n\r\n\t\tif ( index !== undefined ) {\r\n\r\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\r\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = json.data.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\r\n\r\n\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n\r\n\t\tif ( groups !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = json.data.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tvar center = new Vector3();\r\n\r\n\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\r\n\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nvar TYPED_ARRAYS = {\r\n\tInt8Array: Int8Array,\r\n\tUint8Array: Uint8Array,\r\n\t// Workaround for IE11 pre KB2929437. See #11440\r\n\tUint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\r\n\tInt16Array: Int16Array,\r\n\tUint16Array: Uint16Array,\r\n\tInt32Array: Int32Array,\r\n\tUint32Array: Uint32Array,\r\n\tFloat32Array: Float32Array,\r\n\tFloat64Array: Float64Array\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction CubeTextureLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n}\r\n\r\nObject.assign( CubeTextureLoader.prototype, {\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tload: function ( urls, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar texture = new CubeTexture();\r\n\r\n\t\tvar loader = new ImageLoader( this.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.setPath( this.path );\r\n\r\n\t\tvar loaded = 0;\r\n\r\n\t\tfunction loadTexture( i ) {\r\n\r\n\t\t\tloader.load( urls[ i ], function ( image ) {\r\n\r\n\t\t\t\ttexture.images[ i ] = image;\r\n\r\n\t\t\t\tloaded ++;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) { onLoad( texture ); }\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, undefined, onError );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\r\n\r\n\t\t\tloadTexture( i );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction FontLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\r\n}\r\n\r\nObject.assign( FontLoader.prototype, {\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tvar json;\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tjson = JSON.parse( text );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tconsole.warn( 'FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\r\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar font = scope.parse( json );\r\n\r\n\t\t\tif ( onLoad ) { onLoad( font ); }\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\treturn new Font( json );\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction ImageBitmapLoader( manager ) {\r\n\r\n\tif ( typeof createImageBitmap === 'undefined' ) {\r\n\r\n\t\tconsole.warn( 'ImageBitmapLoader: createImageBitmap() not supported.' );\r\n\r\n\t}\r\n\r\n\tif ( typeof fetch === 'undefined' ) {\r\n\r\n\t\tconsole.warn( 'ImageBitmapLoader: fetch() not supported.' );\r\n\r\n\t}\r\n\r\n\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\r\n\tthis.options = undefined;\r\n\r\n}\r\n\r\nImageBitmapLoader.prototype = {\r\n\r\n\tconstructor: ImageBitmapLoader,\r\n\r\n\tsetOptions: function setOptions( options ) {\r\n\r\n\t\tthis.options = options;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( url === undefined ) { url = ''; }\r\n\r\n\t\tif ( this.path !== undefined ) { url = this.path + url; }\r\n\r\n\t\turl = this.manager.resolveURL( url );\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\tif ( onLoad ) { onLoad( cached ); }\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t}, 0 );\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\tfetch( url ).then( function ( res ) {\r\n\r\n\t\t\treturn res.blob();\r\n\r\n\t\t} ).then( function ( blob ) {\r\n\r\n\t\t\treturn createImageBitmap( blob, scope.options );\r\n\r\n\t\t} ).then( function ( imageBitmap ) {\r\n\r\n\t\t\tCache.add( url, imageBitmap );\r\n\r\n\t\t\tif ( onLoad ) { onLoad( imageBitmap ); }\r\n\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t} ).catch( function ( e ) {\r\n\r\n\t\t\tif ( onError ) { onError( e ); }\r\n\r\n\t\t\tscope.manager.itemEnd( url );\r\n\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function (  ) {\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction LOD() {\r\n\r\n\tObject3D.call( this );\r\n\r\n\tthis.type = 'LOD';\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tlevels: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: []\r\n\t\t}\r\n\t} );\r\n\r\n}\r\n\r\nLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\r\n\r\n\tconstructor: LOD,\r\n\r\n\tcopy: function ( source ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tObject3D.prototype.copy.call( this, source, false );\r\n\r\n\t\tvar levels = source.levels;\r\n\r\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar level = levels[ i ];\r\n\r\n\t\t\tthis$1.addLevel( level.object.clone(), level.distance );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddLevel: function ( object, distance ) {\r\n\r\n\t\tif ( distance === undefined ) { distance = 0; }\r\n\r\n\t\tdistance = Math.abs( distance );\r\n\r\n\t\tvar levels = this.levels;\r\n\r\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n\t\t\tif ( distance < levels[ l ].distance ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\r\n\r\n\t\tthis.add( object );\r\n\r\n\t},\r\n\r\n\tgetObjectForDistance: function ( distance ) {\r\n\r\n\t\tvar levels = this.levels;\r\n\r\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( distance < levels[ i ].distance ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn levels[ i - 1 ].object;\r\n\r\n\t},\r\n\r\n\traycast: ( function () {\r\n\r\n\t\tvar matrixPosition = new Vector3();\r\n\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\r\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tupdate: function () {\r\n\r\n\t\tvar v1 = new Vector3();\r\n\t\tvar v2 = new Vector3();\r\n\r\n\t\treturn function update( camera ) {\r\n\r\n\t\t\tvar levels = this.levels;\r\n\r\n\t\t\tif ( levels.length > 1 ) {\r\n\r\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\t\tvar distance = v1.distanceTo( v2 );\r\n\r\n\t\t\t\tlevels[ 0 ].object.visible = true;\r\n\r\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\r\n\r\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\r\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( ; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tlevels[ i ].object.visible = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\t\tdata.object.levels = [];\r\n\r\n\t\tvar levels = this.levels;\r\n\r\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar level = levels[ i ];\r\n\r\n\t\t\tdata.object.levels.push( {\r\n\t\t\t\tobject: level.object.uuid,\r\n\t\t\t\tdistance: level.distance\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Fog( color, near, far ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new Color( color );\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 1;\r\n\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\r\n}\r\n\r\nFog.prototype.isFog = true;\r\n\r\nFog.prototype.clone = function () {\r\n\r\n\treturn new Fog( this.color, this.near, this.far );\r\n\r\n};\r\n\r\nFog.prototype.toJSON = function (  ) {\r\n\r\n\treturn {\r\n\t\ttype: 'Fog',\r\n\t\tcolor: this.color.getHex(),\r\n\t\tnear: this.near,\r\n\t\tfar: this.far\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction FogExp2( color, density ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new Color( color );\r\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n}\r\n\r\nFogExp2.prototype.isFogExp2 = true;\r\n\r\nFogExp2.prototype.clone = function () {\r\n\r\n\treturn new FogExp2( this.color, this.density );\r\n\r\n};\r\n\r\nFogExp2.prototype.toJSON = function (  ) {\r\n\r\n\treturn {\r\n\t\ttype: 'FogExp2',\r\n\t\tcolor: this.color.getHex(),\r\n\t\tdensity: this.density\r\n\t};\r\n\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar Geometries = {\r\n    WireframeGeometry: WireframeGeometry,\r\n    TetrahedronGeometry: TetrahedronGeometry,\r\n    TetrahedronBufferGeometry: TetrahedronBufferGeometry,\r\n    OctahedronGeometry: OctahedronGeometry,\r\n    OctahedronBufferGeometry: OctahedronBufferGeometry,\r\n    IcosahedronGeometry: IcosahedronGeometry,\r\n    IcosahedronBufferGeometry: IcosahedronBufferGeometry,\r\n    DodecahedronGeometry: DodecahedronGeometry,\r\n    DodecahedronBufferGeometry: DodecahedronBufferGeometry,\r\n    PolyhedronGeometry: PolyhedronGeometry,\r\n    PolyhedronBufferGeometry: PolyhedronBufferGeometry,\r\n    TubeGeometry: TubeGeometry,\r\n    TubeBufferGeometry: TubeBufferGeometry,\r\n    TorusKnotGeometry: TorusKnotGeometry,\r\n    TorusGeometry: TorusGeometry,\r\n    TorusBufferGeometry: TorusBufferGeometry,\r\n    TextGeometry: TextGeometry,\r\n    TextBufferGeometry: TextBufferGeometry,\r\n    SphereGeometry: SphereGeometry,\r\n    SphereBufferGeometry: SphereBufferGeometry,\r\n    RingGeometry: RingGeometry,\r\n    RingBufferGeometry: RingBufferGeometry,\r\n    PlaneGeometry: PlaneGeometry,\r\n    PlaneBufferGeometry: PlaneBufferGeometry,\r\n    LatheGeometry: LatheGeometry,\r\n    LatheBufferGeometry: LatheBufferGeometry,\r\n    ShapeGeometry: ShapeGeometry,\r\n    ShapeBufferGeometry: ShapeBufferGeometry,\r\n    ExtrudeGeometry: ExtrudeGeometry,\r\n    ExtrudeBufferGeometry: ExtrudeBufferGeometry,\r\n    EdgesGeometry: EdgesGeometry,\r\n    ConeGeometry: ConeGeometry,\r\n    ConeBufferGeometry: ConeBufferGeometry,\r\n    CylinderGeometry: CylinderGeometry,\r\n    CylinderBufferGeometry: CylinderBufferGeometry,\r\n    CircleGeometry: CircleGeometry,\r\n    CircleBufferGeometry: CircleBufferGeometry,\r\n    BoxGeometry: BoxGeometry,\r\n    BoxBufferGeometry: BoxBufferGeometry\r\n};\r\nfunction ObjectLoader( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\r\n\tthis.texturePath = '';\r\n\r\n}\r\n\r\nObject.assign( ObjectLoader.prototype, {\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.texturePath === '' ) {\r\n\r\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new FileLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tvar json = null;\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tjson = JSON.parse( text );\r\n\r\n\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\tif ( onError !== undefined ) { onError( error ); }\r\n\r\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar metadata = json.metadata;\r\n\r\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\r\n\r\n\t\t\t\tconsole.error( 'ObjectLoader: Can\\'t load ' + url + '. Use JSONLoader instead.' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.parse( json, onLoad );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tparse: function ( json, onLoad ) {\r\n\r\n\t\tvar shapes = this.parseShape( json.shapes );\r\n\t\tvar geometries = this.parseGeometries( json.geometries, shapes );\r\n\r\n\t\tvar images = this.parseImages( json.images, function () {\r\n\r\n\t\t\tif ( onLoad !== undefined ) { onLoad( object ); }\r\n\r\n\t\t} );\r\n\r\n\t\tvar textures = this.parseTextures( json.textures, images );\r\n\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\r\n\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\r\n\t\tif ( json.animations ) {\r\n\r\n\t\t\tobject.animations = this.parseAnimations( json.animations );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\r\n\t\t\tif ( onLoad !== undefined ) { onLoad( object ); }\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t},\r\n\r\n\tparseShape: function ( json ) {\r\n\r\n\t\tvar shapes = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar shape = new Shape().fromJSON( json[ i ] );\r\n\r\n\t\t\t\tshapes[ shape.uuid ] = shape;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn shapes;\r\n\r\n\t},\r\n\r\n\tparseGeometries: function ( json, shapes ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar geometries = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar geometryLoader = new JSONLoader();\r\n\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar geometry;\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\tcase 'BoxBufferGeometry':\r\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CircleGeometry':\r\n\t\t\t\t\tcase 'CircleBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CylinderGeometry':\r\n\t\t\t\t\tcase 'CylinderBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.openEnded,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'ConeGeometry':\r\n\t\t\t\t\tcase 'ConeBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.openEnded,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'SphereGeometry':\r\n\t\t\t\t\tcase 'SphereBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'DodecahedronGeometry':\r\n\t\t\t\t\tcase 'DodecahedronBufferGeometry':\r\n\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\t\t\t\t\tcase 'IcosahedronBufferGeometry':\r\n\t\t\t\t\tcase 'OctahedronGeometry':\r\n\t\t\t\t\tcase 'OctahedronBufferGeometry':\r\n\t\t\t\t\tcase 'TetrahedronGeometry':\r\n\t\t\t\t\tcase 'TetrahedronBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'RingGeometry':\r\n\t\t\t\t\tcase 'RingBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.innerRadius,\r\n\t\t\t\t\t\t\tdata.outerRadius,\r\n\t\t\t\t\t\t\tdata.thetaSegments,\r\n\t\t\t\t\t\t\tdata.phiSegments,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusGeometry':\r\n\t\t\t\t\tcase 'TorusBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\tdata.q\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'LatheGeometry':\r\n\t\t\t\t\tcase 'LatheBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.points,\r\n\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'PolyhedronGeometry':\r\n\t\t\t\t\tcase 'PolyhedronBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tdata.vertices,\r\n\t\t\t\t\t\t\tdata.indices,\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.details\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'ShapeGeometry':\r\n\t\t\t\t\tcase 'ShapeBufferGeometry':\r\n\r\n\t\t\t\t\t\tvar geometryShapes = [];\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar shape = shapes[ data.shapes[ j ] ];\r\n\r\n\t\t\t\t\t\t\tgeometryShapes.push( shape );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tgeometryShapes,\r\n\t\t\t\t\t\t\tdata.curveSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'ExtrudeGeometry':\r\n\t\t\t\t\tcase 'ExtrudeBufferGeometry':\r\n\r\n\t\t\t\t\t\tvar geometryShapes = [];\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar shape = shapes[ data.shapes[ j ] ];\r\n\r\n\t\t\t\t\t\t\tgeometryShapes.push( shape );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar extrudePath = data.options.extrudePath;\r\n\r\n\t\t\t\t\t\tif ( extrudePath !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\r\n\t\t\t\t\t\t\tgeometryShapes,\r\n\t\t\t\t\t\t\tdata.options\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Geometry':\r\n\r\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data, this$1.texturePath ).geometry;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tconsole.warn( 'ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) { geometry.name = data.name; }\r\n\t\t\t\tif ( geometry.isBufferGeometry === true && data.userData !== undefined ) { geometry.userData = data.userData; }\r\n\r\n\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometries;\r\n\r\n\t},\r\n\r\n\tparseMaterials: function ( json, textures ) {\r\n\r\n\t\tvar materials = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar loader = new MaterialLoader();\r\n\t\t\tloader.setTextures( textures );\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tif ( data.type === 'MultiMaterial' ) {\r\n\r\n\t\t\t\t\t// Deprecated\r\n\r\n\t\t\t\t\tvar array = [];\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < data.materials.length; j ++ ) {\r\n\r\n\t\t\t\t\t\tarray.push( loader.parse( data.materials[ j ] ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmaterials[ data.uuid ] = array;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterials[ data.uuid ] = loader.parse( data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn materials;\r\n\r\n\t},\r\n\r\n\tparseAnimations: function ( json ) {\r\n\r\n\t\tvar animations = [];\r\n\r\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\r\n\r\n\t\t\tvar data = json[ i ];\r\n\r\n\t\t\tvar clip = AnimationClip.parse( data );\r\n\r\n\t\t\tif ( data.uuid !== undefined ) { clip.uuid = data.uuid; }\r\n\r\n\t\t\tanimations.push( clip );\r\n\r\n\t\t}\r\n\r\n\t\treturn animations;\r\n\r\n\t},\r\n\r\n\tparseImages: function ( json, onLoad ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar images = {};\r\n\r\n\t\tfunction loadImage( url ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\treturn loader.load( url, function () {\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t}, undefined, function () {\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json !== undefined && json.length > 0 ) {\r\n\r\n\t\t\tvar manager = new LoadingManager( onLoad );\r\n\r\n\t\t\tvar loader = new ImageLoader( manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\tfor ( var i = 0, il = json.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar image = json[ i ];\r\n\t\t\t\tvar url = image.url;\r\n\r\n\t\t\t\tif ( Array.isArray( url ) ) {\r\n\r\n\t\t\t\t\t// load array of images e.g CubeTexture\r\n\r\n\t\t\t\t\timages[ image.uuid ] = [];\r\n\r\n\t\t\t\t\tfor ( var j = 0, jl = url.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tvar currentUrl = url[ j ];\r\n\r\n\t\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( currentUrl ) ? currentUrl : scope.texturePath + currentUrl;\r\n\r\n\t\t\t\t\t\timages[ image.uuid ].push( loadImage( path ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// load single image\r\n\r\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\r\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn images;\r\n\r\n\t},\r\n\r\n\tparseTextures: function ( json, images ) {\r\n\r\n\t\tfunction parseConstant( value, type ) {\r\n\r\n\t\t\tif ( typeof value === 'number' ) { return value; }\r\n\r\n\t\t\tconsole.warn( 'ObjectLoader.parseTexture: Constant should be in numeric form.', value );\r\n\r\n\t\t\treturn type[ value ];\r\n\r\n\t\t}\r\n\r\n\t\tvar textures = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tif ( data.image === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'ObjectLoader: No \"image\" specified for', data.uuid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'ObjectLoader: Undefined image', data.image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar texture;\r\n\r\n\t\t\t\tif ( Array.isArray( images[ data.image ] ) ) {\r\n\r\n\t\t\t\t\ttexture = new CubeTexture( images[ data.image ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture = new Texture( images[ data.image ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\ttexture.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) { texture.name = data.name; }\r\n\r\n\t\t\t\tif ( data.mapping !== undefined ) { texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING ); }\r\n\r\n\t\t\t\tif ( data.offset !== undefined ) { texture.offset.fromArray( data.offset ); }\r\n\t\t\t\tif ( data.repeat !== undefined ) { texture.repeat.fromArray( data.repeat ); }\r\n\t\t\t\tif ( data.center !== undefined ) { texture.center.fromArray( data.center ); }\r\n\t\t\t\tif ( data.rotation !== undefined ) { texture.rotation = data.rotation; }\r\n\r\n\t\t\t\tif ( data.wrap !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\r\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.format !== undefined ) { texture.format = data.format; }\r\n\r\n\t\t\t\tif ( data.minFilter !== undefined ) { texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER ); }\r\n\t\t\t\tif ( data.magFilter !== undefined ) { texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER ); }\r\n\t\t\t\tif ( data.anisotropy !== undefined ) { texture.anisotropy = data.anisotropy; }\r\n\r\n\t\t\t\tif ( data.flipY !== undefined ) { texture.flipY = data.flipY; }\r\n\r\n\t\t\t\ttextures[ data.uuid ] = texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn textures;\r\n\r\n\t},\r\n\r\n\tparseObject: function ( data, geometries, materials ) {\n\t\tvar this$1 = this;\n\r\n\r\n\t\tvar object;\r\n\r\n\t\tfunction getGeometry( name ) {\r\n\r\n\t\t\tif ( geometries[ name ] === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'ObjectLoader: Undefined geometry', name );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometries[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getMaterial( name ) {\r\n\r\n\t\t\tif ( name === undefined ) { return undefined; }\r\n\r\n\t\t\tif ( Array.isArray( name ) ) {\r\n\r\n\t\t\t\tvar array = [];\r\n\r\n\t\t\t\tfor ( var i = 0, l = name.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar uuid = name[ i ];\r\n\r\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'ObjectLoader: Undefined material', uuid );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tarray.push( materials[ uuid ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn array;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( materials[ name ] === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'ObjectLoader: Undefined material', name );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn materials[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tswitch ( data.type ) {\r\n\r\n\t\t\tcase 'Scene':\r\n\r\n\t\t\t\tobject = new Scene();\r\n\r\n\t\t\t\tif ( data.background !== undefined ) {\r\n\r\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\r\n\r\n\t\t\t\t\t\tobject.background = new Color( data.background );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.fog !== undefined ) {\r\n\r\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\r\n\r\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\r\n\r\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\r\n\r\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'PerspectiveCamera':\r\n\r\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\r\n\t\t\t\tif ( data.focus !== undefined ) { object.focus = data.focus; }\r\n\t\t\t\tif ( data.zoom !== undefined ) { object.zoom = data.zoom; }\r\n\t\t\t\tif ( data.filmGauge !== undefined ) { object.filmGauge = data.filmGauge; }\r\n\t\t\t\tif ( data.filmOffset !== undefined ) { object.filmOffset = data.filmOffset; }\r\n\t\t\t\tif ( data.view !== undefined ) { object.view = Object.assign( {}, data.view ); }\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'OrthographicCamera':\r\n\r\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n\t\t\t\tif ( data.zoom !== undefined ) { object.zoom = data.zoom; }\r\n\t\t\t\tif ( data.view !== undefined ) { object.view = Object.assign( {}, data.view ); }\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'AmbientLight':\r\n\r\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'DirectionalLight':\r\n\r\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'PointLight':\r\n\r\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'RectAreaLight':\r\n\r\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'SpotLight':\r\n\r\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'HemisphereLight':\r\n\r\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'SkinnedMesh':\r\n\r\n\t\t\t\tconsole.warn( 'ObjectLoader.parseObject() does not support SkinnedMesh yet.' );\r\n\r\n\t\t\tcase 'Mesh':\r\n\r\n\t\t\t\tvar geometry = getGeometry( data.geometry );\r\n\t\t\t\tvar material = getMaterial( data.material );\r\n\r\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\r\n\r\n\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tobject = new Mesh( geometry, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'LOD':\r\n\r\n\t\t\t\tobject = new LOD();\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'Line':\r\n\r\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'LineLoop':\r\n\r\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'LineSegments':\r\n\r\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'PointCloud':\r\n\t\t\tcase 'Points':\r\n\r\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'Sprite':\r\n\r\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'Group':\r\n\r\n\t\t\t\tobject = new Group();\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tobject = new Object3D();\r\n\r\n\t\t}\r\n\r\n\t\tobject.uuid = data.uuid;\r\n\r\n\t\tif ( data.name !== undefined ) { object.name = data.name; }\r\n\r\n\t\tif ( data.matrix !== undefined ) {\r\n\r\n\t\t\tobject.matrix.fromArray( data.matrix );\r\n\r\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) { object.matrixAutoUpdate = data.matrixAutoUpdate; }\r\n\t\t\tif ( object.matrixAutoUpdate ) { object.matrix.decompose( object.position, object.quaternion, object.scale ); }\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( data.position !== undefined ) { object.position.fromArray( data.position ); }\r\n\t\t\tif ( data.rotation !== undefined ) { object.rotation.fromArray( data.rotation ); }\r\n\t\t\tif ( data.quaternion !== undefined ) { object.quaternion.fromArray( data.quaternion ); }\r\n\t\t\tif ( data.scale !== undefined ) { object.scale.fromArray( data.scale ); }\r\n\r\n\t\t}\r\n\r\n\t\tif ( data.castShadow !== undefined ) { object.castShadow = data.castShadow; }\r\n\t\tif ( data.receiveShadow !== undefined ) { object.receiveShadow = data.receiveShadow; }\r\n\r\n\t\tif ( data.shadow ) {\r\n\r\n\t\t\tif ( data.shadow.bias !== undefined ) { object.shadow.bias = data.shadow.bias; }\r\n\t\t\tif ( data.shadow.radius !== undefined ) { object.shadow.radius = data.shadow.radius; }\r\n\t\t\tif ( data.shadow.mapSize !== undefined ) { object.shadow.mapSize.fromArray( data.shadow.mapSize ); }\r\n\t\t\tif ( data.shadow.camera !== undefined ) { object.shadow.camera = this.parseObject( data.shadow.camera ); }\r\n\r\n\t\t}\r\n\r\n\t\tif ( data.visible !== undefined ) { object.visible = data.visible; }\r\n\t\tif ( data.frustumCulled !== undefined ) { object.frustumCulled = data.frustumCulled; }\r\n\t\tif ( data.renderOrder !== undefined ) { object.renderOrder = data.renderOrder; }\r\n\t\tif ( data.userData !== undefined ) { object.userData = data.userData; }\r\n\t\tif ( data.layers !== undefined ) { object.layers.mask = data.layers; }\r\n\r\n\t\tif ( data.children !== undefined ) {\r\n\r\n\t\t\tvar children = data.children;\r\n\r\n\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\r\n\r\n\t\t\t\tobject.add( this$1.parseObject( children[ i ], geometries, materials ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( data.type === 'LOD' ) {\r\n\r\n\t\t\tvar levels = data.levels;\r\n\r\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n\t\t\t\tvar level = levels[ l ];\r\n\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\r\n\r\n\t\t\t\tif ( child !== undefined ) {\r\n\r\n\t\t\t\t\tobject.addLevel( child, level.distance );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nvar TEXTURE_MAPPING = {\r\n\tUVMapping: UVMapping,\r\n\tCubeReflectionMapping: CubeReflectionMapping,\r\n\tCubeRefractionMapping: CubeRefractionMapping,\r\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\r\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\r\n\tSphericalReflectionMapping: SphericalReflectionMapping,\r\n\tCubeUVReflectionMapping: CubeUVReflectionMapping,\r\n\tCubeUVRefractionMapping: CubeUVRefractionMapping\r\n};\r\n\r\nvar TEXTURE_WRAPPING = {\r\n\tRepeatWrapping: RepeatWrapping,\r\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\r\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\r\n};\r\n\r\nvar TEXTURE_FILTER = {\r\n\tNearestFilter: NearestFilter,\r\n\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\r\n\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\r\n\tLinearFilter: LinearFilter,\r\n\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\r\n\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\r\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run \"npm run convert\". //\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction Cylindrical( radius, theta, y ) {\r\n\r\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\r\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\r\n\tthis.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\r\n\r\n\treturn this;\r\n\r\n}\r\n\r\nObject.assign( Cylindrical.prototype, {\r\n\r\n\tset: function ( radius, theta, y ) {\r\n\r\n\t\tthis.radius = radius;\r\n\t\tthis.theta = theta;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( other ) {\r\n\r\n\t\tthis.radius = other.radius;\r\n\t\tthis.theta = other.theta;\r\n\t\tthis.y = other.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromVector3: function ( v ) {\r\n\r\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\r\n\r\n\t},\r\n\r\n\tsetFromCartesianCoords: function ( x, y, z ) {\r\n\r\n\t\tthis.radius = Math.sqrt( x * x + z * z );\r\n\t\tthis.theta = Math.atan2( x, z );\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction WebGL2Renderer( parameters ) {\r\n\r\n\tconsole.log( 'WebGL2Renderer', REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\r\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';\r\n\r\n\t// initialize\r\n\r\n\tvar gl;\r\n\r\n\ttry {\r\n\r\n\t\tvar attributes = {\r\n\t\t\talpha: _alpha,\r\n\t\t\tdepth: _depth,\r\n\t\t\tstencil: _stencil,\r\n\t\t\tantialias: _antialias,\r\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\r\n\t\t\tpowerPreference: _powerPreference\r\n\t\t};\r\n\r\n\t\t// event listeners must be registered before WebGL context is created, see #12753\r\n\r\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\t_canvas.addEventListener( 'webglcontextrestored', function () { } );\r\n\r\n\t\tgl = _context || _canvas.getContext( 'webgl2', attributes );\r\n\r\n\t\tif ( gl === null ) {\r\n\r\n\t\t\tif ( _canvas.getContext( 'webgl2' ) !== null ) {\r\n\r\n\t\t\t\tthrow new Error( 'Error creating WebGL2 context with your selected attributes.' );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'Error creating WebGL2 context.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} catch ( error ) {\r\n\r\n\t\tconsole.error( 'WebGL2Renderer: ' + error.message );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar _autoClearColor = true,\r\n\t\t_autoClearDepth = true,\r\n\t\t_autoClearStencil = true,\r\n\r\n\t\t_clearColor = new Color( 0x000000 ),\r\n\t\t_clearAlpha = 0,\r\n\r\n\t\t_width = _canvas.width,\r\n\t\t_height = _canvas.height,\r\n\r\n\t\t_pixelRatio = 1,\r\n\r\n\t\t_viewport = new Vector4( 0, 0, _width, _height );\r\n\r\n\tvar extensions = new WebGLExtensions( gl );\r\n\tvar state = new WebGLState( gl, extensions, function () {} );\r\n\r\n\t//\r\n\r\n\tfunction clear( color, depth, stencil ) {\r\n\r\n\t\tvar bits = 0;\r\n\r\n\t\tif ( color === undefined || color ) { bits |= gl.COLOR_BUFFER_BIT; }\r\n\t\tif ( depth === undefined || depth ) { bits |= gl.DEPTH_BUFFER_BIT; }\r\n\t\tif ( stencil === undefined || stencil ) { bits |= gl.STENCIL_BUFFER_BIT; }\r\n\r\n\t\tgl.clear( bits );\r\n\r\n\t}\r\n\r\n\tfunction setPixelRatio( value ) {\r\n\r\n\t\tif ( value === undefined ) { return; }\r\n\r\n\t\t_pixelRatio = value;\r\n\r\n\t\tsetSize( _viewport.z, _viewport.w, false );\r\n\r\n\t}\r\n\r\n\tfunction setSize( width, height, updateStyle ) {\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\t_canvas.width = width * _pixelRatio;\r\n\t\t_canvas.height = height * _pixelRatio;\r\n\r\n\t\tif ( updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\tsetViewport( 0, 0, width, height );\r\n\r\n\t}\r\n\r\n\tfunction setViewport( x, y, width, height ) {\r\n\r\n\t\tstate.viewport( _viewport.set( x, y, width, height ) );\r\n\r\n\t}\r\n\r\n\tfunction render( scene, camera ) {\r\n\r\n\t\tif ( camera !== undefined && camera.isCamera !== true ) {\r\n\r\n\t\t\tconsole.error( 'WebGL2Renderer.render: camera is not an instance of Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar background = scene.background;\r\n\r\n\t\tif ( background === null ) {\r\n\r\n\t\t\tstate.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );\r\n\r\n\t\t} else if ( background && background.isColor ) {\r\n\r\n\t\t\tstate.buffers.color.setClear( background.r, background.g, background.b, 1, _premultipliedAlpha );\r\n\r\n\t\t}\r\n\r\n\t\t{\r\n\r\n\t\t\tthis.clear( _autoClearColor, _autoClearDepth, _autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction onContextLost( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tdomElement: _canvas,\r\n\r\n\t\tclear: clear,\r\n\t\tsetPixelRatio: setPixelRatio,\r\n\t\tsetSize: setSize,\r\n\t\trender: render\r\n\t};\r\n\r\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n}\r\n\r\nVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\r\n\r\n\tconstructor: VideoTexture,\r\n\r\n\tisVideoTexture: true,\r\n\r\n\tupdate: function () {\r\n\r\n\t\tvar video = this.image;\r\n\r\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\r\n\r\n\t\t\tthis.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\n\nexport { CCDIKSolver, MMDAnimationHelper, MMDPhysics, AnimationClipCreator, CinematicCamera, Car, DeviceOrientationControls, DragControls, EditorControls, FirstPersonControls, FlyControls, MapControls, OrbitControls, OrthographicTrackballControls, PointerLockControls, TrackballControls, TransformControls, TransformControlsGizmo, TransformControlsPlane, ConvexObjectBreaker, GrannyKnot, HeartCurve, VivianiCurve, KnotCurve, HelixCurve, TrefoilKnot, TorusKnot, CinquefoilKnot, TrefoilPolynomialKnot, FigureEightPolynomialKnot, DecoratedTorusKnot4a, DecoratedTorusKnot4b, DecoratedTorusKnot5a, DecoratedTorusKnot5c, NURBSCurve, NURBSSurface, NURBSUtils, Detector, AnaglyphEffect, AsciiEffect, OutlineEffect, ParallaxBarrierEffect, PeppersGhostEffect, StereoEffect, ColladaExporter, GLTFExporter, MMDExporter, OBJExporter, PLYExporter, STLExporter, TypedGeometryExporter, ConvexGeometry, ConvexBufferGeometry, DecalGeometry, hilbert2D, hilbert3D, TeapotBufferGeometry, GPUComputationRenderer, GPUParticleSystem, GPUParticleContainer, Gyroscope, ImprovedNoise, Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry, Wireframe, WireframeGeometry2, ThreeMFLoader, AMFLoader, AssimpJSONLoader, AssimpLoader, AWDLoader, BabylonLoader, BinaryLoader, BVHLoader, ColladaLoader, DDSLoader, LegacyGLTFLoader, DRACOLoader, EquirectangularToCubeGenerator, EXRLoader, FBXLoader, GCodeLoader, GLTFLoader, HDRCubeTextureLoader, KMZLoader, KTXLoader, LoaderSupport, MD2Loader, MMDLoader, MTLLoader, NodeMaterialLoader, OBJLoader, OBJLoader2, PCDLoader, PDBLoader, PlayCanvasLoader, PLYLoader, PRWMLoader, PVRLoader, HDRLoader, RGBELoader, STLLoader, SVGLoader, TDSLoader, TGALoader, TTFLoader, VRMLLoader, VRMLoader, VTKLoader, MarchingCubes, ColorConverter, Lut, MD2Character, MD2CharacterComplex, ExplodeModifier, SimplifyModifier, SubdivisionModifier, TessellateModifier, MorphAnimMesh, MorphBlendMesh, CameraNode, ColorsNode, LightNode, NormalNode$1 as NormalNode, PositionNode, ReflectNode, ResolutionNode, ScreenUVNode, UVNode, BlinnExponentToRoughnessNode, BlinnShininessExponentNode, RoughnessToBlinnExponentNode, AttributeNode, ConstNode, ExpressionNode, FunctionCallNode, FunctionNode, InputNode$1 as InputNode, Node, NodeBuilder, NodeFrame, NodeLib, NodeUniform, NodeUtils, StructNode, TempNode, VarNode, BlurNode, ColorAdjustmentNode, LuminanceNode, ColorNode, CubeTextureNode, FloatNode, IntNode, Matrix3Node, Matrix4Node, PropertyNode, ReflectorNode, RTTNode, ScreenNode, TextureNode, Vector2Node, Vector3Node, Vector4Node, MeshStandardNodeMaterial, NodeMaterial, MeshStandardNode, PhongNode, RawNode, SpriteNode, StandardNode, PhongNodeMaterial, SpriteNodeMaterial, StandardNodeMaterial, CondNode, Math1Node, Math2Node, Math3Node, OperatorNode, BumpMapNode, NormalMapNode, TextureCubeNode, TextureCubeUVNode, NodePass, NodePostProcessing, CheckerNode, NoiseNode, BypassNode, ColorSpaceNode, JoinNode, MaxMIPLevelNode, SwitchNode, TimerNode, UVTransformNode, VelocityNode, Lensflare, LensflareElement, Reflector, ReflectorRTT, Refractor, ShadowMesh, Sky, Water, Water2, Ocean, Octree, OctreeObjectData, OctreeNode, PMREMCubeUVPacker, PMREMGenerator, AdaptiveToneMappingPass, AfterimagePass, BloomPass, BokehPass, ClearPass, CubeTexturePass, DotScreenPass, EffectComposer, FilmPass, GlitchPass, HalftonePass, MaskPass, ClearMaskPass, OutlinePass, Pass, RenderPass, SAOPass, SavePass, ShaderPass, SMAAPass, SSAARenderPass, SSAOPass, TAARenderPass, TexturePass, UnrealBloomPass, PRNG, QuickHull, SpriteCanvasMaterial, CanvasRenderer, CSS2DObject, CSS2DRenderer, CSS3DObject, CSS3DSprite, CSS3DRenderer, RenderableObject, RenderableFace, RenderableVertex, RenderableLine, RenderableSprite, Projector, RaytracingRenderer, SoftwareRenderer, SVGObject, SVGRenderer, WebGLDeferredRenderer, RollerCoasterGeometry, RollerCoasterLiftersGeometry, RollerCoasterShadowGeometry, SkyGeometry, TreesGeometry, ShaderGodRays, AfterimageShader, BasicShader, BleachBypassShader, BlendShader, BokehShader, BokehShader2, BokehDepthShader, BrightnessContrastShader, ColorCorrectionShader, ColorifyShader, ConvolutionShader, CopyShader, DepthLimitedBlurShader, BlurShaderUtils, DigitalGlitch, DOFMipMapShader, DotScreenShader, FilmShader, FocusShader, FreiChenShader, FresnelShader, FXAAShader, GammaCorrectionShader, HalftoneShader, HorizontalBlurShader, HorizontalTiltShiftShader, HueSaturationShader, KaleidoShader, LuminosityHighPassShader, LuminosityShader, MirrorShader, NormalMapShader, ParallaxShader, PixelShader, RGBShiftShader, SAOShader, SepiaShader, SMAAShader, SobelOperatorShader, SSAOShader, TechnicolorShader, ToneMapShader, TriangleBlurShader, UnpackDepthRGBAShader, VerticalBlurShader, VerticalTiltShiftShader, VignetteShader, WaterRefractionShader, ShaderSkin, ShaderTerrain, ShaderToon, TranslucentShader, SimplexNoise, TimelinerController, TypedArrayUtils, UCSCharacter, BufferGeometryUtils, GeometryUtils, MathUtils, SceneUtils, ShadowMapViewer, SkeletonUtils, UVsDebug, VolumeSlice, DaydreamController, GearVRController, PaintViveController, ViveController, WebVR, AnimationAction, AnimationClip, AnimationMixer, AnimationObjectGroup, AnimationUtils, KeyframeTrack, PropertyBinding, PropertyMixer, BooleanKeyframeTrack, ColorKeyframeTrack, NumberKeyframeTrack, QuaternionKeyframeTrack$1 as QuaternionKeyframeTrack, StringKeyframeTrack, VectorKeyframeTrack$1 as VectorKeyframeTrack, Audio, AudioAnalyser, AudioContext, AudioListener, PositionalAudio, ArrayCamera, Camera, CubeCamera, OrthographicCamera, PerspectiveCamera, StereoCamera, REVISION, MOUSE, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, FrontFaceDirectionCW, FrontFaceDirectionCCW, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, SmoothShading, NoColors, FaceColors, VertexColors, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, Uncharted2ToneMapping, CineonToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, SphericalReflectionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipMapNearestFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipMapNearestFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, RGBEFormat, DepthFormat, DepthStencilFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, Float64BufferAttribute, Float32BufferAttribute, Uint32BufferAttribute, Int32BufferAttribute, Uint16BufferAttribute, Int16BufferAttribute, Uint8ClampedBufferAttribute, Uint8BufferAttribute, Int8BufferAttribute, BufferAttribute, BufferGeometry, Clock, DirectGeometry, EventDispatcher, Face3, Geometry, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBuffer, InterleavedBufferAttribute, Layers, Object3D, Raycaster, Uniform, Curve, CurvePath, Font, CatmullRom, QuadraticBezier, CubicBezier, Path, Shape, ShapePath, ArcCurve, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, EllipseCurve, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve, Earcut, ImageUtils, ImmediateRenderObject, ShapeUtils, BoxGeometry, BoxBufferGeometry, CircleGeometry, CircleBufferGeometry, ConeGeometry, ConeBufferGeometry, CylinderGeometry, CylinderBufferGeometry, DodecahedronGeometry, DodecahedronBufferGeometry, EdgesGeometry, ExtrudeGeometry, ExtrudeBufferGeometry, IcosahedronGeometry, IcosahedronBufferGeometry, LatheGeometry, LatheBufferGeometry, OctahedronGeometry, OctahedronBufferGeometry, ParametricGeometry, ParametricBufferGeometry, PlaneGeometry, PlaneBufferGeometry, PolyhedronGeometry, PolyhedronBufferGeometry, RingGeometry, RingBufferGeometry, ShapeGeometry, ShapeBufferGeometry, SphereGeometry, SphereBufferGeometry, TetrahedronGeometry, TetrahedronBufferGeometry, TextGeometry, TextBufferGeometry, TorusGeometry, TorusBufferGeometry, TorusKnotGeometry, TorusKnotBufferGeometry, TubeGeometry, TubeBufferGeometry, WireframeGeometry, ArrowHelper, AxesHelper, Box3Helper, BoxHelper, CameraHelper, DirectionalLightHelper, FaceNormalsHelper, GridHelper, HemisphereLightHelper, PlaneHelper, PointLightHelper, PolarGridHelper, RectAreaLightHelper, SkeletonHelper, SpotLightHelper, VertexNormalsHelper, AmbientLight, DirectionalLight, DirectionalLightShadow, HemisphereLight, Light, LightShadow, PointLight, RectAreaLight, SpotLight, SpotLightShadow, AnimationLoader, AudioLoader, BufferGeometryLoader, Cache, CompressedTextureLoader, CubeTextureLoader, DataTextureLoader, FileLoader, FontLoader, ImageBitmapLoader, ImageLoader, JSONLoader, Loader$1 as Loader, LoaderUtils, DefaultLoadingManager, LoadingManager, MaterialLoader, ObjectLoader, TextureLoader, LineBasicMaterial, LineDashedMaterial, Material, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, PointsMaterial, RawShaderMaterial, ShaderMaterial, ShadowMaterial, SpriteMaterial, Box2, Box3, Color, Cylindrical, Euler, Frustum, Interpolant, CubicInterpolant, DiscreteInterpolant, LinearInterpolant, QuaternionLinearInterpolant, Line3, _Math, Matrix3, Matrix4, Plane, Quaternion, Ray, Sphere, Spherical, Triangle, Vector2, Vector3, Vector4, Bone, Group, Line, LineLoop, LineSegments, LOD, Mesh, Points, Skeleton, SkinnedMesh, Sprite, ShaderChunk, ShaderLib, UniformsLib, UniformsUtils, WebGLAnimation, WebGLAttributes, WebGLBackground, WebGLBufferRenderer, WebGLCapabilities, WebGLClipping, WebGLExtensions, WebGLGeometries, WebGLIndexedBufferRenderer, WebGLInfo, WebGLLights, WebGLMorphtargets, WebGLObjects, WebGLProgram, WebGLPrograms, WebGLProperties, WebGLRenderLists, WebGLRenderStates, WebGLShader, WebGLShadowMap, WebGLState, WebGLTextures, WebGLUniforms, WebGLUtils, WebGL2Renderer, WebGLRenderer, WebGLRenderTarget, WebGLRenderTargetCube, WebVRManager, WebXRManager, Fog, FogExp2, Scene, CanvasTexture, CompressedTexture, CubeTexture, DataTexture, DepthTexture, Texture, VideoTexture, arrayMin, arrayMax };\n","/** @license React v16.5.2\n * schedule.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';Object.defineProperty(exports,\"__esModule\",{value:!0});var c=null,e=!1,f=!1,g=\"object\"===typeof performance&&\"function\"===typeof performance.now,l={timeRemaining:g?function(){var a=h()-performance.now();return 0<a?a:0}:function(){var a=h()-Date.now();return 0<a?a:0},didTimeout:!1};function m(){if(!e){var a=c.timesOutAt;f?n():f=!0;p(q,a)}}function r(){var a=c,b=c.next;if(c===b)c=null;else{var d=c.previous;c=d.next=b;b.previous=d}a.next=a.previous=null;a=a.callback;a(l)}\nfunction q(a){e=!0;l.didTimeout=a;try{if(a)for(;null!==c;){var b=exports.unstable_now();if(c.timesOutAt<=b){do r();while(null!==c&&c.timesOutAt<=b)}else break}else if(null!==c){do r();while(null!==c&&0<h()-exports.unstable_now())}}finally{e=!1,null!==c?m(c):f=!1}}\nvar t=Date,u=\"function\"===typeof setTimeout?setTimeout:void 0,v=\"function\"===typeof clearTimeout?clearTimeout:void 0,w=\"function\"===typeof requestAnimationFrame?requestAnimationFrame:void 0,x=\"function\"===typeof cancelAnimationFrame?cancelAnimationFrame:void 0,y,z;function A(a){y=w(function(b){v(z);a(b)});z=u(function(){x(y);a(exports.unstable_now())},100)}if(g){var B=performance;exports.unstable_now=function(){return B.now()}}else exports.unstable_now=function(){return t.now()};var p,n,h;\nif(\"undefined\"===typeof window){var C=-1;p=function(a){C=setTimeout(a,0,!0)};n=function(){clearTimeout(C)};h=function(){return 0}}else if(window._schedMock){var D=window._schedMock;p=D[0];n=D[1];h=D[2]}else{\"undefined\"!==typeof console&&(\"function\"!==typeof w&&console.error(\"This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills\"),\"function\"!==typeof x&&console.error(\"This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills\"));\nvar E=null,F=!1,G=-1,H=!1,I=!1,J=0,K=33,L=33;h=function(){return J};var M=\"__reactIdleCallback$\"+Math.random().toString(36).slice(2);window.addEventListener(\"message\",function(a){if(a.source===window&&a.data===M){F=!1;var b=exports.unstable_now();a=!1;if(0>=J-b)if(-1!==G&&G<=b)a=!0;else{H||(H=!0,A(N));return}G=-1;b=E;E=null;if(null!==b){I=!0;try{b(a)}finally{I=!1}}}},!1);var N=function(a){H=!1;var b=a-J+L;b<L&&K<L?(8>b&&(b=8),L=b<K?K:b):K=b;J=a+L;F||(F=!0,window.postMessage(M,\"*\"))};p=function(a,\nb){E=a;G=b;I?window.postMessage(M,\"*\"):H||(H=!0,A(N))};n=function(){E=null;F=!1;G=-1}}exports.unstable_scheduleWork=function(a,b){var d=exports.unstable_now();b=void 0!==b&&null!==b&&null!==b.timeout&&void 0!==b.timeout?d+b.timeout:d+5E3;a={callback:a,timesOutAt:b,next:null,previous:null};if(null===c)c=a.next=a.previous=a,m(c);else{d=null;var k=c;do{if(k.timesOutAt>b){d=k;break}k=k.next}while(k!==c);null===d?d=c:d===c&&(c=a,m(c));b=d.previous;b.next=d.previous=a;a.next=d;a.previous=b}return a};\nexports.unstable_cancelScheduledWork=function(a){var b=a.next;if(null!==b){if(b===a)c=null;else{a===c&&(c=b);var d=a.previous;d.next=b;b.previous=d}a.next=a.previous=null}};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nfunction emptyFunction() {}\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim\n  };\n\n  ReactPropTypes.checkPropTypes = emptyFunction;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.styles = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _withStyles = _interopRequireDefault(require(\"../styles/withStyles\"));\n\nvar _colorManipulator = require(\"../styles/colorManipulator\");\n\nvar _ButtonBase = _interopRequireDefault(require(\"../ButtonBase\"));\n\nvar _chainPropTypes = _interopRequireDefault(require(\"../utils/chainPropTypes\"));\n\nvar _helpers = require(\"../utils/helpers\");\n\n// @inheritedComponent ButtonBase\nvar styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: (0, _extends2.default)({}, theme.typography.button, {\n      boxSizing: 'border-box',\n      minWidth: 64,\n      minHeight: 36,\n      padding: '8px 16px',\n      borderRadius: theme.shape.borderRadius,\n      color: theme.palette.text.primary,\n      transition: theme.transitions.create(['background-color', 'box-shadow', 'border'], {\n        duration: theme.transitions.duration.short\n      }),\n      '&:hover': {\n        textDecoration: 'none',\n        backgroundColor: (0, _colorManipulator.fade)(theme.palette.text.primary, theme.palette.action.hoverOpacity),\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: 'transparent'\n        },\n        '&$disabled': {\n          backgroundColor: 'transparent'\n        }\n      },\n      '&$disabled': {\n        color: theme.palette.action.disabled\n      }\n    }),\n\n    /* Styles applied to the span element that wraps the children. */\n    label: {\n      width: '100%',\n      // assure the correct width for iOS Safari\n      display: 'inherit',\n      alignItems: 'inherit',\n      justifyContent: 'inherit'\n    },\n\n    /* Styles applied to the root element if `variant=\"text\"`. */\n    text: {},\n\n    /* Styles applied to the root element if `variant=\"text\"` and `color=\"primary\"`. */\n    textPrimary: {\n      color: theme.palette.primary.main,\n      '&:hover': {\n        backgroundColor: (0, _colorManipulator.fade)(theme.palette.primary.main, theme.palette.action.hoverOpacity),\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: 'transparent'\n        }\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"text\"` and `color=\"secondary\"`. */\n    textSecondary: {\n      color: theme.palette.secondary.main,\n      '&:hover': {\n        backgroundColor: (0, _colorManipulator.fade)(theme.palette.secondary.main, theme.palette.action.hoverOpacity),\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: 'transparent'\n        }\n      }\n    },\n\n    /* Styles applied to the root element for backwards compatibility with legacy variant naming. */\n    flat: {},\n\n    /* Styles applied to the root element for backwards compatibility with legacy variant naming. */\n    flatPrimary: {},\n\n    /* Styles applied to the root element for backwards compatibility with legacy variant naming. */\n    flatSecondary: {},\n\n    /* Styles applied to the root element if `variant=\"outlined\"`. */\n    outlined: {\n      border: \"1px solid \".concat(theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)')\n    },\n\n    /* Styles applied to the root element if `variant=\"outlined\"` and `color=\"primary\"`. */\n    outlinedPrimary: {\n      border: \"1px solid \".concat((0, _colorManipulator.fade)(theme.palette.primary.main, 0.5)),\n      '&:hover': {\n        border: \"1px solid \".concat(theme.palette.primary.main)\n      },\n      '&$disabled': {\n        border: \"1px solid \".concat(theme.palette.action.disabled)\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"outlined\"` and `color=\"secondary\"`. */\n    outlinedSecondary: {\n      border: \"1px solid \".concat((0, _colorManipulator.fade)(theme.palette.secondary.main, 0.5)),\n      '&:hover': {\n        border: \"1px solid \".concat(theme.palette.secondary.main)\n      },\n      '&$disabled': {\n        border: \"1px solid \".concat(theme.palette.action.disabled)\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"[contained | fab]\"`. */\n    contained: {\n      color: theme.palette.getContrastText(theme.palette.grey[300]),\n      backgroundColor: theme.palette.grey[300],\n      boxShadow: theme.shadows[2],\n      '&$focusVisible': {\n        boxShadow: theme.shadows[6]\n      },\n      '&:active': {\n        boxShadow: theme.shadows[8]\n      },\n      '&$disabled': {\n        color: theme.palette.action.disabled,\n        boxShadow: theme.shadows[0],\n        backgroundColor: theme.palette.action.disabledBackground\n      },\n      '&:hover': {\n        backgroundColor: theme.palette.grey.A100,\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: theme.palette.grey[300]\n        },\n        '&$disabled': {\n          backgroundColor: theme.palette.action.disabledBackground\n        }\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"[contained | fab]\"` and `color=\"primary\"`. */\n    containedPrimary: {\n      color: theme.palette.primary.contrastText,\n      backgroundColor: theme.palette.primary.main,\n      '&:hover': {\n        backgroundColor: theme.palette.primary.dark,\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: theme.palette.primary.main\n        }\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"[contained | fab]\"` and `color=\"secondary\"`. */\n    containedSecondary: {\n      color: theme.palette.secondary.contrastText,\n      backgroundColor: theme.palette.secondary.main,\n      '&:hover': {\n        backgroundColor: theme.palette.secondary.dark,\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: theme.palette.secondary.main\n        }\n      }\n    },\n\n    /* Styles applied to the root element for backwards compatibility with legacy variant naming. */\n    raised: {},\n    // legacy\n\n    /* Styles applied to the root element for backwards compatibility with legacy variant naming. */\n    raisedPrimary: {},\n    // legacy\n\n    /* Styles applied to the root element for backwards compatibility with legacy variant naming. */\n    raisedSecondary: {},\n    // legacy\n\n    /* Styles applied to the root element if `variant=\"[fab | extendedFab]\"`. */\n    fab: {\n      borderRadius: '50%',\n      padding: 0,\n      minWidth: 0,\n      width: 56,\n      height: 56,\n      boxShadow: theme.shadows[6],\n      '&:active': {\n        boxShadow: theme.shadows[12]\n      }\n    },\n\n    /* Styles applied to the root element if `variant=\"extendedFab\"`. */\n    extendedFab: {\n      borderRadius: 48 / 2,\n      padding: '0 16px',\n      width: 'auto',\n      minWidth: 48,\n      height: 48\n    },\n\n    /* Styles applied to the ButtonBase root element if the button is keyboard focused. */\n    focusVisible: {},\n\n    /* Styles applied to the root element if `disabled={true}`. */\n    disabled: {},\n\n    /* Styles applied to the root element if `color=\"inherit\"`. */\n    colorInherit: {\n      color: 'inherit'\n    },\n\n    /* Styles applied to the root element if `size=\"mini\"` & `variant=\"[fab | extendedFab]\"`. */\n    mini: {\n      width: 40,\n      height: 40\n    },\n\n    /* Styles applied to the root element if `size=\"small\"`. */\n    sizeSmall: {\n      padding: '7px 8px',\n      minWidth: 64,\n      minHeight: 32,\n      fontSize: theme.typography.pxToRem(13)\n    },\n\n    /* Styles applied to the root element if `size=\"large\"`. */\n    sizeLarge: {\n      padding: '8px 24px',\n      minWidth: 112,\n      minHeight: 40,\n      fontSize: theme.typography.pxToRem(15)\n    },\n\n    /* Styles applied to the root element if `fullWidth={true}`. */\n    fullWidth: {\n      width: '100%'\n    }\n  };\n};\n\nexports.styles = styles;\n\nfunction Button(props) {\n  var _classNames;\n\n  var children = props.children,\n      classes = props.classes,\n      classNameProp = props.className,\n      color = props.color,\n      disabled = props.disabled,\n      disableFocusRipple = props.disableFocusRipple,\n      focusVisibleClassName = props.focusVisibleClassName,\n      fullWidth = props.fullWidth,\n      mini = props.mini,\n      size = props.size,\n      variant = props.variant,\n      other = (0, _objectWithoutProperties2.default)(props, [\"children\", \"classes\", \"className\", \"color\", \"disabled\", \"disableFocusRipple\", \"focusVisibleClassName\", \"fullWidth\", \"mini\", \"size\", \"variant\"]);\n  var fab = variant === 'fab' || variant === 'extendedFab';\n  var contained = variant === 'contained' || variant === 'raised';\n  var text = variant === 'text' || variant === 'flat' || variant === 'outlined';\n  var className = (0, _classnames.default)(classes.root, (_classNames = {}, (0, _defineProperty2.default)(_classNames, classes.fab, fab), (0, _defineProperty2.default)(_classNames, classes.mini, fab && mini), (0, _defineProperty2.default)(_classNames, classes.extendedFab, variant === 'extendedFab'), (0, _defineProperty2.default)(_classNames, classes.text, text), (0, _defineProperty2.default)(_classNames, classes.textPrimary, text && color === 'primary'), (0, _defineProperty2.default)(_classNames, classes.textSecondary, text && color === 'secondary'), (0, _defineProperty2.default)(_classNames, classes.flat, variant === 'text' || variant === 'flat'), (0, _defineProperty2.default)(_classNames, classes.flatPrimary, (variant === 'text' || variant === 'flat') && color === 'primary'), (0, _defineProperty2.default)(_classNames, classes.flatSecondary, (variant === 'text' || variant === 'flat') && color === 'secondary'), (0, _defineProperty2.default)(_classNames, classes.contained, contained || fab), (0, _defineProperty2.default)(_classNames, classes.containedPrimary, (contained || fab) && color === 'primary'), (0, _defineProperty2.default)(_classNames, classes.containedSecondary, (contained || fab) && color === 'secondary'), (0, _defineProperty2.default)(_classNames, classes.raised, contained || fab), (0, _defineProperty2.default)(_classNames, classes.raisedPrimary, (contained || fab) && color === 'primary'), (0, _defineProperty2.default)(_classNames, classes.raisedSecondary, (contained || fab) && color === 'secondary'), (0, _defineProperty2.default)(_classNames, classes.outlined, variant === 'outlined'), (0, _defineProperty2.default)(_classNames, classes.outlinedPrimary, variant === 'outlined' && color === 'primary'), (0, _defineProperty2.default)(_classNames, classes.outlinedSecondary, variant === 'outlined' && color === 'secondary'), (0, _defineProperty2.default)(_classNames, classes[\"size\".concat((0, _helpers.capitalize)(size))], size !== 'medium'), (0, _defineProperty2.default)(_classNames, classes.disabled, disabled), (0, _defineProperty2.default)(_classNames, classes.fullWidth, fullWidth), (0, _defineProperty2.default)(_classNames, classes.colorInherit, color === 'inherit'), _classNames), classNameProp);\n  return _react.default.createElement(_ButtonBase.default, (0, _extends2.default)({\n    className: className,\n    disabled: disabled,\n    focusRipple: !disableFocusRipple,\n    focusVisibleClassName: (0, _classnames.default)(classes.focusVisible, focusVisibleClassName)\n  }, other), _react.default.createElement(\"span\", {\n    className: classes.label\n  }, children));\n}\n\nButton.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * The content of the button.\n   */\n  children: _propTypes.default.node.isRequired,\n\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css-api) below for more details.\n   */\n  classes: _propTypes.default.object.isRequired,\n\n  /**\n   * @ignore\n   */\n  className: _propTypes.default.string,\n\n  /**\n   * The color of the component. It supports those theme colors that make sense for this component.\n   */\n  color: _propTypes.default.oneOf(['default', 'inherit', 'primary', 'secondary']),\n\n  /**\n   * The component used for the root node.\n   * Either a string to use a DOM element or a component.\n   */\n  component: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func, _propTypes.default.object]),\n\n  /**\n   * If `true`, the button will be disabled.\n   */\n  disabled: _propTypes.default.bool,\n\n  /**\n   * If `true`, the  keyboard focus ripple will be disabled.\n   * `disableRipple` must also be true.\n   */\n  disableFocusRipple: _propTypes.default.bool,\n\n  /**\n   * If `true`, the ripple effect will be disabled.\n   */\n  disableRipple: _propTypes.default.bool,\n\n  /**\n   * @ignore\n   */\n  focusVisibleClassName: _propTypes.default.string,\n\n  /**\n   * If `true`, the button will take up the full width of its container.\n   */\n  fullWidth: _propTypes.default.bool,\n\n  /**\n   * The URL to link to when the button is clicked.\n   * If defined, an `a` element will be used as the root node.\n   */\n  href: _propTypes.default.string,\n\n  /**\n   * If `true`, and `variant` is `'fab'`, will use mini floating action button styling.\n   */\n  mini: _propTypes.default.bool,\n\n  /**\n   * The size of the button.\n   * `small` is equivalent to the dense button styling.\n   */\n  size: _propTypes.default.oneOf(['small', 'medium', 'large']),\n\n  /**\n   * @ignore\n   */\n  type: _propTypes.default.string,\n\n  /**\n   * The variant to use.\n   * __WARNING__: `flat` and `raised` are deprecated.\n   * Instead use `text` and `contained` respectively.\n   */\n  variant: (0, _chainPropTypes.default)(_propTypes.default.oneOf(['text', 'flat', 'outlined', 'contained', 'raised', 'fab', 'extendedFab']), function (props) {\n    if (props.variant === 'flat') {\n      return new Error('The `flat` variant will be removed in the next major release. ' + '`text` is equivalent and should be used instead.');\n    }\n\n    if (props.variant === 'raised') {\n      return new Error('The `raised` variant will be removed in the next major release. ' + '`contained` is equivalent and should be used instead.');\n    }\n\n    return null;\n  })\n} : {};\nButton.defaultProps = {\n  color: 'default',\n  component: 'button',\n  disabled: false,\n  disableFocusRipple: false,\n  fullWidth: false,\n  mini: false,\n  size: 'medium',\n  type: 'button',\n  variant: 'text'\n};\n\nvar _default = (0, _withStyles.default)(styles, {\n  name: 'MuiButton'\n})(Button);\n\nexports.default = _default;","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPalette;\nexports.dark = exports.light = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _warning = _interopRequireDefault(require(\"warning\"));\n\nvar _deepmerge = _interopRequireDefault(require(\"deepmerge\"));\n\nvar _indigo = _interopRequireDefault(require(\"../colors/indigo\"));\n\nvar _pink = _interopRequireDefault(require(\"../colors/pink\"));\n\nvar _grey = _interopRequireDefault(require(\"../colors/grey\"));\n\nvar _red = _interopRequireDefault(require(\"../colors/red\"));\n\nvar _common = _interopRequireDefault(require(\"../colors/common\"));\n\nvar _colorManipulator = require(\"./colorManipulator\");\n\n// < 1kb payload overhead when lodash/merge is > 3kb.\nvar light = {\n  // The colors used to style the text.\n  text: {\n    // The most important text.\n    primary: 'rgba(0, 0, 0, 0.87)',\n    // Secondary text.\n    secondary: 'rgba(0, 0, 0, 0.54)',\n    // Disabled text have even lower visual prominence.\n    disabled: 'rgba(0, 0, 0, 0.38)',\n    // Text hints.\n    hint: 'rgba(0, 0, 0, 0.38)'\n  },\n  // The color used to divide different elements.\n  divider: 'rgba(0, 0, 0, 0.12)',\n  // The background colors used to style the surfaces.\n  // Consistency between these values is important.\n  background: {\n    paper: _common.default.white,\n    default: _grey.default[50]\n  },\n  // The colors used to style the action elements.\n  action: {\n    // The color of an active action like an icon button.\n    active: 'rgba(0, 0, 0, 0.54)',\n    // The color of an hovered action.\n    hover: 'rgba(0, 0, 0, 0.08)',\n    hoverOpacity: 0.08,\n    // The color of a selected action.\n    selected: 'rgba(0, 0, 0, 0.14)',\n    // The color of a disabled action.\n    disabled: 'rgba(0, 0, 0, 0.26)',\n    // The background color of a disabled action.\n    disabledBackground: 'rgba(0, 0, 0, 0.12)'\n  }\n};\nexports.light = light;\nvar dark = {\n  text: {\n    primary: _common.default.white,\n    secondary: 'rgba(255, 255, 255, 0.7)',\n    disabled: 'rgba(255, 255, 255, 0.5)',\n    hint: 'rgba(255, 255, 255, 0.5)',\n    icon: 'rgba(255, 255, 255, 0.5)'\n  },\n  divider: 'rgba(255, 255, 255, 0.12)',\n  background: {\n    paper: _grey.default[800],\n    default: '#303030'\n  },\n  action: {\n    active: _common.default.white,\n    hover: 'rgba(255, 255, 255, 0.1)',\n    hoverOpacity: 0.1,\n    selected: 'rgba(255, 255, 255, 0.2)',\n    disabled: 'rgba(255, 255, 255, 0.3)',\n    disabledBackground: 'rgba(255, 255, 255, 0.12)'\n  }\n};\nexports.dark = dark;\n\nfunction addLightOrDark(intent, direction, shade, tonalOffset) {\n  if (!intent[direction]) {\n    if (intent.hasOwnProperty(shade)) {\n      intent[direction] = intent[shade];\n    } else if (direction === 'light') {\n      intent.light = (0, _colorManipulator.lighten)(intent.main, tonalOffset);\n    } else if (direction === 'dark') {\n      intent.dark = (0, _colorManipulator.darken)(intent.main, tonalOffset * 1.5);\n    }\n  }\n}\n\nfunction createPalette(palette) {\n  var _palette$primary = palette.primary,\n      primary = _palette$primary === void 0 ? {\n    light: _indigo.default[300],\n    main: _indigo.default[500],\n    dark: _indigo.default[700]\n  } : _palette$primary,\n      _palette$secondary = palette.secondary,\n      secondary = _palette$secondary === void 0 ? {\n    light: _pink.default.A200,\n    main: _pink.default.A400,\n    dark: _pink.default.A700\n  } : _palette$secondary,\n      _palette$error = palette.error,\n      error = _palette$error === void 0 ? {\n    light: _red.default[300],\n    main: _red.default[500],\n    dark: _red.default[700]\n  } : _palette$error,\n      _palette$type = palette.type,\n      type = _palette$type === void 0 ? 'light' : _palette$type,\n      _palette$contrastThre = palette.contrastThreshold,\n      contrastThreshold = _palette$contrastThre === void 0 ? 3 : _palette$contrastThre,\n      _palette$tonalOffset = palette.tonalOffset,\n      tonalOffset = _palette$tonalOffset === void 0 ? 0.2 : _palette$tonalOffset,\n      other = (0, _objectWithoutProperties2.default)(palette, [\"primary\", \"secondary\", \"error\", \"type\", \"contrastThreshold\", \"tonalOffset\"]);\n\n  function getContrastText(background) {\n    // Use the same logic as\n    // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59\n    // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54\n    var contrastText = (0, _colorManipulator.getContrastRatio)(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;\n\n    if (process.env.NODE_ENV !== 'production') {\n      var contrast = (0, _colorManipulator.getContrastRatio)(background, contrastText);\n      process.env.NODE_ENV !== \"production\" ? (0, _warning.default)(contrast >= 3, [\"Material-UI: the contrast ratio of \".concat(contrast, \":1 for \").concat(contrastText, \" on \").concat(background), 'falls below the WACG recommended absolute minimum contrast ratio of 3:1.', 'https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast'].join('\\n')) : void 0;\n    }\n\n    return contrastText;\n  }\n\n  function augmentColor(color) {\n    var mainShade = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n    var lightShade = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;\n    var darkShade = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 700;\n\n    if (!color.main && color[mainShade]) {\n      color.main = color[mainShade];\n    }\n\n    if (process.env.NODE_ENV !== 'production' && !color.main) {\n      throw new Error(['Material-UI: the color provided to augmentColor(color) is invalid.', \"The color object needs to have a `main` property or a `\".concat(mainShade, \"` property.\")].join('\\n'));\n    }\n\n    addLightOrDark(color, 'light', lightShade, tonalOffset);\n    addLightOrDark(color, 'dark', darkShade, tonalOffset);\n\n    if (!color.contrastText) {\n      color.contrastText = getContrastText(color.main);\n    }\n  }\n\n  augmentColor(primary);\n  augmentColor(secondary, 'A400', 'A200', 'A700');\n  augmentColor(error);\n  var types = {\n    dark: dark,\n    light: light\n  };\n  process.env.NODE_ENV !== \"production\" ? (0, _warning.default)(types[type], \"Material-UI: the palette type `\".concat(type, \"` is not supported.\")) : void 0;\n  var paletteOutput = (0, _deepmerge.default)((0, _extends2.default)({\n    // A collection of common colors.\n    common: _common.default,\n    // The palette type, can be light or dark.\n    type: type,\n    // The colors used to represent primary interface elements for a user.\n    primary: primary,\n    // The colors used to represent secondary interface elements for a user.\n    secondary: secondary,\n    // The colors used to represent interface elements that the user should be made aware of.\n    error: error,\n    // The grey colors.\n    grey: _grey.default,\n    // Used by `getContrastText()` to maximize the contrast between the background and\n    // the text.\n    contrastThreshold: contrastThreshold,\n    // Take a background color and return the color of the text to maximize the contrast.\n    getContrastText: getContrastText,\n    // Generate a rich color object.\n    augmentColor: augmentColor,\n    // Used by the functions below to shift a color's luminance by approximately\n    // two indexes within its tonal palette.\n    // E.g., shift from Red 500 to Red 300 or Red 700.\n    tonalOffset: tonalOffset\n  }, types[type]), other, {\n    clone: false // No need to clone deep\n\n  });\n  return paletteOutput;\n}"],"mappings":"AAGA;;;;;;;;;;;ACIA;;;;AC8IA;;;;;AC7IA;;ACs3aA;;AA6uBA;;;;;;;;AC5lcA;;;;;;;;ACWA;;;;;;;;ACsKA;;;;;;;;ACnKA;;;;;;AC+EA;;;;;;AAiDA","sourceRoot":""}